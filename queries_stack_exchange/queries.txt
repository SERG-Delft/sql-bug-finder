select orders.orderid, orders.customername from orders;
select orders.orderid, orders.customername from orders;
where orderdetails.orderid is null;
select * from a inner join b on a.a = b.b;
select a.*, b.*  from a,b where a.a = b.b;
select * from a left outer join b on a.a = b.b;
select a.*, b.*  from a,b where a.a = b.b(+);
select * from a right outer join b on a.a = b.b;
select a.*, b.*  from a,b where a.a(+) = b.b;
select * from a full outer join b on a.a = b.b;
select * from dbo.students s;
select * from dbo.students s;
select * from dbo.students s;
select  * from employee inner join location on employee.empid = location.empid or select  * from employee, location where employee.empid = location.empid;
select  * from employee left outer join location on employee.empid = location.empid;
select * from employee right outer join location  on employee.empid = location.empid;
select e.id , e.name , p.phone_num from employees as e inner join phone_numbers_employees as p on e.id = p.emp_id;
select e.id , e.name , p.phone_num from employees as e left join phone_numbers_employees as p on e.id = p.emp_id;
select e.id , e.name , p.phone_num from employees as e outer join phone_numbers_employees as p on e.id = p.emp_id;
select * from table1, table2 select * from table1 cross join table2;
select * from table1, table2 where table1.id = table2.id select * from table1 inner join table2 on table1.id = table2.id;
select * from table1, table2 where table1.id = table2.id union all select *, null, null from table1 where not table1.id in (select id from table2) select * from table1 left join table2 on table1.id = table2.id;
select * from table1, table2 where table1.id = table2.id union all select *, null, null from table1 where not table1.id in (select id from table2) union all select null, null, * from table2 where not table2.id in (select id from table1) select * from table1 left join table2 on table1.id = table2.id union all select * from table2 left join table1 on table2.id = table1.id where table1.id is null select * from table1 full outer join table2 on table1.id = table2.id;
select e1.emp_name, e2.emp_salary from emp1 e1;
select e1.emp_name, e2.emp_salary from emp1 e1;
select * from   tablea a;
select a.empid, a.name, b.name as dept_name from emp a join department b;
select a.empid, a.name, b.name as dept_name from emp a;
select * from a inner join b on a.a = b.b;
select a.*, b.*  from a,b where a.a = b.b;
select * from a left outer join b on a.a = b.b;
select a.*, b.*  from a,b where a.a = b.b(+);
select * from a right outer join b on a.a = b.b;
select a.*, b.*  from a,b where a.a(+) = b.b;
select * from a full outer join b on a.a = b.b;
select * from citizen;
select * from citizen    c join postalcode p on c.postal = p.postal;
select * from citizen         c;
create table citizen (id      number, name    varchar2(20), postal  number,  -- <-- could do with a redesign to postalcode.id instead. create table postalcode (id      number, postal  number, city    varchar2(20), area    varchar2(20));
select 1, 'smith', 2200,  null from dual union select 2, 'green', 31006, 1    from dual union select 3, 'jensen', 623,  1    from dual;
select 1, 2200,     'bigcity',         'geancy'  from dual union select 2, 31006,    'smalltown',       'snizkim' from dual union select 3, 31006,    'settlement',      'moon'    from dual  -- <-- uuh-uhh. union select 4, 78567390, 'lookouttowerx89', 'space'   from dual;
select * from citizen          c where c.postal = p.postal -- < -- the where condition is limiting the resulting rows;
select * from citizen    c join postalcode p on 1 = 1  -- < -- the on condition makes it a cross join;
select * from citizen         c;
select * from citizen         c where p.postal is not null -- < -- removed the row where there's no mathcing result from postalcode;
select * from citizen c1 join citizen c2 on c1.id = c2.leader;
select * from citizen          c where c.name = 'smith' and p.area = 'moon';
select * from citizen          c where c.name = 'smith' select * from citizen          c where p.area = 'moon';
select * from citizen          c where c.name = 'smith' union select * from citizen          c where p.area = 'moon';
select * from citizen          c where c.name = 'smith' or p.area = 'moon';
select * from citizen where name = 'smith';
select * from postalcode where area = 'moon';
update suppliers set supplier_name = (select customers.name from customers where customers.customer_id = suppliers.supplier_id) where exists (select customers.name from customers where customers.customer_id = suppliers.supplier_id);
update table_to_update, table_info set table_to_update.col1 = table_info.col1, table_to_update.col2 = table_info.col2 where table_to_update.id = table_info.id;
update first_table, second_table set first_table.color = second_table.color where first_table.id = second_table.foreign_id;
update table set table.example = a.value from tableexample a where table.field = *key value* -- finds the row in table and a.field = *key value* -- finds the row in tableexample a;
update x set    x.col1 = x.newcol1, x.col2 = x.newcol2 from   (select t.col1, t2.col1 as newcol1, t.col2, t2.col2 as newcol2 from   [table] t join other_table t2;
update table1 set table1.col1 = table2.col1, table1.col2 = table2.col2;
drop table uno drop table dos create table uno ( uid int, col1 char(1), col2 char(2) ) create table dos ( did int, col1 char(1), col2 char(2), [sql] char(4) ) select * from uno select * from dos;
update uno set col1 = (select col1 from dos where uid = did and [sql]='cool'), col2 = (select col2 from dos where uid = did and [sql]='cool');
update uno set col1=d.col1,col2=d.col2 from uno select * from uno select * from dos;
update uno set col1 = (select col1 from dos d where uno.[id] = d.[id] and [sql]='cool'), col2  = (select col2 from dos d where uno.[id] = d.[id] and [sql]='cool');
update t1                    -- just reference table alias here set t1.somevalue = t2.somevalue from table1 t1               -- these rows will be the targets;
update table1 a , table2 b set a.columname = 'some value' where b.columnname is null ;
update t set t.col1 = o.col1 from table1 as t table2 as o;
update yourtable set col1 = othertable.col1, col2 = othertable.col2 from ( select id, col1, col2 from other_table) as othertable where othertable.id = yourtable.id;
as (select t1.col1, t2.col1 as _col1, t1.col2, t2.col2 as _col2 from   t1 join t2 where exists(select t1.col1, t1.col2 select t2.col1, t2.col2)) update cte set    col1 = _col1, col2 = _col2;
update ... from;
update table set table.col1 = other_table.col1, table.col2 = other_table.col2 from table inner join other_table on table.id = other_table.id where table.col1 != other_table.col1 or table.col2 != other_table.col2 or ( other_table.col1 is not null and table.col1 is null ) or ( other_table.col2 is not null and table.col2 is null );
update table set  table.col1 = other_table.col1, table.col2 = other_table.col2 from     table;
and s.tsql = 'cool' update set col1 = s.col1, col2 = s.col2;
select id, col1, col2 from other_table where tsql = 'cool' update set col1 = s.col1, col2 = s.col2;
update table_a set table_a.col1 = table_b.col1, table_a.col2 = table_b.col2 from some_table as table_a where table_a.col3 = 'cool';
update t set t.col1 = o.col1, t.col2 = o.col2 from other_table o join t on t.id = o.id where o.sql = 'cool';
update t set t.col1 = a.col1 from ( select id, col1, col2 from @tbl2) a;
update t set t.col1 = a.col1 from ( select id, col1, col2 from @tbl2) a select * from @tbl1 select * from @tbl2;
as (select col1,col2,id from   other_table where  sql = 'cool') update a set    a.col1 = b.col1, a.col2 = b.col2 from   table a;
update table as a set ... where ...;
set table_a.col1 = table_b.col1, table_a.col2 = table_b.col2;
update tq set tq.isprocessed = 1, tq.textname = 'bla bla bla' from tablequeue tq where tq.isprocessed = 0;
select tq.isprocessed, 1 as newvalue1, tq.textname, 'bla bla bla' as newvalue2 from tablequeue tq where tq.isprocessed = 0;
create table #source ([id] int, [desc] varchar(10));
create table #dest   ([id] int, [desc] varchar(10));
update #dest set #dest.[desc] = #source.[desc] from #source where #dest.[id] = #source.[id];
update table1 set table1.col1 = table2.col1, table1.col2 = table2.col2 from table2 where table1.id = table2.id;
update a set a.col = a.col,b.col1 = b.col1 from  first_table as a;
update table t, (select col1, col2 from other_table where sql = 'cool' ) o set t.col1 = o.col1, t.col2=o.col2 where t.id = o.id;
update table set col1, col2 from table where sql = 'cool';
select * from @tblmarks update m set m.std_name=s.name from @tblmarks as m select * from @tblmarks;
update table1 set column1 = (select expression1 from table2 where conditions);
update some_table as table_a join other_table as table_b using(id) set table_a.col1 = table_b.col1, table_a.col2 = table_b.col2 where table_a.col3 = 'cool';
update table1                                     //table that's going to be updated set fieldfromtable1 = tb2.fieldfromtable2;            //field to be updated on table1;
create table [dbo].[product]( [id] [int] identity(1, 1) not null, [name] [nvarchar](100) not null, [description] [nvarchar](100) null;
create table [dbo].[product_bak]( [id] [int] identity(1, 1) not null, [name] [nvarchar](100) not null, [description] [nvarchar](100) null;
update p1 set name = p2.name from product p1 where p1.id = 2;
( select id, name from product_bak where id = 2 ) update p set name = p2.name from  product p  inner join cte p2 on p.id = p2.id where p2.id = 2;
update set p1.[description] = p2.[description], p1.name = p2.name;
update set p1.[description] = p2.[description], p1.name = p2.name;
update t1 set t1.col1 = t2.col1, t1.col2 = t2.col2 from table1 as t1 where t1.col3 = 'cool';
update a set a.col1 = b.col1, a.col2 = b.col2 from some_table as a where a.col3 = 'cool';
update table set col1 = b.col1, col2 = b.col2 from ( select id, col1, col2 from other_table) b where b.id = table.id;
alter table tes add ssd  number   default '0';
alter table yourtable add column1 int not null default 0, column2 int not null default 1, column3 varchar(50) default 'hello';
alter table [dbo.table_name] add [column_name] bit not null default ( 0 );
if exists ( select 1 from information_schema.columns where table_name = 'table_emplyee' and column_name = 'column_employeename' ) if exists ( select 1 from sys.default_constraints where object_id = object_id('[dbo].[df_table_emplyee_column_employeename]') and parent_object_id = object_id('[dbo].[table_emplyee]') ) alter table [dbo].[table_emplyee] drop constraint [df_table_emplyee_column_employeename] end --    -----   drop column   ----------------------------------------------------------------- alter table [dbo].table_emplyee drop column column_employeename end  if not exists ( select 1 from information_schema.columns where table_name = 'table_emplyee' and column_name = 'column_employeename' ) alter table dbo.table_emplyee add column_employeename bit   not null constraint [df_table_emplyee_column_employeename]  default (0) end ;
alter table product add productid int not null default(1);
alter table [employees] add seniority int not null default 0 go;
alter table mytable add mynewcolumn varchar(200) default 'snuggles';
alter table table add column bit     -- demonstration with null-able column added constraint constraint_name default 0 with values;
alter table mytablename add recordaddeddate smalldatetime null default (getdate());
alter table {tablename} add {columnname} {type} {null|not null} constraint {constraint_name} default {default_value};
exec sp_msforeachtable;
alter table {tablename} add {columnname} {type} {null|not null} constraint {constraint_name} default {default_value};
alter table mytable add mynewcolumn int not null default 0;
alter table [schema].[tablename] add  default ((0)) for [columnname];
alter table [schema].[tablename] drop constraint [constraintname];
alter table add columnname {column_type} constraint;
alter table protocols add protocoltypeid int not null default(1);
alter table {tablename} add {columnname} {type} {null|not null} constraint {constraint_name} default {default_value};
alter table sometable add somecol bit null --or not null. constraint d_sometable_somecol --when omitted a default-constraint name is autogenerated. default (0)--optional default-constraint.;
constraint d_sometable_somecol;
alter table <table name> add <new column name> <data type> not null alter table <table name> add constraint <constraint name> default <default value> for <new column name>;
alter table [tablename] add mynewcolumn int not null default 0 go;
alter table product add referenceid uniqueidentifier not null default (cast(cast(0 as binary) as uniqueidentifier));
if not exists ( select * from information_schema.columns where table_name ='tablename' and column_name = 'columnname' ) alter table tablename add columnname nvarchar(max) not null default end;
alter table [table] add column1 datatype;
alter table [test] add id int;
alter table [test] add id int identity(1,1) not null;
create table student (student_id int not null);
alter table student add student_name int not null default(0) select * from student;
alter table tbl_table add int_column int not null default(0);
alter table table_name add field field_name data_type;
create default default_name as 'default_value';
exec sp_bindefault 'default_name' , 'schema_name.table_name.field_name';
exec sp_bindefault 'today', 'humanresources.employee.hiredate';
if not exists (select * from information_schema.columns where table_name = 'tasksheet' and column_name = 'isbilledtoclient') alter table dbo.tasksheet add end go;
alter table {tablename} add {columnname} {type} {null|not null} constraint {constraint_name} default {default_value};
alter table tablename add columnname datatype default defaultvalue;
alter table {schemaname}.{tablename} add {columnname} {datatype} null constraint {constraintname} default {defaultvalue} update {schemaname}.{tablename} set {columnname} = {defaultvalue} where {columname} is null alter table {schemaname}.{tablename} alter column {columnname} {datatype} not null;
update top (1000000) {schemaname}.{tablename} set {columnname} = {defaultvalue} where {columname} is null if @@rowcount < 1000000 end;
create table testtable alter table testtable add secondcol int update testtable set secondcol = 0 alter table testtable alter column secondcol int not null;
alter table tablename add columnname (type) -- null or not null default (default value);
alter table activities add status int not null default (0);
alter table table_1 add row3 int not null constraint constraint_name default (0);
alter table testtable add thirdcol int not null default(0);
alter table table1 add col3 int not null default(0);
alter table tablename add columnname datatype null|not null default (default_value);
alter table tablename add  constraint [constraint_name]  default;
alter table mytable add mynewcolumn datatype default defaultvalue;
alter table {tablename} add {columnname} {datatype} default {default_value};
alter table [table1] add [column1] int default 1;
alter table <your_tablename> add <your_columnname> <datatype> <null|not null> add constraint <constraint_name>   ----optional default <default_value>;
alter table temp_tablename add column1 numeric(10,0) not null add constraint abcde   ----optional default (0);
alter [online | offline] [ignore] table tbl_name add [column] (col_name column_definition,...);
if (empty($dir) || $dir !== 'desc') {;
select password from users where name = 'root';
select password from users where name = 0x726f6f74;
select password from users where name = unhex('726f6f74');
select ... where id = -1 union all select table_name from information_schema.tables;
select ... where id = -1 union all select column_name from information_schema.column where table_name = __0x61727469636c65__;
select ... where id = unhex('2d312075...3635');
select * from trainers where name = ? and email = ? and last_login > ?');
select * from mysql.user where user='username';
select * from users where name = '".mysql_escape_string($name_from_html_form)."';
where 1=1   or  limit 1;
select * from users where name = '".mysql_escape_string($name_from_html_form)."' limit 1;
if (is_string($value)) else if (is_null($value)) else if (!is_int($value) && !is_float($value)) '/{(\\d+)}/', function($match) use ($values) if (isset($values[$match[1]])) else { $query;
'user.id', '=', 'tweet.user_id';
select * from user where name = 'john';
create index name_index;
select * from employee where employee_name = 'abc';
create database;
create database if not exists db_name;
-s, --silent        be more silent. print results with a tab as separator, each row on new line.;
create database dbname;
select * from ( select id, name, age, comments, row_number() over(partition by name, age order by name) as rank from customers;
create table my_users(id number, name varchar2(100), email varchar2(100));
select * from my_users where rowid not in (select min(rowid) from my_users group by name, email);
select count(distinct col_01) from table_01;
select duplicatekey1 from mytable having count(*) > 1 ) select e.* from mytable e join mycte cte and e.duplicatekey2=cte.duplicatekey2;
select emp.ename, emp.empno, dept.loc from emp (select ename, count(*) from having count(*) > 1);
from ccnmaster ) select * from cte;
create table my_table(id int, name varchar(100), email varchar(100));
select count(1) as total_rows from my_table select count(1) as distinct_rows from ( select distinct * from my_table) abc;
select name, email, count(*) from users name, email having count(*) > 1;
select name, email from users having ( count(*) > 1 );
select name,email, count(*) as countof from @yourtable having count(*)>1;
select y.id,y.name,y.email from @yourtable y from @yourtable having count(*)>1;
delete d from @yourtable d from @yourtable y from @yourtable having count(*)>1 where dt2.rowrank!=1 select * from @yourtable;
select * from users s where rowid < any;
select * from users s where rowid not in;
delete from users s where rowid < any;
delete from users s where rowid not in;
select name, email, count(*) from users having count(*) > 1;
(  select row_number() over (partition by name order by name) as t from     @yourtable ) delete from cte where t > 1;
select u.* from users as u join (select username, email from users having count(*)>1) as w;
select * from  from users) where cnt >1;
select name, email, count(*) from users having count(*) > 1;
select name, email, count(distinct id) from users having count(distinct id) > 1;
select name, email,count(email) from users where email in ( select email from users having count(email) > 1);
create table #tableb (id_account int, data int, [date] date) (1, 20, '10/09/2018'), (2 ,-900, '10/01/2018'), (1 ,20, '09/25/2018'), (1 ,-100, '08/01/2018') select id_account , data, count(*) from #tableb having count(id_account) > 1 drop table #tableb;
select distinct * into #temnewtable from #originaltable drop table #temnewtable;
select count(empcode),empcode from tbl_employees where status=1;
select column_name,count(*) from table_name group by column1, having count(*) > 1;
select name, email from users where email in having count(*)>1);
select id, count(id) from table1 group by id having count(id)>1;
select id, name, email from users u, users u2 where u.name = u2.name and u.email = u2.email and u.id > u2.id;
delete from users where id in ( select id/*, name, email*/ from users u, users u2 where u.name = u2.name and u.email = u2.email and u.id > u2.id );
select * from users a where exists (select * from users b where (     a.name = b.name or  a.email = b.email) and a.id != b.id);
select group_concat( id ) from users having ( count(email) > 1 );
select name, email else 'no' end "duplicated ?" from users;
as ( select name,emailid,row_number() over(partition by emailid order by id) as duplicate from [employees] ) select * from mycte where duplicate>1;
select id,name,count(*) from user group by id,name having count(*)>1;
as ( select studentid, firstname, lastname, dateofbirth as dob, sum(1) over (partition by firstname, lastname, dateofbirth) as rowcnt from tblstudent ) select * from cte where rowcnt > 1;
select * from users u where rowid = (select max(rowid) from users u1 where;
select * from table where id not in ( select min(id) from table;
delete from table where id not in ( select min(id) from table;
create table users (id int, name varchar(10), email varchar(50));
select name, email, count(*) as countof from users having count(*)>1;
delete * from users where id in ( select u1.id from users u1, users u2 where u1.name = u2.name and u1.email = u2.email and u1.id > u2.id;
select *, count(*) from users t1 where t1.id > t2.id and t1.name = t2.name and t1.email=t2.email;
select name, email, count(*) from users email having count(*) > 1;
select 1 as a, group_concat(name order by name asc separator ', ') as people from users where id in (1,2,3);
select @names = @names + ' ' + name from names;
select @names = coalesce(@names + ', ', '') + name from people;
select @names = coalesce(@names + ', ', '') + name from people where name is not null;
select @names = coalesce(@names + ', ', '') + from people;
select @name = '' select @names = @names + ',' + names from people select substring(2, @names, 7998);
select main.subjectid, left(main.students,len(main.students)-1) as "students" from ( select distinct st2.subjectid, ( select st1.studentname + ',' as [text()] from dbo.students st1 where st1.subjectid = st2.subjectid from dbo.students st2;
select distinct st2.subjectid, substring( ( select ','+st1.studentname  as [text()] from dbo.students st1 where st1.subjectid = st2.subjectid from dbo.students st2;
select stuff( (select n', ' + name from names for xml path(''),type);
select per.id, emails = json_value( replace( (select _ = em.email from email em where em.person = per.id for json path) ) from person per;
select fname + ', ' as 'data()' from namelist;
(select fname as 'data()'  from namelist  for xml path(''));
( select row_number() over(order by id) id, -- id is a line id from source -- line source result_lines as ( select id, cast(line as nvarchar(max)) line from lines where id = 1 union all select l.id, cast(r.line + n', ' + l.line as nvarchar(max)) from lines l result_lines r ) select top 1 from result_lines id desc;
( id int, name varchar(10) ) select 1,'a' union all select 1,'b' union all select 2,'c' union all select 2,'d' select id, stuff( ( select ','+ [name] from @t where id = t.id for xml path('') from (select distinct id from @t ) t;
select @names = coalesce(coalesce(@names + ', ', '') + name, @names) from people;
select substring( (select ', '+name as 'data()' from names for xml path(''));
set @names = '' select @names = @names + ', ' + name from names set @ssql = left(@ssql, len(@ssql) - 1);
column employees format a50 select deptno, listagg(ename, ',') within group (order by ename) as employees from   emp;
select id, cast(name as varchar(max)) name, row_number() over (partition by id order by seq) rw, count(*) over (partition by id) recs from (values (1, 'm', 2), (2, 'bill', 1), (2, 's.', 4), (2, 'preston', 5), (2, 'esq.', 6), (3, 'ted', 1), (3, 'theodore', 2), (3, 'logan', 3), (4, 'peter', 1), (4, 'paul', 2), (4, 'mary', 3) rcte as ( select recs, id, name, rw from basetable where rw = 1 union all  select b.recs, r.id, r.name +', '+ b.name name, r.rw + 1 from basetable b ) select name from rcte where recs = rw and id=4;
create table test=# insert into names (name) values ('peter'), ('paul'), ('mary');
create table name;
select substr(max(sys_connect_by_path (first_name, ',')),2) from (select rownum r, first_name from name ) n start with r=1 connect by prior r+1=r;
select  rtrim(xmlagg (xmlelement (e, first_name || ',')).extract ('//text()'), ',') first_name from name;
select string_agg(name, ',') from names;
select question_id, listagg(element_id, ',') within group (order by element_id) from your_table;
create table #test (id int,name varchar(10)) select @t = isnull(@t + ',' + name, name) from #test where id = 1 select @t drop table #test;
select * from npath( on students 'true' as a ) first(subjectid of a) as subjectid, accumulate(studentname of a) as studentname );
( id int identity, name varchar(500) ) set @rowscount = (select count(id) from @mytable) set @names = @names + ', ' + (select name from @mytable where id = @i) set @i = @i + 1 end select @names;
select @names = concat(@names, ' ', name) from names select @names;
select @phone=@phone + mobileno +',' from  members select @phone;
exec sp_configure 'show advanced options', 1 exec sp_configure 'clr strict security', 1;
create assembly concat_assembly from '<path to concat.dll in server>' create aggregate dbo.concat ( ;
select dbo.concat(field1, ',') from table1;
create table `data` ( `id` int(11) not null, `user_id` int(11) not null (2, 1), (3, 1), (4, 1), (5, 1), (6, 0), (7, 1), (8, 1), (9, 0), (10, 1);
create table `user` ( `id` int(11) not null (1);
select user.id, group_concat(data.id order by data.id) as rowlist from user left join data on user.id = data.user_id group by user.id;
select  @numbers = coalesce(@numbers + ',', '') + number from   tablename where number is not null select @numbers;
select table_name select ',' + column_name from information_schema.columns columns where tables.table_name = columns.table_name from information_schema.columns tables;
select pagecontent = stuff( (   select pagecontent from dbo.infoguide where categoryid = @categoryid and subcategoryid = @subcategoryid 1, 1, '') from dbo.infoguide info;
create table dbo.students ( studentid int create table dbo.subjects ( subjectid int create table dbo.schedules ( studentid int select sub.subjectid from dbo.subjects sub ( select case row_number() over (order by stu.name) when 1 then '' else ', ' end from dbo.students stu where sch.subjectid = sub.subjectid stu.name;
select @mylist = case when @mylist > '' then @mylist + @delimiter else '' end + fieldtoconcatenate from mydata;
select @char = coalesce(@char + ', ' + [column], [column]) from [table];
select string_agg(name, ', ') as departments from humanresources.department;
select groupname, string_agg(name, ', ') as departments from humanresources.department;
select groupname, string_agg(name, ', ') within group (order by name asc) as departments from humanresources.department;
select stuff((select ', ' + name from [table] for xml path('')), 1, 2, '');
select stuff((select ', ' + name from @t for xml path('')), 1, 2, '');
create table "names" ("name" varchar2(10 byte))) ;
select max(rownum) into maxnum from names;
select name into  c_name from end loop;
create table tbl ) select 'c0001','thomas','breakfast','milk' union select 'c0001','thomas','breakfast','bread' union select 'c0001','thomas','breakfast','egg' union select 'c0001','thomas','lunch','rice' union select 'c0001','thomas','lunch','fish curry' union select 'c0001','thomas','lunch','lessy' union select 'c0002','joseph','breakfast','bread' union select 'c0002','joseph','breakfast','jam' union select 'c0002','joseph','breakfast','tea' union select 'c0002','joseph','supper','tea' union select 'c0002','joseph','brunch','roti' create  function [dbo].[fn_getitemsbytype] ( @customercode varchar(50) ) as begin select  stuff((select distinct ',' + [items] from tbl where customercode = @customercode and type=@type end  @query  as nvarchar(max) select @cols = stuff((select distinct ',' + quotename(type) from tbl set @query = 'select customercode,customername,' + @cols + ' from ( select distinct customercode from tbl t ( max(items);
select customercode, customername, case when typez = 'breakfast' then items else null end as 'breakfast' from #customer ) select distinct customercode, customername, substring( ( select ','+breakfast as [text()] from cte_base b1 where b1.customercode = b2.customercode and b1.customername = b2.customername substring( ( select ','+lunch as [text()] from cte_base b1 where b1.customercode = b2.customercode and b1.customername = b2.customername from cte_base b2;
select t1.id, group_concat(t1.id) ids from table t1 join table t2 on (t1.id = t2.id);
create table tmptable (name varchar(30)) ;
select * , row_number() over(order by name) rang , count(*) over() nbrow from tmptable tmprecursive as ( select *, cast(name as varchar(2000)) as allname from tblwithrank  where rang=1 union all select f0.*,  cast(f0.name + ',' + f1.allname as varchar(2000)) as allname from tblwithrank f0 inner join tmprecursive f1 on f0.rang=f1.rang +1 ) select allname from tmprecursive where rang=nbrow;
union all select t2.id,cast(t1.str+',' +t2.str as nvarchar(100)) ,t1.ind+1 from cte t1 inner join @mytable t2 on t2.id=t1.id+1) select top 1 str from @myresult order by r# desc;
select distinct @names = coalesce(@names + ',', '') + name from people where name is not null select @names;
select carnamesstring = stuff(( select ',' + [name] from tbl_cars;
select [name], group_concat(distinct [name]  separator ',') from tbl_cars;
select array_to_string(array_agg(distinct rolname), ',') from pg_catalog.pg_roles;
select string_agg(rolname::text,',') from pg_catalog.pg_roles;
title nvarchar(50) ) select p.title from dbo.person p set @mainstring = '';
set @itemtitle = (select top(1) t.title from @temp t) if @mainstring = '' set @mainstring = @itemtitle end else begin set @mainstring = concat(@mainstring,',',@itemtitle) end  delete top(1) from @temp end print @mainstring;
select cast(createddate as date) as derivedate from table;
select convert(datetime, convert(varchar, getdate(), 103));
select convert(datetime, convert(varchar, getdate(), 101));
select convert(datetime, convert(varchar, getdate(), 102));
select cast(getdate() as date) as 'date1' select date2  = convert(date, getdate()) select convert(date, getdate()) as 'date3' select convert(char(10), getdate(), 121) as 'date4' select convert(char(10), getdate(), 126) as 'date5' select convert(char(10), getdate(), 127) as 'date6';
select date(getdate());
select convert(datetime, (round(convert(float, getdate()-.5),0)));
select convert(getdate() as date) select convert(datetime,convert(date, getdate()));
select convert(smalldatetime,convert(int,convert(float,getdate())));
select convert(varchar(max),getdate(),103) select cast(getdate() as date);
select convert(date, getdate()) select dateadd(dd, 0, datediff(dd, 0, @your_date)) select dateadd(dd, 0, datediff(dd, 0, getdate()));
select convert (date, getdate()) 'date part only';
select format(getdate(), 'yyyy-mm-dd 00:00:00.000');
select format ( @d, 'd', 'en-us' ) as 'us english result' select format ( @d, 'd', 'en-us' ) as 'us english result';
select @date   --> 2017-05-03;
( str( year( getdate() ) ) + '/' + ) as datetime);
select cast(current_timestamp as date);
select sysdate today from dual;
select cast(floor(cast(getdate() as float)) as datetime);
select format(getdate(), 'yyyy-mm-dd');
select * from tablename where cast ([my_date_time_var] as date)= '8/5/2015';
select convert(varchar(10),getdate(),111);
select convert(datetime, convert(varchar, getdate(), 101));
select convert(date, getdate());
select dateadd(dd, 0, datediff(dd, 0, @your_date));
select dateadd(dd, 0, datediff(dd, 0, getdate()));
select dateadd(dd, datediff(dd, 0, getdate()), 0);
select getdate() select dateadd(hh, datediff(hh, 0, getdate()), 0) select dateadd(hh, 0, datediff(hh, 0, getdate())) select dateadd(dd, datediff(dd, 0, getdate()), 0) select dateadd(dd, 0, datediff(dd, 0, getdate())) select dateadd(mm, datediff(mm, 0, getdate()), 0) select dateadd(mm, 0, datediff(mm, 0, getdate())) select dateadd(yy, datediff(yy, 0, getdate()), 0) select dateadd(yy, 0, datediff(yy, 0, getdate()));
select dateadd(dd, datediff(dd, 0, getdate()), 0) select dateadd(day, 0, datediff(day,0, getdate())) select convert(datetime, convert(varchar(10), getdate(), 101));
select cast(floor(cast(getdate() as float)) as datetime);
set showplan_text on;
select convert(date, getdate());
select convert(varchar,dateadd(day,-1,getdate()),103) --21/09/2011 select convert(varchar,dateadd(day,-1,getdate()),101) --09/21/2011 select convert(varchar,dateadd(day,-1,getdate()),111) --2011/09/21 select convert(varchar,dateadd(day,-1,getdate()),107) --sep 21, 2011;
select cast(getdate() as date);
select convert(datetime,convert(date,getdate()));
select convert(date, getdate()) --2014-03-26 select convert(varchar(10), getdate(), 111) --2014/03/26;
select convert(datetime, convert(varchar(10), getdate(), 111)) as onlydate;
select convert(datetime, convert(varchar(10), getdate(), 112)) as onlydate;
set @onlydate = datediff(dd, 0, getdate()) select @onlydate as onlydate;
select  date_format( some_datetime_column,  '%d-%m-%y' ) from table_name;
select convert(date, @yourdate);
select cast(date_variable as date);
select date_variable::date;
select table1.column1, table2.column2... from table1;
select tablea.firstname,tablea.lastname,tableb.age,tableb.place from tablea;
select table1.column1, table2.column2... from table1;
select tablea.firstname,tablea.lastname,tableb.age,tableb.place from tablea;
select table1.column1, table2.column2... from table1;
select tablea.firstname,tablea.lastname,tableb.age,tableb.place from tablea;
select table1.column1, table2.column2... from table1;
select tablea.firstname,tablea.lastname,tableb.age,tableb.place from tablea;
values ('fred', 'smith'), ('john', 'smith'), ('michael', 'smith'), ('robert', 'smith');
select  'first' ,1 union all select  'second' ,2 union all select  'third' ,3;
values ('john', 123, 'lloyds office'), ('jane', 124, 'lloyds office'), ('billy', 125, 'london office'), ('miranda', 126, 'bristol office');
exec sp_serveroption 'yourservername', 'data access', true select  * from    openquery(yourservername, 'exec db.schema.sproc 1');
create table #tmpbus ( col1 int, col2 int ) exec spgetrecords 'params';
create proc getbusinesslinehistory as begin select * from sys.databases end go select * into #mytemptable from openrowset('sqlncli', 'server=(local)\sql2008;trusted_connection=yes;', 'exec getbusinesslinehistory') select * from #mytemptable;
create function customersbyregion ( @regionid int ) as return select * from customers where regionid = @regionid;
select * from customersbyregion(1);
select * into custlist from customersbyregion(1);
create procedure uspcustomersbyregion ( @regionid int ) as begin select * from customersbyregion(@regionid);
select * from dbo.fnfunctionname(10, 20) ) select col1, col2 from temp;
select id from dbo.fnfunctionname(10, 20) temp2030 as ( select id from dbo.fnfunctionname(20, 30) ) select * from temp1020 where id not in (select id from temp2030);
create table #t1 ( col1 int not null, col2 nchar(50) not null, col3 text not null, col4 datetime null, col5 nchar(50) null, col6 char(2) null, col6 nchar(100) null, col7 int null, col8 nchar(50) null, col9 datetime null, col10 datetime null ) set @para1 = 1025 set @para2 = n'6as54fsd56f46sd4f65sd' set @para3 = n'xxxx\username' set @para4 = n'127.0.0.1' set @para5 = n'xxxxxxx' set @para6 = n'x' set @para7 = n'x' ( col1, col2, col3, col4, col5, col6, col6, col7, col8, col9, col10, ) exec [dbo].[usp_procedurename] @para1, @para2, @para3, @para4, @para5, @para6, @para6;
( name varchar(255), field varchar(255), filename varchar(255), filegroup varchar(255), size varchar(255), maxsize varchar(255), growth varchar(255), usage varchar(255) select * from @temp;
exec sp_serveroption 'myservername', 'data access', true;
set @locdateone = '2/11/2010' set @locdatetwo = getdate() select * into #tempcoattendancerpt20100211 from openquery(dbaseserver, 'exec database.dbo.proc_mystoredproc 1,"2/1/2010","2/15/2010 3:00 pm"') set @loccompanyid = '7753231' exec database.dbo.proc_mystoredproc @loccompanyid,@locdateone,@locdatetwo set @loccompanyid = '9872231' exec database.dbo.proc_mystoredproc @loccompanyid,@locdateone,@locdatetwo select * from #tempcoattendancerpt20100211 drop table #tempcoattendancerpt20100211;
@provider = 'sqloledb', @datasrc = @@servername;
select * from table(cast(f$my_functions('8028767') as my_tab_type));
create procedure [dbo].[execintotable] ( @tablename          nvarchar(256), @storedprocwithparameters   nvarchar(max) ) as begin set @driver = '''sqlncli''' set @connectionstring = set @rowsetsql = '''exec ' + replace(@storedprocwithparameters, '''', '''''') + '''' set @sql = ' select * from openrowset(' + @driver + ',' + @connectionstring + ',' + @rowsetsql + ')' exec (@sql) end go;
( --these columns were copied from sp_help col2 int ) exec spmyproc;
set @storedprocname = 'mystoredproc' select @strsql = @strsql+stuff(( select ',' +name+' ' + system_type_name from sys.dm_exec_describe_first_result_set_for_object (object_id(@storedprocname),0) exec (@strsql) exec ('mystoredproc @param1=1, @param2=2') select * from mytablename drop table mytablename;
create procedure #temptableforsp(@tableid int, @procedureid int) as begin from tempdb.sys.tables where object_id = @tableid set @tsql = ' from tempdb.sys.columns c where c.object_id =  ' + ) alter table tempdb.dbo.' + @tablename + ' add ' + quotename(@tempid) + ' int;
exec sp_executesql @drop;
select ''alter table ' + @tablename from sys.dm_exec_describe_first_result_set_for_object(' alter table '  + @tablename + ' drop column ' + quotename(@tempid) + '  ';
end go create table #exampletable (pk int);
exec #temptableforsp @tableid, @procedureid;
exec examplestoredprocedure;
create table #temptable (column1 int, column2 varchar(max));
exec [app].[sproc_name] @param2 =2;
create procedure dbo.usp_getstoredproctabledefinition( @procedurename  nvarchar(128), @tablename      nvarchar(128), @sql            nvarchar(max) output ) as set @sql = 'create table ' + @tablename + ' (' select @sql = @sql + '['+name +'] '+ system_type_name +''  + ',' from sys.dm_exec_describe_first_result_set_for_object ( object_id(@procedurename), null set @sql = substring(@sql,0,len(@sql)) set @sql =  @sql +')';
exec dbo.usp_getstoredproctabledefinition @tablename='##yourglobaltemptable',@sql = @sql output exec    [dbo].usp_yourprocedure select * from ##yourglobaltemptable;
select * into #tmpbusline from dbo.udf_getbusinesslinehistory '16 mar 2009';
create table #temp (...);
select * from openrowset('sqlncli', 'server=localhost;trusted_connection=yes;', 'exec [db].[schema].[sproc]');
create table [dbo].[tbltestingtree]( [id] [int] identity(1,1) not null, [parentid] [int] null, [isleft] [bit] null, [isright] [bit] null, constraint [pk_tbltestingtree] primary key clustered ( [id] asc set identity_insert [dbo].[tbltestingtree] on set identity_insert [dbo].[tbltestingtree] off values (10, 5, 1, null) set identity_insert [dbo].[tbltestingtree] on create procedure getdate as begin select id,parentid from tbltestingtree end  create table tbltemp ( id int, parentid int ) exec getdate select * from tbltemp;
@tmp_global_table varchar(255) = '##global_tmp_' + convert(varchar(36), newid()) set @sql = @sql + 'select * into [' + @tmp_global_table + '] from yourtable';
@sql nvarchar(max) set @sql = 'create table ##' + @procname + ' (' select      @sql = @sql + '[' + r.name + '] ' +  r.system_type_name + ',' from        sys.procedures as p where       p.name = @procname set @sql = substring(@sql,1,len(@sql)-1) + ')' end;
requisitiontypesourcetypeid int ) exec [dbo].[usp_mysp] 726,3 select * from @abc;
exec ... into ...;
select p.name, r.* from sys.procedures as p;
drop table if exists kv;
create table kv (id_person int, mykey varchar(30), myvalue int);
(1, 'weight', 63), (1, 'height', 175), (2, 'age', 26), (2, 'weight', 83), (2, 'height', 185);
select distinct mykey from kv ) select @comma_separated_keys=string_agg(mykey,',') from cte;
select @comma_separated_keys as keys;
drop table if exists #pivoted;
set @executeexpression = n' select * from ( select mykey, myvalue, id_person from kv max(t.myvalue) set @executeexpression = replace(@executeexpression, 'comma_separated_keys', @comma_separated_keys);
select * from #pivoted;
select * from #pivoted;
drop table if exists kv;
create table kv (id_person int, mykey varchar(30), myvalue int);
(1, 'weight', 63), (1, 'height', 175), (2, 'age', 26), (2, 'weight', 83), (2, 'height', 185);
select distinct mykey from kv ) select @comma_separated_keys=string_agg(mykey,',') from cte;
select @comma_separated_keys as keys;
drop table if exists #pivoted;
set @executeexpression = n' select * from ( select mykey, myvalue, id_person from kv max(t.myvalue) select * from #pivoted;
set @executeexpression = replace(@executeexpression, 'comma_separated_keys', @comma_separated_keys);
from openrowset(''sqlncli'', ''server=servername;database=dbname;trusted_connection=yes'', ''exec storedprocedurename '+ cast(@param1 as varchar(15)) +','+ cast(@param2 as varchar(15)) +''') as a ;
select * from #mytemptable;
drop table #mytemptable;
create table #d max_length  smallint  null, precision   tinyint  null,  scale   tinyint  null,  collation_name  sysname null, user_type_id  int null, user_type_database    sysname null, user_type_schema    sysname null,user_type_name sysname null,assembly_qualified_type_name   nvarchar(4000),xml_collection_id    int null,xml_collection_database    sysname null, xml_collection_schema   sysname null,xml_collection_name    sysname null,is_xml_document    bit  null,is_case_sensitive bit  null,is_fixed_length_clr_type  bit  null, source_server   sysname null,source_database    sysname null,source_schema  sysname null,source_table   sysname null,source_column  sysname null,is_identity_column bit null, is_part_of_unique_key   bit null,is_updateable  bit null,is_computed_column bit null,is_sparse_column_set   bit null,ordinal_in_order_by_list   smallint null, order_by_list_length    smallint null,order_by_is_descending    smallint null,tds_type_id   int  null,tds_length    int  null,tds_collation_id  int null, tds_collation_sort_id   tinyint null) exec sp_describe_first_result_set @exestr, null, 0 select @qry = 'create table ##t(' + (select ',' + name + ' '+ system_type_name + ' null' from #d d for xml path, type) exec '+@procname+' ' + @param exec sp_executesql @qry select * from ##t drop table #d;
create or alter procedure [dbo].[sp_gettabledefinitionfromsqlbatch_describefirstresultset] ( @sql nvarchar(4000) ) as begin set nocount on ) exec sp_describe_first_result_set @sql select n'create table ' + @table_name + n' (' as textval union all  select concat( case column_ordinal from @resultdefinition where is_hidden = 0  -- may not be needed union all  select n');' + @newline ) select @temptabledefinition = coalesce (@temptabledefinition + @newline + textval, textval) from stmt select @tabledefinition = @temptabledefinition end;
drop table if exists #mytemptable drop table if exists ##fe264bf5_9c32_438f_8462_8a5dc8dee49e_mytemptable exec [dbo].[sp_gettabledefinitionfromsqlbatch_describefirstresultset] exec sp_executesql @tabledef exec sp_executesql @sql select * from ##fe264bf5_9c32_438f_8462_8a5dc8dee49e_mytemptable select * from #mytemptable drop table if exists #mytemptable drop table if exists ##fe264bf5_9c32_438f_8462_8a5dc8dee49e_mytemptable;
id int primary key identity not null ) values ('n', 'n'), ('n', 'y'), ('y', 'y'), ('y', 'n') as ( select 'checkifinstock' = cast(isnull(nullif(isnull(nullif(p.[instock], 'y'), 1), 'n'), 0) as bit) from @product as p ) select 'salable' = c.[checkifinstock] & ~c.[checkifobsolote] from [cte] c;
select iif(obsolete = 'n' or instock = 'y', 1, 0) as salable, * from   product;
select 'doe', 'john', 'chicago' from dual where not exists where last_name = 'doe' and first_name = 'john' and city = 'chicago');
if exists(select * from   northwind.dbo.customers where  customerid = 'alfki') else print 'need to add customer record alfki' if exists(select * from   northwind.dbo.customers where  customerid = 'larse') else print 'need to add customer record larse';
select iif(obsolete = 'n' or instock = 'y', 1, 0) as salable, * from   product;
if @includeextendedinformation = 1 select a,b,c,x,y,z from   t end else begin select a,b,c from   t end;
select (case else 'no' from product;
select salable = case obsolete else 0 end;
select case when obsolete = 'n' or instock = 'y' then 'true' else 'false' end as salable, * from product;
select cast( case when obsolete = 'n' or instock = 'y' then 1 else 0 end as bit) as saleable, * from product;
select case then 1 else 0 end as saleable, * from product;
select iif(obsolete = 'n' or instock = 'y', 1, 0) as saleable, * from product;
select firstname, lastname, salary, dob, case gender end from employees;
select case when obsolete = 'n' or instock = 'y' then 'yes' else 'no' end;
where 1 = case when obsolete = 'n' or instock = 'y' then 1 else 0 end;
select case then 'y' else 'n' end as available;
select case <variable> when <value>      then <returnvalue> else <returndefaultcase> end as <newcolumnname> from <table>;
select case when <test>      then <returnvalue> else <returndefaultcase> end as <newcolumnname> from <table>;
select case when profile.nrefillno = 0 then 'n' else 'r'end as newref from profile;
case statement some what similar to if in sql server select case then 1 else 0 end as saleable, * from product;
if @val < 25 else print 'by ravi anand.';
if @val < 25 else begin if @val < 50 else print 'bye ravi anand.';
case orweb2.dbo.inventory.regulatingagencyname then orweb2.dbo.countystateagcontactinfo.contactstate then orweb2.dbo.countystateagcontactinfo.contactstate then orweb2.dbo.countystateagcontactinfo.contactstate then orweb2.dbo.countystateagcontactinfo.contactag else ( case orweb2.dbo.countystateagcontactinfo.iscontract then orweb2.dbo.countystateagcontactinfo.contactcounty else orweb2.dbo.countystateagcontactinfo.contactstate end ) end as [county contact name];
select iif ( (obsolete = 'n' or instock = 'y'), 1, 0) as saleable, * from product;
select 1 as saleable, * from @product where ( obsolete = 'n' or instock = 'y' ) union select 0 as saleable, * from @product where not ( obsolete = 'n' or instock = 'y' );
select iif(obsolete = 'n' or instock = 'y',1,0) as saleable, * from product;
select case when obsolete = 'n' or instock = 'y' then 1 else 0 end as saleable, * from product;
(2,'a','b'), (3,'n','b'), (4,'a','y') select p.* , isnull(stmt.saleable,0) saleable from @product p ( values;
select cast( case when obsolete = 'n' or instock = 'y' then else 0 end as bit from product;
select if(obsolete = 'n' or instock = 'y' ? 1 : 0) as saleable, * from product;
select case when p.obsolete = 'n' or p.instock = 'y' then 1 else 0 end as saleable, p.* from product p;
select iif ( (obsolete = 'n' or instock = 'y'), 1, 0) as saleable, * from product;
select case then 1 else 0 end as saleable, * from product;
select orderid, quantity, case when quantity > 30 then "the quantity is greater than 30" else "the quantity is under 30" end as quantitytext from orderdetails;
select case else null end as saleable;
select case else 'false' -- either false or null end as saleable;
select case when obsolete = 'n' or instock = 'y' then 1 else 0 end as salable from product;
select  from ...;
select case when (obsolete = 'n' or instock = 'y') then 1 else 0 end saleable, product.* from product;
select if((obsolete = 'n' or instock = 'y'), 1, 0) as saleable, * from product;
select * from users where name like '%m%';
$lt:isodate("2017-05-05t10:08:16.111z")}, status:"pending", fullname:/last/}).pretty();
orderid:/pha876174/;
query.matches("strname", new bsonregularexpression("abcd", "i")), query.matches("strval", new bsonregularexpression("4121", "i")));
query.matches("strname", new bsonregularexpression("abcd","i")), query.matches("strval", new bsonregularexpression("33156", "i")));
users table => user;
select customername from customers where customerid = 100;
select * from teams where playerid = x;
select * from players inner join teams on players.playerid = teams.playerid where teams.teamid = x;
select orderheader.id from orderheader where orderheader.reference = 'abc123';
select * from cars where color='blue' select * from car where color='blue';
select from customer where customerid = 100;
select customer.customername from customer where customer.customerid = 100;
select customers.customername from customers where customers.customerid = 100;
select * from user;
select * from user where age = '21';
select customer.name, customer.address from customer where customer.name > "def";
select customers.name, customers.address from customers where customers.name > "def";
select [name] from [dbo].[customer] where [location] = 'wa';
select  col1 from    table2;
select  table2.column1, table2.column2, 8, 'some string etc.' from    table2 where   table2.id = 7;
table "owner".table;
create table someone.table ( ... );
pf_emp_code    , pf_dept_code   , pf_sec_code    , pf_prol_no     , pf_fm_seq      , pf_seq_no      , pf_sep_tag     , pf_source) select pfl_emp_code    , pfl_dept_code   , pfl_sec         , pfl_prol_no     , pf_fm_seq       , pf_seq_no       , pfl_sep_tag     , pf_source from cesc_pf_stmt_ext, cesc_pfl_emp_master where pfl_sep_tag like '0' and pfl_emp_code=pf_emp_code(+);
select  col1, col2 from    table2;
select  col1 from    table2;
select table1.column1, table1.column2, table2.column1, table2.column2, 'some string' as somestring, 8 as someint from table1 inner join table2 on table1.column1 = table2.column3;
select col1, col2 ... from table_you_need_to_take_from;
select * -- column sequence should be same. from #table2;
select column1,column2..desired column from #table2 from #table2;
select "hello world", 3, email from table2 where ...;
select * from orders;
set identity_insert tmp on select * from orders set identity_insert tmp off;
values (value1, value2, (select column_table2 from table2 where column_table2 like "blabla"), value4);
select col1, 2, 3... from table2;
select fielda, fieldb, fieldc from donortable;
select  student.id, course.id from student, course where student.name = 'paddy murphy' and course.name = 'basket weaving for beginners';
select  * from    table1;
first_name, last_name) values (1002,'charles','babbage'), (1003,'george', 'boole'), (1001,'donald','chamberlin'), (1004,'alan','turing'), (1005,'my','widenius');
select  column_name from    another_table_name where condition;
full_name , login_name , password ) select  userid , full_name , login_name , password from    users_table;
values ( 'col1_value', 'col2_value', (select col_table2 from table2 where idtable2 = 'your_satisfied_value_for_col_table2_selected'), 'col3_value';
values ('dummy1', (select <field> from <table_name> ),'dummy2');
select 'dummy1', <field>, 'dummy2' from <table_name>;
values (value1, value2);
mobile_no, address from owner_info cm);
select * from purchases p1 where total in;
select a.* from purchases a join ( select customer, min( id ) as id from purchases;
create index purchases_id on purchases (id);
select  customer, (array_agg(id order by total desc))[1], max(total) from purchases;
select p.id, p.customer, p.total, row_number() over(partition by p.customer from purchases p) select s.* from summary s where s.rk = 1;
select min(x.id),  -- change to max if you want the highest x.total from purchases x join (select p.customer, max(total) as max_total from purchases p and y.max_total = x.total;
select <b>distinct on</b> (customer) from   purchases;
select distinct on (2) from   purchases;
create index purchases_3c_idx on purchases (customer, total desc, id);
desc nulls last;
select customer, (array_agg(id order by total desc))[1], max(total) from purchases;
select i from (values (9),(12),(17),(18),(19),(20),(22),(21),(23),(10)) as v(i) ) select * from yourtable where  <condition> --use this as filter for other conditions ) select tops.* from ids ( select top(1) * from src where commodityid = ids.i ) select * from joined;
select * from ( select row_number() from purchases) n where strank = 1;
select distinct;
select distinct customer_id, first_value(row(id, total)) over(partition by customer_id order by total desc, id) from            purchases;
select id, customer, total from purchases;
select purchases.* from purchases and purchases.total < p.total where p.total is null;
and purchases.total < p.total;
where p.total is null;
select ( select **id** from t2 where id = any ( array_agg( tf.id ) ) and amount = max( tf.amount ) name, max(amount) ma, sum( ratio ) from t2  tf;
create or replace function public.first_agg ( anyelement, anyelement ) select $1;
create aggregate public.first ( sfunc    = public.first_agg, basetype = anyelement, stype    = anyelement create or replace function public.last_agg ( anyelement, anyelement ) select $2;
create aggregate public.last ( sfunc    = public.last_agg, basetype = anyelement, stype    = anyelement;
select first(id), customer, first(total) from  purchases;
select first(id order by id), customer, first(total order by id) from purchases;
create table purchases ( id          serial;
select (random() * 10000)::int             as customer_id  -- 10k customers from   generate_series(1,200000) g;
alter table purchases add constraint purchases_id_pkey primary key (id);
delete from purchases where random() > 0.9; -- some dead rows select (random() * 10000)::int             as customer_id  -- 10k customers from   generate_series(1,20000) g;  -- add 20k to make it ~ 200k create index purchases_3c_idx on purchases (customer_id, total desc, id);
create table customer as select customer_id, 'customer_' || customer_id as customer from   purchases alter table customer add constraint customer_customer_id_pkey primary key (customer_id);
select id, customer_id, total from   purchases ) select id, customer_id, total from   cte where  rn = 1;
select id, customer_id, total from   ( select id, customer_id, total from   purchases where  rn = 1;
select distinct on (customer_id) from   purchases;
(  -- parentheses required select id, customer_id, total from   purchases limit  1 ) union all select u.* from   cte c select id, customer_id, total from   purchases where  customer_id > c.customer_id  -- lateral reference limit  1 ) select id, customer_id, total from   cte;
select l.* from   customer c select id, customer_id, total from   purchases where  customer_id = c.customer_id  -- lateral reference limit  1;
select (array_agg(id order by total desc))[1] as id from   purchases;
where customer between x and y;
where customer = x;
create index purchases_3c_idx on purchases (customer, total desc, id);
select * from purchase join ( select min(id) as id from purchase join ( select customer, max(total) as total from purchase;
select article, dealer, price from   shop s1 where  price=(select max(s2.price) from shop s2 where s1.article = s2.article;
select 'foo' as bar union select 'foo' as bar;
select 'foo' as bar union all select 'foo' as bar;
select project_id from t_project union select project_id from t_project_contact;
select project_id from t_project union all select project_id from t_project_contact;
select * from mytable where a=x union all select * from mytable where b=y and a!=x;
select distinct;
select * from table1 union select * from table2;
select distinct * from ( select * from table1 union all select * from table2) dt;
select to_date(sysdate, 'yyyy-mm-dd') from dual union select to_date(sysdate, 'yyyy-mm-dd') from dual;
select to_date(sysdate, 'yyyy-mm-dd') from dual union all select to_date(sysdate, 'yyyy-mm-dd') from dual;
select * from student union select * from teacher;
select * from student union all select * from teacher;
create table #t1 (data varchar(10)) select 'abc' union all select 'bcd' union all select 'cde' union all select 'def' union all select 'efg' create table #t2 (data varchar(10)) select 'abc' union all select 'cde' union all select 'efg';
select t1.year, t1.product from t1 union all  select t2.year, t2.product from t2;
select t1.year, t1.product from t1 union  select t2.year, t2.product from t2;
select a.shape from tablea a union select b.shape from tableb b;
delete workrecord2 from workrecord2 where company = '1' and date = '2013-05-06';
delete zpost from zpost where zcomment.icomment = "first";
delete workrecord2, employee from workrecord2 where tbl_name.company = '1' and tbl_name.date = '2013-05-06';
delete w from workrecord2 w where company = '1' and date = '2013-05-06';
delete workrecord2 from workrecord2 where company = '1' and date = '2013-05-06';
delete from dbo.workrecord2 where employeerun in ( select e.employeeno from dbo.employee e where ... );
delete from dbo.workrecord2 where exists( select 1 from dbo.employee e where employeerun = e.employeeno and .... );
delete from workrecord2 from employee where employeerun=employeeno and company = '1' and date = '2013-05-06';
delete           w from             workrecord2   w, employee      e where            w.employeerun = e.employeeno and w.company = '1' and w.date = '2013-05-06';
delete table1.* , table2.* from table1;
as (select * from   workrecord2 w where  exists (select 1 from   employee e where  employeerun = employeeno and company = '1' and date = '2013-05-06')) delete from cte;
and company = '1' and date = '2013-05-06';
delete from workrecord2 where exists ( select * from employee s where s.employeeno = workrecord2.employeerun and company = '1' and date = '2013-05-06' );
delete from aspnetusers where email = @email delete from userprofiles where id = (select id from @profileid);
select contact.naam_contactpersoon, bedrijf.bedrijfsnaam, bedrijf.adres, bedrijf.postcode from contact;
delete contact from contact;
delete from contact;
delete a from workrecord2 a where a.company = '1' and a.date = '2013-05-06';
delete from users where id in( select user_id from employee where company = '1' and date = '2013-05-06' );
update ud set assid = sale.assid from sale where sale.udid = id;
update ud set assid = ( select sale.assid from sale where sale.udid = ud.id ) where exists ( select * from sale where sale.udid = ud.id;
update ud u set u.assid = s.assid;
update u set u.assid = s.assid from ud u;
update ud set assid = s.assid from sale s where ud.id = s.udid;
update (select s.assid as old_assid from ud u set up.new_assid = up.old_assid;
update ud set assid = ( select sale.assid from sale where sale.udid = ud.id ) where rowid in ( select rowid from ud where sale.udid = ud.id;
update ud set assid = (select assid from sale s where ud.id=s.id);
update ud set assid = s.assid from ud u join sale s on u.id=s.id;
update ud, sale set ud.assid = sale.assid where sale.udid = ud.id;
update [low_priority] [ignore] table_references set col_name1={expr1|default} [, col_name2={expr2|default}] ...;
update table1 set    column = value from   table2, table3 where  table1.column_id = table2.id and table1.column_id = table3.id and table1.column = value and table2.column = value and table3.column = value;
update set ud.assid = sale.assid; -- how to update;
update first_table ft join second_table st on st.some_id = ft.some_id join third_table tt  on tt.some_id = st.some_id set ft.some_column = some_value where ft.some_column = 123456 and st.some_column = 123456;
update ud set u.assid = s.assid from ud u;
create table ud (id integer, assid integer);
create table sales (id integer, udid integer, assid integer);
update ud set assid = sales.assid from sales where sales.id = ud.id;
update ud set ud.assid = sale.assid from ud where sale.udid is not null;
update cte set col1=col2;
update users user blacklist_users blacklistuser ( user.username = blacklistuser.account_ref or user.email = blacklisteduser.account_ref or user.phone_number = blacklistuser.account_ref and user.is_active = 1 and blacklistuser.has_run = 0 ) set user.is_active = 0, blacklistuser.has_run = 1;
update table set column = 'newvalue' where rowid = join table2 t2 on t1.joinfield = t2.joinfield where t2.selectvalue = 'foomybarplease');
update ud set ud.assid = sale.assid;
update tblappraisalbasicdata set tblappraisalbasicdata.iscbo=1 from tblappraisalbasicdata si inner join  aaa_test ran on si.empid = ran.id;
update users set users.divisionid=divisions.divisionid from divisions join users on divisions.name=users.division;
create table `taxons` ( `taxonid` smallint(6) not null default '0', `classid` smallint(6) default null, `orderid` smallint(6) default null, `familyid` smallint(6) default null, `genusid` smallint(6) default null, `name` varchar(150) not null default '';
create function nomen_tree() returns trigger as $_$ if tg_op = 'insert' then select $1.id,$1.id,0 union all select $1.id,ancestor_id,depth+1 from ' || tg_argv[1] || ' where child_id=$1.' || tg_argv[2] using new;
else -- execute does not support conditional statements inside if coalesce(old_parent,0) <> coalesce(new_parent,0) then update ' || tg_argv[0] || ' set ' || tg_argv[2] || ' = $1.' || tg_argv[2] delete from ' || tg_argv[1] || ' where child_id in and ancestor_id in select child_id,ancestor_id,d_c+d_a from end if;
create trigger nomenclature_tree_tr after insert or update on nomenclature for each row execute procedure nomen_tree('my_db.nomenclature', 'my_db.nom_helper', 'parent_id');
create function rebuild_tree(tbl_base text, tbl_closure text, fld_parent text) returns void as $$ ( select id as child_id,id as ancestor_id,0 as depth from ' || tbl_base || ' union all select t.id,ancestor_id,depth+1 from ' || tbl_base || ' as t join tree on child_id = ' || fld_parent || ' ) select * from tree;';
select tbl_orig.*,depth from tbl_closure left join tbl_orig on descendant_id = tbl_orig.id where ancestor_id = xxx and depth <> 0;
select tbl_orig.* from tbl_closure left join tbl_orig on descendant_id = tbl_orig.id where ancestor_id = xxx and depth = 1;
select tbl_orig.* from tbl_closure left join tbl_orig on ancestor_id = tbl_orig.id where descendant_id = xxx and depth <> 0;
select max(depth) from tbl_closure where ancestor_id = xxx;
select id, max(rev) from yourtable;
select a.id, a.rev, a.contents from yourtable a select id, max(rev) rev from yourtable;
select a.* from yourtable a where b.id is null;
select * from t1 where (id,rev) in from t1 );
select yourtable.id, rev, content from yourtable select id, max(rev) as maxrev from yourtable;
select yt.id, yt.rev, yt.contents from yourtable yt where rev =;
select * from ( select * from ( select 1 as id, 1 as rev, 'content1' as content union select 2, 1, 'content2' union select 1, 2, 'content3' union select 1, 3, 'content4';
select id, cast(substring(max(packed_col) from 2 for 6) as float) as max_rev, substring(max(packed_col) from 11) as content_for_max_rev from  (select id, cast(1000 + rev + .001 as char) || '---' || cast(content as char) as packed_col from yourtable );
select all_fields.* from (select id, max(rev) from yourtable group by id) as max_recs;
select * from (select * from mytable order by id, rev desc ) x;
select d2.id, d2.rev, d2.content from docids d1 select top 1 * from docs d where d.id = d1.id;
select id, rev from yourtable t where not exists ( select * from yourtable t where t.id = id and rev > t.rev );
select id, max(rev) as rev from t1;
select count(field1) as summ , field1 from table_name select * from temp where summ = (select max(summ) from temp);
select t.* from test as t join (select max(rev) as rev from test;
select * from platnosci as p join firmy as f join (select max(id_obj) as id_obj from firmy;
select id, rev, content from (select id, rev, content, @prevvalue := id from (select id, rev, content from yourtable order by id asc, rev desc) temp, (select @rownum := 1 from dual) x, (select @prevvalue := -1 from dual) y) temp where row_num = 1;
select * from (select * from table1 order by id, rev desc) x group by x.id;
create table table1 values (1, 1, 'one-one'), (1, 2, 'one-two'), (2, 1, 'two-one'), (2, 2, 'two-two'), (3, 2, 'three-two'), (3, 1, 'three-one'), (3, 3, 'three-three');
select a.id, a.rev, a.contents from (select id, rev, contents, row_number() over (partition by id order by rev desc) rank from yourtable) a where a.rank = 1;
select distinct t1.id, max(t1.rev), max(t2.content) from table1 as t1 join table1 as t2 on t2.id = t1.id and t2.rev = ( select max(rev) from table1 t3 where t3.id = t1.id );
select distinct table1.id, max(table1.rev), max(table2.content);
join table1 as table2 on table2.rev = table1.rev;
select * from (select * from employee as employeesub;
select * from employee where employee.id = 12345 limit 1;
select maxrevid & ((1 << 32) - 1) as id, maxrevid >> 32 as rev from (select max(((rev << 32) | id)) as maxrevid from yourtable;
create table #temp1 ( id varchar(20) ) select a.id, max(a.rev) as rev from ( select id, content, sum(rev) as rev from yourtable;
select a.id, a.rev, content from #temp1 as a ( select id, content, sum(rev) as rev from yourtable;
select a.keyfield1, a.keyfield2, a.field3, a.field4, a.field5 from myfile a where rrn(a) in from myfile b where b.keyfield1 = a.keyfield1 and b.keyfield2 = a.keyfield2;
select t.* from ( select id from yourtable where t.rev = t.max_rev;
select t.* from ( select id from yourtable where t.rank = 1;
select a.id , a.rev, a.content from table1 a (select id, max(rev) rev from table1 group by id) x on x.id =a.id and x.rev =a.rev;
select history.* from score, history where history.score_up = score.max;
select * from employee where employee.salary in (select max(salary) from employee group by employe_id);
mytable, mytablealias, onclause=and_( mytable.id == mytablealias.id, mytable.version_int < mytablealias.version_int isouter=true ) mytablealias.id  == none, ).all();
select * from docs where (id, rev) in (select id, max(rev) as rev from docs group by id order by id);
alter table my_table modify column id int(10) unsigned;
alter table my_table modify column id int(10) unsigned auto_increment;
alter table news_feed drop id alter table news_feed add  id bigint( 200 ) not null auto_increment first ,add primary key (id);
update your_table set id = @num := (@num+1);
alter table your_table auto_increment =1;
alter table tablename auto_increment = value;
alter table tablename auto_increment = 1;
alter table tablename auto_increment = value;
update your_table set id = @num := (@num+1);
alter table your_table auto_increment =1;
alter table tablename auto_increment = value;
alter table `tablename` change `id` `id` int(10) unsigned not null;
alter table `tablename` change `id` `id` int(10) unsigned not null auto_increment;
alter table table_name auto_increment =;
alter table <table_name> auto_increment=<table_id>;
create procedure reset_autoincrement(in tablename varchar(200)) set @get_next_inc = concat('select @next_inc := max(id) + 1 from ',tablename,';');
select @next_inc as result;
set @alter_statement = concat('alter table ', tablename, ' auto_increment = ', @next_inc, ';');
alter table tablename auto_increment=1, algorithm=inplace;
alter table tbl_name drop column column_id;
alter table tbl_access add column `access_id` int(10) not null primary key auto_increment first;
alter table `table_name` auto_increment = 1;
alter table `table_name` drop `auto_colmn`;
alter table `table_name` add  `auto_colmn` int( {many you want} ) not null auto_increment first ,add primary key (`auto_colmn`);
alter table tablename auto_increment = 1;
select name from sysobjects where id in ( select id from syscolumns where name like '%column_name%' );
select      c.name  as 'columnname' from        sys.columns c join        sys.tables  t   on c.object_id = t.object_id where       c.name like '%myname%';
select      column_name as 'columnname' from        information_schema.columns where       column_name like '%myname%';
select column_name, table_name from information_schema.columns where column_name like '%myname%';
select * from information_schema.columns where column_name like '%clientid%';
select object_name(object_id) as tablename,* from  sys.columns where name like '%myname%';
select * from  information_schema.columns where column_name like '%myname%';
set @columnname = 'columnname' select t.name as table, c.name as column, ty.name as type, c.max_length as length from sys.tables as t where c.name like @columnname;
select  'select * from ' + t.name + ' where ' + c.name + ' = 148' as sqltorun from sys.columns c, c.name as colname, t.name as tablename join sys.tables t where c.name like '%projectid%';
select  'delete from ' + t.name + ' where ' + c.name + ' = 148' as sqltorun from sys.columns c, c.name as colname, t.name as tablename join sys.tables t where c.name like '%projectid%';
select t.name as table_name, schema_name(schema_id) as schema_name, c.name as column_name from sys.tables as t where c.name like '%yourcolumnname%';
select s.[name]            'schema', t.[name]            'table', c.[name]            'column', d.[name]            'data type', c.[max_length]      'length', d.[max_length]      'max length', d.[precision]       'precision', c.[is_identity]     'is id', c.[is_nullable]     'is nullable', c.[is_computed]     'is computed', d.[is_user_defined] 'is userdefined', t.[modify_date]     'date modified', t.[create_date]     'date created' from        sys.schemas s where c.name like '%columnname%';
and c.is_nullable = 0;
select distinct(table_name) from information_schema.columns where column_name like '%myname%';
select t.name as table_name, schema_name(schema_id) as schema_name, c.name as column_name from sys.tables as t where c.name like '%employeeid%';
select  [table_name] , [information_schema].columns.column_name from    information_schema.columns where   information_schema.columns.column_name like '%name%' ;
select schema_name(schema_id) + '.' + t.name as 'table name' from sys.tables t where c.name like '%columnname%';
select t.table_type as [type], c.table_name as [object], c.column_name as [column] from information_schema.columns as c where c.column_name like '%myname%' [type], [object], [column];
view        view1    myname1 view        view2    myname2;
select c.name as columnname, t.name as tablename from sys.columns c join sys.tables t on c.object_id = t.object_id where c.name like '%myname%';
select t.table_name, c.column_name from systab as t key join systabcol as c where c.column_name = 'mycolumnname';
select t.name as table_name, schema_name(schema_id) as schema_name, c.name as column_name from sys.tables as t where c.name like '%myname%';
select column_name, table_name, table_schema from information_schema.columns where column_name like '%col_name%';
create table #yourcolumndetails( dbasename varchar(100), tableschema varchar(50), tablename varchar(100), columnname varchar(100), datatype varchar(100), charmaxlength varchar(100)) exec sp_msforeachdb @command1='use [?];
from information_schema.columns where column_name like ''origin''' select * from #yourcolumndetails drop table #yourcolumndetails;
select distinct table_name as tablename,column_name as columnname from information_schema.columns where column_name like '%myname%';
select table_name, column_name from information_schema.columns where table_catalog = 'your_database' and column_name like '%your_column%';
select owner, table_name, column_name from all_tab_columns where column_name like '%your_column_name%' and owner in ('your_schema_name');
select table_name, column_name from user_tab_columns where column_name like '%myname%';
select * from information_schema.columns where table_catalog= 'thedatabase' and column_name like 'thecol%';
select t.name as table_name, schema_name(schema_id) as schema_name, c.name as column_name from sys.tables as t inner join sys.columns c on t.object_id = c.object_id where c.name like '%label%';
select object_name(object_id) from sys.columns where name like '%received_at%';
select object_schema_name(object_id),object_name(object_id) from sys.columns where name like '%received_at%';
select concat(object_schema_name(object_id),'.',object_name(object_id)) from sys.columns where name like '%received_at%';
create procedure usp_tablecheck as select concat(object_schema_name(object_id),'.',object_name(object_id)) as [table name], name as [column] from sys.columns where name like concat('%',@name,'%');
create procedure [dbo].[usp_tablecheck] as declare @sql nvarchar(4000) = concat(' select concat(object_schema_name(col.object_id,db_id(''',@db,''')),''.'',object_name(col.object_id,db_id(''',@db,'''))) as [table name] from ',@db,'.sys.columns col where col.name like concat(''%'',''',@name,''',''%'') and ob.type =''u'';
set @columnname = '%absence%';
select case then 'view' then 'view' else 'table' end as [type], '[' + [s].[name] + '].' + '[' + case then [v].[name] then [v].[name] else [t].[name] end + ']' as [table], [c].[name] as [column] from [sys].[schemas] as [s] left join [sys].[tables] as [t] on [s].schema_id = [t].schema_id or [v].object_id = [c].object_id where [c].[name] like @columnname then [v].[name] then [v].[name] else [t].[name] end + ']', [t].[name], [c].[name], [s].[name] then [v].[name] then [v].[name] else [t].[name] end + ']', case then 'view' then 'view' else 'table';
select t.name as tablename, c.name as columnname from sys.tables as t where c.name like '%<your_search_string>%';
select 'dbname' as dbname, column_name, table_name, table_schema from  dbname.information_schema.columns where column_name like '%yourcolumnname%' and table_schema in ('yourschemaname');
select 'dbname1' as db, column_name, table_name, table_schema from dbname1.information_schema.columns where column_name like '%yourcolumnname%' union select 'dbname2' as db,  column_name, table_name, table_schema from dbname2.information_schema.columns where column_name like '%yourcolumnname%';
select i.*, (select group_concat(userid) from favourites f where f.itemid = i.id) as idlist from items i where i.id = $someid;
select concat(hobbies) as `hobbies` from people_hobbies where 1;
select group_concat(hobbies) as `hobbies` from people_hobbies where 1;
select distinct userid from event group by userid having count(distinct(cohort))=2);
select group_concat(sub.userid separator ', ') from (select distinct userid from event;
select cast(group_concat(field separator ',') as char) from table;
select @logmsg := concat_ws(',',@logmsg,items) from temp_splitfields a;
select @hobbies = @hobbies + hobbies + ',' from peoples_hobbies where person_id = 5;
select person_id, group_concat(hobbies separator ', ') from peoples_hobbies;
select person_id, group_concat(distinct hobbies separator ', ') from peoples_hobbies;
select person_id, group_concat(hobbies order by hobbies asc separator ', ') from peoples_hobbies;
set group_concat_max_len = 2048;
set group_concat_max_len = cast( (select sum(length(hobbies)) + count(*) * length(', ') from peoples_hobbies;
select group_concat(hobbies separator ', ') from peoples_hobbies where person_id = 5;
select name from sqlite_master where type='table' union all  select name from sqlite_temp_master where type='table';
select name from sqlite_master where type='table';
select * from dbname.sqlite_master where type='table';
select * from tablename;
select name from sqlite_master where type='table';
select name from sqlite_master where type = "table";
select name from sqlite_master where type in ('table','view') and name not like 'sqlite_%' union all select name from sqlite_temp_master where type in ('table','view');
select name from my_db.sqlite_master where type='table';
select name from sqlite_temp_master where type='table';
select name from sqlite_master where type in ('table','view') and name not like 'sqlite_%' union all select name from sqlite_temp_master where type in ('table','view');
set identity_insert on;
create table #foo ( fooid   int identity not null, fooname varchar(20) ) select @@identity            as [@@identity], scope_identity()      as [scope_identity()], ident_current('#foo') as [ident_current] set identity_insert #foo on fooname) values      (1, 'one'), (2, 'two') set identity_insert #foo off select @@identity            as [@@identity], scope_identity()      as [scope_identity()], ident_current('#foo') as [ident_current] values      ('three') select @@identity            as [@@identity], scope_identity()      as [scope_identity()], ident_current('#foo') as [ident_current] set identity_insert #foo on fooname) values      (10, 'ten'), (11, 'eleven') set identity_insert #foo off select @@identity            as [@@identity], scope_identity()      as [scope_identity()], ident_current('#foo') as [ident_current] select * from   #foo;
create sequence countby1;
select next value for countby1 as sequenceid;
values ('2f802845-447b-4caa-8783-2086a0a8d437', 'peter', 'mainstreet 7', '88888');
select * from table where uuid='2f802845-447b-4caa-8783-2086a0a8d437';
values (...), (...), (...);
select t.[turboencabulatorid ] from @generated_keys as g join dbo.turboencabulators as t where @@rowcount > 0;
select t.[turboencabulatorid], t.[rowversion] from @generated_keys as g join dbo.turboencabulators as t where @@rowcount > 0;
update turboencabulators set statorslots = 'lotus-o deltoid type' where ((turboencabulatorid = 1) and (rowversion = 792)) select rowversion from turboencabulators where @@rowcount > 0 and turboencabulatorid = 1;
select cast(scope_identity() as int);
create table tablewithidentity ... ) values ( ... ) select @identityvalue = (select id from @identityoutput);
name varchar(50), modifieddate datetime);
values (n'operator error', getdate());
select newscrapreasonid, name, modifieddate from @mytablevar;
select scrapreasonid, name, modifieddate from production.scrapreason;
select subject, count(*) from subject_selection;
select subject, semester, count(*) from subject_selection;
select column_name, aggregate_function(column_name) from table_name where column_name operator value select column_name1, column_name2, aggregate_function(column_name3) from table_name column_name1, column_name2;
select orderid, sum(unitprice * qty) total from orderdetails having total > 950;
select customerid, count(*) from orders;
select categoryname, avg(unitprice) from products p categories c on c.categoryid = p.categoryid having avg(unitprice) > 10;
select categoryid, productid, productname, unitprice from products p1 where unitprice = ( select min(unitprice) from products p2 where p2.categoryid = p1.categoryid);
select categoryid, categoryname, productid, sum(unitprice) from products p categories c on c.categoryid = p.categoryid;
select `_c5`,`_c7`,count(*)  from res group by `_c5`,`_c7`;
select column1, column2 from table_name where [ conditions ];
select name, sum(salary) from employee;
select subject, year, count(*) from student;
select table_name "tables" from user_tables;
select * from user_tab_columns;
select column_name from all_tab_columns where owner = 'schema_owner_username' and table_name='table_name';
select owner, table_name as table_view from dba_tables union all select owner, view_name as table_view from dba_views;
select * from dba_tables;
select * from dba_objects where object_type = 'table';
select * from dba_tab_columns;
select * from dba_dependencies where referenced_type='table' and referenced_name=:t_name;
select * from dba_source;
select * from dba_tables;
select * from user_tables;
select * from all_tables;
select object_name from user_objects where object_type='table';
select * from tab;
select table_name from user_tables;
select table_name from user_tables;
select distinct owner, object_name from dba_objects where object_type = 'table' and owner='some_schema_name';
select distinct owner, object_name from all_objects where object_type = 'table' and owner='some_schema_name';
set colsep '|' set linesize 167 set pagesize 30 set pagesize 1000;
select table_name, owner, tablespace_name from all_tables;
select table_name from user_tables;
select view_name from all_views;
select table_name from user_tables;
select * from dba_tables;
select table_name, column_name from cols where table_name like 'est%' and column_name like '%callref%';
select owner, table_name from dba_tables;
select any dictionary;
select owner, table_name from all_tables;
select table_name from user_tables;
select table_name from all_tables;
select  owner, table_name  from sys.all_tables;
select owner, table_name, column_name, data_type, data_length from sys.all_tab_columns;
select * from tabs;
select * from all_all_tables;
select cola, colb, ... from mytable as t1 join myothertable as t2;
create table t1(x int);
create table t2(y int);
select * from   t1 select * from   t1;
select * from ( select * from emp where rownum <= 5;
select * from where rownum <= :max_row_to_fetch ) where rnum  >= :min_row_to_fetch;
select * from   sometable;
( select *                   -- get the table from sometable twenty as ( select *                   -- get the first 30 rows from base where rownum < 30 ) select *                       -- then get rows 21 .. 30 from twenty where rownum > 20;
select * from ( select t.*, row_number() over (order by name) myrow from sometable t ) where myrow between 10 and 20;
select * from ( select a.*, rownum rnum from ( <select statement with order by clause>;
select * from ( <select statement with order by clause>;
select * from ( select statement, rownum as rn with order by clause;
select * from   (select t.*, rownum as rn from   shhospede t) a where  a.rn >= in_first and    a.rn <= in_first;
select * from sometable;
select * from   sometable;
create table rownum_order_test ( val  number select level from   dual;
select val from   rownum_order_test;
select val from   rownum_order_test;
select val from   rownum_order_test;
select val from   rownum_order_test;
select val from   rownum_order_test;
select val from   rownum_order_test;
select * from (select * from some_table where rownum <= 4 and rownum > 1;
select * from (select *, rownum rnum from (select * from skijump_results where rownum <= 4) where rnum > 1;
select * from xyz a;
select * from ( select rownum rnum from sometable a ) where rnum between 10 and 20;
from sometable a order by name ) select * from b where rnum between 10 and 20;
select * from (select from emp ) emp  where rowid=5;
select * from (select from emp ) emp  where rowid>5;
select * from (select from emp ) emp  where rowid=5;
select * from sometable1 so where so.id in ( select so2.id from sometable2 so2 where rownum <=5 ) and order by so.somefield and rownum <= 100;
select title from post id desc;
select * from ( select title from post id desc ) where rownum <= 50;
create table rownum_order_test ( val  number select level from   dual;
select val from   rownum_order_test;
select "a1"."val" "val" from  (select "a2"."val" "val","a2"."val" "rowlimit_$_0", row_number() over ( order by "a2"."val" desc ) "rowlimit_$$_rownumber" from "rownum_order_test" "a2") "a1" where "a1"."rowlimit_$$_rownumber"<=5 order by "a1"."rowlimit_$_0" desc;
input_sql_text => ' select val from   rownum_order_test output_sql_text => x);
input_sql_text => ' select val from   rownum_order_test output_sql_text => x);
select "a1"."val" "val" from  (select "a2"."val" "val","a2"."val" "rowlimit_$_0", rank() over ( order by "a2"."val" desc ) "rowlimit_$$_rank" from "rownum_order_test" "a2") "a1" where "a1"."rowlimit_$$_rank"<=5 order by "a1"."rowlimit_$_0" desc;
input_sql_text => ' select val from   rownum_order_test output_sql_text => x);
select "a1"."val" "val" from  (select "a2"."val" "val","a2"."val" "rowlimit_$_0", row_number() over ( order by "a2"."val") "rowlimit_$$_rownumber" from "rownum_order_test" "a2") "a1" where "a1"."rowlimit_$$_rownumber"<=case  when (4>=0) then floor(to_number(4)) else 0 end +4 and "a1"."rowlimit_$$_rownumber">4;
set @tags = ruby|rails|scruffy|rubyonrails select * from tags where name in (select item from fnsplit(@tags, |));
create function [dbo].[fnsplit]( @sinputlist varchar(8000) -- list of delimited items select @sitem=rtrim(ltrim(substring(@sinputlist,1,charindex(@sdelimiter,@sinputlist,0)-1))), @sinputlist=rtrim(ltrim(substring(@sinputlist,charindex(@sdelimiter,@sinputlist,0)+len(@sdelimiter),len(@sinputlist)))) if len(@sitem) > 0 end  if len(@sinputlist) > 0 end;
select ... where tag in( @tag1, isnull( @tag2, @tag1 ), isnull( @tag3, @tag1 ), etc. );
(s, i) => "@tag" + i.tostring();
select * from tags where '|ruby|rails|scruffy|rubyonrails|' like '%|' + name + '|%';
create type dbo.tagnamestabletype as table ( name nvarchar(50) );
if (values == null || !values.any()) return null; // annoying, but sqlclient wants null instead of 0 rows;
alter function [dbo].[fn_sqllist_to_table](@list  as varchar(8000), @delim as varchar(10)) position int, value    varchar(8000)) as begin set @mypos = 1 values     (@mypos,left(@list, charindex(@delim, @list) - 1)) set @mypos = @mypos + 1 if charindex(@delim, @list) = len(@list) values     (@mypos,'') set @list = right(@list, len(@list) - charindex(@delim, @list)) end  if len(@list) > 0 values     (@mypos,@list) end;
select * from tags where name in (select value from fn_sqllist_to_table(@name,',')));
substring(list.names, 2, len(list.names)) as names from (select ',doc,grumpy,happy,sneezy,bashful,sleepy,dopey,' names) as list union all select (n - 1) as n, substring(names, 1 + charindex(',', names), len(names)) as names from qry where n > 1) select n, substring(names, 1, charindex(',', names) - 1) dwarf from qry;
select n, substr(name, 1, instr(name, ',') - 1) dwarf from (select n, substr(val, 1 + instr(val, ',', 1, n)) name from (select rownum as n, list.val from  (select ',doc,grumpy,happy,sneezy,bashful,sleepy,dopey,' val from dual) list;
select pivot.n, substring_index(substring_index(list.val, ',', 1 + pivot.n), ',', -1) from (select 1 as n union all select 2 as n union all select 3 as n union all select 4 as n union all select 5 as n union all select 6 as n union all select 7 as n union all select 8 as n union all select 9 as n union all select 10 as n) pivot,    (select ',doc,grumpy,happy,sneezy,bashful,sleepy,dopey,' val) as list where pivot.n <  length(list.val) -;
select ... where '|peanut|butter|' like '%|' + 'pe%ter' + '|%';
select ... where '|butter|peanut|' like '%|' + 'pe%ter' + '|%';
select ... where '|peanut|butter|' like '%|' + 'pe\%ter' + '|%' escape '\';
select ... where '|pe%ter|' like '%|' + replace( 'pe%ter' ,'%','\%') + '|%' escape '\';
select ... where '|pe%t!r|' like '%|' + replace(replace( 'pe%t!r' ,'!','!!'),'%','!%') + '|%' escape '!';
select ... where '|p_%t!r|' like '%|' + replace(replace(replace( 'p_%t!r' ,'$','$$'),'%','$%'),'_','$_') + '|%' escape '$';
select * from sometable where values in <cfqueryparam value="#myvalues#" list="true">;
where invalues.contains(tag.name) select tag;
create function dbo.fnparsearray (@array varchar(1000),@separator char(1)) as begin set @array = @array + @separator select @separator_position = patindex('%' + @separator + '%',@array) select @array_value = left(@array, @separator_position - 1) select @array = stuff(@array, 1, @separator_position, '') end return end;
select * from dbo.fnparsearray('a,b,c,d,e,f', ',');
and ( {1}==0 or b.companyid in ({2},{3},{4},{5},{6}) );
if (origcount > 5) { origcount, idlist[0], idlist[1], idlist[2], idlist[3], idlist[4]);
select @inputstring = @inputstring + ',' as ( select x = substring(@inputstring,0,charindex(',',@inputstring,0)), y = substring(@inputstring,charindex(',',@inputstring,0)+1,len(@inputstring)) union all select x = substring(y,0,charindex(',',y,0)), y = substring(y,charindex(',',y,0)+1,len(y)) from recursivecsv where substring(y,charindex(',',y,0)+1,len(y)) <> '' or ) select * from tags where name in (select x from recursivecsv);
select * from tags where name in @names;
where names.contains(tag.name) select tag;
set @x='<items> select x.item.value('@myvalue[1]', 'decimal') as myvalue from @x.nodes('//items/item') as x(item) ) select * from yourtable where tablecolumnname in (select myvalue from cte);
select * from tags where patindex('%<' + name + '>%','<jo>,<john>,<scruffy>,<rubyonrails>') > 0;
create stored procedure getsearchmachingtagnames @delimiter char(1) as begin select * from tags where name in (select data from [dbo].[split](@pipedelimitedtagnames,@delimiter) end;
dataaccesskind.none, isdeterministic = true, systemdataaccess = systemdataaccesskind.none, isprecise = true, fillrowmethodname = "splitfillrow", tabledefinintion = "s nvarchar(max)"] if (s.isnull);
set @desiredtags = 'ruby,rails,scruffy,rubyonrails';
select * from tags where name in [dbo].[split] (',', @desiredtags);
create type [dbo].[stringlist] as table( [stringvalue] [nvarchar](max) not null ) set @str = 'declare @list [dbo].[stringlist]; insert into @list values ' select @str = @str + '(''' + stringvalue + '''),' from @list set @str = substring(@str, 1, len(@str)-1) set @str = @str + '; select * from @list;';
create table tags values (1, 'ruby'), (2, 'rails'), (3, 'scruffy'), (4, 'rubyonrails');
set @param = 'ruby,rails,scruffy,rubyonrails' select * from tags where charindex(name,@param)>0;
create table selectedtags;
select @list=coalesce(@list+',','')+st.name from selectedtags st select * from tags where charindex(name,@param)>0;
create procedure [dbo].[sp_myproc] as select column from table where ph.unitid in (select * from csvtoint(@unitlist));
create function [dbo].[csvtoint] ( @array varchar(max)) as begin set @separator = ',' set @array = @array + ',' select @separator_position = patindex('%,%' , @array) select @array_value = left(@array, @separator_position - 1) values (cast(@array_value as int)) select @array = stuff(@array, 1, @separator_position, '') end return end;
if (pars != null) if (pars[i] is ienumerable<object>) else { if (pars != null) else {;
select @invalue = '''bishnu'',''gautam''' select @dynamicsql = 'select * from #temp where [name] in (' + @invalue + ')' exec (@dynamicsql);
select * from mytable where id in (@p1, @p2, @p3, ... , @p[batch-size]);
select * from mytable where id=@id;
create function [dbo].[convertstringtolist] [id] int null) as beg in  set @x = '<t>' + replace(@str, @delimeter, '</t><t>') + '</t>' select distinct x.i.value('.', 'int') as token from @x.nodes('//t') x(i) end;
select * from table where id in ([dbo].[convertstringtolist(your comma separated string ,',')]);
create function [dbo].[split] (@sep char(1), @s varchar(8000)) as return ( with pieces(pn, start, stop) as ( select 1, 1, charindex(@sep, @s) union all select pn + 1, stop + 1, charindex(@sep, @s, stop + 1) from pieces where stop > 0 ) select substring(@s, start, case when stop > 0 then stop-start else 512 end) as s from pieces );
select * from tags where name in (select s from dbo.split(';','ruby;rails;scruffy;rubyonrails'));
select * from tags where name in (select [value] from string_split(@names, ','));
select t.* from tags t join string_split(@names,',');
select productid, name, tags from product where ',1,2,3,' like '%,' + cast(productid as varchar(20)) + ',%';
create table #t(val nvarchar(120));
select * from tags tg join #t t;
create table dbo.tags ( name  varchar(50), count int ) values      ('vb',982), ('ruby',1306), ('rails',1478), ('scruffy',1), ('c#',1784) create proc dbo.someproc as select t.* from   dbo.tags t where  t.name in (select j.value collate latin1_general_ci_as from   openjson(concat('[', @tags, ']')) j) exec dbo.someproc @tags = '"ruby","rails","scruffy","rubyonrails"' drop table dbo.tags;
(paramtext, paramnumber) => "@" + paramprefix + paramnumber.tostring()) (paramtext, paramnumber) => "@" + paramprefix + paramnumber.tostring();
select * from tags t count desc;
select * from tags where name in (select distinct name from temp);
create type [string_list] as table ([your_string_element] varchar(max) primary key);
create procedure [dbo].[usp_listcheck] as select a.* from [dbo].[tags] a join @string_list_in b on a.[name] = b.[your_string_element];
where @currentshipmentstatusidarray is null or @currentshipmentstatusidarray like '%|' + convert(nvarchar,shipments.currentshipmentstatusid) + '|%';
where @currentshipmentstatusidarray is null or @currentshipmentstatusidarray like '%|' + shipments.currentshipmentstatusid+ '|%';
select * from messages where id in;
select m1.* from messages m1 where m2.id is null;
select m1.* from messages m1 inner join (select max(id) as lastmsgid from messages group by name) m2 on m1.id=m2.lastmsgid;
select column1, column2 from table_name where id in from table_name;
select `id`, `name`, substring_index( group_concat( `other_columns` '||', 1 from messages;
select m1.* from messages m1, ( select substr(others_data,1,2),max(others_data) as max_others_data from messages where m1.others_data = m2.max_others_data;
select test_id, max(request_id) as request_id from testresults;
select test_id, request_id from ( select test_id, max(request_id) as request_id from testresults;
select test_id, request_id from testresults, (select @group:=null) as init where if(ifnull(@group, -1)=@group:=test_id, 0, 1);
select id, name, other_columns from messages where id in ( select max(id) from messages;
select *, max(id) from messages group by name;
select jos_categories.title as name, joined .catid, joined .title, joined .introtext from   jos_categories from   (select `title`, catid, `created`, introtext from   `jos_content` where  `sectionid` = 6;
delete from messages where id not in from messages m1 left join messages m2 where m2.id is null);
drop table if exists uniqueids;
create temporary table uniqueids (id int(11));
and t1.id < t2.id) where t2.id is null);
delete from table where id not in (select id from uniqueids);
select a.* from messages a (select name, max(id) as maxid from messages group by name) as b on;
select a.* from messages a (select name, max(other_col) as other_col from messages group by name) as b on and a.other_col = b.other_col;
select id, name, othercolumns, row_number() over ( partition by name from messages ) select id, name, othercolumns from messages where rk = 1;
select id, name, othercolumns from messages where not exists ( select * from messages as m2 where m2.name = messages.name and m2.id > messages.id );
select m.*, row_number() over (partition by name order by id desc) as rn from messages as m ) select * from ranked_messages where rn = 1;
select m1.* from messages m1 left join messages m2 where m2.id is null;
select p1.postid from posts p1 from posts pi group by pi.owneruserid) p2 where p1.owneruserid = 20860;
select p1.postid from posts p1 left join posts p2 where p2.postid is null and p1.owneruserid = 20860;
create table `posts` ( `postid` bigint(20) unsigned not null auto_increment, `posttypeid` bigint(20) unsigned not null, `acceptedanswerid` bigint(20) unsigned default null, `parentid` bigint(20) unsigned default null, `creationdate` datetime not null, `score` int(11) not null default '0', `viewcount` int(11) not null default '0', `body` text not null, `owneruserid` bigint(20) unsigned not null, `ownerdisplayname` varchar(40) default null, `lasteditoruserid` bigint(20) unsigned default null, `lasteditdate` datetime default null, `lastactivitydate` datetime default null, `title` varchar(250) not null default '', `tags` varchar(150) not null default '', `answercount` int(11) not null default '0', `commentcount` int(11) not null default '0', `favoritecount` int(11) not null default '0', `closeddate` datetime default null, primary key  (`postid`), unique key `postid` (`postid`), key `posttypeid` (`posttypeid`), key `acceptedanswerid` (`acceptedanswerid`), key `owneruserid` (`owneruserid`), key `lasteditoruserid` (`lasteditoruserid`), key `parentid` (`parentid`), constraint `posts_ibfk_1` foreign key (`posttypeid`) references `posttypes` (`posttypeid`);
select d1.id,name,city from demo_user d1 (select max(id) as id from demo_user group by name) as p on (d1.id=p.id);
select * from (select * from demo_user order by id desc) as t group by name ;
select t1.id, t1.name, t1.other_columns from ( select id, name, other_columns, ( case name when @cura then @currow := @currow + 1 else @currow := 1 and @cura := name end from messages t, (select @currow := 0, @cura := '') r where t1.rn = 1;
select distinct on (name) * from messages;
select * from messages group by name desc;
select * from messages where islastingroup = 1;
create table temperature( id int unsigned not null auto_increment, groupid int unsigned not null, recordedtimestamp timestamp not null, recordedvalue int not null, index groupindex(groupid, recordedtimestamp), primary key (id) create temporary table selected_group(id int unsigned not null, primary key(id));
select last(t1.id) as id, t1.groupid, last(t1.recordedtimestamp) as recordedtimestamp, last(t1.recordedvalue) as recordedvalue from selected_group g;
select t1.id, t1.groupid, t1.recordedtimestamp, t1.recordedvalue from selected_group g select t2.id from temperature t2 where t2.groupid = g.id limit 1;
select t1.id, t1.groupid, t1.recordedtimestamp, t1.recordedvalue from temperature t1 select max(t2.id) as id from temperature t2 select t3.groupid, max(t3.recordedtimestamp) as recordedtimestamp from selected_group g;
select t1.id, t1.groupid, t1.recordedtimestamp, t1.recordedvalue from temperature t1 where t1.id in ( select max(t2.id) as id from temperature t2 select t3.groupid, max(t3.recordedtimestamp) as recordedtimestamp from selected_group g );
select t1.id, t1.groupid, t1.recordedtimestamp, t1.recordedvalue from selected_group g select max(t2.id) from temperature t2 where t2.groupid = g.id and t2.recordedtimestamp = ( select max(t3.recordedtimestamp) from temperature t3 where t3.groupid = g.id );
select t1.id, t1.groupid, t1.recordedtimestamp, t1.recordedvalue from ( select t2.id, t2.groupid, t2.recordedtimestamp, t2.recordedvalue, row_number() over ( partition by t2.groupid order by t2.recordedtimestamp desc, t2.id desc from selected_group g;
select t1.id, t1.groupid, t1.recordedtimestamp, t1.recordedvalue from ( select last_value(t2.id) over w as id, t2.groupid, last_value(t2.recordedtimestamp) over w as recordedtimestamp, last_value(t2.recordedvalue) over w as recordedvalue from selected_group g partition by t2.groupid );
select t1.id, t1.groupid, t1.recordedtimestamp, t1.recordedvalue from selected_group g and ( t2.recordedtimestamp > t1.recordedtimestamp or (t2.recordedtimestamp = t1.recordedtimestamp and t2.id > t1.id) ) where t2.id is null;
select * from messages a where id = (select max(id) from messages where a.name = name);
select distinct name, max(messages) over(partition by name) messages from message;
select * from posts group by category_id;
select id, category_id, post_title from posts where id in ( select max(id) from posts;
select * from table_name where primary_key in (select max(primary_key) from table_name group by column_name );
select * from message where `id` in ( select max(`id`) from message `name` ) `id` desc;
select user, count(user) as count, max(id) as last from request;
( select id, name, othercolumns, row_number() over (partition by name order by id ) select id, name,othercolumns from temp_table where rank=1;
select * from properties p join ( select max(m2_price) as max_price from properties having p.m2_price = max_price;
select * from `data` where `id` in (select max(`id`) from `data` group by `name_id`);
select *, max(id) from messages group by name;
set quoted_identifier off;
set quoted_identifier on;
set quoted_identifier off;
update table set name = replace(name, "'s", "s");
set quoted_identifier on;
[value] varchar(200) ) select * from @my_table;
set @singlequote =  char(39);
select 'i''m happpy';
select unicode(':');
select 'i'+nchar(39)+'m happpy';
set quoted_identifier off;
set quoted_identifier on;
select distinct quotename(column_name),data_type from information_schema.columns;
set quoted_identifier off;
set @sql = 'select distinct ''' + @tablename + ''',''' + replace(@columnname,"'","''") + ...etc set quoted_identifier on;
set quoted_identifier off;
set quoted_identifier on;
select * from customers c and c.state = 'ny' and a.status = 1;
select * from customers c where c.state = 'ny' and a.status = 1;
select stuff from tables where conditions;
update sales_import set sales_import.accountnumber = ran.accountnumber from sales_import si retrieveaccountnumber ran;
update sales_import si, retrieveaccountnumber ran set si.accountnumber = ran.accountnumber where si.leadid = ran.leadid;
update [sales_lead].[dbo].[sales_import] set [accountnumber] = from retrieveaccountnumber where [sales_lead].[dbo].[sales_import].leadid = retrieveaccountnumber.leadid;
update sales_import set    accountnumber = (select retrieveaccountnumber.accountnumber from   retrieveaccountnumber where  sales_import.leadid =retrieveaccountnumber.leadid) where sales_import.leadid = (select  retrieveaccountnumber.leadid from   retrieveaccountnumber where  sales_import.leadid = retrieveaccountnumber.leadid);
update table2 set table2.col1 = table1.col1, table2.col2 = table1.col2, ... from table1, table2 where table1.memberid = table2.memberid;
( no int ) ( no int ) select * from @tb1 update @tb1 set name =s.name from @tb1 t select * from @tb1;
update ... from;
update set accountnumber = retrieveaccountnumber.accountnumber;
update sales_import si,retrieveaccountnumber ran set si.accountnumber = ran.accountnumber where si.leadid = ran.leadid;
update sales_import si set accountnumber = ran.accountnumber from retrieveaccountnumber ran where ran.leadid = si.leadid;
( no int ) ( no int ) select * from @tb1 select * from @tb2 update @tb1 set name = t2.name from        @tb1 t1 select * from @tb1;
update table1 set table1.column = 'some_new_val' where table1.id in ( select * from ( select table1.id from  table1 where table1.column = 'some_expected_val' and table12.column is null );
update table1 set table1.column = 'some_new_val' where table1.id in ( select * from ( select table1.id from  table1 join table2 on ( table2.column = table1.column ) where table1.column = 'some_expected_val' );
update application set omts_received_date = ( select date_created from application_history where application.id = application_history.application_id and application_history.application_status_id = 8;
update t1 set t1.column = t2.column from table1 t1;
update t1 set t1.colmun = t2.column from table1 t1, table2 t2 where t1.id = t2.id;
update table1 t1, table2 t2 set t1.column = t2.column where t1.id = t2.id;
update table_a set table_a.accountnumber = table_b.accountnumber , from dbo.sales_import as table_a where table_a.leadid = table_b.leadid;
update table2 set table2.col1 = table1.col1, table2.col2 = table1.col2, ... from table1, table2 where table1.memberid = table2.memberid;
update sales_import, retrieveaccountnumber set sales_import.accountnumber = retrieveaccountnumber.accountnumber where sales_import.leadid = retrieveaccountnumber.leadid;
drop table #tmp1 drop table #tmp2 create table #tmp1(leadid int,accountnumber nvarchar(50)) create table #tmp2(leadid int,accountnumber nvarchar(50)) update a set a.accountnumber = b.accountnumber from #tmp1 a where a.accountnumber <> b.accountnumber  --don't overwrite a value with the same value select * from #tmp1;
update sales_import a left join retrieveaccountnumber b on a.leadid = b.leadid set a.accountnumber = b.accountnumber where a.leadid = b.leadid;
update [aspnetusers] set [aspnetusers].[name] = [userprofile].[name] from [aspnetusers], [userprofile] where [aspnetusers].[id] = [userprofile].[id];
update  c4 set price=cp.price*p.factorrate from tablenamea_a c4 where c4..name='myname';
( select c4.tablename_a_id,(cp.price*p.factorrate) as calctot from tablenamea_a c4 where p.name='myname' update set price=calctot  ;
update database1..ciudad set ciudaddistrito=c2.ciudaddistrito from database1..ciudad c1 database2..ciudad c2 on c2.ciudadid=c1.ciudadid;
update table1 t1, table2 t2 set t1.column_name = t2.column_name where t1.id = t2.id;
update `site` as destination set destdestination.`reasonid` = backupontuesday.`reasonid`;
create procedure [dbo].[message_findhighestmatches];
set nocount on create table  #temp ( messageid         int, subjects          nchar(255), subjectscount    int ) select top 20 messageid, subjects, subjectscount, (t.cnt * 100)/t3.inputvalues as matchpercentage from #temp join dbo.split(@topicalneighborhood,',') as t2 drop table #temp;
select id as [xt_id] from dbo.table_with_xml xt;
select * from person p where;
select p.*,t.companyname from person p select * from company c where p.companyid = c.companyid and c.companyname like '%yyy%';
select f.* from sys.objects o;
select f.* from sys.objects o where f.schema_id= o.schema_id;
select f.* from sys.objects o where f.schema_id= o.schema_id;
select  t1.*, t2o.* from    t1 ( select  top 3 * from    t2 where   t2.t1_id = t1.id t2.rank desc;
( select  t2.*, row_number() over (partition by t1_id order by rank) as rn from    t2 ) select  t1.*, t2o.* from    t1 t2o and t2o.rn <= 3;
( select  *, row_number() over (order by id) as rn from    master t as ( select  1 as id union all select  2 ) select  * from    t join    q;
( select  1 as id union all select  2 ) select  * from    t ( select  top (t.id) m.* from    master m id;
create table #tempstrings ([somestring] [nvarchar](10) not null);
create table #tempnumbers ([somenumber] [int] not null);
create table #tempnumbers2 ([somenumber] [int] not null);
select st.somestring, nbr.somenumber from -- basic join ('cross join') select st.somestring, nbr.somenumber from -- basic join ('cross join') where st.somestring = nbr.somenumber select st.somestring, nbr.somenumber from -- inner join select st.somestring, nbr.somenumber from #tempstrings st cross apply (select * from #tempnumbers tempnbr where st.somestring = tempnbr.somenumber) nbr select st.somestring, nbr.somenumber from #tempstrings st cross apply (select * from #tempnumbers tempnbr where 1 = 2) nbr select st.somestring, nbr.somenumber from #tempstrings st outer apply (select * from #tempnumbers tempnbr where 1 = 2) nbr select st.somestring, nbr.somenumbers from #tempstrings st cross apply (select somenumbers = string_agg(tempnbr.somenumber, ', ') from #tempnumbers2 tempnbr where st.somestring = tempnbr.somenumber) nbr drop table #tempstrings;
drop table #tempnumbers;
drop table #tempnumbers2;
create function dbo.fn_getallemployeeofadepartment(@deptid as int) as return ( select * from employee e where e.departmentid = @deptid ) select * from department d;
select m.id,m.name,d.period,d.qty from master m ( select top 2 id, period,qty from details d;
select m.id,m.name,d.period,d.qty from master m ( select top 2 id, period,qty from details d where m.id=d.id;
where m.id=d.id;
select m.id,m.name,c.period,c.qty from master m;
create function fngetqty ( @id int ) as return ( select id,period,qty from details where id=@id );
select distinct id,dates from mytable;
select * from customer select top 1 * from order where order.customerid = customer.customerid;
create function;
3,truck,1,2017-10-02,,t,,0,, 4,truck,2,2017-10-02,,t,,0,,;
select  * from    test-db.table1 t coltoupdate2 = t.coltoupdate2, ...;
alter table `table` add unique `unique_index`(`name`);
alter table `table` add unique `unique_index`(`name`, `age`);
delete table from table as a, table as b where a.id < b.id and a.name <=> b.name and a.age <=> b.age;
select title from books where author_id = ( select id from authors where last_name = 'bar' and first_name = 'foo';
select title from books where author_id in ( select id from authors where last_name ~ '^[a-e]';
select * from t1 where exists select * from t2 where t2.parent=t1.id;
select id, alias from mos_categories where id in ( select distinct catid from mos_content;
select distinct mos_content.catid, mos_categories.alias from mos_content, mos_categories where mos_content.catid = mos_categories.id;
select distinct mos_categories.id, mos_categories.alias from mos_content, mos_categories where mos_content.catid = mos_categories.id;
from `vote-ranked-listory` vrl where vrl.position <= 15 and l.status='active' and l.is_public=1 and vrl.ontology_id < 1000000000 and (select list_id from list_tag where list_id=l.list_id and tag_id=43) is null and (select list_id from list_tag where list_id=l.list_id and tag_id=55) is null and (select list_id from list_tag where list_id=l.list_id and tag_id=246403) is not null;
from `vote-ranked-listory` vrl where vrl.position <= 15 and l.status='active' and l.is_public=1 and vrl.ontology_id < 1000000000 and lt1.list_id is null and lt2.tag_id is null;
and (select list_id from list_tag where list_id=l.list_id and tag_id=246403) is not null;
select * from crv.workorder_details wd;
select * from crv.workorder_details where workorder_id in (select workorder_id from crv.workorder);
select gpa from student where sid in (select sid from apply where major = 'cs');
select avg(gpa) from student where sid in (select sid from apply where major = 'cs');
select gpa from student, apply where student.sid = apply.sid and apply.major = 'cs';
select avg(gpa) from student, apply where student.sid = apply.sid and apply.major = 'cs';
select titles, price from books, orders where price = from orders) and (books.id=orders.id);
select min(price) from orders;
select titles, price from books b where o.price = 2.99;
select moo, (select roger from wilco where moo = me) as bar from foo;
select moo from foo where bar = (select roger from wilco where moo = me);
select moo, bar from foo select min(bar), me from wilco group by me;
create temporary table ...;
select moo, bar from ( select moo, concat(roger, wilco) as bar from foo having bar like 'spaceq%';
create temporary table ...;
select id,name from table1 a join table2 b on a.name=b.name where id='123'  select id,name from table1 a join table2 b on a.name=b.name and a.id='123';
set `ensembl_transcript_id` = 'ensorgt00000000001', `transcript_chrom_start` = 12345, `transcript_chrom_end` = 12678;
if (select count(*) from beta where name = 'john' > 0) update alfa set c1=(select id from beta where name = 'john') else begin end;
if (count($vars)) {;
'mycolumn1' => 'myvalue1', 'mycolumn2' => 'myvalue2', 'mycolumn3' => 'myvalue3' );
select 'stuff for value1', 'stuff for value2' from dual where not exists (select * from `table` where `value1`='stuff for value1' and `value2`='stuff for value2' limit 1);
select * from `table` where `value1`='stuff for value1' and `value2`='stuff for value2' limit 1;
where not exists;
select 'stuff for value1', 'stuff for value2' from dual;
where not exists;
create table `transcripts` ( `ensembl_transcript_id` varchar(20) not null, `transcript_chrom_start` int(10) unsigned not null, `transcript_chrom_end` int(10) unsigned not null, primary key (`ensembl_transcript_id`);
set `ensembl_transcript_id` = 'ensorgt00000000001', `transcript_chrom_start` = 12345, `transcript_chrom_end` = 12678;
set `ensembl_transcript_id` = 'ensorgt00000000001', `transcript_chrom_start` = 12345, `transcript_chrom_end` = 12678;
update table set c=c+1 where a=1;
set col_name={expr | default}, ...;
update wp_postmeta set meta_value = ? where meta_key = ? and post_id = ?;
select t.id, t.some_column_id, t.some_type, t.some_value from ( select id, some_column_id, some_type, some_value from my_table where some_column_id = ? and some_type = ? union all select s.id, s.some_column_id, s.some_type, s.some_value from (select null as id, ? as some_column_id, ? as some_type, ? as some_value) as s limit 1;
select * from information_schema.routines where routine_definition like '%search_string%';
select top 10 * from where object_definition(object_id) like '%\[abd\]%';
select name from   sys.procedures where  object_definition(object_id) like '%strhell%';
select object_name(id) from syscomments where [text] like '%flags.%' and objectproperty(id, 'isprocedure') = 1;
select distinct object_name(id) from syscomments where text like '%[abd]%';
where m.definition like '%\[abd\]%' escape '\';
select distinct o.name as object_name,o.type_desc from sys.sql_modules m where charindex('[abd]',m.definition) >0 ;
select distinct o.name as object_name,o.type_desc from sys.sql_modules m where patindex('[[]abd]',m.definition) >0 ;
where m.definition like '%[[]abd]%';
create procedure [search]( @filter nvarchar(max) ) as begin select name from   procedures where   definition like '%'+@filter+'%' end;
exec [search] 'text';
select distinct o.name as object_name, o.type_desc from sys.sql_modules m        inner join        sys.objects o;
select distinct a.name as object_name, a.type_desc from sys.sql_modules m where m.definition like '%['+@search_text+']%';
so you can browse them without having to script them individually. /* select [object].object_id                       as [object_id], [schema].name                            as [schema_name], [object].name                            as [object_name], [object].type                            as [object_type], [object].type_desc                       as [object_type_desc], [details].definition                     as [module_definition] from /* sys.sql_modules = where the body of sprocs and views live */ join /* sys.objects = where the metadata for every object in the database lives */ join /* sys.schemas = where the schemas in the datatabase live */ where (@def_key is null or [details].definition like @def_key)      /* <<< searches definition */ and (@name_key is null or [object].name like @name_key)       /* <<< searches name       */ and (@schema_key is null or [schema].name like @schema_key)   /* <<< searches schema     */ ) select ( /* select top 100 percent [schema_name] + '.' + [object_name]    as [@full_name], [module_definition]                    as [module_definition] from searchresults where object_type = 'p' [schema_name], [object_name] this alias causes the <procedure> elements ( /* select top 100 percent [schema_name] + '.' + [object_name]    as [@full_name], [module_definition]                    as [module_definition] from searchresults where object_type = 'v' [schema_name], [object_name] this alias causes the <view> elements;
select distinct object_name(id) from syscomments where text like '%string%' and objectproperty(id, 'isprocedure') = 1;
create procedure [dbo].[searchinall] as begin set nocount on;
select object_name(object_id) sp_name from   sys.procedures where  object_definition(object_id) like '%'+@strfind+'%' end  select object_name(object_id) view_name from   sys.views where  object_definition(object_id) like '%'+@strfind+'%' end  select routine_name           function_name from   information_schema.routines where  routine_definition like '%'+@strfind+'%' and routine_type = 'function' routine_name end  select t.name      as table_name from   sys.tables  as t where  c.name like '%'+@strfind+'%' table_name end end;
if object_id('tempdb..##nothing') is not null drop table ##nothing create table ##nothing ( databasename varchar(30), schemaname varchar(30), objectname varchar(100), objecttype varchar(50) ) exec master.sys.sp_msforeachdb select db_name() as [database], [scehma]=schema_name(o.schema_id), o.name, o.type from sys.sql_modules m where m.definition like ''%some_text%''' select * from ##nothing n;
select [scehma] = schema_name(o.schema_id) from sys.sql_modules m where m.definition like '%your search keywords%';
select distinct object_name([id]),[text] from syscomments where [id] in (select [id] from sysobjects where xtype in;
if object_id('tempdb..#t_dbname') is not null drop table #t_dbname if object_id('tempdb..#t_procedure') is not null drop table #t_procedure create table #t_dbname ( idx int identity(1,1) primary key ) create table #t_procedure ( idx int identity(1,1) primary key ) select name from master.dbo.sysdatabases set @t_sql_param = select top 1 from #t_dbname where idx > @t_c_idx order by idx asc set @t_sql = '' set @t_sql = @t_sql + 'insert into #t_procedure(dbname, procedure_name, procedure_description)' set @t_sql = @t_sql + 'select specific_catalog, routine_name, routine_definition ' set @t_sql = @t_sql + 'from ' + @t_c_dbname +  '.information_schema.routines  ' set @t_sql = @t_sql + 'where routine_definition like ''%''+ @t_find_text + ''%'' ' set @t_sql = @t_sql + 'and routine_type = ''procedure'' ' exec sp_executesql  @t_sql, @t_sql_param, @t_c_dbname, @t_find_text end try select @t_c_dbname + ' error' end catch set @t_c_idx = @t_c_idx + 1 end  select idx, dbname, procedure_name from #t_procedure order by dbname asc;
alter procedure [dbo].[usp_find_objects] ( @search varchar(255), @target varchar(255) = null, @db varchar(35) = null ) as  set nocount on;
if @db <> '' set @usedb = 'use ' + @db else set @usedb = '' if @target is null set @target = '' set @tsql = @usedb + ' set @search = ''%' + @search + '%'' set @target = ''' + @target + ''' if @target like ''%procedure%'' begin select o.name as ''stored procedures'' from sysobjects o where c.text like @search and o.xtype in (''p'',''fn'') end  else if @target like ''%view%'' begin select o.name as ''views'' from sysobjects o where c.text like @search and o.xtype = ''v'' end  else if @target like ''%table%'' begin select t.name as ''tablename'' from sys.columns c join sys.tables t on c.object_id = t.object_id where c.name like @search end  else if @target like ''%job%'' begin select  j.job_id, s.srvname, j.name, js.step_id, js.command, j.enabled from    [msdb].dbo.sysjobs j join    [msdb].dbo.sysjobsteps js join    master.dbo.sysservers s where   js.command like @search end  else begin select o.name as ''stored procedures'' from sysobjects o where c.text like @search and o.xtype in (''p'',''fn'') select o.name as ''views'' from sysobjects o where c.text like @search and o.xtype = ''v'' select t.name as ''tables'' from sys.columns c join sys.tables t on c.object_id = t.object_id where c.name like @search select  j.name as ''jobs'' from    [msdb].dbo.sysjobs j join    [msdb].dbo.sysjobsteps js join    master.dbo.sysservers s where   js.command like @search end ';
select routine_name from information_schema.routines where routine_definition like '%\[abd\]%';
select a, lookupvalue(b), c from customers;
select a, b, dbo.myfunction(c) from table;
select a, b, c from table where a = dbo.myfunc(c);
select * from dbo.mytable where col1 = dbo.myfunction(col2);
create function myfunction (@somevalue integer) returns integer as begin select localvalue from dbo.localtonationalmaptable where nationalvalue = @somevalue end;
select dbo.functionname('parameter1');
select name, dbo.functionname('parameter1') from sysobjects;
table <tablename>(name varchar(10),salary getsal(name));
create function ... returns scalar_type as begin ... end;
create function ... returns @r table(...) as begin ... end;
create function ... returns table as return select ...;
in procedure.                       |   management in function. select statement                    |   statement.;
select m.*                    -- get the row that contains the max value from topten m                 -- "m" from "max" and m.datetime < b.datetime           -- want "bigger" than "max" where b.datetime is null      -- keep only if there is no bigger than max;
select b.id, a.home,b.[datetime],b.player,a.resource from ;
select home, max(year) as year from table1 group by home ) select * from table1 a inner join cte on a.home = cte.home and a.year = cte.year;
select * from ( select ord.*, if (@prev_home = ord.home, 0, 1) as is_first_appear, @prev_home := ord.home from ( select t1.id, t1.home, t1.player, t1.resource from topten t1 select home, max(datetime) as mx_dt from topten where is_first_appear = 1;
select tt.* from topten tt ( select home, max(datetime) as maxdatetime from topten;
select a.* from topten a where ( select count(*) from topten b where a.home = b.home and a.`datetime` < b.`datetime`;
select a.* from topten a where ( select count(*) from topten b where a.home = b.home and  case then a.id < b.id else a.`datetime` < b.`datetime` end ) + 1 = 1;
select distinct tt.home  , tt.maxdatetime from topten tt (select home, max(datetime) as maxdatetime from topten and tt.datetime = groupedtt.maxdatetime;
select c1, c2, c3, c4, c5 from table1 where c3 = (select max(c3) from table) select * from table1 where c3 = (select max(c3) from table1);
select t1.id, t1.home, t1.date, t1.player, t1.resource from   t_scores_1 t1 where t1.date > t2.date;
select t.* from from   topten t1 where t1.date > t2.date where t.rw = 1;
select * from (select * from topten order by datetime desc) tmp group by home;
select tt.* from topten tt (select home, max(datetime) as maxdatetime from topten and tt.datetime = groupedtt.maxdatetime;
select id, home, datetime, player, resource from   ( select ( select  id from    topten ti where   ti.home = t1.home ti.datetime desc limit 1 from   ( select  distinct home from    topten where  t2.id = ro.lid;
select   home, max(datetime) from     my_table;
select * from mytable a join from mytable;
select  tt.* from    testtable tt ( select  coord, max(datetime) as maxdatetime from    rapsa krd and tt.datetime = groupedtt.maxdatetime;
player varchar(20), resource int) select 1, 10, '2009-03-04', 'john', 399 union select 2, 11, '2009-03-04', 'juliet', 244 union select 5, 12, '2009-03-04', 'borat', 555 union select 3, 10, '2009-03-03', 'john', 300 union select 4, 11, '2009-03-03', 'juliet', 200 union select 6, 12, '2009-03-03', 'borat', 500 union select 7, 13, '2008-12-24', 'borat', 600 union select 8, 13, '2009-01-01', 'borat', 700 select id, home, date, player, resource from (select id, home, date, player, resource, rank() over (partition by home order by date desc) n from @testtable select t.id, t.home, t.date, t.player, t.resource from @testtable t (   select ti.id, ti.home, ti.date, rank() over (partition by ti.home order by ti.date) n from @testtable ti where ti.date in (select max(tm.date) from @testtable tm);
select id, home, date, player, resource from testtable as t1 where (select count(*) from testtable as t2 where t2.home = t1.home and t2.date > t1.date;
select id from table ) select id from table_max where home = maxhome;
select id, home,datetime,player,resource, row_number() over (partition by home order by datetime desc) as rownum from tablename where rownum=1;
select tt.* from topten tt ( select min(id) as min_id, home from topten tt2 ( select home, max(datetime) as maxdatetime from topten;
select   orders.ordernumber, lineitems.quantity, lineitems.description from     orders join     lineitems ( select  top 1 lineitemguid from    lineitems where   orderid = orders.orderid );
select  orders.ordernumber, lineitems2.quantity, lineitems2.description from    orders ( select  top 1 lineitems.quantity, lineitems.description from    lineitems where   lineitems.orderid = orders.orderid;
select orders.ordernumber, lineitems.quantity, lineitems.description from orders inner join lineitems where lineitems.lineitemid = ( select min(lineitemid) from   lineitems where  orderid = orders.orderid );
select orders.ordernumber from ( select orders.orderid select top 1 lineitemid from lineitems where lineitems.orderid = orders.orderid ) from orders join lineitems and lineitems.lineitemid = orders.firstlineitemid;
select orders.ordernumber, lineitems.quantity, lineitems.description from orders select orders.ordernumber, max(lineitem.lineitemid) as lineitemid from orders inner join lineitems;
select orders.ordernumber, max(lineitems.quantity), max(lineitems.description) from orders;
select orders.ordernumber, topline.quantity, topline.description from orders ( select top 1 description,quantity from lineitems where orders.orderid = lineitems.orderid;
select orders.ordernumber, lineitems.quantity, lineitems.description from orders select orders.ordernumber, max(lineitem.lineitemid) as lineitemid from orders;
select distinct o.ordernumber , first_value(li.quantity) over ( partition by o.ordernumber order by li.description ) as quantity , first_value(li.description) over ( partition by o.ordernumber order by li.description ) as description from    orders as o;
select * from users join widgets on widgets.id = ( select id from widgets where widgets.user_id = users.id limit 1 );
select o.ordernumber, li.quantity, li.description from orders as o where not exists ( select 1 from lineitems as li_later where li_later.orderid = o.orderid and li_later.lineitemguid > li.lineitemguid );
select orders.ordernumber, lineitems.quantity, lineitems.description, row_number() over (partiton by orders.orderid order by orders.orderid) lp from orders join lineitems on orders.orderid = lineitems.orderid from firstonly where lp = 1;
select * from orders o select cast((select l.description + ',' from lineitems l where l.orderid = s.orderid;
select  orders.ordernumber, lineitems2.quantity, lineitems2.description from    orders ( select  lineitems.quantity, lineitems.description, orderid, row_number() from    lineitems;
select listagg((column_name), ', ') within group (order by column_id) from all_tab_columns where table_name = 'put_here_your_table' and column_name not in ('dont_want_this_column','neither_this_one','etc_column');
create table contact (contactid int, name varchar(100), dob datetime) select @columns = isnull(@columns + ', ','') + quotename(column_name) from information_schema.columns where table_name = 'contact' and column_name <> 'dob' exec ('select ' + @columns + ' from contact');
select @variable = @variable + ... from;
set @variable = (select ... for xml path(''));
exec (@variable);
select * from thatview;
select  @cols = stuff ( ( select distinct '], [' + name from sys.columns where object_id = ( select top 1 object_id from sys.objects where name = 'mytable' ) and name not in ('columnidontwant1', 'columnidontwant2') select @query = 'select ' + @cols + ' from mytable';
select * into #temptable from yourtable alter table #temptable drop column columntodrop select * from #temptable drop table #temptable;
select top 1 * from table;
select @sql = coalesce(@sql + ', ', '') + name from sys.columns where object_id = object_id(@tablename) and name not in ('not this', 'or that');
select @sql = 'select ' + @sql + ' from ' + @tablename exec (@sql);
create procedure [usp_select_without] @table_name sysname, @list_of_columns_excluded nvarchar(max), @separator nchar(1) = n',' as begin @full_table_name nvarchar(max) = concat(@schema_name, n'.', @table_name);
select @sql = coalesce(@sql + ', ', '') + quotename([name]) from sys.columns sc where sc.object_id = object_id(@full_table_name, n'u') and ss.[value] is null;
select @sql = n'select ' + @sql + n' from ' + @full_table_name;
exec [usp_select_without] @list_of_columns_excluded = n'id, date, name';
set ansi_nulls on set quoted_identifier on create procedure [dbo].[select_without] @table_name sysname, @list_of_columns_excluded nvarchar(max), @separator nchar(1) = n',' as begin @full_table_name nvarchar(max) = concat(@schema_name, n'.', @table_name);
select @sql = coalesce(@sql + ', ', '') + quotename([name]) from sys.columns sc where sc.object_id = object_id(@full_table_name) and ss.[value] is null;
select @sql = n'select ' + @sql + n' from ' + @full_table_name;
if ($row_cnt > 0) {;
select * , "" as password from tablename;
set hive.support.quoted.identifiers=none;
select `(unwanted_col1|unwanted_col2|unwanted_col3)?+.+` from database.table;
select @colnames=@colnames+','+name from syscolumns where object_id(tablename)=id and name not in (column3,column4) set @colnames=right(@colnames,len(@colnames)-1);
set @dyn_colums = (select replace( group_concat(`column_name`), ',column_name_to_remove','') from `information_schema`.`columns` where set @sql = concat("select ", @dyn_colums, " from table_name");
if dc.columnname.tolower <> excludefield then end if;
create table temptable as select * from #yourtable;
alter table temptable drop column #yourcolumn;
select * from temptable;
drop table temptable;
select 'select ' || array_to_string(array(select 'o' || '.' || c.column_name from information_schema.columns as c where table_name = 'officepark' and  c.column_name not in('officeparkid', 'contractor');
select @sql = coalesce(@sql + ', ', ' ' ) + name from sys.columns where name not in ('colname1','colname2') and object_id = (select id from sysobjects where name = 'tblname') select @sql = 'select ' + @sql + ' from ' + 'tblname' exec sp_executesql  @sql;
select group_concat( concat('`', `column_name`, '`') from information_schema.`columns` where `table_schema` = 'db' and `table_name` = 'table_name_here' and `column_name` not in ('exclude_col1', 'exclude_col2');
`included_col2`, `included_col3`;
select `included_col1`, `included_col2`, `included_col3` from db.table_name_here;
set dateformat dmy select @d = '2013-06-05', @d2 = '2013-06-05' select @d, @d2;
select @d1 as 'iammay6becauseofrounding', @d2 'may5', @d3 'stillmay5because2msearlier';
where entry_time >= '2017-01-01 00:00:00' and entry_time < '2018-01-01 00:00:00';
select validuntil + 1 from documents;
sdt smalldatetime, dt datetime, dt20 datetime2(0), dt27 datetime2(7) ) select getdate(),getdate(),getdate(),getdate() select sdt,datalength(sdt) as sdt_bytes, dt,datalength(dt) as dt_bytes, dt20,datalength(dt20) as dt20_bytes, dt27, datalength(dt27) as dt27_bytes from @temp;
select object_name(fkeys.constraint_object_id) foreign_key_name from sys.foreign_key_columns as fkeys;
where object_name(fkeys.parent_object_id) = 'table_name' and;
select  'alter table [poacomfinh].['+sch.name+'].['+referencingtable.name+'] drop constraint ['+foreignkey.name+']' 'query' from poacomfinh.sys.foreign_key_columns fk join poacomfinh.sys.tables referencingtable on fk.parent_object_id = referencingtable.object_id join poacomfinh.sys.schemas sch on referencingtable.schema_id = sch.schema_id join poacomfinh.sys.objects foreignkey on foreignkey.object_id = fk.constraint_object_id join poacomfinh.sys.tables referencedtable on fk.referenced_object_id = referencedtable.object_id end --cerrar cursor;
select f.name as 'name of foreign key', object_name(f.parent_object_id) as 'table name', col_name(fc.parent_object_id,fc.parent_column_id) as 'fieldname', object_name(t.object_id) as 'references table name', col_name(t.object_id,fc.referenced_column_id) as 'references fieldname',   from sys.foreign_keys as f, sys.foreign_key_columns as fc, sys.tables t where f.object_id = fc.constraint_object_id and t.object_id = fc.referenced_object_id and object_name(t.object_id) = 'employees'      --  just show the fks which reference a particular table;
alter table [dbo].[employees]  with nocheck add constraint [fk_employees_employees] foreign key([reportsto]);
alter table [employees] drop constraint [fk_employees_employees];
alter table [employees] with nocheck add constraint [fk_employees_employees];
exec sp_fkeys 'table', 'schema';
if object_id('tempdb..#temp1') is not null drop table #temp1;
create table #temp1 ( pktable_qualifier sysname, pktable_owner sysname, pktable_name sysname, pkcolumn_name sysname, fktable_qualifier sysname, fktable_owner sysname, fktable_name sysname, fkcolumn_name sysname, update_rule smallint, delete_rule smallint, fk_name sysname, pk_name sysname, deferrability sysname, fk_rowcount int select pktable_qualifier = convert(sysname,db_name()), pktable_owner = convert(sysname,schema_name(o1.schema_id)), pktable_name = convert(sysname,o1.name), pkcolumn_name = convert(sysname,c1.name), fktable_qualifier = convert(sysname,db_name()), fktable_owner = convert(sysname,schema_name(o2.schema_id)), fktable_name = convert(sysname,o2.name), fkcolumn_name = convert(sysname,c2.name), -- force the column to be non-nullable (see sql bu 325751) update_rule = convert(smallint,case objectproperty(f.object_id,'cnstisupdatecascade') else 1 delete_rule = convert(smallint,case objectproperty(f.object_id,'cnstisdeletecascade') else 1 fk_name = convert(sysname,object_name(f.object_id)), pk_name = convert(sysname,i.name), deferrability = convert(smallint,7)   -- sql_not_deferrable from   sys.all_objects o1, sys.all_objects o2, sys.all_columns c1, sys.all_columns c2, sys.foreign_keys f and f.key_index_id = i.index_id) where  o1.object_id = f.referenced_object_id and o2.object_id = f.parent_object_id and c1.object_id = f.referenced_object_id and c2.object_id = f.parent_object_id and c1.column_id = k.referenced_column_id and c2.column_id = k.parent_column_id and o1.name = @dbtablename set @sql = 'select @dbcountout = count(*) from [' + @fktable_name + '] where [' + @fkcolumn_name + '] = ''' + cast(@dbrowid as varchar(max)) + '''';
select * from #temp1;
select ccu.table_name as sourcetable from information_schema.constraint_column_usage ccu;
set @tblname = null-->null will return all pk/fk constraints for every table in the database select pktable_qualifier = convert(sysname,db_name()), pktable_owner = convert(sysname,schema_name(o1.schema_id)), pktable_name = convert(sysname,o1.name), pkcolumn_name = convert(sysname,c1.name), fktable_qualifier = convert(sysname,db_name()), fktable_owner = convert(sysname,schema_name(o2.schema_id)), fktable_name = convert(sysname,o2.name), fkcolumn_name = convert(sysname,c2.name), -- force the column to be non-nullable (see sql bu 325751) update_rule = convert(smallint,case objectproperty(f.object_id,'cnstisupdatecascade') else 1 delete_rule = convert(smallint,case objectproperty(f.object_id,'cnstisdeletecascade') else 1 fk_name = convert(sysname,object_name(f.object_id)), pk_name = convert(sysname,i.name), deferrability = convert(smallint,7)   -- sql_not_deferrable from   sys.all_objects o1, sys.all_objects o2, sys.all_columns c1, sys.all_columns c2, sys.foreign_keys f and f.key_index_id = i.index_id) where  o1.object_id = f.referenced_object_id and o2.object_id = f.parent_object_id and c1.object_id = f.referenced_object_id and c2.object_id = f.parent_object_id and c1.column_id = k.referenced_column_id and c2.column_id = k.parent_column_id and (   o1.name = @tblname or o2.name = @tblname or @tblname is null);
select 'alter table ['+sch.name+'].['+referencingtable.name+'] drop constraint ['+foreignkey.name+']' '[dropcommand]' from sys.foreign_key_columns fk join sys.tables referencingtable on fk.parent_object_id = referencingtable.object_id join sys.schemas sch on referencingtable.schema_id = sch.schema_id join sys.objects foreignkey on foreignkey.object_id = fk.constraint_object_id join sys.tables referencedtable on fk.referenced_object_id = referencedtable.object_id where referencedtable.name = 'mytablename';
alter table [dbo].[othertable1] drop constraint [fk_othertable1_mytable] alter table [dbo].[othertable2] drop constraint [fk_othertable2_mytable];
set @tablename = 'yourtablename' select name from yourdatabase.sys.objects where type_desc = 'foreign_key_constraint' and (name like '%_' + @tablename + 'empdb_%' or name like '%_' + @tablename );
select name from yourdatabase_prod.sys.objects where type_desc = 'foreign_key_constraint' and name like '%' + @tablename + '%' and;
select object_name(parent_object_id) 'parent table', c.name 'parent column name', object_name(referenced_object_id) 'referenced table', cref.name 'referenced column name' from sys.foreign_key_columns fkc sys.columns c and fkc.parent_object_id = c.object_id sys.columns cref and fkc.referenced_object_id = cref.object_id  where   object_name(parent_object_id) = 'tablename';
select  obj.name as fk_name, sch.name as [schema_name], tab1.name as [table], col1.name as [column], tab2.name as [referenced_table], col2.name as [referenced_column] from sys.foreign_key_columns fkc;
select pktable_qualifier = convert(sysname,db_name()), pktable_owner = convert(sysname,schema_name(o1.schema_id)), pktable_name = convert(sysname,o1.name), pkcolumn_name = convert(sysname,c1.name), fktable_qualifier = convert(sysname,db_name()), fktable_owner = convert(sysname,schema_name(o2.schema_id)), fktable_name = convert(sysname,o2.name), fkcolumn_name = convert(sysname,c2.name), -- force the column to be non-nullable (see sql bu 325751) update_rule = convert(smallint,case objectproperty(f.object_id,'cnstisupdatecascade') else 1 delete_rule = convert(smallint,case objectproperty(f.object_id,'cnstisdeletecascade') else 1 fk_name = convert(sysname,object_name(f.object_id)), pk_name = convert(sysname,i.name), deferrability = convert(smallint,7)   -- sql_not_deferrable from   sys.all_objects o1, sys.all_objects o2, sys.all_columns c1, sys.all_columns c2, sys.foreign_keys f and f.key_index_id = i.index_id) where  o1.object_id = f.referenced_object_id and o2.object_id = f.parent_object_id and c1.object_id = f.referenced_object_id and c2.object_id = f.parent_object_id and c1.column_id = k.referenced_column_id and c2.column_id = k.parent_column_id;
select t.name as tablewithforeignkey, fk.constraint_column_id as fk_partno, c.name as foreignkeycolumn, o.name as fk_name from sys.foreign_key_columns as fk and fk.parent_column_id = c.column_id where fk.referenced_object_id = (select object_id from sys.tables where name = 'tableothersforeignkeyinto');
select object_name(parent_object_id), object_name(referenced_object_id), name from sys.foreign_keys where parent_object_id = object_id('table name');
@objname nvarchar(776) select @objname = 'customer' select @objid = object_id(@objname) if exists (select * from sys.foreign_keys where referenced_object_id = @objid) select 'table is referenced by foreign key' = from sys.foreign_keys where referenced_object_id = @objid;
select object_name(fk.parent_object_id) as referencingtable, object_name(fk.constraint_object_id) as [fkcontraint] from sys.foreign_key_columns as fk where fk.referenced_object_id = object_id('referencedtable', 'u');
select object_name(object_id) from sys.columns where name like 'client_id';
exec sp_fkeys 'tablename';
exec sp_fkeys @pktable_name = 'tablename', @pktable_owner = 'dbo';
select o.name as [object_name], c.text as [object_definition] from sys.syscomments c where c.text like '%table_name%';
as ( select  constraint_name= cast (pknukey.name as varchar(30)) , constraint_type=cast (pknukey.type_desc as varchar(30)) , parent_table_name=cast (pknutable.name as varchar(30)) , parent_col_name=cast ( pknukeycol.name as varchar(30)) , parent_col_name_data_type=  oparentcoldtl.data_type, reference_table_name='' , reference_col_name='' from sys.key_constraints as pknukey and pknucolidx.index_id = pknukey.unique_index_id and pknukeycol.column_id = pknucolidx.column_id and oparentcoldtl.column_name=pknukeycol.name union all select  constraint_name= cast (oconstraint.name as varchar(30)) , constraint_type='fk', parent_table_name=cast (oparent.name as varchar(30)) , parent_col_name=cast ( oparentcol.name as varchar(30)) , parent_col_name_data_type= oparentcoldtl.data_type, reference_table_name=cast ( oreference.name as varchar(30)) , reference_col_name=cast (oreferencecol.name as varchar(30)) from sys.foreign_key_columns fkc and fkc.parent_column_id=oparentcol.column_id/* id of the column. is unique within the object.column ids might not be sequential.*/ and oparentcoldtl.column_name=oparentcol.name and fkc.referenced_column_id=oreferencecol.column_id/* id of the column. is unique within the object.column ids might not be sequential.*/ ) select * from   all_keys_in_table where parent_table_name  in ('your_table_name') or reference_table_name  in ('your_table_name');
select t.name as tablewithforeignkey, fk.constraint_column_id as fk_partno, c. from sys.foreign_key_columns as fk sys.tables as t on fk.parent_object_id = t.object_id sys.columns as c on fk.parent_object_id = c.object_id and fk.parent_column_id = c.column_id where fk.referenced_object_id = (select object_id from sys.tables where name = 'tableothersforeignkeyinto') tablewithforeignkey, fk_partno;
select distinct name from sys.objects where object_id in where fk.referenced_object_id = );
select object_name(f.parent_object_id) tablename, col_name(fc.parent_object_id,fc.parent_column_id) colname from sys.foreign_keys as f sys.foreign_key_columns as fc sys.tables t where object_name (f.referenced_object_id) = 'tablename';
exec sp_fkeys 'tablename', 'schemaname';
select object_name (fk.referenced_object_id) 'referenced table', object_name(fk.parent_object_id) 'referring table', fk.name 'foreign key', col_name(fk.referenced_object_id, fkc.referenced_column_id) 'referenced column', col_name(fk.parent_object_id,fkc.parent_column_id) 'referring column' from sys.foreign_keys as fk where object_name (fk.referenced_object_id) = 'yourtablename' and col_name(fk.referenced_object_id, fkc.referenced_column_id) = 'yourcolumnname';
select * from information_schema.columns where table_name = n'customers';
select * from sys.columns where object_id = object_id('dbo.yourtablename');
select   o.name, c.name from     sys.columns c join sys.objects o on o.object_id = c.object_id where    o.type = 'u';
select column_name from information_schema.columns where table_name like 'table name';
select * from information_schema.columns where table_name='tablename';
select o.name                   as table_name from syscolumns c where o.type = 'u';
select column_name, data_type, character_maximum_length, table_name,ordinal_position, is_nullable from information_schema.columns where table_name like 'your_table_name';
select name from sys.columns where object_id = object_id('table_name');
select t.table_name as 'table name', c.column_name as 'column name' from information_schema.tables t where   t.table_type='base table' and t.table_name like 'your table name';
select * from sys.all_columns where object_id = object_id('logging');
select * from my_table where 1=0 or select top 0 * from my_table;
select * from information_schema.columns where table_name = n'customers';
select * from information_schema.columns where column_name like n'%[columnname]%' and table_name = n'[tablename]';
select top (0) [toid] from [reportdatabase].[ticket].[to];
select [name] from sys.columns where object_id = object_id('[yourschematype].[yourtablename]');
desc <table name> ;
select * from information_schema.columns where column_name like n'%[columnname]%' and table_name = n'[tablename]';
select c.name from sys.columns c join sys.objects o on o.object_id = c.object_id where o.object_id = object_id('table_name');
exec sp_columns 'your table name';
select column_name from information_schema.columns where table_name = 'name_of_your_table';
drop table if exists test;
create table test ( col001 integer ) select case row_number() over(order by ordinal_position) else '   or ' end + column_name +' is not null' else '' end from information_schema.columns where table_schema='dbo' and table_name = 'test' ordinal_position;
set statistics time on select count(1) from mytable (nolock) -- table containing 1 million records.;
select count(*) from mytable (nolock) -- table containing 1 million records.;
select count(*) from mypersistedtable;
select  count(sys_guid()) from    t_even;
select  count(*) from    ( select  sys_guid() from    t_even );
exists (select * ...;
exists (select 1 ...;
select count(1) from dbo.tab800krows select count(1),fkid from dbo.tab800krows group by fkid select count(*) from dbo.tab800krows select count(*),fkid from dbo.tab800krows group by fkid;
select count(*) from something;
select count(1) from something;
create table [dbo].[employee]( [id] [bigint] identity(1,1) not null, [name] [nvarchar](50) not null, constraint [pk_employee] primary key clustered ( [id] asc;
set statistics time on select count(*) from employee set statistics time off;
set statistics time on select count(1) from employee set statistics time off;
if object_id( n'dbo.blitzen', n'u') is not null drop table dbo.blitzen;
create table dbo.blitzen (id int null, somelala char(1) null);
select count(*), count(1), count(id), count(somelala) from dbo.blitzen;
drop table dbo.blitzen;
select /* test-1 */ count(1) from employees;
select value from v$diag_info where name = 'diag trace';
select count(*) count(1) from course.employees employees;
select count(1) from table;
select count(*) from table;
select count(column) from table;
select count(*) from t;
select count(1) from t;
delete from [testtable];
select * from tablexyz set identity_insert tablexyz on alter table #temp drop column (nameofidentitycolumn) set identity_insert tablexyz off select * from #temp;
delete from [mytable];
select @max=max([id])from [testtable] if @max is null   //check when max is returned as null set @max = 0;
select @max=isnull(max(id),0) from [testtable];
if (object_id('[dbo].[presetidentityfield]') is null) end go set  ansi_nulls on set  quoted_identifier on alter procedure [dbo].[presetidentityfield] select @identitycolumn = c.[name] from sys.tables t where     c.is_identity = 1 and t.name = @ptablename and s.[name] = @pschemaname if @identitycolumn is null 'one of the following is true: 1. the table you specified doesn''t have an identity field, 2. you specified an invalid schema, 3. you specified an invalid table' if @max is null set @max = 0;
drop table test01 create table test01 (id int identity(1,1), descr nvarchar(10)) select * from test01 delete from test01 select * from test01;
select table_name from information_schema.tables where table_type = 'base table' and table_catalog = 'mydb' set @tblname = '' if charindex('mycommonwordforalltablesiwanttodothisto', @tblname) > 0 end  end ;
if @maxid is null if (select ident_current('dbo.tbl')) > 1 else dbcc checkident ('dbo.tbl', reseed, 1) else dbcc checkident ('dbo.tbl', reseed, @maxid);
update mytable set myscore=100 where exists ( select 1 from table1 );
select p.id as "p.id", pc.id as "pc.id" from post p;
select p.id as "p.id", pc.id as "pc.id" from post p where 1 = 1;
select p.id as "p.id", pc.id as "pc.id" from post p;
select p.id as "p.id", pc.id as "pc.id" from post p where 1 = 0;
select p.id as "p.id", pc.post_id as "pc.post_id", pc.id as "pc.id", p.title as "p.title", pc.review  as "pc.review" from post p;
select p.id as "p.id", pc.post_id as "pc.post_id", pc.id as "pc.id", p.title as "p.title", pc.review  as "pc.review" from post p, post_comment pc where pc.post_id = p.id;
select * from employee where employee_id=101;
select * from employee;
select documents.name, downloads.id from documents where username = 'sandeep';
select documents.name, downloads.id from documents and username = 'sandeep';
select song_id,songs.fullname, singers.fullname from music join songs on songs.id = music.song_id join singers on singers.id = music.singer_id;
select * from orders where orders.id = 12345;
select * from orders and orders.id = 12345;
where t2.idfield is null;
select a.actor_id, a.first_name, a.last_name, count(fa.film_id) from actor a where film_id < 10;
select a.actor_id, a.first_name, a.last_name, count(fa.film_id) from actor a and film_id < 10;
select * from a;
select * from a and b.id_a = specificpart;
select * from a where b.id_a = specificpart;
select * from a inner join b on a.c = b.c;
select * from a inner join b where a.c = b.c;
if ((entities.count - currentcount) < commitcount);
select (columns...) from some_staging_table;
if (context != null) entity entity, int count, int commitcount, bool recreatecontext) if (count % commitcount == 0) if (recreatecontext);
if (count % commitcount == 0) if (recreatecontext);
() => new yourcontext());
if (gpsreceivertracks == null) ( new object[] gpsreceivertracks[i].downloadedtrackid, gpsreceivertracks[i].time, gpsreceivertracks[i].latitude, gpsreceivertracks[i].longitude, gpsreceivertracks[i].altitude;
if (propertytype.isgenerictype && properties.select(property => property.getvalue(entity, null) ?? dbnull.value).toarray());
if (propertytype.isgenerictype && properties.select(property => property.getvalue(entity, null) ?? dbnull.value).toarray());
new sqlparameter("@param2", entity.property2));
if (attribute.isdefined(prop, typeof(keyattribute)) || attribute.isdefined(prop, typeof(foreignkeyattribute))) case type inttype when inttype == typeof(int) || inttype == typeof(int?): case type stringtype when stringtype == typeof(string): case type datetype when datetype == typeof(datetime) || datetype == typeof(datetime?): case type decimaltype when decimaltype == typeof(decimal) || decimaltype == typeof(decimal?): case type doubletype when doubletype == typeof(double) || doubletype == typeof(double?): case type floattype when floattype == typeof(float) || floattype == typeof(float?): case type guidtype when guidtype == typeof(guid):;
create procedure testproc @secondparam varchar(50) as insert into sometable(name, address) values(@firstparam, @secondparam);
if (i % 100 == 0);
where tchild : class, ientitychild where tfather : class, ientityfather if (context != null);
if (entity != null) if (count % commitcount == 0) if (recreatecontext);
select * from t1 union select * from t1;
select * from t1 union all select * from t1 where t1.id is null;
select * from lefttable lt union select lt.*, rl.*  -- to match column set from righttable rt;
select * from `t1`;
select * from `t1`;
select * from `t1`;
select * from `t1` union  select * from `t1`;
select * from `t1` union  select * from `t1` where `t1`.`id` is null;
select a.name, b.title from author as a book as b union select a.name, b.title from author as a book as b;
select t1.name, t2.name from t1 union select t1.name, t2.name from t2;
select t1.value, t2.value from t1 union all      -- using `union all` instead of `union` select t1.value, t2.value from t2 where t1.value is null;
select t1.value, t2.value from t1 join t2 on t1.value = t2.value union all  -- and plus select t1.value, null from t1 where not exists( select 1 from t2 where t2.value = t1.value) union all  -- and plus select null, t2.value from t2 where not exists( select 1 from t1 where t2.value = t1.value);
select t1.value, t2.value from t1 left join t2 on t1.value = t2.value union all -- include duplicates select t1.value, t2.value from t1 right join t2 on t1.value = t2.value where t1.value is null;
select * from t1 full outer join t2 on t1.name = t2.name;
select t1.*, t2.* from (select name from t1 union  -- this is intentionally union to remove duplicates select name from t2;
select * from t1 full outer join t2 on t1.id = t2.id;
select t1.*, t2.* from (select * from t1 union select name from t2) tmp;
( select 1 as id1 union all select 2 union all select 5 union all select 6 union all select 6 cte_t2 as ( select 3 as id2 union all select 4 union all select 5 union all select 6 union all select 6 );
select t1.*, t2.* from (select * from t1 union select name from t2) tmp;
( select a.* from tablea a where b.`key` is null ) union all ( select a.* from tablea a where  a.`key` = b.`key` ) union all ( select b.* from tablea a where a.`key` is null;
select t1.*, t2.* from table1 t1;
select * from t1 union select * from t1;
select * from t1 union select * from t2;
select * from t1 where t1.col1 = 'somevalue' union select * from t1 where t1.col1 = 'somevalue';
select * from t1 where t1.col1 = 'somevalue' union select * from t2 where t1.col1 = 'somevalue';
from table1 t1 table2 t2 on t1.id = t2.id where t2.id is null) union all (select from table1 t1 table2 t2 on t1.id = t2.id where t1.id is null);
select fields from firsttable;
select fields from firsttable union all select fields (replacing any fields from firsttable with null) from secondtable where not exists (select 1 from firsttable where joincondition);
select fields from firsttable union all select fields from firsttable where firsttable.foo is null;
select id , if(type='p', ifnull(amount,0), ifnull(amount,0) * -1) as amount from table;
select id, case report.type end as amount from `report`;
select id, if(type = 'p', amount, amount * -1) as amount from report;
select id, if(type = 'p', ifnull(amount,0), ifnull(amount,0) * -1) as amount from report;
select id, case when report_type = 'p' then amount then -amount else null end from table;
if report.type = 'p' else amount = -1*amount;
select id, if(report.type = 'p', abs(amount), -1*abs(amount)) as amount from  report;
select companyname, case when country in ('usa', 'canada') then 'north america' else 'europe' end as continent from suppliers;
select id, amount from report where type='p' union  select id, (amount * -1) as amount from report where type = 'n';
(case case when @topby = 1  then [rx count] end desc;
select * from people order by firstname desc, yearofbirth asc;
select  * from    mytable column1 desc, column2 asc;
update t1.column1 = value from tbltemp as t1 where t1.[column1]=value and t2.[column1] = value;
create table dbo.target ( employeeid int , employeename varchar(100) , constraint target_pk primary key ( employeeid ) create table dbo.source ( employeeid int , employeename varchar(100) , constraint source_pk primary key ( employeeid ) values  ( 100, 'mary' );
values  ( 101, 'sara' );
values  ( 102, 'stefano' );
values  ( 100, 'bob' );
values  ( 104, 'steve' );
select * from dbo.source select * from dbo.target update set t.employeename = s.employeename + '[updated]';
select '-------after merge----------' select * from dbo.source select * from dbo.target;
update shopping_cart sc package pc on sc. package_id = pc.id set sc. amount = pc.amount;
update item_master set mf_item_number = (some value) from group_master as gm join manufacturar_master as mm on ........ where .... (your conditions here);
update im set mf_item_number = gm.sku --etc from item_master im join group_master gm join manufacturer_master mm where im.mf_item_number like 'sta%' and;
update a set foo = b.bar from tablea a join tableb b where ...;
update p set    p.category = c.category from   products p where  c.categories like 'whole%';
select im.itemid from item_master im, group_master gm, manufacturer_master mm where im.mf_item_number like 'sta%' and im.sku=gm.sku and gm.manufacturerid = mm.manufacturerid and gm.manufacturerid=34) update cte set mf_item_number = <your other field>;
update item_master im join group_master gm on im.sku=gm.sku join manufacturer_master mm on gm.manufacturerid=mm.manufacturerid set im.mf_item_number = gm.sku --etc where im.mf_item_number like 'sta%' and gm.manufacturerid=34;
update customer_table c join employee_table e join anyother_ table a set c.active = "yes" where c.city = "new york";
update im set mf_item_number = (some value) from item_master im join group_master gm join manufacturer_master mm where im.mf_item_number like 'sta%' and;
update table1 set table1.col1 = table2.col1, table1.col2 = table2.col2 from table2 where table1.id = table2.id;
set foreign_key_checks=0;
alter table mytable disable keys;
set foreign_key_checks=0;
alter table mytable disable keys;
delete from mytable;
alter table mytable enable keys;
set foreign_key_checks=1;
set global foreign_key_checks = 0;
set global foreign_key_checks = 1;
set foreign_key_checks=0;
set foreign_key_checks=1;
alter table tablename1 drop foreign key fk_name1; //get rid of current constraints alter table tablename2 drop foreign key fk_name2;
alter table tablename1 add foreign key (table2_id) alter table tablename2 add foreign key (table1_id);
set foreign_key_checks=0;
set foreign_key_checks=1;
set global foreign_key_checks=0;
set global foreign_key_checks=1;
if exists ( select 1 from sys.columns where name = 'oldcolumnname' and not exists ( select 1 from sys.columns where name = 'newcolumnname' and ) exec sp_rename 'schemaname.tablename.oldcolumnname', 'newcolumnname', 'column';
exec sp_rename 'tablename.oldcolumnname' , 'newcolumnname', 'column';
exec sp_rename 'table_name.old_name', 'new_name', 'column';
exec sp_rename 'tablename.oldname', 'newname', 'column';
set @schemaname = 'dbo' set @tablename = 'tablename' set @oldcolumnname = 'oldcolumnname' set @newcolumnname = 'newcolumnname' set @paramvalue = @schemaname + '.' + @tablename + '.' + @oldcolumnname if exists ( select 1 from sys.columns where name = @oldcolumnname and object_name(object_id) = @tablename ) and not exists ( select 1 from sys.columns where name = @newcolumnname and object_name(object_id) = @tablename ) exec sp_rename @paramvalue, @newcolumnname, 'column';
exec sp_rename 'tablename.oldcolumnname', 'newcolumnname', 'column';
exec sp_rename '[db].[dbo].[tablename].oldcolumnname', 'newcolumnname', 'column';
alter table table_name rename column old_name new_name varchar(50) not null;
select count(*) from stats;
select count(id), date_format(record_date, '%y-%m-%d') as day, date_format(record_date, '%y-%m') as month, date_format(record_date, '%y') as year from stats where year = 2009 date_format(record_date, '%y-%m-%d ');
select count(*) from stats where record_date >= :year and record_date <  :year + interval 1 year;
select count(*) from stats extract(month from timestamp), extract(month from timestamp), extract(year  from timestamp);
select count(id) from stats where year(record_date) = 2009;
select sql_no_cache year(record_date), month(record_date), count(*) from stats;
select sql_no_cache year(record_date), month(record_date), count(*) from stats;
select month(date_column), count(*) from date_table where date_column >= '2000-01-01' and date_column < '2001-01-01';
where year(date_column) = 2000;
select year(date_column), month(date_column), count(*) from date_table select year(date_column), month(date_column), count(*) from date_table select year(date_column), month(date_column), count(*) from date_table;
select count(id), year(record_date), month(record_date) from `table` month(record_date) month(record_date) desc;
select count(id) from stats;
select count(id) from stats;
select last_day(record_date) month_ending, count(*) record_count from stats where record_date >= '2000-01-01' and record_date <  '2000-01-01' + interval 1 year;
select count(id) from stats;
ulong length) if (mysql->server_status & server_status_no_backslash_escapes);
char *to, size_t to_length, const char *from, size_t length) if (*from == '\'') if (to + 2 > to_end);
select * from test where name = "" or 1=1 -- " limit 1;
select @@character_set_database, @@collation_database;
select schema_name 'database', default_character_set_name 'charset', default_collation_name 'collation' from information_schema.schemata;
select @@character_set_database;
select default_character_set_name from information_schema.schemata;
select default_character_set_name from information_schema.schemata where schema_name = "schemaname";
select ccsa.character_set_name from information_schema.`tables` t, information_schema.`collation_character_set_applicability` ccsa where ccsa.collation_name = t.table_collation and t.table_schema = "schemaname" and t.table_name = "tablename";
select character_set_name from information_schema.`columns` where table_schema = "schemaname" and table_name = "tablename" and column_name = "columnname";
create function upsert (sql_update text, sql_insert text) as $$ if found then end if;
update table set field='c', field2='z' where id=3;
select 3, 'c', 'z' where not exists (select 1 from table where id=3);
update table set column = x.column from (values (1,'aa'),(2,'bb'),(3,'cc')) as x (id, column) where table.id = x.id;
values (1, 'a', 'x'), (2, 'b', 'y'), (3, 'c', 'z') set column_1 = excluded.column_1, column_2 = excluded.column_2;
create table db (a int primary key, b text);
create function merge_db(key int, data text) returns void as update db set b = data where a = key;
if found then end if;
-- we could get a unique-key failure end loop;
select merge_db(1, 'david');
select merge_db(1, 'dennis');
where updated.id is null;
create or replace function upsert(sql_insert text, sql_update text) if found then end if;
alter function upsert(text, text);
select upsert($$insert into ...$$,$$update... $$);
select all current name value pairs where id = $id into a hash record create a merge record from the current and update record delete all name value pairs where id = $id end transaction;
update ... returning;
create table foo (k int primary key, v text);
create function update_foo(k int, v text) update foo set v = $2 where k = $1 returning $1 create function upsert_foo(k int, v text) select $1, $2 where not exists (select update_foo($1, $2));
select upsert_foo(1, 'hi');
select upsert_foo(1, 'bye');
select upsert_foo(3, 'hi');
select upsert_foo(3, 'bye');
values (1, 'a', 'x'), (2, 'b', 'y'), (3, 'c', 'z') upsert as ( update mytable m set field1 = nv.field1, field2 = nv.field2 from new_values nv where m.id = nv.id ) select id, field1, field2 from new_values where not exists (select 1 from upsert up where up.id = new_values.id);
create table dns ( "time" timestamp without time zone not null, customer_id integer not null, hits integer;
create rule replace_dns as where (exists (select 1 from dns where ((dns."time" = new."time") and (dns.customer_id = new.customer_id)))) set hits = new.hits where ((dns."time" = new."time") and (dns.customer_id = new.customer_id));
create or replace function save_user(_id integer, _name character varying) update users set name = _name where id = _id;
if found then end if;
update users set name = _name where id = _id;
create or replace function merge_tabla(key int, data text) if exists(select a from tabla where a = key) then update tabla set b = data where a = key;
else insert into tabla(a,b) values (key, data);
create table tablename (a integer primary key, b integer, c integer);
alter user myuser with superuser;
alter user "user" with superuser;
alter user username with superuser;
alter user username with nosuperuser;
alter user username createdb;
alter user username superuser;
alter user myuser with superuser;
values (null, '$val1', '$val2')";
values (null, '".$val1."', '".$val2."')";
values (null, '.$val1.', '.$val2.')';
select "column" from table where foo = "bar";
select `column_name` from `table_name` where id='2';
select `column_name` from `table_name` where (id='2' and gender='male') or name='rakesh';
create function [dbo].[fnsplit] ( @sep char(1), @str varchar(512) ) with pieces(pn, start, stop) as ( select 1, 1, charindex(@sep, @str) union all select pn + 1, stop + 1, charindex(@sep, @str, stop + 1) from pieces where stop > 0 ) select pn as id, substring(@str, start, case when stop > 0 then stop - start else 512 end) as data from pieces );
select distinct s.data from fnsplit(' ', 'word1 word2 word3') s -- contains words select distinct t.* from mytable t where f2.data is null;
select * from mytable where charindex('word1', column1) > 0 and charindex('word2', column1) > 0 and charindex('word3', column1) > 0;
select * from mytable where instr('word1 word2 word3',column1)<>0;
select * from mytable where instr(';word1;word2;word3;',';'||column1||';')<>0;
select * from mytable where contains(column1,'word1 and word2 and word3', 1) > 0;
select * from mytable where contains(column1,'word1 or word2 or word3', 1) > 0;
create index search_idx on mytable(column) indextype is ctxsys.context;
select * from mytable where column1 like '%word1%' or column1 like '%word2%' or column1 like '%word3%';
select * from mytable where column1 like '%word1%' and column1 like '%word2%' and column1 like '%word3%';
select * from mytable where and column1 like '%word2%' and column1 like  '%word3%';
select * from table where name regexp '^word[1-3]$';
select * from table where name in ('word1','word2','word3');
select * from mytable where column1 contains 'word1 word2 word3';
select * from mytable where column1 contains 'word1 and word2 and word3';
select * from mytable where column1 contains '"phrase one" and word2 and "phrase two"';
select * from mytable where column1 like "*word*";
set @searchstr = ' ' create table #results (columnname nvarchar(370), columnvalue nvarchar(3630)) set nocount on set  @tablename = '' set @searchstr2 = quotename('%' + @searchstr + '%','''') set @columnname = '' set @tablename = ( select min(quotename(table_schema) + '.' + quotename(table_name)) from     information_schema.tables where         table_type = 'base table' and    quotename(table_schema) + '.' + quotename(table_name) > @tablename and    objectproperty( object_id( quotename(table_schema) + '.' + quotename(table_name) ) set @columnname = ( select min(quotename(column_name)) from     information_schema.columns where         table_schema    = parsename(@tablename, 2) and    table_name    = parsename(@tablename, 1) and    data_type in ('char', 'varchar', 'nchar', 'nvarchar', 'int', 'decimal') and    quotename(column_name) > @columnname ) if @columnname is not null exec ( 'select ''' + @tablename + '.' + @columnname + ''', left(' + @columnname + ', 3630) from ' + @tablename + ' (nolock) ' + ) end end end  select columnname, columnvalue from #results drop table #results;
select * from mytable where contains(column1, 'word1 near word2 near word3') select * from mytable where contains(column1, 'word1 ~ word2 ~ word3');
select * from mytable where and contains(column1 , n'word2' ) and contains(column1 , n'word3' );
select * from table where columnname in (word1, word2, word3);
create table dbo.mytable ( mytableid int not null identity (1, 1), code varchar(200) not null, description varchar(200) not null -- this column contains the values we are going to search in create function [dbo].[fnsplit] (@stringinput nvarchar(max), @delimiter nvarchar(1)) id nvarchar(1000) ) as begin set @string = left(@stringinput, isnull(nullif(charindex(@delimiter, @stringinput) - 1, -1), len(@stringinput)));
set @stringinput = substring(@stringinput, isnull(nullif(charindex ( @delimiter, @stringinput 0 ( @stringinput) ) values (@string);
if (len(trim(@search)) = 0) -- if search string is empty, just return records ordered alphabetically select 1 as priority ,mytableid, code, description from mytable order by description end  wordrank int identity(1,1), -- individual words are assinged priority order (in order of occurence/position) ) ) ('with'), ('at'), ('in'), ('for'), ('on'), ('by'), ('like'), ('up'), ('off'), ('near'), ('is'), ('are'), (','), (':'), (';') select id from dbo.fnsplit(@search,' '); -- this function gives you a table with rows containing all the space separated words of the search like in this e.g., the output will be - delete s from @splittable s join @nonwordtable n  on s.word = n.id; -- trimming out non-words here ( select mytableid, @highestpriority as priority from mytable where description like @search  -- exact matches have highest priority union select mytableid, @highestpriority-1 as priority from mytable where description like  @search + '%'  -- then with something at the end union select mytableid, @highestpriority-2 as priority from mytable where description like '%' + @search -- then with something at the beginning union select mytableid, @highestpriority-3 as priority from mytable where description like '%' + @search + '%' -- then if the word falls somewhere in between splitwordmatches as( -- give each searched word a rank based on its position in the searched string select mytable.mytableid, (@countofsearchstrings - s.wordrank) as priority, s.word, wordindex = charindex(s.word, mytable.description)  from mytable join @splittable s on mytable.description like '%'+ s.word + '%' matchingrowswithallwords as ( select mytableid, count(mytableid) as mytablecount from splitwordmatches group by(mytableid) having count(mytableid) = @countofsearchstrings ) select s.mytableid, priority, word, row_number() over (partition by s.mytableid order by wordindex desc) as comparativewordindex from splitwordmatches s join matchingrowswithallwords m on s.mytableid = m.mytableid ) wordindexsequenceratings as ( -- need to do this to ensure that if the same set of words from search string is found in two rows, -- their sequence in the field value is taken into account for higher priority select w.mytableid, w.word, (w.priority + w.comparativewordindex + coalesce(sequncedpriority ,0)) as priority from wordindexratings w left join ( select w1.mytableid, w1.priority, w1.word, w1.comparativewordindex, count(w1.mytableid) as sequncedpriority from wordindexratings w1 join wordindexratings w2 on w1.mytableid = w2.mytableid and w1.priority > w2.priority and w1.comparativewordindex>w2.comparativewordindex ) prioritizedsplitwordmatches as ( -- this calculates the cumulative priority for a field value select  w1.mytableid, sum(w1.priority) as overallpriority from wordindexsequenceratings w1 join wordindexsequenceratings w2 on w1.mytableid =  w2.mytableid where w1.word <> w2.word group by w1.mytableid completeset as ( select mytableid, priority from plainmatches -- get plain matches which should be highest ranked union select mytableid, overallpriority as priority from prioritizedsplitwordmatches -- get ranked split word matches (which are ordered based on word rank in search string and sequence) maximizedcompleteset as( -- set the priority of a field value = maximum priority for that field value select mytableid, max(priority) as priority  from completeset group by mytableid ) select priority, mytable.mytableid , code, description from maximizedcompleteset m join mytable  on m.mytableid = mytable.mytableid;
select @key, @fielda where not exists ( select * from  mytable where key = @key ) if @@rowcount = 0 update mytable set fielda=@fielda where key=@key if @@rowcount = 0 end;
as source (field1, field2) update set field1 = source.field1, field2 = source.field2, ... values ( 7,  source.field1, source.field2, ... );
alter procedure dbo.merge_foo2 as  set nocount, xact_abort on;
update set f.updatespid = @@spid, updatetime = sysdatetime() ( id, insertspid, inserttime ) values ( new_foo.id, @@spid, sysdatetime();
if exists (select * from [table] where id = rowid) update [table] set propertyone = propone, property2 . . . else insert into [table] (propone, proptwo . . .);
if exists (select * from table with (updlock,serializable) where key = @key) update table set ... where key = @key end else begin values (@key, ...) end commit tran;
update table with (serializable) set ... where key = @key if @@rowcount = 0 end commit tran;
set @rowexists = 0 update mytable set datafield1 = 'xxx', @rowexists = 1 where key = 123 if @rowexists = 0;
update table set id = @id, description = @description where id = @id select @id, @description where not exists (select null from table where id = @id);
if exists (select * from table with (updlock,serializable) where key = @key) update table set ... where key = @key end else begin values (@key, ...) end commit tran;
update <tablename> set <field>=@field where key=@key;
if @@rowcount = 0 select @field where not exists (select * from tablename where key = @key);
create table applicationsdessocietes ( id                   int identity(0,1)    not null, applicationid        int                  not null, societeid            int                  not null, suppression          bit                  null, constraint pk_applicationsdessocietes primary key (id) ) as source (applicationid, societeid, suppression) update --place your list of set here set target.suppression = source.suppression values (source.applicationid, source.societeid, source.suppression);
update dbo.table with (updlock, serializable) set ... where pk = @pk;
if @@rowcount = 0 end ;
set transaction isolation level serializable;
if exists (select 1 from dbo.table where pk = @pk) update ... end else begin end commit transaction;
end try if error_number() = 2627 update ... end catch;
set transaction isolation level repeatable read;
if (exists (select * from mytable where key=@key) update mytable set ... where key=@key else insert into mytable (key, ...) values (@key, ...);
where key=@key2;
if ($binding instanceof \datetime) {;
if (is_bool($binding)) {;
select * from users;
//     "bindings" => [], // ] //     "bindings" => [ 7 ], // ];
if ($pos !== false) { if (gettype($replace) === "string") {;
if (!isset($localbindings)) { case "boolean": case "null": case "string": case "object":;
name: "admin", email: "admin@example.com", created_at: "2019-01-11 19:06:23", updated_at: "2019-01-11 19:06:23", };
"time" => $query->time, ];
$query->bindings, $query->time;
$query->sql, $query->bindings, $query->time;
select * from ( values ('use staging'), ('go'), ('exec sp_msforeachtable;
select @tmp = msgbody from emailssentlog where id=6769;
set @text = 'this is line 1.' + char(13) + 'this is line 2.' select @text;
create table crlf ( col1 varchar(1000) ) select col1 from crlf update crlf set col1 = replace(col1, '@', char(13));
if (!string.isnullorempty(orig_line)) if (cum_length >= imaxlen) break;                // stop appending if we're already over if ((cum_length+orig_line.length+2)>=imaxlen)    // if this one will push us over, truncate and warn:;
select userid, my_date, ... from users;
select user_id, user_value_1, user_value_2 from (select user_id, user_value_1, user_value_2, row_number() from users) as r where r.row_number=1;
select value from table1 where time =;
select distinct userid, max(date) over (partition by userid order by date desc), max(values) over (partition by userid order by date desc) from ( select userid, date, sum(value) as values from <<table_name>> );
select * from ( select u.*, first_value(u.rowid) over(partition by u.user_id order by u.date desc) as last_rowid from users u where u2.rowid = u2.last_rowid;
select first, last, sum(points) as total from students s, results r where s.sid = r.sid and r.cat = 'h' having sum(points) >= all (select sum (points) from results where cat = 'h';
select x.isbn, x.title, x.loans from (select book.isbn, book.title, count(loan.datetimeout) as loans from catalogentry book having loans >= all (select count(loan.datetimeout) as loans from catalogentry book;
select columnnames, max(datecolumn) from log  group by columnnames order by 1 desc;
select userid, value from users as user where date = ( select max(date) from users as maxtest where maxtest.userid = user.userid );
create table users (userid int , value int , date datetime) select t1.userid, t1.value, t1.date from users t1, (select max(date) as maxdate, userid from users group by userid) t2 where t1.userid= t2.userid and t1.date = t2.maxdate;
select userid, my_date, ... from ( select userid, my_date, ... from   users ) where my_date = max_my_date;
select thetable.userid, thetable.value from thetable inner join (select userid, max([date]) maxdate from thetable;
select userid, value from users u1 where;
select usertest.userid, usertest.value from usertest ( select userid, max(date) maxdate from usertest and usertest.date = dates.maxdate;
select userid, value, date from table, ( select userid, max(date) as mdate from table group by userid where table.userid = subquery.userid and;
select userid, value, date from thetable t1 , ( select t2.userid, max(t2.date) date2 from thetable t2 where t3.userid t1.userid and;
select t1.userid, (select top 1 t2.value from table t2 where t2.userid = t1.userid order by date desc) as 'value' from table t1 t1.userid t1.userid;
select userid, value from users u where date = (select max(date) from users where userid = u.userid);
create table table_name (id int, the_value varchar(2), the_date datetime);
select id, the_value from table_name u1 where the_date = (select max(the_date) from table_name u2 where u1.id = u2.id);
select userid, max(value) keep (dense_rank first order by date desc) from table;
as ( select userid, value, row_number() over (partition by userid order by date desc) rownum from userdates ) select userid, value from bydate where rownum = 1 as ( select userid, value, rank() over (partition by userid order by date desc) rnk from userdates ) select userid, value from bydate where rnk = 1;
select distinct userid from ( select userid partition by userid from sometable );
select t1.* from mytable t1 where t2.userid is null;
select t1.* from mytable t1 or (t1."date" = t2."date" and t1.id < t2.id)) where t2.userid is null;
where t2.userid is null;
select * from mytable where (user, date) in;
select userid, my_date, ... from ( select @sno:= case when @pid<>userid then 0 else @sno+1 end as serialnumber, @pid:=userid, my_date, ... from   users order by userid, my_date where a.serialnumber=0;
select   userid,max(date) over (partition by userid) value from users;
select userid, to_number(substr(max(to_char(date,'yyyymmdd') || to_char(value)), 9)) as value, max(date) as date from users userid;
select userid,max(adate),(array_agg(value order by adate desc))[1] as value from yourtable;
select userid, max(adate), substr( (listagg(value, ',') within group (order by adate desc)), 0, instr((listagg(value, ',') within group (order by adate desc)), ',')-1 from yourtable;
select distinct  sno,item_name,max(start_date) over(partition by sno),max(end_date) over(partition by sno),max(creation_date)  over(partition by sno), max(last_modified_date)  over(partition by sno) from uniq_select_records;
select userid, value, date from (select userid, value, date, row_number() over (partition by userid order by date desc) rn from users) u where rn = 1;
select * from your_table;
select * from your_table;
select t.userid,t.dt from (select userid,max(dt);
select userid,max(dt) from t_users group by userid;
select a.* from user a inner join (select userid,max(date) as date12 from user1 group by userid) b;
select a.userid,a.values1,b.mm from table_name a,(select userid,max(date1)as mm from table_name group by userid) b where a.userid=b.userid and a.date1=b.mm;
select user_id, value, date , row_number() over (partition by user_id order by date desc) as rn from table_name where rn= 1;
my_database.table1 );
if [ -z "$1" ] ; then if [ -n "${offset}" ]; then else offset=0 if [ "${#str}" -eq "${#1}" ]; then if [ $i != 'performance_schema/' ] ; then if [ "$found" == "" ] ; then;
concat('--ignore-table=', table_schema, '.', table_name) separator ' ' ) from tables where table_type = 'view' and table_schema = 'employees'");
select id,phno,case gender else 'no gender' end as gender from contacts;
select s.stock_code,s.stock_desc,s.stock_desc_ar, mc.category_name,s.sel_price, case when s.allow_discount=0 then 'non promotional item' else 'prmotional from tbl_stock s inner join tbl_stock_category c on s.stock_id=c.stock_id where mc.category_id=2 and s.isserialbased=0;
update table_name set column_name=case then 'update_value' then 'update_value' end;
case expression else resultn end;
case when boolean_expression1 then result1 else resultn end;
select firstname, state=(case statecode else null from dbo.customer select firstname,state=(case else null from dbo.customer;
update customer set statecode = case statecode else null end  update customer set statecode = case else null end;
select * from dbo.customer case gender when 'm' then firstname end desc, case gender when 'f' then lastname end asc select * from dbo.customer case when gender='m' then firstname end desc, case when gender='f' then lastname end asc;
select firstname ,statecode,gender, total=max(payrate) from dbo.customer having (max(case gender when 'm' then payrate else null end) > 180.00 or max(case gender when 'f' then payrate else null end) > 170.00) select firstname ,statecode,gender, total=max(payrate) from dbo.customer having (max(case when gender = 'm' then payrate else null end) > 180.00 or max(case when gender = 'f' then payrate else null end) > 170.00);
select store_name, case store_name else sales end as "new sales", txn_date from store_information;
case productline else 'not for sale';
case when listprice =  0 then 'mfg item - not for resale' else 'over $1000' end;
case when ebv.db_no = 22978 or then 'wecs 9500' else 'wecs 9520' end as wecs_system;
case when ebv.db_no in (22978,23218,23219) then 'wecs 9500' else 'wecs 9520' end;
case when ebv.db_no in (22978, 23218, 23219) then 'wecs 9500' else 'wecs 9520' end as wecs_system;
case ebv.db_no else 'wecs 9520' end as wecs_system;
case when ebv.db_no in (22978, 23218, 23219) then 'wecs 9500' else 'wecs 9520' end as wecs_system;
case when ebv.db_no = 22978 or then 'wecs 9500' else 'wecs 9520' end as wecs_system;
drop database `your_db_name`;
create schema `your_db_name`;
create database new_db;
top 1 with ties;
select top 1 with ties from documentstatuslogs;
select distinct documentid from documentstatuslogs;
select t.doc_id, t.status, t.date_created from ( select a.*, row_number() over (partition by doc_id order by date_created desc) as rnk from doc a where t.rnk = 1;
( select   *, rn = row_number() over (partition by documentid order by datecreated desc) from     documentstatuslogs ) select  id from    cte where   rn = 1;
select  distinct from    documentstatuslogs;
select  distinct from    documentstatuslogs d select  top 1 i.* from    documentstatuslogs i where   i.documentid = d.documentid;
select documentid, status, datecreated from   documentstatuslogs dlogs where  status = (select status from   documentstatuslogs where  documentid = dlogs.documentid limit  1);
select [documentid] from ( select [documentid] from documentstatuslogs;
select o.* from `documentstatuslogs` o where b.documentid is null ;
( select *, row_number() over (partition by documentid order by datecreated desc) as rn from documentstatuslogs ) select * from cte where rn = 1;
select * from select documentid, max(datecreated) datecreated from documentstatuslogs;
select d.documentid, ds.status, ds.datecreated from documents as d from documentstatuslogs where documentid = d.documentid;
select ds.documentid, ds.status, ds.datecreated from documentstatuslogs ds and ds.datecreated < filter.datecreated where filter.documentid is null;
select ds.documentid, ds.status, ds.datecreated from documentstatuslogs ds where ds.id not in ( select filter.id from documentstatuslogs filter where ds.documentid = filter.documentid and ds.datecreated < filter.datecreated);
select where col = (select max(col))           6.6               854.4;
if (object_id('tempdb..#documentstatuslogs') is not null) begin drop table #documentstatuslogs end create table #documentstatuslogs ( [id] int not null, [documentid] int not null, [status] varchar(20), [datecreated] datetime );
select [extent1].[id], [extent1].[documentid], [extent1].[status], [extent1].[datecreated] from #documentstatuslogs as [extent1] select top 1 [extent2].[documentid], [extent2].[status], [extent2].[datecreated] from #documentstatuslogs as [extent2] where [extent1].[documentid] = [extent2].[documentid] where ([project2].[id] is null or [project2].[id] = [extent1].[id]);
select [limit1].[documentid] as [id], [limit1].[documentid] as [documentid], [limit1].[status] as [status], [limit1].[datecreated] as [datecreated] from ( select distinct [extent1].[documentid] as [documentid] from #documentstatuslogs as [extent1] select top (1) [project2].[id] as [id], [project2].[documentid] as [documentid], [project2].[status] as [status], [project2].[datecreated] as [datecreated] from ( select [extent2].[id] as [id], [extent2].[documentid] as [documentid], [extent2].[status] as [status], [extent2].[datecreated] as [datecreated] from #documentstatuslogs as [extent2] where [distinct1].[documentid] = [extent2].[documentid];
select * from documentstatuslogs d1 join ( select documentid,max(datecreated) as maxdate from documentstatuslogs documentid and d2.maxdate=d1.datecreated;
select [limit1].[documentid] as [documentid], [limit1].[status] as [status], [limit1].[datecreated] as [datecreated] from   (select distinct [extent1].[documentid] as [documentid] from [dbo].[documentstatuslogs] as [extent1]) as [distinct1] from (select [extent2].[documentid] as [documentid], [extent2].[status] as [status], [extent2].[datecreated] as [datecreated] from [dbo].[documentstatuslogs] as [extent2] where ([distinct1].[documentid] = [extent2].[documentid]);
select max(datecreated), * from documentstatuslogs;
select * from documentstatuslogs d where datecreated = (select max(datecreated) from documentstatuslogs where id = d.id);
select d.documentid, max(d.status), max(d1.datecreated) from documentstatuslogs d, documentstatuslogs d1;
values 'john', 'mary', 'paul';
('data1', 'data2'), ('data1', 'data2'), ('data1', 'data2');
select 'data1' as 'column1', 'data2' as 'column2' union all select 'data1', 'data2' union all select 'data1', 'data2' union all select 'data1', 'data2';
select 'c' union select 'd' union select 'a' union select 'b';
select avalue as col1,anothervalue as col2 union select morevalue,evenmorevalue;
select 'a','b' union select 'c','d' union ...;
select 'texto','outro' union all select 'mais texto','novo texto';
select 'value1', 'value1' union select 'value2', 'value2' union select 'value3', 'value3';
create table "tblplanner" ("probid" text,"userid" text,"selectedtime" datetime,"plannerid" text,"islocal" bool,"applicationid" text, "comment" text, "subject" text);
[[arr objectatindex:i] objectforkey:@"plannerid"], [[arr objectatindex:i] objectforkey:@"probid"], [[arr objectatindex:i] objectforkey:@"userid"], [[arr objectatindex:i] objectforkey:@"selectedtime"], [[arr objectatindex:i] objectforkey:@"islocal"], [[arr objectatindex:i] objectforkey:@"subject"], [[arr objectatindex:i] objectforkey:@"comment"], [[nsuserdefaults standarduserdefaults] objectforkey:@"applicationid"];
<append 2> <append 3> <append 4> <append 5> <append 6> <append 7> <append 8> <append 9>;
('data3', 'data4'), ('data5', 'data6'), ('data7', 'data8');
union select nextv1+, nextv2+, nextv3+;
create table t_example (qid int not null, primary key (qid));
end transaction;
select rowid,* from t_example;
data2) values      (val1, val2), (val1, val2), (val1, val2), (val1, val2), (val1, val2), (val1, val2), (val1, val2), (val1, val2);
select null as 'column1', 'data1' as 'column2', 'data2' as 'column3' union select null, 'data3', 'data4' union select null, 'data5', 'data6' union select null, 'data7', 'data8';
create table if not exists tab(id int);" select count(*) from tab;
select a.id, b.id from tab a, tab b;
update destination_table dt set my_field1 = ( select my_field1 from source_table st where st.primary_key = dt.primary_key ) select my_field2 from source_table st where st.primary_key = dt.primary_key ) where exists( select st2.primary_key from source_table st2 where st2.primary_key = dt2.primary_key my_field1 ) select st.my_field1 from source_table st where not exists( select dt2.primary_key from destination_table dt2 where dt2.primary_key = st.primary_key;
create table table1( id integer primary key on conflict replace, field1 text;
values (1, 'john foo', 'ceo');
values (1, 'code monkey');
values (  1, 'code monkey', (select name from employee where id = 1);
values (  1, 'susan bar', coalesce((select role from employee where id = 1), 'benchwarmer');
id, name, title, content, author, date_added) select old.id, "about", "about this site", old.content, 42, ifnull(old.date_added,"21/05/2013") from singleton;
not exists(select changes() as change from contact where change <> 0);
drop table if exists contact;
create table [contact] ( [id] integer primary key, [name] text update contact set name = 'bob' where id = 2;
select 2, 'bob' where not exists(select changes() as change from contact where change <> 0);
select * from contact;
drop table if exists contact;
create table [contact] ( [id] integer primary key, [name] text update contact set name = 'bob' where id = 3;
select 3, 'bob' where not exists(select changes() as change from contact where change <> 0);
select * from contact;
select count(*) from table1 where id = 1;
update table1 set col1 = var4, col2 = var5, col3 = var6 where id = 1;
update <table> set <column1>=<value1>, <column2>=<value2>, ... where changes()=0 and <primarykey>=<primarykeyvalue>;
select case changes() when 0 then last_insert_rowid() else <primarykeyvalue> end;
create table page ( id      integer primary key, name    text unique, title   text, content text, author  integer not null references user (id), ts      timestamp default current_timestamp;
select old.id, new.name, new.title, old.content, new.author from new left join page as old on new.name = old.name;
select --this is needed to ensure that the null row comes second from ( select --an existing row from employees where employee_id = '300' union  select --a dummy row if the original cannot be found null as first_name, null as last_name ) employee_id is null --we want nulls to be last limit 1 --we only want one row from this statement ) select --this is where you provide defaults for what you would like to insert 'davis' from registered_employees;
if (index2 == 0) remoteid = value2;
if (typeof columnparts[i] === 'string');
as ( values(100, 'about', 'about this site', 'whatever new content here', 42) ) select old.id, coalesce(old.name, new.name), new.title, new.content, coalesce(old.author, new.author) from new left join page as old on new.name = old.name;
values ("youruuid", "value12", "value2") set column1 = "value1", column2 = "value2";
where somevalue not in (select aval from t);
where somevalue != (select aval from t where id=1) and somevalue != (select aval from t where id=2) and somevalue != (select aval from t where id=3) and somevalue != (select aval from t where id=4);
select x.col from big_table x where x.key in( select key from really_big_table );
select x.col from big_table x where exists( select key from really_big_table where key = x.key);
and id = very_limiting_criteria;
select productid, productname from northwind..products p where od.productid is null;
select * from table1 where col1 not in (select col1 from table2);
select * from table1 t1 where not exists (select col1 from table2 t2 where t1.col1 = t2.col2);
select productid, productname from   products p where  not exists (select * from   [order details] od where  p.productid = od.productid);
select p.productid, p.productname from   products p;
select productid, productname from   products p where  not exists (select * from   [order details] od where  p.productid = od.productid) and not exists (select * from   [order details] where  productid is null);
select productid, productname from   products p where  not exists (select * from   [order details] od where  p.productid = od.productid) and not exists (select * from   [order details] where  productid is null) and not exists (select * from   (select top 1 * from   [order details]) s where  p.productid is null);
where sales.salesorderdetail.productid is null;
select student_grade.student_id from student_grade where student_grade.grade = 10 and student_grade.student_id;
select id, first_name, last_name from student where exists ( select 1 from student_grade where student_grade.student_id = student.id and );
select id, first_name, last_name from student where not exists ( select 1 from student_grade where student_grade.student_id = student.id and );
select  * from mytable order by id offset n row fetch next 1 rows only;
select r.id, r.name from table as r;
as ( select row_number() over(order by id) as selrow, num_value from table ) select * from table where num_value = ( select top 1 num_value from cte_table  where selrow >= rand() * (select max(selrow) from cte_table) );
select column from table limit 1;
select first 1 column from table order by rand();
select max(id) from table;
select id from table where id >= my_generated_random order by id limit 1;
select id from table where id <= my_generated_random order by id desc limit 1;
select top 1 * from [table];
select * from tbl_post as t join ... join ( select id, cast(-2147483648 * random() as integer) as rand from tbl_post where create_time >= 1349928000 where create_time >= 1349928000 and ... limit 100;
set @i = (select floor(rand() * count(*)) from table); prepare get_stmt from 'select * from table limit ?, 1'; execute get_stmt using @i;
select top 10 percent * from table_name;
select top 10 percent * from table_name;
set @seed = year(getdate()) * month(getdate()) /* any other initial seed here */ select top 10 percent * from table_name;
select * from employee sample(1) where rownum=1;
select top 100 * from employee order by crypt_gen_random(10);
select top 100 * from employee order by newid();
select name from random as r1 join from random)) as id) as r2 where r1.id >= r2.id limit 1;
select top 1 * from mytable order by newid();
select * from table order by rand() limit 1;
select top 1 * from mytable order by newid();
select firstname, lastname from contact;
select column from table limit 1;
select column from table limit 1;
select top 1 column from table;
select column, rand() as idx from table;
select column from where rownum = 1;
select * from table order by rand() limit 1;
select * from table where num_value >= rand() *;
select * from sales.salesorderdetail where 0.01 >= cast(checksum(newid(),salesorderid) & 0x7fffffff as float);
set statistics time on set statistics io on select top 1 percent number from numbers select number from numbers select number from numbers where 0.01 >= cast(checksum(newid(), number) & 0x7fffffff as float) set statistics io off set statistics time off;
from generate_series(1,10)) limit 1;
from generate_series(1,10)) union all (select * from cms_refs order by random() limit 1) limit 1;
select * from sales.salesorderdetail where 0.01 >= cast(checksum(newid(), salesorderid) & 0x7fffffff as float);
select top 1 from ( select top(@idx) from dbo.dictionaryabridged with(nolock) word desc word asc;
where num_value >= rand() * (select max(num_value) from table);
select comlumn, rand() as idx from table) select column from table where idx > .5;
select * from mytable where parentid is null union all select m.* from mytable as m join mytree as t on m.parentid = t.id ) select * from mytree;
create table closuretable ( ancestor_id   int not null references flattable(id), descendant_id int not null references flattable(id), primary key (ancestor_id, descendant_id);
(2,2), (2,4), (3,3), (3,5), (4,4), (5,5), (6,6);
select f.* from flattable f join closuretable a on (f.id = a.descendant_id) where a.ancestor_id = 1;
(2,2,0), (2,4,1), (3,3,0), (3,5,1), (4,4,0), (5,5,0), (6,6,0);
select f.* from flattable f join closuretable a on (f.id = a.descendant_id) where a.ancestor_id = 1 and path_length = 1;
select f.name from flattable f join closuretable a on (f.id = a.descendant_id) where a.ancestor_id = 1;
select f.name, group_concat(b.ancestor_id order by b.path_length desc) as breadcrumbs from flattable f join closuretable a on (f.id = a.descendant_id) join closuretable b on (b.descendant_id = a.descendant_id) where a.ancestor_id = 1;
select lpad(' ', (level - 1) * 4) || "name" as "name" from (select * from tmp_node order by "order");
[id] select [node].[id] from [node] where [node].[parentid] = 0 union all select [node].[id] from [node] from [node];
create table tree ( id int  not null, name varchar(32)  not null, parent_id int  null, node_order int  not null, constraint tree_pk primary key (id), constraint tree_tree_fk foreign key (parent_id) (1, 'node 1', 0, 10), (2, 'node 1.1', 1, 10), (3, 'node 2', 0, 20), (4, 'node 1.1.1', 2, 10), (5, 'node 2.1', 3, 10), (6, 'node 1.2', 1, 20);
select id, name, 0, parent_id, 1 from tree where parent_id is null union all select t.id, t.name, ts.level + 1, ts.id, t.node_order from tree t, tree_search ts where t.parent_id = ts.id ) select * from tree_search where level > 0;
create table `node` ( `id` int(10) unsigned not null auto_increment, `name` varchar(255) not null, `tw` int(10) unsigned not null, `pa` int(10) unsigned default null, `sz` int(10) unsigned default null, `nc` int(11) generated always as (tw+sz) stored, primary key (`id`), key `node_tw_index` (`tw`), key `node_pa_index` (`pa`), key `node_nc_index` (`nc`), constraint `node_pa_fk` foreign key (`pa`) references `node` (`tw`) on delete cascade );
select anc.* from node me,node anc where me.tw=22 and anc.nc >= me.tw and anc.tw <= me.tw;
select des.* from node me,node des where me.tw=17 and des.tw < me.nc and des.tw >= me.tw;
update node me, node anc set anc.sz = anc.sz - me.sz from and ((anc.nc >= me.tw and anc.tw < me.pa) or (anc.tw=me.pa));
update node me, node anc set anc.tw = anc.tw - me.sz from;
update node me, node anc set anc.pa = anc.pa - me.sz from;
create function dbo.uf_rounddatetime(@dt as datetime, @part as char) as begin if charindex( @part, 'smhd',0) = 0 return @dt;
case @part end as datetime ) end;
select convert(datetime, floor(convert(float,getdate())));
create function dateonly (  @dt datetime ) as begin end;
select convert(date,getdate());
if (!input.isnull) else return sqldatetime.null;
( cast(year(datefield) as varchar(4)) + '/' cast(mm(datefield) as varchar(2)) + '/' cast(dd(datefield) as varchar(2)) as datetime );
select dateadd(dd, datediff(dd, 0, '2013-12-31 23:59:59.999'), 0);
select cast(convert(char(11), '2013-12-31 23:59:59.999', 113) as datetime);
select cast(cast my_datetime_field as date) as datetime);
select cast(cast(getdate() as date) as datetime);
select convert(datetime,convert(int,convert(float,[modified])));
select convert(datetime,round(convert(float,[modified]),0));
select date_only(dd);
select cast(floor(cast(getdate() as float)) as datetime);
select dateadd(dd, datediff(dd, @datetime2epoch, @datetime2value), @datetime2epoch);
select cast(cast(getutcdate() - 0.50000004 as int) as datetime);
floor( cast( getdate() as float ) ) as datetime );
create view v1 select `a`.`id` as `id`, `a`.`created_date` as `created_date` from t1;
create view v1 select 1 as `id`, 1 as `created_date`;
select name from table2 where name not in from table1);
select * from [dbo].[table1] t1 where t2.[t2_id] is null;
select * from @t1 select a.* from @t1 a join @t2 b on a.id = b.id;
select name from table2 where name not in from table1);
select t1.name from table1 t1 where t2.name is null;
select name from table2 where name not in from table1);
select name from table2 where not exists from table1 where table1.name = table2.name);
select id, name from table1 select id, name from table2;
select * from table1 where from table1 e table2 s on e.id = s.id);
select <column_list> from tablea a where b.key is null;
select temp_table_1.name from original_table_1 temp_table_1 where temp_table_2.name is null;
select o.orderid, --max(o.negotiatedprice, o.suggestedprice) from order o;
select o.orderid from (values (o.negotiatedprice), (o.suggestedprice)) as value(v)) as maxvalue from order o;
select iif(isnull(@a, -2147483648) > isnull(@b, -2147483648), @a, @b);
select  @a = 2, @b = 1 select  iif(isnull(@a, -2147483648) > isnull(@b, -2147483648), @a, @b) select  @a = 2, @b = 3 select  iif(isnull(@a, -2147483648) > isnull(@b, -2147483648), @a, @b) select  @a = 2, @b = null select  iif(isnull(@a, -2147483648) > isnull(@b, -2147483648), @a, @b) select  @a = null, @b = 1 select  iif(isnull(@a, -2147483648) > isnull(@b, -2147483648), @a, @b);
( orderid int primary key identity(1,1), negotiatedprice decimal(10,2), suggestedprice decimal(10,2) (2, 1), (3, null), (null, 4);
select o.orderid, o.negotiatedprice, o.suggestedprice, iif(o.negotiatedprice >= o.suggestedprice, o.negotiatedprice, isnull(o.suggestedprice, o.negotiatedprice)) as maxprice from @order o;
select t.* from sometable t select max(v.col) as [maximum], min(v.col) as [minimum], sum(v.col) as [total], avg(v.col) as [average] from (values (t.col1), (t.col2), (t.col3), (t.col4)) v(col);
create function inlinemax(val1 int, val2 int) returns int as if val1 > val2 then else return val2;
end // select inlinemax(1,2) as test;
select max(v) from (values (1), (2), (3)) as value(v);
select orderid, ( select max([price]) from ( select negotiatedprice [price] union all select suggestedprice;
select o.orderid, case when (o.negotiatedprice > o.suggestedprice or o.suggestedprice is null) then o.negotiatedprice else o.suggestedprice end as maxprice from order o;
select array_max(array[o.negotiatedprice, o.suggestedprice]);
create function inlinemax ( @p1 sql_variant, @p2 sql_variant as begin else @p2 end;
case when a >= b then a else isnull(b,a) end;
select o.orderid, iif( o.negotiatedprice >= o.suggestedprice, o.negotiatedprice, isnull(o.suggestedprice, o.negiatedprice) ) from order o;
select o.orderid, iif( isnull( o.negotiatedprice, 0 ) > isnull( o.suggestedprice, 0 ), o.negotiatedprice, o.suggestedprice ) from order o;
select o.orderid, case when o.negotiatedprice > o.suggestedprice then o.negotiatedprice else o.suggestedprice end from order o;
select case when o.negotiatedprice > o.suggestedprice then o.negotiatedprice else o.suggestedprice end;
select o.orderid case when o.negotiatedprice > o.suggestedprice then else o.suggestedprice end as price;
select orderid, max(price) as price from ( select o.orderid, o.negotiatedprice as price from order o union all select o.orderid, o.suggestedprice as price from order o;
create function dbo.inlinemax(@val1 int, @val2 int) as begin if @val1 > @val2 end;
select o.orderid, dbo.inlinemax(o.negotiatedprice, o.suggestedprice) from order o;
select o.orderid, case when isnull(o.negotiatedprice, o.suggestedprice) > isnull(o.suggestedprice, o.negotiatedprice) then isnull(o.negotiatedprice, o.suggestedprice) else isnull(o.suggestedprice, o.negotiatedprice) end from order o;
create function dbo.higherargumentornull(@val1 int, @val2 int) as begin if @val1 >= @val2 if @val1 < @val2 end;
from (select 1 as value union select 2 as value) as t1);
create function [dbo].[fnmax] (@p1 int, @p2 int) as begin set @p2 = coalesce(@p2, @p1) select @result = ( select case when @p1 > @p2 then @p1 else @p2 end ) end;
create table #t (a int, b int) select 1,2 union all select 3,4 union all select 5,2 select case when a > b then a else b end from #t select a from #t where a >= b union all select b from #t where b > a create function dbo.greatest ( @a as sql_variant, @b as sql_variant ) if @a is null or @b is null return null if @b > @a return @b end  select dbo.greatest(a,b) from #t;
create table #t (id int identity(1,1), a int, b int) select 1,2 union all select 3,4 union all select 5,2 select id, max(val) from #t;
select 0.5 * ((@val1 + @val2) + abs(@val1 - @val2));
( select 1 as orderid, 100 as negotiatedprice, 110 as suggestedprice union all select 2 as orderid, 1000 as negotiatedprice, 50 as suggestedprice ) select o.orderid, (select max(price)from union all select o.suggestedprice) d) as maxprice from  [order]  o;
create function fngreatestint (@int1 int, @int2 int ) as begin if @int1 >= isnull(@int2,@int1) else return @int2 end;
select o.orderid, (select max(price) from (values (o.negotiatedprice),(o.suggestedprice)) as allprices(price)) from order o;
set @a = 'test';
set @var = 1 select @var2 := 2;
create procedure prc_test (var int) set var2 = 1;
create procedure prc_test () set var2 = var2 + 1;
set @var2 = @var2 + 1;
select  var2, @var2;
( select table_id, row_number() over (order by table_id) as rn from table (nolock) ) select t2.field1, t2.field2, t2.field3, t.total from table t2 (nolock) where t.rn >= 100 and t.rn < 200;
create procedure sp_company_list (@pagesize int = -1 ,@pageindex int= 0   ) > as begin  set nocount on;
select  id , nameen     from company  order by id asc;
exec  @return_value = [dbo].[sp_company_list]         @pagesize = 1 ,         > @pageindex = 2 select    'return value' = @return_value;
select salesorderdetailid, salesorderid, productid, row_number() over (order by salesorderdetailid) as rownum from sales.salesorderdetail where 1=1 ) select salesorderdetailid, salesorderid, productid from result where result.rownum between ((@pagenumber-1)*@rowsperpage)+1 and @rowsperpage*(@pagenumber);
select salesorderdetailid, salesorderid, productid from ( select salesorderdetailid, salesorderid, productid, row_number() over (order by salesorderdetailid) as rownum from sales.salesorderdetail where 1=1 where sod.rownum between ((@pagenumber-1)*@rowsperpage)+1 and @rowsperpage*(@pagenumber);
create procedure sp_paging ( @pageno as int, @records as int ) as begin set @offsetcount=(@pageno-1)*@records select id,bs,variable from salary order by id offset @offsetcount rows fetch next @records rows only end;
exec sp_paging 2,3;
create view vw_sppb_part_listsource as select row_number() over (partition by sppb_part.init_id order by sppb_part.sppb_part_id asc ) as idx, * from ( select part.sppb_part_id from t_sppb_init_part part where prev.sppb_part_id is null union select part.sppb_part_id from t_sppb_init_part part;
set @pagenumber = 2 set @rowsppage = 10 select id_example, nm_example, dt_create from tb_example;
select top 20 col2, col3, col4 from ( select tbl.col1 as col1 order by current_timestamp from dbo.mytable tbl where query.sort_row > 10;
create table vlt ( id int identity(1,1), name nvarchar(50), tel varchar(20) ) values ('name' + convert(varchar(10),@@identity),'famil' + convert(varchar(10),@@identity));
select data.id, data.name, data.tel from ( select row_number() case when @sortbyfield = 1 and @sortorder = 'asc' then vlt.id end asc, case when @sortbyfield = 1 and @sortorder = 'desc' then vlt.id end desc, case when @sortbyfield = 2 and @sortorder = 'asc' then vlt.name end asc, case when @sortbyfield = 2 and @sortorder = 'desc' then vlt.name end asc, case when @sortbyfield = 3 and @sortorder = 'asc' then vlt.tel end asc, case when @sortbyfield = 3 and @sortorder = 'desc' then vlt.tel end asc from vlt where ( -- we apply the filter logic here case when @filtertype = 'none' then 1 and ( -- in this case, when the filter value is empty, we want to show everything. or @filtervalue = '' and ( -- in this case, when the filter value is empty, we want to show everything. or @filtervalue = '' and vlt.id = @filtervalue then 1 and vlt.id <> @filtervalue then 1 and ( -- in this case, when the filter value is empty, we want to show everything. or @filtervalue = '' and ( -- in this case, when the filter value is empty, we want to show everything. or @filtervalue = '' and vlt.name = @filtervalue then 1 and vlt.name <> @filtervalue then 1 and ( -- in this case, when the filter value is empty, we want to show everything. or @filtervalue = '' and ( -- in this case, when the filter value is empty, we want to show everything. or @filtervalue = '' and vlt.tel = @filtervalue then 1 and vlt.tel <> @filtervalue then 1 end ) = 1 where data.rownum > @pagesize * (@pagenumber - 1) and data.rownum <= @pagesize * @pagenumber;
as ( select row_number() case when @sortbyfield = 1 and @sortorder = 'asc' then vlt.id end asc, case when @sortbyfield = 1 and @sortorder = 'desc' then vlt.id end desc, case when @sortbyfield = 2 and @sortorder = 'asc' then vlt.name end asc, case when @sortbyfield = 2 and @sortorder = 'desc' then vlt.name end asc, case when @sortbyfield = 3 and @sortorder = 'asc' then vlt.tel end asc, case when @sortbyfield = 3 and @sortorder = 'desc' then vlt.tel end asc from vlt where ( -- we apply the filter logic here case when @filtertype = 'none' then 1 and ( -- in this case, when the filter value is empty, we want to show everything. or @filtervalue = '' and ( -- in this case, when the filter value is empty, we want to show everything. or @filtervalue = '' and vlt.id = @filtervalue then 1 and vlt.id <> @filtervalue then 1 and ( -- in this case, when the filter value is empty, we want to show everything. or @filtervalue = '' and ( -- in this case, when the filter value is empty, we want to show everything. or @filtervalue = '' and vlt.name = @filtervalue then 1 and vlt.name <> @filtervalue then 1 and ( -- in this case, when the filter value is empty, we want to show everything. or @filtervalue = '' and ( -- in this case, when the filter value is empty, we want to show everything. or @filtervalue = '' and vlt.tel = @filtervalue then 1 and vlt.tel <> @filtervalue then 1 end ) = 1 ) select data.id, data.name, data.tel from data_cte as data where data.rownum > @pagesize * (@pagenumber - 1) and data.rownum <= @pagesize * @pagenumber;
as ( select * from vlt where ( -- we apply the filter logic here case when @filtertype = 'none' then 1 and ( -- in this case, when the filter value is empty, we want to show everything. or @filtervalue = '' and ( -- in this case, when the filter value is empty, we want to show everything. or @filtervalue = '' and vlt.id = @filtervalue then 1 and vlt.id <> @filtervalue then 1 and ( -- in this case, when the filter value is empty, we want to show everything. or @filtervalue = '' and ( -- in this case, when the filter value is empty, we want to show everything. or @filtervalue = '' and vlt.name = @filtervalue then 1 and vlt.name <> @filtervalue then 1 and ( -- in this case, when the filter value is empty, we want to show everything. or @filtervalue = '' and ( -- in this case, when the filter value is empty, we want to show everything. or @filtervalue = '' and vlt.tel = @filtervalue then 1 and vlt.tel <> @filtervalue then 1 end ) = 1 ) select data.id, data.name, data.tel from data_cte as data case when @sortbyfield = 1 and @sortorder = 'asc' then data.id end asc, case when @sortbyfield = 1 and @sortorder = 'desc' then data.id end desc, case when @sortbyfield = 2 and @sortorder = 'asc' then data.name end asc, case when @sortbyfield = 2 and @sortorder = 'desc' then data.name end asc, case when @sortbyfield = 3 and @sortorder = 'asc' then data.tel end asc, case when @sortbyfield = 3 and @sortorder = 'desc' then data.tel end asc;
select * from tablename order by id offset 10 rows fetch next 10 rows only;
( select row_number() over(order by firstname desc) as rownumber, firstname, lastname, round(salesytd,2,1) as "sales ytd" from [dbo].[vsalesperson] ) select rownumber, firstname, lastname, sales ytd from orderedorders where rownumber > 50 and rownumber < 60;
select top 10 first_name, last_name, score, count(*) over() from players where (score < @previousscore) or (score = @previousscore and player_id < @previousplayerid);
select top @offset a.* from (select top @limit b.*, count(*) over() totalrows from tablename b order by id asc) a;
select * from orders where orderdate >= '1980-01-01' order by orderdate;
select count(*) from orders where orderdate >= '1980-01-01';
select  * from    ( select    row_number() over ( order by orderdate ) as rownum, * from      orders where     orderdate >= '1980-01-01' where   rownum >= 1 and rownum < 20;
alter procedure [dbo].[re_listingreports_selectsummary] @pagenumber     int, @pagesize   int, @sort       varchar(200) as  set @pagenumber = 1 set @strpagesize = cast(@pagesize as varchar(20)) set @strskippedrows = cast(((@pagenumber - 1) * @pagesize) as varchar(20))-- for    example if pagenumber is 5  pagesize is 10, then skippedrows = 40. set @strid = 'listingdbid' set @strfields = 'listingdbid, listingid, [extraroom] set @strfrom = ' vwlistingsummary ' set @strfilter = ' where end set @sortby = '' set @sortby = ' order by ' + @sort set @sql =  'select count(' + @strid + ')  from ' + @strfrom + @strfilter exec sp_executesql @sql set @sql = 'select ' + @strfields + ' from ' + @strfrom + exec sp_executesql @sql;
set @pageno = 51 set @pagesize = 20 set @firstrecord = (@pageno - 1) * @pagesize + 1 -- 1001 set @lastrecord = @firstrecord + @pagesize - 1   -- 1020 rownum int identity not null primary key clustered, tablekey int not null ) set rowcount @lastrecord set rowcount 0 select t.* from orders t where o.rownum >= @firstrecord;
if patindex('%|%', @products) > 0 set @individual = substring(@products, 0, patindex('%|%', @products)) select @individual set @products = substring(@products, len(@individual + '|') + 1, len(@products)) end else begin set @individual = @products set @products = null select @individual end end;
( accountingcycle varchar(10) ) set @vchaccountingcycleids = ltrim(rtrim(@vchaccountingcycleids)) + ',' set @intposition = charindex(',', @vchaccountingcycleids, 1) if replace(@vchaccountingcycleids, ',', '') <> '' set @vchaccountingcycle = ltrim(rtrim(left(@vchaccountingcycleids, @intposition - 1))) if @vchaccountingcycle <> '' end set @vchaccountingcycleids = right(@vchaccountingcycleids, len(@vchaccountingcycleids) - @intposition) set @intposition = charindex(',', @vchaccountingcycleids, 1) end end;
create function splitstring ( -- add the parameters for the function here @deliminator varchar(10) ) ( -- add the column definitions for the table variable here [part] [varchar](50) null ) as begin select @ispaces = charindex(@deliminator,@mystring,0) select @part = substring(@mystring,0,charindex(@deliminator,@mystring,0)) select @part select @mystring = substring(@mystring,charindex(@deliminator,@mystring,0)+ len(@deliminator),len(@mystring) - charindex(' ',@mystring,0)) select @ispaces = charindex(@deliminator,@mystring,0) end  if len(@mystring) > 0 select @mystring end go;
select * from splitstring('hello john smith',' ');
select * from splitstring('hello**john**smith','**');
create function [splitwordlist] ( @list varchar(8000) ) ( word varchar(50) not null, position int identity(1,1) not null ) as begin @lpos int, @item varchar(100), @ignore varchar(100), @dl int, @a1 int, @a2 int, @z1 int, @z2 int, @n1 int, @n2 int, @c varchar(1), @a smallint select @a1 = ascii('a'), @a2 = ascii('a'), @z1 = ascii('z'), @z2 = ascii('z'), @n1 = ascii('0'), @n2 = ascii('9') set @ignore = '''"' set @pos = 1 set @dl = datalength(@list) set @lpos = 1 set @item = '' set @c = substring(@list, @pos, 1) if (@ignore not like '%' + @c + '%') begin set @a = ascii(@c) if ((@a >= @a1) and (@a <= @z1)) or ((@a >= @a2) and (@a <= @z2)) or ((@a >= @n1) and (@a <= @n2)) set @item = @item + @c end else if (@item > '') begin set @item = '' end end set @pos = @pos + 1 end if (@item > '') begin end return end;
select * from splitwordlist('hello john smith');
select parsename(replace('hello john smith', ' ', '.'), 2);
select parsename(replace('hello john smith', ' ', '.'), 3)  --return hello;
create function dbo.splitstring ( @str nvarchar(4000), @separator char(1) ) as return ( with tokens(p, a, b) as ( select 1, 1, charindex(@separator, @str) union all select p + 1, b + 1, charindex(@separator, @str, b + 1) from tokens where b > 0 ) select p-1 zerobasedoccurance, substring( @str, a, case when b > 0 then b-a else 4000 end) as s from tokens );
select s from dbo.splitstring('hello john smith', ' ') where zerobasedoccurance=1;
create function dbo.splitstring ( @str nvarchar(max), @separator char(1) ) as return ( with tokens(p, a, b) as ( select cast(1 as bigint), cast(1 as bigint), charindex(@separator, @str) union all select p + 1, b + 1, charindex(@separator, @str, b + 1) from tokens where b > 0 ) select p-1 itemindex, substring( @str, a, case when b > 0 then b-a else len(@str) end) as s from tokens;
create table dbo.numbers (n int primary key);
select top 1000 row_number() over(order by number) from master..spt_values;
create table #yak (i int identity(1,1) primary key, array varchar(50)) select 'a,b,c' from dbo.numbers n cross join dbo.numbers nn;
create function [dbo].[ufn_parsearray] @delimiter  char(1) = ',', @baseident  int ) substring(@input, n, charindex(@delimiter, @input + @delimiter, n) - n) s from    dbo.numbers where   n <= convert(int, len(@input)) and );
select * from #yak;
drop table dbo.numbers;
drop function  [dbo].[ufn_parsearray];
select * from dbo.split('ram shyam hari gopal',' ');
set ansi_nulls on set quoted_identifier on create function [dbo].[split](@string varchar(8000), @delimiter char(1)) as begin select @idx = 1 if len(@string)<1 or @string is null  return set @idx = charindex(@delimiter,@string) if @idx!=0 set @slice = left(@string,@idx - 1) else set @slice = @string set @string = right(@string,len(@string) - @idx) if len(@string) = 0 break end return end;
if (!s.tolower().equals("or") && !s.tolower().equals("and")) {;
select substring(column_name,1,charindex(' ',column_name,1)-1) from table_name;
create function [dbo].[split]( @delimited nvarchar(max), @delimiter nvarchar(100) as begin set @xml = n'<t>' + replace(@delimited,@delimiter,'</t><t>') + '</t>' select  r.value('.','varchar(max)') as item from  @xml.nodes('/t') as records(r) end;
select * from dbo.split('hello john smith',' ');
set @str = 'hello john smith' set @separator = ' ' set @str = replace(@str, @separator, '''),(''') set @str = 'select * from (values(''' + @str + ''')) as v(a)' select * from @splited;
create function dbo.splitstrings_cte(@list nvarchar(max), @delimiter nvarchar(1)) as begin ( select substring(@list, 0, charindex(@delimiter,  @list + @delimiter)) as val, cast(stuff(@list + @delimiter, 1, charindex(@delimiter, @list + @delimiter), '') as nvarchar(max)) as stval, 1 as [level] union all select substring(stval, 0, charindex(@delimiter, stval)), cast(stuff(stval, 1, charindex(@delimiter, stval), '') as nvarchar(max)), [level] + 1 from cte where stval != '' ) select replace(val, ' ','' ) as val, [level] from cte where val > '' end;
if object_id(n'dbo.ufn_getinttablefromdelimitedlist', n'tf') is not null drop function dbo.[ufn_getinttablefromdelimitedlist];
create function dbo.[ufn_getinttablefromdelimitedlist](@string nvarchar(max),                 @delimiter char(1)) ( value int not null ) as begin set @pattern = '%' + @delimiter + '%' if patindex(@pattern, @string) > 0 set @value = substring(@string, 0, patindex(@pattern, @string)) set @string = substring(@string, len(@value + @delimiter) + 1, len(@string)) end else begin end end  end go;
select * from dbo.[ufn_getinttablefromdelimitedlist]('1,20,3,343,44,6,8765', ',');
select [id], [firstname] from [user] u join dbo.[ufn_getinttablefromdelimitedlist]('1,20,3,343,44,6,8765', ',') t on u.[id] = t.[value];
( value nvarchar(max) not null );
set @str = 'hello john smith how are you' set @separator = ' ' set @str = replace(@str, @separator, ''' union all select ''') set @str = ' select  ''' + @str + '''  ' select * from @splited;
alter function dbo.fn_split ( @expression nvarchar(max), @delimiter  nvarchar(20) = ',', @qualifier  char(1) = null ) as begin select * from dbo.fn_split('apple pear grape banana orange honeydew cantalope 3 2 1 4', ' ', null) select * from dbo.fn_split('1,abc,"doe, john",4', ',', '"') select * from dbo.fn_split('hello 0,"&""&&&&', ',', '"') @temp  nvarchar(max), @temp2 nvarchar(max), @start int, @end   int select @expression = (select @expression for xml path('')) select -- starting character position of @qualifier -- @expression starting at the @start position -- next position of @qualifier within @expression -- the part of expression found between the @qualifiers -- new @expression @qualifier + @temp2 + case when @end < 0 then '' else @qualifier end, replace(@temp2, @delimiter, '|||***|||') ) end  set @x = cast('<fn_split>' + select "value" = ltrim(rtrim(replace(c.value('.', 'nvarchar(max)'), '|||***|||', @delimiter))) from @x.nodes('fn_split') as x(c) end;
create function [dbo].[splitstring] ( @list nvarchar(max), @delim varchar(255) ) as return ( select [value], idx = rank() over (order by n) from ( select n = number, [value] = ltrim(rtrim(substring(@list, [number], charindex(@delim, @list + @delim, [number]) - [number]))) from (select number = row_number() over (order by name) from sys.all_objects) as x where number <= len(@list) and substring(@delim + @list, [number], len(@delim)) = @delim;
select value from dbo.splitstring('foo,bar,blat,foo,splunge',',') where idx = 3;
create table course( courses varchar(100) );
cast( substring( courses, charindex( ' ' , courses) + 1 , len(courses ) ) + ' ' as varchar(100) )  as a_r, courses as a, 0 as n from course t union all select left(a_r, charindex( ' ' , a_r) ) as a_l, substring( a_r, charindex( ' ' , a_r) + 1 , len(a_r ) ) as a_r, cte.a, cte.n + 1 as n from course t inner join cte ) select a_l, n from cte;
create function [dbo].[udf_splitparseout] ( @list nvarchar(max), @spliton nvarchar(5), @getindex smallint ) as  (  value nvarchar(max) ) select value = ltrim(rtrim(substring(@list,1,charindex(@spliton,@list)-1))) set @list = substring(@list,charindex(@spliton,@list)+len(@spliton),len(@list)) end  select value = ltrim(rtrim(@list)) select @result = value from @rtnvalue where id = @getindex end;
alter function [dbo].[split]( @text nvarchar(200),@splitor char(1) ) as begin set @text+=@splitor set @pathind=patindex('%'+@splitor+'%',@text) set @text= substring(@text, @pathind+1, len(@text)) end return end;
select * from [utility].[split_string](n'"this"."string"."gets"."split"."and"."removes"."leading"."and"."trailing"."quotes"', n'"."', n'"', n'"');
select * from [utility].[split_string](n'"this"."string"."gets"."split"."but"."leaves"."leading"."and"."trailing"."quotes"', n'"."', null, null);
select * from [utility].[split_string](n'[netbios_name].[machine_name].[instance].[database].[schema].[table].[column]', n'].[', n'[', n']');
create function [utility].[split_string] ( @input       [nvarchar](max) [index]  [int] set @input = right(@input, len(@input) - @lead_length);
set @input = left(@input, len(@input) - @lag_length);
as (select cast(@separator_length as [bigint]) union all select [index] + 1 from   [splitter] where  [start_location] > 0) select [index] - @separator_length                   as [index] then [start_location] - [starting_position] else len(@input) from   [splitter];
set nocount on set @splitendpos = charindex(@splitdelim, @stringtosplit, @splitstartpos) set @splitvalue = substring(@stringtosplit, @splitstartpos, (@splitendpos - @splitstartpos)) set @splitstartpos = @splitendpos + 1 set @splitendpos = charindex(@splitdelim, @stringtosplit, @splitstartpos) end  set @splitvalue = substring(@stringtosplit, @splitstartpos, 2147483647) set nocount off;
select source         = q.value('(/n[1])', 'varchar(10)'), recordtype     = q.value('(/n[2])', 'varchar(20)'), recordnumber   = q.value('(/n[3])', 'int'), status         = q.value('(/n[4])', 'varchar(5)') from   ( select   q = convert(xml,'<n>'+replace(fieldname,'.','</n><n>')+'</n>') from     some_table;
select id, [3] as pathprovidingid, [4] as pathprovider, [5] as componentprovidingid, [6] as componentproviding, [7] as inputrecievingid, [8] as inputrecieving, [9] as rowspassed, [10] as inputrecieving2 from ( select id,message,d.* from sysssislog cross apply       ( select item = y.i.value('(./text())[1]', 'varchar(200)'), row_number() over(order by y.i) as rn from ( select x = convert(xml, '<i>' + replace(message, ':', '</i><i>') + '</i>').query('.') where event;
select id, tokens.value('(/n[3])', 'varchar(100)')as pathprovidingid, tokens.value('(/n[4])', 'varchar(100)') as pathprovider, tokens.value('(/n[5])', 'varchar(100)') as componentprovidingid, tokens.value('(/n[6])', 'varchar(100)') as componentproviding, tokens.value('(/n[7])', 'varchar(100)') as inputrecievingid, tokens.value('(/n[8])', 'varchar(100)') as inputrecieving, tokens.value('(/n[9])', 'varchar(100)') as rowspassed from ( select id, convert(xml,'<n>'+replace(message,'.','</n><n>')+'</n>') tokens from sysssislog where event;
create function [dbo].[fnsplitstring] ( @string nvarchar(max), @delimiter char(1) ) ) select @start = 1, @end = charindex(@delimiter, @string) if @end = 0 set @end = len(@string) + 1 set @start = @end + 1 set @end = charindex(@delimiter, @string, @start) end return end;
select *from dbo.fnsplitstring('querying sql server','');
create function [dbo].[splitstringtoresultset] (@value varchar(max), @separator char(1)) as return select value, cast(null as varchar(max)) [x], -1 [no] from (select rtrim(cast(@value as varchar(max))) [value]) as j union all select right(value, len(value)-case charindex(@separator, value) when 0 then len(value) else charindex(@separator, value) end) [value] from r where value > '') select ltrim(x) [value], [no] [index] from r where x is not null;
select * from [dbo].[splitstringtoresultset]('hello john smith', ' ') where [index] = 1;
create function [dbo].[splitstringsep] ( @str nvarchar(4000), @separator char(1) ) as return ( with tokens(p, a, b) as ( select 1, 1, charindex(@separator, @str) union all select p + 1, b + 1, charindex(@separator, @str, b + 1) from tokens where b > 0 ) select p-1 zerobasedoccurance, substring( @str, a, case when b > 0 then b-a else 4000 end) as s from tokens );
set @item = left(@x,charindex(@splitter,@x)) set @x    = right(@x,len(@x)-len(@item) ) select @item as item, @x as x;
set @bla = 'bed40dfc-f468-46dd-8017-00ef2fa3e4a4,64b59fc5-3f4d-4b0e-9a48-01f3d4f220b0,a611a108-97ca-42f3-a2e1-057165339719,e72d95ea-578f-45fc-88e5-075f66fd726c' select x.xmlcol.value('.', 'varchar(36)') as val from ( select cast('<e>' + replace(@bla, ',', '</e><e>') + '</e>' as xml) as rawxml;
set @bla = '<html>unsafe & safe utf8charsdon''tgetencoded  - "conex"<html>,barnes & noble,abc,def,ghi' select x.xmlcol.value('.', 'nvarchar(max)') as val from ( select cast('<e>' + replace((select @bla for xml path('')), ',', '</e><e>') + '</e>' as xml) as rawxml;
create function getstringpartbydelimeter ( @value as nvarchar(max), @delimeter as nvarchar(max), @position as int as begin set @endpos = -1 set @startpos = @endpos + 1 set @endpos = charindex(@delimeter, @value, @startpos) set @endpos = len(@value) + 1 end  set @position = @position - 1 end  end;
select dbo.getstringpartbydelimeter ('a;b;c;d;e', ';', 3);
select cast(n'<x>' + replace(@input,n' ',n'</x><x>') + n'</x>' as xml).value('/x[2]','nvarchar(max)');
select cast(n'<x>' + replace(@input,@dlmt,n'</x><x>') + n'</x>' as xml).value('/x[sql:variable("@pos")][1]','nvarchar(max)');
set @input=n'some <, > and &;other @;one more';
select cast(n'<x>' + replace((select replace(@input,@dlmt,'#dlmt#') as [*] for xml path('')),n'#dlmt#',n'</x><x>') + n'</x>' as xml).value('/x[sql:variable("@pos")][1]','nvarchar(max)');
select json_value('["' + replace(@str,' ','","') + '"]',concat('$[',@position-1,']'));
select  jsonarray.[key] as [position] from openjson('["' + replace(@str,' ','","') + '"]') jsonarray;
select @somedelimitedstring          as theoriginal from openjson(@jsonarray);
select ( substring( @strng, charindex(' ', @strng) + 1, ( (charindex(' ', @strng, charindex(' ', @strng) + 1)) );
select reverse( substring( reverse_substring, 0, charindex(';', reverse_substring) ) ) from ( select msg, substring( reverse(msg), charindex( ';', reverse(msg), charindex( ';', reverse(msg) 1000 from ( select 'first;second;third;fourth;fifth' msg;
select value from string_split(@string, ',');
select row_number() over (order by value) as rownr, value from string_split(@string, ' ');
create function [dbo].[splitstring] ( @list nvarchar(max), @delim varchar(255) ) as return ( select [value] from ( select [value] = ltrim(rtrim(substring(@list, [number], charindex(@delim, @list + @delim, [number]) - [number]))) from (select number = row_number() over (order by name) from sys.all_objects) as x where number <= len(@list) and substring(@delim + @list, [number], len(@delim+'x')-1) = @delim;
select value from string_split('hello john smith',' ');
select compatibility_level from sys.databases where name = 'yourdbname';
create function [dbo].[splitstring] ( @list       varchar(max), @delimiter  varchar(255), @elementnumber int ) as begin set @inp = (select replace(@list,@delimiter,'_delmtr_') for xml path('')) set @xml = '<split><el>' + replace(@inp,'_delmtr_','</el><el>') + '</el></split>' set @ret = (select from  @xml.nodes('/split/el[string-length(.)>0][position() = sql:variable("@elementnumber")]') split(el)) end;
select dbo.splitstring('hello john smith', ' ', 2);
select substring(@name, 0, (select charindex(' ', @name))) select substring(@name, (select charindex(' ', @name)) + 1, len(@name));
select substring(fullname, 0, (select charindex(' ', fullname))) as firstname, substring(fullname, (select charindex(' ', fullname)) + 1, len(fullname)) as lastname, from fullnametable;
select substring( substring('hello john smith' ,0,charindex(' ','hello john smith',charindex(' ','hello john smith')+1) );
set @samplestring = '[' + replace(@samplestring, ' ', '","') + ']';
select json_value(@samplestring, '$[0]') as element1value, json_value(@samplestring, '$[1]') as element2value, json_value(@samplestring, '$[2]') as element3value;
select row_number() over (order by r.[index]) [index], r.[value] from ( select 1 [index], nullif(trim([value]), '') [value] from string_split(@string_value, ',') t where nullif(trim([value]), '') is not null;
select dbo.splitandreturnnth('hello john smith',' ',2);
set identity_insert sometablewithidentity on values (anidentityvalue, col2value, col3value, ...) set identity_insert sometablewithidentity off;
select (field1,...) from table;
set identity_insert sometablewithidentity on values (anidentityvalue, col2value, col3value, ...) set identity_insert sometablewithidentity off;
set identity_insert database.dbo.baskets on;
set identity_insert ... on;
set identity_insert ... on;
set identity_insert ... on;
select column from table limit 10;
drop temporary table if exists rands;
create temporary table rands ( rand_id int );
if cnt < 1 then end if;
select r1.id from random as r1 join from random)) as id) as r2 where r1.id >= r2.id limit 1;
set cnt = cnt - 1;
end loop loop_me;
drop temporary table if exists rands;
create temporary table rands ( rand_id int );
if cnt < 1 then end if;
set @no_gaps_id := 0;
select r1.id from (select id, @no_gaps_id := @no_gaps_id + 1 as no_gaps_id from random) as r1 join from random)) as id) as r2 where r1.no_gaps_id >= r2.id limit 1;
set cnt = cnt - 1;
end loop loop_me;
select id, id * rand( ) as random_no, first_name, last_name from user;
select * from table_with_600k_rows where rand() < 10/600000 limit 10;
select * from random, ( select id as sid from random limit 10 where random.id = tmp.sid;
drop temporary table if exists tmp_randorder;
create table tmp_randorder (id int(11) not null auto_increment primary key, data_id int(11));
select dt.* from (select (rand() * from tmp_randorder)) as id) as rnd limit 1;
select l.* from datatable l limit 1;
select name from random as r1 join from random)) as id) as r2 where r1.id >= r2.id limit 1;
select * from table where key >= floor(rand()*max(id)) limit 1;
else $id_in="$id";
select * from tbl as t1 join (select id from tbl order by rand() limit 10) as t2 on t1.id=t2.id;
select * from table where id % (select count(1) from table);
select * from table where id % (select count(1) from table) limit 10000;
select floor(rand() * @max) + 1 as rand);
select id from table inner join (...) on id > rand limit 1;
select t.id, t.name -- etc, etc from table t (select id from table inner join (select floor(rand() * @max := (select max(id) from table)) + 1 as rand) r on id > rand limit 1) union;
set @count = (select from `table_name`);
select * from table_name order by rand() limit 0,10;
select d.* from ( select  t.*,  @rownum := @rownum + 1 as rank from mytable as t, (select @rownum := 0) as r, (select @cnt := (select rand() * (select count(*) from mytable))) as n;
select * from ( select d.* from ( select  c.*,  @rownum := @rownum + 1 as rank from buildbrain.`commits` as c, (select @rownum := 0) as r, (select @cnt := (select rand() * (select count(*) from buildbrain.`commits`))) as rnd where rank >= @cnt limit 10000;
select group_concat(n separator ',') g from ( select floor(rand() * ( select id from tbl order by id desc limit 1 select * from tbl where id in ($result);
select max(id) from table_name;
select * from table_name where id > floor(rand() * max) limit n;
drop procedure if exists `random_rows` $$ create procedure `random_rows`(in tab_name varchar(64), in num_rows int) set @t = concat('set @max=(select max(id) from ',tab_name,')');
set @t = concat( 'select * from ', tab_name, ' where id>floor(rand()*@max) limit ', num_rows);
select floor(rand() * (select max(key) from table)) from table limit 10;
select user_firstname , count(distinct usr_fk_id) cnt from userdetails limit 10;
select * from `table_name` where id >= (select floor( max(id) * rand()) from `table_name` ) order by id limit 30;
select * from `table_name` where 1 order by rand() limit 30;
select name from random as r1 join from random)) as id) as r2 where r1.id >= r2.id limit 30;
set @total = (select count(*) from table);
set @_offset = floor(rand() * @total);
set @total = (select count(*) from table where available=true);
set @_offset = floor(rand() * @total);
set @rows_count = 10;
set @total = (select count(*) from table where available=true);
set @_offset = floor(rand() * @total);
set @_offset = (select if(@total-@_offset<@rows_count,@_offset-@rows_count,@_offset));
set @_offset = (select if(@_offset<0,0,@_offset));
select from tbl where random_number >= :random limit 1;
select count(*) as rows from table;
select * from table limit 1 offset a_i;
select * from t where rand() < (select 10 / count(*) from t);
where rand() < 0.1;
update tablename set field_name = replace(field_name , 'oldstring', 'newstring') where field_name like ('oldstring%');
update dbo.[table_name] set column_name= replace(column_name, 'old_value', 'new_value') where column_name like %condition%;
update dbo.xxx set value=replace(value,'123\','') where id in(1, 2, 3, 4) update dbo.xxx set value=replace(value,'123\','') where id <= 4;
update dbo.xxx set value = replace(value, '123', '') where id <=4;
update dbo.xxx set value = replace(value, '123', '') where id <=4;
update dbo.xxx set value = replace(cast(value as nvarchar(4000)), '123', '') where id <=4;
update dbo.xxx set value = replace(value, '123', '') where id <= 4 and value like '%123%';
update products set code = replace(code, '32-', '14-') where ...(put your where statement in here);
create table tbl_personaldetail (n'31-3-2015', n'monay', 2), (n'28-12-2015', n'monay', 2), (n'19-4-2015', n'monay', 2) set @date = (select [date] from tbl_personaldetail where id = 2) update tbl_personaldetail set [date] = (replace(@date , '-','/')) where id = 2;
update table_name set field_name = '0' where field_name is null;
set global sql_mode=(select replace(@@sql_mode,'only_full_group_by',''));
select count(*) as cnt, `regions_id` from regionables where `regionable_id` = '115' or `regionable_id` = '714' having cnt > 1;
select * from `users` group by `name`;
select `name` from `users` group by `name`;
select any_value(`id`), any_value(`email`), `name` from `users` group by `name`;
select `age`, count(`age`) from `users` group by `age`;
select g.group_id as 'value', g.group_name as 'text' from mod_users_groups g where g.active = 1 and g.department_id = 1 and g.manage_work_orders = 1 and g.group_name != 'root' and g.group_name != 'superuser' g.group_name, g.group_id having count(d.user_id) > 0;
select name,           address , max(age) from t group by name; -- fails select name, any_value(address), max(age) from t group by name; -- works;
select name, address, max(age) from t group by name;
select name, any_value(address), max(age) from t group by name;
select count(*) as attempts, sum(elapsed) as elapsedtotal, userid, timestamp, questionid, answerid, sum(correct) as correct, elapsed, ipaddress from `gameplay` where timestamp >= date_sub(now(), interval 1 day) and cookieid = #;
if (date == null) {;
 ,                                         // specify the ordinal number of which argument in sql statement. );
java.util.date javadate) { if (javadate != null) {;
create table test ( id int identity(1,1), somecolumn varchar(10) create table test2 ( id int not null, somecolumn varchar(10) alter table test switch to test2;
drop table test;
exec sp_rename 'test2','test';
select * from test;
alter table...switch;
alter table (yourtable) add newcolumn int identity(1,1) alter table (yourtable) drop column oldcolumnname exec sp_rename 'yourtable.newcolumn', 'oldcolumnname', 'column';
alter table footable add barcolumn int identity(1, 1) not null primary key clustered;
create table dbo.tmp_names ( id int not null name varchar(50) null ) set identity_insert dbo.tmp_names on if exists ( select  * from    dbo.names ) select  id, name from    dbo.names tablockx set identity_insert dbo.tmp_names off drop table dbo.names exec sp_rename 'tmp_names', 'names';
alter table names add id_new int identity(1, 1) alter table names drop column id exec sp_rename 'names.id_new', 'id', 'column';
set quoted_identifier on set transaction isolation level serializable set arithabort on set numeric_roundabort off set concat_null_yields_null on set ansi_nulls on set ansi_padding on set ansi_warnings on create table dbo.tmp_user ( userid int not null identity (1, 1), lastname varchar(50) not null, firstname varchar(50) not null, middleinitial char(1) null set identity_insert dbo.tmp_user on if exists(select * from dbo.[user]) select userid, lastname, firstname, middleinitialfrom dbo.[user] tablockx') set identity_insert dbo.tmp_user off drop table dbo.[user] alter table dbo.[user] add constraint ( userid;
exec sp_help 'dbo.table_name_old';
set identity_insert dbo.table_name on;
( field1, field2, etc... ) select field1, field2, etc... from dbo.table_name_old;
select * from dbo.table_name_new;
set identity_insert toyrecp.toyawards.lkpfile_new off;
select f.name as foreignkey, object_name(f.parent_object_id) as tablename, col_name(fc.parent_object_id, fc.parent_column_id) as columnname, object_name (f.referenced_object_id) as referencetablename, col_name(fc.referenced_object_id, fc.referenced_column_id) as referencecolumnname from sys.foreign_keys as f;
alter table [dbo].[table_name] drop constraint [name_of_fk];
drop table dbo.table_name_old;
exec sp_rename '[schema_name.oldtablename]' , '[newtablename]';
alter table [yourtablename] add constraint [columntosetasprimarykey] primary key ([columntosetasprimarykey]);
exec sp_rename 'adminusers.userid' , 'olduserid', 'column';
alter table tablename add old_columnname int not null primary key identity(1,1);
alter table users add userid int not null primary key identity(1,1);
alter table table_name drop column renamed_columnname;
alter table users drop column olduserid;
@table_schema nvarchar(max);
select t.name, s.name from sys.schemas as s where exists ( select [c].[name] from sys.columns [c] join sys.types [y] on [y].system_type_id = [c].system_type_id where [c].[object_id] = [t].[object_id] and [y].name = 'bigint' and [c].[column_id] = 1 ( select 1 from sys.identity_columns where [object_id] = t.[object_id] select 1 from sys.indexes as [i] where object_name([ic].[object_id]) = [t].[name] ) delete from @sql @pkcol nvarchar(100) select  top 1 @pkcol = col_name(ic.object_id,ic.column_id) from    sys.indexes as [i] where   i.is_primary_key = 1 and object_name(ic.object_id) = @table_name set @q = replace(@q, 'select', 'select top 1 @output = ') exec sp_executesql @q, n'@output bigint output', @ident_seed output select '  ['+[c].[name]+'] ' + else '' end) case when [c].name = @pkcol then 'identity(' +coalesce(@ident_seed, '1')+',1)' else '' end + ' ' + replace( replace( ltrim( rtrim( replace( replace( replace( replace( ltrim( rtrim( replace( replace( object_definition([c].default_object_id) ) ) ) ) case when object_definition([c].default_object_id) like '%get%date%' then '()' else '' end from sys.columns c join sys.types y on y.system_type_id = c.system_type_id where object_name(c.[object_id]) = @table_name and [y].name != 'sysname' update @sql set s=left(s,len(s)-1) where id=@@identity select @cols = stuff( ( select ',['+c.name+']' from sys.columns c join sys.types y on y.system_type_id = c.system_type_id where c.[object_id] = object_id(@table_name) and [y].name != 'sysname' and [y].name != 'timestamp' ) if ( @pkname is not null ) begin select '  ['+column_name+'] asc,' from information_schema.key_column_usage where constraint_name = @pkname update @sql set s=left(s,len(s)-1) where id=@@identity end  select @fqry = (select char(10) + s from @sql order by id for xml path ('')) select @table_name as [table_name], @fqry as [generated_query] exec sp_executesql @fqry end close vendor_cursor;
create sequence  sequence_name start with here_higher_number_than_max_existed_value_in_column increment by 1;
alter table table_name add constraint constraint_name default next value for sequence_name for column_name;
alter table dbo.tblproductpricelist drop column id alter table dbo.tblproductpricelist add id int identity(1,1) if  not exists (select * from sys.key_constraints  where object_id = object_id(n'[dbo].[pk_tblproductpricelist]') and parent_object_id = object_id(n'[dbo].[tblproductpricelist]')) alter table [tblproductpricelist] add primary key (id);
create index index_name on table_name(column);
create unique index index_name on table_name(column);
select * from customers where exists ( select * from orders where orders.customerid = customers.id );
select * from customers where id in ( select customerid from orders );
select customers.* from customers;
select * from orders o where exists ( select * from products p where p.productnumber = o.productnumber);
select * from orders where productnumber in (1, 10, 100);
select * from orders where productnumber in ( select productnumber from products where productinventoryquantity > 0);
select count(*) from [table] where ... exists ( select * from [table] where ... );
select * from [table] where [field] in (1, 2, 3);
select    * from      t1 where     x in (select x from t2);
select * from abctable where exists (select null);
select * from abctable where abctable_id in (select null);
select * from temp1 where exists(select 1 from temp2 where conditions...);
create table t1 (id int, title varchar(20), someintcol int) create table t2 (id int, t1id int, somedata varchar(20)) select 1, 'title 1', 5 union all select 2, 'title 2', 5 union all select 3, 'title 3', 5 union all select 4, 'title 4', 5 union all select null, 'title 5', 5 union all select null, 'title 6', 5 select 1, 1, 'data 1' union all select 2, 1, 'data 2' union all select 3, 2, 'data 3' union all select 4, 3, 'data 4' union all select 5, 3, 'data 5' union all select 6, 3, 'data 6' union all select 7, 4, 'data 7' union all select 8, null, 'data 8' union all select 9, 6, 'data 9' union all select 10, 6, 'data 10' union all select 11, 8, 'data 11';
select from    t1 where   not  exists (select * from t2 where t1.id = t2.t1id);
select t1.* from   t1 where  t1.id not in (select  t2.t1id from t2 );
in certain circumstances, it is better to use in rather than exists. in general, if the selective predicate is in the subquery, then use in. if the selective predicate is in the parent query, then use exists.;
delete from tbl1  where id  in having count(dupval)>1));
delete t1 from contacts t1 where t1.id < t2.id and;
delete c1 from contacts c1 where c1.id > c2.id and;
create table source_copy like source;
select * from source;
drop table source;
alter table source_copy rename to source;
create table [dbo].[largesourcetable] ( id int identity(1,1), [createdate]        datetime constraint [df_largesourcetable_createdate] default (getdate()) not null, [column1]    char (36)      not null, [column2]  nvarchar (100) not null, [column3]        char (36)      not null, primary key (column1, column2) with (ignore_dup_key = on);
set identity_insert largesourcetable on set @pagenumber = 0 set @rowsppage = 1000000;
select @totalrows = count (*) from largesourcetable_temp;
( select * from largesourcetable_temp order by id ) ( id ) select id from cte select @dt = convert(varchar(19), getdate(), 121) set @pagenumber = @pagenumber + 1 end;
set identity_insert largesourcetable off;
select distinct * into #tmp from table delete from table select * from #tmp drop table #tmp select * from table;
delete from cte_duplicates where rownumber!=1;
delete from cte where id>1 select name from @tb;
delete from cte where id>1;
select name from @tb;
select linkorder partition by linkorder order by linkorder desc from u_links;
delete prg.person where id in ( select dublicaterow.id from ( select min(id) minid, nationalcode from  prg.person group by nationalcode  having count(nationalcode ) > 1 join  prg.person dublicaterow on dublicaterow.nationalcode = groupselect.nationalcode where dublicaterow.id <> groupselect.minid);
delete from table where col1 in ( select max(id) from table group by id having ( count(col1) > 1 ) );
alter table dbo.duppedtable add rowid int not null identity(1,1);
delete b from dbo.duppedtable b where b.rowid not in ( select min(rowid) as rowid from dbo.duppedtable a with (nolock) a.characteristic, a.intvalue, a.floatvalue, a.stringvalue;
select a.item_number, a.characteristic, a.intvalue, a.floatvalue, a.stringvalue, count(*)--min(rowid) as rowid from dbo.duppedtable a with (nolock) a.characteristic, a.intvalue, a.floatvalue, a.stringvalue;
alter table dbo.duppedtable drop column rowid;
select distinct [col1],[col2],[col3],[col4],[col5],[col6],[col7] from [oldtable];
delete from myduplicatetable where id not in ( select max(id) from myduplicatetable;
('john',1,1,1,1,1,1), ('sally',2,2,2,2,2,2), ('sally',2,2,2,2,2,2);
delete  aliasname from ( select  *, row_number() over (partition by col1,col2,col3,col4,col5,col6,col7 order by col1) as rownumber from    @table) aliasname where   rownumber > 1 select * from @table;
as  ( select productname,row_number() over(partition by productname order by slno) as duplicate from productdetails ) delete from mycte where duplicate>1;
as (select row_number() over (partition by col1, col2, col3-- based on what? --can be multiple columns from   mytable) delete  from cte where  rn > 1;
( select *,row_number() over (partition by col1,col2,col3 order by col1,col2,col3) as rn from mytable ) delete from cte where rn<>1;
from mytable) delete cte where r in (select r from cte group by r having count(*)>1);
delete from cte...;
select * from cte;
select [col1], [col2], [col3], [col4], [col5], [col6], [col7], rn = row_number()over(partition by col1 order by col1) from dbo.table1 ) delete from cte where rn > 1;
delete from search where id not in ( select min(id) from search having count(*)=1 union  select min(id) from search having count(*) > 1 );
delete from t1 where myprimarykey=1;
delete from dublicated_table t1 (nolock) join ( select t2.dublicated_field from dublicated_table t2 (nolock) and len(t1.field_kept)=t3.min_field_kept;
delete from table where id not in ( select min(id) from table );
delete t1 from table t1 inner join table t2 where t1.id > t2.id and t1.col1 = t2.col1;
contact => contact.dealerid, dealer => dealer.dealerid, (contact, dealer) => contact);
join cn in db.countries on c.countryid equals cn.id join ct in db.cities on c.cityid equals ct.id join sect in db.sectors on c.sectorid equals sect.id where (c.countryid == cn.id) && (c.cityid == ct.id) && (c.sectorid == company.sectorid) && (company.sectorid == sect.id) select new { country = cn.name, city = ct.name, c.id, c.name, c.address1, c.address2, c.address3, c.countryid, c.cityid, c.region, c.postcode, c.telephone, c.website, c.sectorid, status = (contactstatus)c.statusid, sector = sect.name };
from contact in dealer.dealercontacts select contact;
from contact in db.dealercontact where dealer.dealerid == contact.dealerid select dealercontact;
from contact in db.dealercontact;
from t1 in db.table1 join t2 in db.table2 on t1.field equals t2.field select new { t1.field2, t2.field3};
join dealer in dealer on contact.dealerid equals dealer.id select contact;
join dc in dealerconact on d.dealerid equals dc.dealerid select dc;
from dealer in db.dealers from contact in dealer.dealercontacts select new { whatever you need from dealer or contact };
select <columns> from dealer, dealercontact where dealer.dealerid = dealercontact.dealerid;
join course in oddatacontext.courses select new { student.student_name, student.student_city, course.course_name, course.course_desc };
join dept in db.departments select new dept.dname, emp.elocation;
join dc in dealercontact on d.dealerid equals dc.dealerid select d;
dc => dc.dealerid, d => d.dealerid, (dc, d) => new { dealercontact = dc, dealer = d }) dc_d.dealer.firstname, dc_d.dealer.lastname, dc_d.dealercontact.city, dc_d.dealercontact.state });
join q2 in table2 select new { q1.name, q1.mobile, q2.purchase, q2.dates };
select new{ dealercontact.contactname;
join s in db.yourothertablename(t2) on t1.fieldname equals t2.feldname;
select new {u.userid, u.customerid, u.clientid, u.roleid, u.username, u.email, u.password, u.salt, u.hint1, u.hint2, u.hint3, u.locked, u.active,c.profilepic}).first();
pd.productid, pd.name, pd.unitprice, od.quantity, od.price, }).tolist();
select distinct right (address, 6), count(*) as count from datafile where address is not null right (address, 6);
select count(*) from (select distinct column1,column2 from  tablename where condition ) as dt;
select region, count(*) from item where region is not null;
select count(program_name) as [count],program_type as [type] from (select distinct program_name,program_type from cm_production where push_number=@push_number;
select count(distinct program_name) as count, program_type as [type] from cm_production where push_number=@push_number;
distinct count(*);
select count(distinct program_name) as count, program_type as [type] from cm_production where push_number=@push_number;
-> color varchar(15), paint varchar(10));
-> ('green', 'gloss'), ('blue', 'metallic'), -> ('white' 'gloss'), ('black' 'gloss');
-> brand varchar(15));
-> ('nissan'), ('smart'), ('bmw');
-> model varchar(15));
-> color int(3), brand int(3), model int(3));
-> (4,4,2), (2,2,3), (3,5,4), (4,1,3), (2,2,1), (5,2,3), (4,5,1);
select id, model from cars join models;
select cars.id, models.model from cars join models;
select a.id, b.model from cars a join models b;
select a.id, b.model from cars a join models b where b.id=1;
select a.id, b.model from cars a join models b join colors c where b.id=1;
select a.id, b.model, c.color from cars a join models b join colors c where b.id=1;
select a.id, b.model, c.color from cars a join models b join colors c join brands d where b.id=1;
select a.id, b.model, c.color from cars a join models b join colors c join brands d and b.brand=d.id where b.id=1;
select a.id, b.model from cars a join models b;
select a.id, b.model, c.color from cars a join models b join colors c join brands d where b.id=1 or b.id=3;
select a.id, b.model, c.color from cars a join models b join colors c join brands d where b.id=1;
select a.id, b.model, c.color from cars a join models b join colors c join brands d where b.id=3;
select a.id, b.model, c.color from cars a join models b join colors c join brands d where b.id=1 union all select a.id, b.model, c.color from cars a join models b join colors c join brands d where b.id=3;
select a.brand from brands a;
select a.brand from brands a join cars b a.brand;
select a.brand from brands a a.brand;
select a.brand, count(b.id) as countofbrand from brands a a.brand;
select b.brand, c.color, count(a.id) as countofbrand from cars a join colors c a.brand, c.color;
select a.brand, c.color, count(b.id) as countofbrand from brands a a.brand, c.color;
select * from colors where id>2 select * from colors where id<4;
select a.id, a.color, a.paint from colors a join colors b where a.id>2 and b.id<4;
select a.id, b.brand from cars a join brands b;
select b.brand, count(a.id) as countcars from cars a join brands b b.brand;
select a.id, b.brand, count(a.id) as countcars from cars a join brands b a.id, b.brand;
select a.id, b.brand, ( select count(c.id) from cars c where a.brand=c.brand from cars a join brands b;
select a.id, b.brand, d.countcars from cars a join brands b join ( select c.brand, count(c.id) as countcars from cars c c.brand;
select id, brand from brands where brand like '%o%';
select a.id, b.brand from cars a join brands b where a.brand in ( select id from brands where brand like '%o%' );
select a.id, b.brand from cars a join brands b where a.brand in (1,2,6);
select a.id, a.brand from brands a where a.id not in(select brand from cars);
select a.brand from brands a where b.brand is null;
update brands set brand='holden' where id= from brands where id=6);
update brands set brand='holden' where id= from (select from brands where id=6 ) as updatetable);
select distinct e.id,e.name,d.name,lap.lappy laptop_make,c_loc.cnty county from  ( select c.id cnty,l.name from   county c, location l where  c.id=l.county_id and l.end_date is not null ( select l.id lappy, c.name cmpy from   laptop l, company c where l.make = c.name;
create table movielist ( id int, moviename varchar(25), constraint ml_pk primary key (id), constraint ml_uq unique (moviename) create table categorylist ( movieid int, categoryname varchar(25), constraint cl_uq unique(movieid, categoryname), constraint cl_fk foreign key (movieid) references movielist(id);
select  distinct a.moviename from    movielist a where   b.categoryname = 'comedy' and;
select  distinct a.moviename from    movielist a where   b.categoryname in ('comedy','romance');
select  a.moviename from    movielist a where   b.categoryname in ('comedy','romance') having count(*) = 2;
create table software ( id int, softwarename varchar(25), descriptions varchar(150), constraint sw_pk primary key (id), constraint sw_uq unique (softwarename) create table versionlist ( softwareid int, versionno int, datereleased date, constraint sw_uq unique (softwareid, versionno), constraint sw_fk foreign key (softwareid) references software(id);
select  a.softwarename, a.descriptions, max(b.versionno) as latestversion, b.datereleased from    software a;
select  a.softwarename, a.descriptions, b.latestversion, c.datereleased from    software a ( select  softwareid, max(versionno) latestversion from    versionlist;
create table userlist ( id int, name varchar(20), constraint us_pk primary key (id), constraint us_uq unique (name) create table conversation ( id int, from_id int, to_id int, message varchar(250), deliverydate date;
select    b.name sendername, c.name recipientname, a.message, a.deliverydate from      conversation a where     (least(a.from_id, a.to_id), greatest(a.from_id, a.to_id), deliverydate) in ( select  least(from_id, to_id) minfrom, greatest(from_id, to_id) maxto, max(deliverydate) maxdate from    conversation );
delete from names where id not in (select * from (select min(n.id) from names n;
delete from names where id not in (select * from (select max(n.id) from names n;
and n1.id <> n2.id;
delete n1 from names n1, names n2 where n1.id > n2.id and n1.name = n2.name;
delete n1 from names n1, names n2 where n1.id < n2.id and n1.name = n2.name;
select distinct cellid,attributeid,entityrowid,value from tablename;
create table departments ( id           number(10)    not null, description  varchar2(50)  not null);
alter table departments add ( constraint dept_pk primary key (id));
create sequence dept_seq start with 1;
create or replace trigger dept_bir select dept_seq.nextval from   dual;
create table t1 ( c1 number generated by default on null as identity, c2 varchar2(10);
create table t1 ( c1 number generated always as identity(start with 1 increment by 1), c2 varchar2(10);
create sequence dept_seq start with 1;
create table departments ( id           number(10)    default dept_seq.nextval not null, description  varchar2(50)  not null);
alter table departments add ( constraint dept_pk primary key (id));
create sequence name_of_sequence;
create or replace trigger trigger_name select name_of_sequence.nextval from dual;
create or replace trigger trigger_name;
create table table_name ( primary_key_column raw(16) default sys_guid() primary key, <<other columns>> );
create table foo ( x number primary key create sequence  foo_seq;
create or replace trigger foo_trg select foo_seq.nextval into :new.x from dual;
create table foo ( x varchar(32) primary key        -- string version create or replace trigger foo_trg select cast(sys_guid() as varchar2(32)) into :new.x from dual;  -- string version;
create table mytable(id number default mysequence.nextval);
create table mytable(id number generated as identity);
create table maps ( map_id integer generated always as identity (start with 1 increment by 1) not null, map_name varchar(24) not null, unique (map_id, map_name);
create table maps ( map_id integer not null , map_name varchar(24) not null, unique (map_id, map_name) create sequence maps_seq;
create or replace trigger maps_trg select maps_seq.nextval from   dual;
create trigger t1_trigger select t1_seq.nextval into :new.id from dual;
create sequence table_pk_seq;
create or replace trigger tr_seq_table before insert on table for each row select table_pk_seq.nextval from dual;
create table <table_name> name varchar2(30));
create table table_name ( id number(10) primary key not null, . create sequence table_name_seq start with 1 increment by 1 minvalue 1 nomaxvalue nocycle cache 2;
create or replace trigger table_name_ts before insert or update on table_name for each row select table_name_seq.nextval into :new.id from dual;
select sys_context('userenv', 'sessionid') into :new.sessionid from dual;
select sys_context('userenv','server_host') into :new.hostname from dual;
select sys_context('userenv','os_user') into :new.loginid from dual;
update table set id=rownum;
select max(id) into maxval from table;
create trigger table_trigger;
create table identity_test_tab ( id            number generated always as identity, description   varchar2 (30);
as v_curr_id number;
create sequence sequnce select sequence.nextval into v_curr_id from dual;
select sequence.nextval into v_curr_id from dual;
else dbms_output.put_line('exception : file not found');
seq in number as i number := seq;
if ( r < 10 ) then else s := chr( 55 + r ) || s;
update parent set id = 20 where id = 10;
create table club ( key serial primary key, name text unique create table band ( key serial primary key, name text unique create table concert ( key serial primary key, club_name text references club(name) on update cascade, band_name text references band(name) on update cascade, concert_date date;
select '(' + convert(char(1),[stage]) + ',''' + [label] + ''')' from cv_order_status if @first = 1 set @first = 0 else set @out = @out + ',' + char(13);
set @out = @out + @row end ;
select '-- set the correct schema' from dual;
select 'use test;' from dual;
select '-- drop table if exists' from dual;
select 'if object_id(''table3'', ''u'') is not null drop table dbo.table3;' from dual;
select '-- create the table' from dual;
select 'create table table3 (column1 varchar(10), column2 varchar(10));' from dual;
select 'insert into table3 (column1, column2) values (''', table1.column1, ''',''', table2.column2, ''');' from table1 join table2 on table2.column1 = table1.column1;
select distinct(col1, col2) from table;
select distinct * from (select col1, col2 from table ) as x;
select distinct grondoflucht,sortering from corwijzevanaanleg;
select        grondoflucht from            dbo.corwijzevanaanleg;
select distinct a,b,c from t;
select a,b,c from t group by a,b,c;
update sales set status='active' where id in ( select id from sales s ( select saleprice, saledate from sales having count(*) = 1 );
update sales set status='active' where id in ( select min(id) from sales having count(id) = 1 );
update sales set    status = 'active' where  (saleprice, saledate) in ( select saleprice, saledate from   sales having count(*) = 1;
update sales s set    status = 'active' where  not exists ( select from sales s1                     -- select list can be empty for exists where  s.saleprice = s1.saleprice and    s.saledate  = s1.saledate and    s.id <> s1.id                     -- except for row itself ) and    s.status is distinct from 'active';  -- avoid empty updates. see below;
and    s1.ctid <> s.ctid;
and status <> 'active';
select count(1) filter (where position = 'manager') as managercount, count(1) filter (where position = 'other') as othercount from ...;
select schedule, packagenum, count (uniqueid) as total, sum ( case when then 1 else 0 end ) as numoversize from inventory where customer like '%pepsi%' schedule, packagenum;
select 1, 'manager' union select 2, 'manager' union select 3, 'customer' union select 4, 'boss' union select 5, 'intern' union select 6, 'customer' union select 7, 'customer' union select 8, 'wife' union select 9, 'son' select * from @tbl select count(1) as [total] from @tbl;
select count(if(position = 'manager', 1, null)) as managercount from ...;
select count(*) from bla where position = 'manager';
select count(*) from yourtable where position = 'manager';
select count(case when position = 'manager' then 1 else null end) as managercount from ...;
select count(case when position = 'manager' then 1 else null end) as managercount, count(case when position = 'supervisor' then 1 else null end) as supervisorcount, count(case when position = 'team lead' then 1 else null end) as teamleadcount, from ...;
select sum(case when position = 'manager' then 1 else 0 end) as managercount, sum(case when position = 'ceo' then 1 else 0 end) as ceocount from sometable;
select count(case position when 'manager' then 1 else null end) from ...;
select sum(case position when 'manager' then 1 else 0 end) from ...;
select * from @users count(position) in (manager, ceo, employee);
as id1_12_1_, memberrole0_.member_id as member_i2_12_1_, memberrole0_.role_id as role_id3_12_1_, role1_.id as id1_17_2_, role1_.name as name2_17_2_ from member_roles memberrole0_ left outer join roles role1_ on memberrole0_.role_id=role1_.id where memberrole0_.member_id=104;
select year(p.createdon) as year, count(p) as postcount from post p year(p.createdon);
select extract(year from sqlextract0_.created_on) as col_0_0_, count(sqlextract0_.id) as col_1_0_ from post p extract(year from p.created_on);
select c.id, sum(c.val) from ( select b.id, b.bal from ( select if(@last_id=id,@rnk+1,1) as rnk, a.id, a.val, @last_id=id, from ( select id, val from list where b.rnk < @n) as c;
select year, id, rate from (select from h where year between 2000 and 2009 and id in (select rid from table2) where row_number <= 5;
create procedure count_limit200() select count(distinct(domain)) into stop_loop from db.one;
select * from ( select book,artist,title,count(objectkey) as titlecount, now() from db.one where book = domain_val limit 200 if a = stop_loop then end if;
end loop loop_thru_domain;
select h.year, h.id, h.rate from (select h.year, h.id, h.rate, if(@lastid = (@lastid:=h.id), @index:=@index+1, @index:=0) indx from (select h.year, h.id, h.rate from h where h.year between 2000 and 2009 and id in (select rid from table2) where h.indx <= 5;
select t.id, t.rate, t.year, count(l.rate) as rank from t having count(l.rate) < 5;
having count(distinct l.rate) < 5;
select * from ( select *, rank() over (partition by id order by rate desc) as rnk from t where rnk <= 5;
set @num := 0, @type := '';
select `year`, `id`, `rate`, @num := if(@type = `id`, @num + 1, 1) as `row_number`, @type := `id` as `dummy` from ( select * from `h` where ( `year` between '2000' and '2009' and `id` in (select `rid` from `table2`) as `temp_rid` ) having `row_number`<='5';
select * from yourtable where id in (select ',', 1) id from yourtable;
select   id, group_concat(year order by rate desc) grouped_year from     yourtable;
select find_in_set('2006', '2006,2003,2008,2001,2007,2009,2002,2004,2005,2000');
select find_in_set('2009', '2006,2003,2008,2001,2007,2009,2002,2004,2005,2000');
select yourtable.* from yourtable inner join ( select id, group_concat(year order by rate desc) grouped_year from yourtable and find_in_set(year, grouped_year) between 1 and 5 yourtable.id, yourtable.year desc;
select h.year, h.id, h.rate from ( select id, substring_index(group_concat(concat(id, '-', year) order by rate desc), ',' , 5) as l from h where year between 2000 and 2009 and substring_index(h_temp.l, concat(h.id, '-', h.year), 1) != h_temp.l;
create definer=`ks_root`@`%` procedure `first_five_record_per_id`() set @query_string='';
if done then end if;
set @datasource1 = tenants;
set @query_string = concat(@query_string,'(select * from demo  where `id` = ''',@datasource1,''' order by rate desc limit 5) union all ');
set @query_string  = trim(trailing 'union all' from trim(@query_string));
select @query_string;
create table `stack` `id` varchar(10) default null, `rate` float default null);
select t3.year,t3.id,t3.rate from (select t1.*, (select count(*) from stack t2 where t1.rate<=t2.rate and t1.id=t2.id) as rownum from stack t1) t3 where rownum <=3 order by id,rate desc;
between 2000 and 2009;
--                this would be 11 (-1 for unbounded/not set) --                this would be 20 (-1 for unbounded/not set) select * from ( select column1, column2 rownum as rn from ( select tbl.column1, tbl.column2 from mytable tbl where tbl.column1 = p_pkparam or decode(p_sortorder, 'a', decode(p_sortcolumn, 1, column1, 'x'),'x'), decode(p_sortorder, 'd', decode(p_sortcolumn, 1, column1, 'x'),'x') desc, decode(p_sortorder, 'a', decode(p_sortcolumn, 2, column2, sysdate),sysdate), decode(p_sortorder, 'd', decode(p_sortcolumn, 2, column2, sysdate),sysdate) desc where (rn >= p_lowerbound or p_lowerbound = -1) and;
select * from the_table order by added desc limit 1,15;
select top 1 field from table where field in (select top 5 field from table order by field asc);
select * from mytable somefield limit 1 offset 20;
select @count = count(<column>) from <table> set @innerpagesize = @pagenum * @pagesize set @outerpagesize = @count - ((@pagenum - 1) * @pagesize) if (@outerpagesize < 0) set @outerpagesize = 0 else if (@outerpagesize > @pagesize) set @outerpagesize = @pagesize set @sql = 'select * from ( select top ' + cast(@outerpagesize as nvarchar(5)) + ' * from ( select top ' + cast(@innerpagesize as nvarchar(5)) + ' * from <table> order by <column> asc;
select * from (select foo from bar order by foo) where rownum = x;
select top 1 start at n * from table order by whatever;
limit y offset x;
select * from ( select row_number() over (order by key asc) as rownumber, columns from tablename where rownumber <= n;
select * from thetable limit n-1, 1;
row = row_number() over (order by id) from sentencetype ) select sen.stuff from sentence sen where sen.row = (abs(checksum(newid())) % 100) + 1;
select * from emp a where  n = (select count( _rowid) from emp b where a. _rowid >= b. _rowid);
set rowcount @row --@row = the row number you wish to work on.;
set rowcount 20   --sets row to 20th row select meat, cheese from dbo.sandwich --select columns from table at 20th row set rowcount 0   --sets rowcount back to all rows;
select * from ( select row_number () over (order by mycolumntoorderby) as rownum, * from table_1 where rownum = 23;
select * from where  recordnumber --> record number to select;
select * from ( select row_number() over (order by columnname1 asc) as rownumber, columnname1, columnname2 from tablename where rownumber % 10 = 0;
select * from table order by `id` desc limit n, 1;
select distinct (`amount`) from cart order by cast( `amount` as signed ) desc limit 4 , 1;
select * from ( select id, name, row_number() over(order by id) as row from table where row = n;
select * from ( select id, name, row_number() over(order by id desc) as row from table where row = n;
select top 10 * from emp select top 9 * from emp;
select top 1 * from table_name where column_name in ( select top n column_name from table order by column_name ) column_name desc;
select top 1 * from employee where emp_id in ( select top 7 emp_id from employee emp_id ) emp_id desc;
select top 1 * from ( select top n * from <table> );
select * from ( select rrn(foo) as rrn, foo.* from foo where bar.rrn = recordnumber;
select * from table limit abs(random()) % (select count(*) from words), 1;
select top(@rownumber) * from [dbo].[sometable];
select top(@rownumber - 1) * from [dbo].[sometable];
select top(@rownumber) * from [dbo].[sometable];
select top(@rownumber - 1) * from [dbo].[sometable];
set @constvar = @constvar - 1;
select * from   sometable;
select (row_number() over (order by mytable.somefield)) as row,* from mytable) select * from mytablewithrows where row = 3;
select distinct dept_id as "second highest" as "third highest" from employees where dept_id in (10,20);
where x in (...);
select top 1 from ( select top 2 --the nth row, alter this to taste ue2.[col2], ue2.[date], ue2.[time], ue2.[uid] from [table1] as ue2 where ue2.[col1] = id --this is a subquery and ue2.[col2] is not null ue2.[date] desc, ue2.[time] desc --sorting by date and time newest first;
select top 1000 * from emp ) select * from r select top 999 from r;
update mytable set column1=@value1 from tvfselectlatestrowofmytablematchingcriteria(@param1,@param2,@param3);
create function tvfselectlatestrowofmytablematchingcriteria ( @param1 int, @param2 int, @param3 int ) ( select top(1) mytable.* from mytable join myothertable join whoknowswhatelse where mytable.somecolumn=@param1 and ... );
update dispatch_post set issync = 1 where challanno in (select top 1000 challanno from dbo.dispatch_post order by;
update  top (500) t set     t.somecolumn = 'value' from    sometable t where   t.someothercolumn = 1;
update top (100) table_name set column_name = value;
as ( select top(100) * from table_name order by id desc ) update table_name set column_name = value;
set rowcount {number};
set rowcount 100;
update table set ..;
( select top 100 * from t1 ) update cte set f1='foo';
update tb set  f1=1 where id in (select top 100 id from tb where f1=0);
update top (100) table1 set field1 = 1;
create table #tmp ( sizeid varchar(max) ) values ('44'), ('44,45,46'), ('44,45,46'), ('44,45,46'), ('44,45,46'), ('44,45,46'), ('44,45,46') select * from #tmp select @sqlstr = stuff((select ',' + sizeid from #tmp select top 1 * from ( select items, count(*)as occurrence from dbo.split(@sqlstr,',') having count(*) > 1;
select a.column1, a.column2 from dbo.a a join (select column1, column2, count(*) as countc from dbo.a having count(*) > 1 ) b and a.column2 = b.column2;
select field1,count(field1) as field1count,field2,count(field2) as field2counts,field3, count(field3) as field3counts from table_name having count(*) > 1;
select row_number() over ( partition by name  order by name) rown, * from tmptest ) select * from mycte where rown <=1;
select field1,field2,field3, count(*) from table_name having count(*) > 1;
select a.id, a.field1, a.field2, a.field3 from mytable a where exists (select b.id from mytable b where b.field1 = a.field1 and b.field2 = a.field2 and b.field3 = a.field3 and b.id < a.id);
create table table1 ( field1 int, field2 int, field3 int, field4 int ) values    (1,1,1,1) select    * from     (select      field1 from      table1) x where     occurrence > 1;
select id from ( select id from table_name where [rank] > 1;
select a.*, b.* from table a, table b where a.id *= b.id;
select * from table a, table b where a.id = b.id (+);
select * from table a;
set @var_name = value;
set @var := value;
select col1, @var_name := col2 from tb_name where "conditon";
select col1, col2 into @var_name, col3 from .....;
select count(*) into @nr from a_table where a_condition;
set new.ord_col =  ifnull( @nr, 0 ) + 1;
set @counter := 100;
select @variable_name := value;
select @price := max(product.price) from product;
select @var_any_var_name;
set @start = 1, @finish = 10;
select @start := 1, @finish := 10;
select * from places where place between @start and @finish;
create procedure sp_test(var1 int) select  var1, start, finish;
select * from places where place between start and finish;
select @@var_name;
select @@sort_buffer_size;
set global sort_buffer_size=1000000;
set @@global.sort_buffer_size=1000000;
set sort_buffer_size=1000000;
set session sort_buffer_size=1000000;
set @@sort_buffer_size=1000000;
set @@local.sort_buffer_size=10000;
select @ids := concat_ws(',',@ids,tbl.id), tbl.col1, ... from mytable tbl;
set regione=(select  id from users where id=1) ;
select regione ;
select name from (select name from agentinformation) a;
select a.name from (select name from agentinformation) a;
select name from (select name from agentinformation) as a;
update table1, table2 set table1.col1='value', table2.col1='value' where table1.col3='567' and table2.col6='567';
update table set;
update table set where column2 > 5;
update table1, table2 set table2.col1 = 'value' where table1.col3 = '567' and table2.col6='567';
update sometable set somevalue = 4 from sometable s inner join anothertable a on s.id = a.id where a.id = 4;
update tablename set col1='000' where id='3' or id='5';
update table1 tab1, table1 tab2 -- alias references the same table set col1 = 1 where tab1.id = tab2.id;
update `your_table` set `something` = if(`id`="2","new_value2",`something`), `smth2` = if(`id`="2", "nv2",`smth2`), `something` = if(`id`="4","new_value3",`something`), `smth2` = if(`id`="4", "nv3",`smth2`), `something` = if(`id`="6","new_value4",`something`), `smth2` = if(`id`="6", "nv4",`smth2`), `something` = if(`id`="3","new_value5",`something`), `smth2` = if(`id`="3", "nv5",`smth2`), `something` = if(`id`="5","new_value6",`something`), `smth2` = if(`id`="5", "nv6",`smth2`);
`smth2` = if(`id`="'.$dat->id.'", "'.$dat->value2.'",`smth2`),';
update my_table m join ( select 1 as id, 10 as _col1, 20 as _col2 union all select 2, 5, 10 union all select 3, 15, 30 set col1 = _col1, col2 = _col2;
set session sql_mode=replace(replace(@@session.sql_mode,"strict_trans_tables",""),"strict_all_tables","");
update my_table m, -- let create a temp table with populated values select 2 as id, 30 as value union -- using a backend code select n as id, x as value set m.value = t.value where t.id=m.id -- now update by join - quick;
alter table test add index index_name(col1(255),col2(255));
alter table test add unique index_name(col1(255),col2(255));
alter table authors add unique(name_first(767), name_second(767));
unique ( problemtextfield(300) );
select count(*) as cnt, last_name from employees;
select count(*) as cnt, left(last_name,9) as prefix from employees limit 0,15;
alter table authors add unique(name_first(20), name_second(20));
create table t_length ( mydata text not null, key ix_length_mydata (mydata(255)));
select this_.code from true.employee this_ where this_.code=?;
set identity_insert table1 on opdescription, filterid) values      (20, 'hierachy update', 1) set identity_insert table1 off;
values (20,'hierachy update',1);
values ('hierachy update',1);
values ('hierachy update',1);
set identity_insert tablename on;
set identity_insert student on;
set identity_insert school on set identity_insert school off;
create table [dbo].[persons] ( id int identity(1,1) primary key, lastname varchar(40) not null, firstname varchar(40);
set identity_insert [dbo].[persons] off;
values ('jane','doe');
values ('joe','brown');
set identity_insert [dbo].[persons] on;
values (5,'john','white');
values (3,'jack','black');
set identity_insert mytable on;
set identity_insert mytable on;
set identity_insert mytable on set identity_insert mytable off;
set identity_insert;
create table testtable (firstname varchar(100), lastname varchar(100)) select firstname, lastname from person.contact where emailpromotion = 2 select firstname, lastname from testtable drop table testtable;
select firstname, lastname from person.contact where emailpromotion = 2 select firstname, lastname from testtable drop table testtable;
set @column_list = (select distinct ( select ', table1.' + syscol1.name  as [text()] from sys.columns syscol1 where syscol1.object_id = syscol2.object_id and syscol1.is_identity <> 1 from sys.columns syscol2 where syscol2.object_id = object_id('dbo.tableone') ) set @sql_insert =  'insert into dbo.tabletwo select ' + @column_list + ' from dbo.tableone table1 where col3 like ' + @search_key exec sp_executesql @sql_insert;
select * from database..othertables....;
select * into tablename from other tablenames;
select * into existing table tablename from other tablenames;
select ... into ...;
select col1, col2 from dbo.tableone where col3 like @search_key;
select col1, col2 from dbo.tableone where col3 like @search_key;
from gengl where book='" & lblbook.caption & "' and docno=" & txtvno.text & "";
if (rs.next()) {;
if (generatedkeys.next()) { else {;
if (pstmt.executeupdate() > 0) { if ( generatedkeys.next() ) {;
if (rs.next()) {;
//all resultsets must be processed if (rs != null);
if (affectedrows == 0) { if (rs.next()) {;
connection connection = datasource.getconnection();
statement.return_generated_keys);
if (affectedrows == 0) { if (generatedkeys.next()) { else {;
select currval(sequencename);
create procedure [dbo].[proc_pivotprepare] ( @db_name        nvarchar(128), @tablename      nvarchar(128) ) as select @db_name = isnull(@db_name,db_name()) select @sql_code        =   'select [<| sql_code |>] = '' '' ' create procedure [dbo].[sp_pivotexecute] ( @columnlistwithactions  columnactionlist readonly ) as  if object_id('tempdb.dbo.#columnlistwithactions', 'u') is not null drop table #columnlistwithactions;
select * into #columnlistwithactions from @columnlistwithactions;
select      [columnname] from        #columnlistwithactions where       [action] = 's' select @listofcolumns_stable = isnull(@listofcolumns_stable, '') + ' [' + @columnname + '] ,';
end  select      [columnname] from        #columnlistwithactions where       [action] = 'd' select @listofcolumns_dimension = isnull(@listofcolumns_dimension, '') + ' [' + @columnname + '] ,';
end  select      [columnname] from        #columnlistwithactions where       [action] = 'v' select @listofcolumns_variable = isnull(@listofcolumns_variable, '') + ' [' + @columnname + '] ,';
end  select @listofcolumns_variable      = left(@listofcolumns_variable, len(@listofcolumns_variable) - 1);
select @listofcolumns_dimension = left(@listofcolumns_dimension, len(@listofcolumns_dimension) - 1);
select @listofcolumns_stable            = left(@listofcolumns_stable, len(@listofcolumns_stable) - 1);
select [dim_id] = row_number() over(order by [columnname]), [columnname] from #columnlistwithactions where [action] = 'd';
select      @dim_id = 1;
if object_id('tempdb.dbo.##all_dimentions', 'u') is not null drop table ##all_dimentions;
select @sql_dimentions      = 'select [xxx_id_xxx] = row_number() over (order by ' + @listofcolumns_dimension + '), ' + @listofcolumns_dimension select @dim_id = @dim_id + 1;
select @sql_dimentions = @sql_dimentions + 'and ' + (select [columnname] from @dim_tab where [dim_id] = @dim_id) +  ' is not null ';
select @dim_id = @dim_id + 1;
end  select @sql_dimentions   = @sql_dimentions + ' )x';
select [stabpos_id] = row_number() over(order by [columnname]), [columnname] from #columnlistwithactions where [action] = 's';
select      @stabpos_id = 1;
if object_id('tempdb.dbo.##all_stablecolumns', 'u') is not null drop table ##all_stablecolumns;
select @sql_mainstablecolumntable       = 'select xxx_id_xxx = row_number() over (order by ' + @listofcolumns_stable + '), ' + @listofcolumns_stable select @stabpos_id = @stabpos_id + 1;
select @sql_mainstablecolumntable = @sql_mainstablecolumntable + 'and ' + (select [columnname] from @stabpos_tab where [stabpos_id] = @stabpos_id) +  ' is not null ';
select @stabpos_id = @stabpos_id + 1;
end  select @sql_mainstablecolumntable    = @sql_mainstablecolumntable + ' )x';
select @full_sql_1 = '' if object_id('tempdb.dbo.##finaltab', 'u') is not null drop table ##finaltab;
select @full_sql_1 = 'select t.*, dim.[xxx_id_xxx] ' select @i = 2 select @full_sql_1 = @full_sql_1 + ' and t.' + (select [columnname] from @dim_tab where [dim_id] = @i) + ' = dim.' + (select [columnname] from @dim_tab where [dim_id] = @i) select @i = @i +1 end execute sp_executesql @full_sql_1 select [stab_id] = row_number() over(order by [columnname]), [columnname] from #columnlistwithactions where [action] = 's';
select [var_id] = row_number() over(order by [columnname]), [columnname] from #columnlistwithactions where [action] = 'v';
select @finalcode = ' select id1.*' select @y = 1 select @z = 1 select @finalcode = @finalcode +    ', [id' + cast((@y) as varchar(10)) + '.' + (select [columnname] from @var_tab where [var_id] = @z) + '] =  id' + cast((@y + 1) as varchar(10)) + '.' + (select [columnname] from @var_tab where [var_id] = @z) select @z = @z + 1 end select @y = @y + 1 end select @finalcode = @finalcode + select @y = 1 select @x = 1 select @finalcode = @finalcode select @finalcode = @finalcode + ' and id1.' + (select [columnname] from @stab_tab where [stab_id] = @x) + ' = id' + cast((@y+1) as varchar(10)) + '.' + (select [columnname] from @stab_tab where [stab_id] = @x) select @x = @x +1 end select @y = @y + 1 end  select * from ##all_dimentions;
select firstname, amount, postalcode, lastname, accountnumber from ( select value, columnname from yourtable ( max(value);
@query  as nvarchar(max) select @cols = stuff((select ',' + quotename(columnname) from yourtable set @query = n'select ' + @cols + n' from ( select value, columnname from yourtable ( max(value) exec sp_executesql @query;
select max(case when columnname = 'firstname' then value end) firstname, max(case when columnname = 'amount' then value end) amount, max(case when columnname = 'postalcode' then value end) postalcode, max(case when columnname = 'lastname' then value end) lastname, max(case when columnname = 'accountnumber' then value end) accountnumber from yourtable;
select fn.value as firstname, a.value as amount, pc.value as postalcode, ln.value as lastname, an.value as accountnumber from yourtable fn and a.columnname = 'amount' and pc.columnname = 'postalcode' and ln.columnname = 'lastname' and an.columnname = 'accountnumber' where fn.columnname = 'firstname';
null, (select id from x where code='aaa'), 'bbb';
values ( null, (select t.id from (select id, code from x) t where t.code='aaa'), 'bbb';
update mytable set mytable.a = ( select b from mytable );
update mytable set mytable.a = ( select b from (select * from mytable) as something );
select * from table;
update pers p set p.gehalt = p.gehalt * 1.05 where p.persid in ( select tempp.tempid from ( select persid as tempid from pers p where p.chefid is not null or gehalt < select max(gehalt * 1.05) from pers ma where ma.chefid = ma.chefid) as _pers ) );
create table test2 as select persid from pers p where ( chefid is not null or gehalt < ( select max ( gehalt * 1.05 ) from pers ma where ma.chefid = p.chefid ) );
update pers p set p.gehalt = p.gehalt * 1.05 where persid in ( select persid from test2 ) drop table test2;
update pers p, ( select persid from pers p where ( chefid is not null or gehalt < ( select max ( gehalt * 1.05 ) from pers ma where ma.chefid = p.chefid ) ) set p.gehalt = p.gehalt * 1.05 where p.persid = t.persid;
update tablea, tablea as tablea_1 set tablea.fieldb= tablea_1.fileda where (((tablea.conditionfild) = 'condition') and ((tablea.fieldc) = tablea_1.fieldd));
delete from table where id not in (select min(id) from table group by field 2);
delete from table where id not in( select min(t.id) from (select id,field2 from table) as t group by field2);
delete from table where id not in( select x.id from (select min(id) as id from table group by field2) as t);
update table1 set col1 = (select max(col1) from table1) where col1 is null;
update table1 set col1 = (select max(col1) from (select * from table1) as table1_new) where col1 is null;
set @v1 := (select ... );
update ... set ... where x=@v1;
update t1 set c1=c1+1 where c2=(select max(c2) from t1);
both as a target for 'update' and as a separate source for data;
update t1 set c1=c1+1 where c2=(select max(c2) from t1);
delete from t1 where c1 in (select b.c1 from t1 b where b.c2=0);
select  c2.field1 , field2 from    (select distinct from   dbo.table as c join dbo.table as c2 on c1.field1 = c2.field1;
select * from table;
select distinct on field1 * from table;
select * from ( select *, row_number() over (partition by field1 order by field2) as row_number from table where row_number = 1;
select field1, max(field2), count(field3), sum(field4), .... from table group by field1;
select * from table where field in (select distinct field from table);
select * from tblname limit 0 , 30;
select * from table group by field1;
select * from persons group by name;
select * from persons group by lastname, firstname;
select * from tablename r, c where c.rowid=r.rowid and c.a=r.a and c.b=r.b and c.c=r.c;
select col1 = 'a', col2 = 'b', col3 = 'c', other = 'r1' union all select col1 = 'c', col2 = 'b', col3 = 'a', other = 'r2' union all select col1 = 'a', col2 = 'b', col3 = 'c', other = 'r3' union all select col1 = 'a', col2 = 'b', col3 = 'c', other = 'r4' union all select col1 = 'c', col2 = 'b', col3 = 'a', other = 'r5' union all select col1 = 'a', col2 = 'a', col3 = 'a', other = 'r6' select *, total_dr_rows = count(*) over(partition by dr) from ( select *, dr = dense_rank() over(order by col1, col2, col3), dr_rn = row_number() over(partition by col1, col2, col3 order by other) from t ) select * from tdr where total_dr_rows > 1;
select field1, field2, field3, ......   from table group by field1;
select *  from table group by field1;
from (select field from table;
select table.* from table select field, max(id) as id from table where //this will result in only the last instance being seen;
select  * from table where field1 in ( select distinct field1 from table );
select table.* from table where otherfield = 'othervalue' limit x;
select country from locations;
select country, city from locations;
select country, max(city) from locations;
select country, min(city) from locations;
select countrylist.*, (select top 1 city from locations where country = countrylist.country and city like 'm%' ) from (select country from locations;
from mytable /* selecting only unique values based on the "id" field */ ) select * /* here you can specify several columns to retrieve */ from cte where rn = 1;
select min(table.id), table.column1 from table;
case when isnull(fitchrating.ratingvalue, 100) < = isnull(moodyrating.ratingvalue, 99) and  isnull(fitchrating.ratingvalue, 100) < = isnull(standardpoorsrating.ratingvalue, 99) then fitchgagency.ratingagencyname then moodyagency.ratingagencyname else isnull(standardpoorsrating.ratingvalue, 'n/a') end;
@v2 int , @v3 int set @v2 = 2 set @v3 = 3 select  ( select    max(vals) from      ( select    v1 as vals union select    v2 union select    v3 where     vals is not null -- this eliminates null warning from    ( select    @v1 as v1;
select [other fields], (select max(v) from (values (date1), (date2), (date3),...) as value(v)) as [maxdate] from [yourtablename];
select case when date1 >= date2 and date1 >= date3 then date1 else date3 end as mostrecentdate;
select 1, '20000101', '20010101','20020101',100 union all select 2, '20000101', '19900101','19980101',99 select number, cost  , (select max([date]) from    (select date1 as [date] union all select date2 union all select date3 ) ) from   @tablename;
create function  fxmost_recent_date;
set @mostrecent='1/1/1900' if @date1>@mostrecent begin set @mostrecent=@date1 end if @date2>@mostrecent begin set @mostrecent=@date2 end if @date3>@mostrecent begin set @mostrecent=@date3 end;
create function dbo.get_min_max_date ( @date1  datetime, @date2  datetime, @date3  datetime, @date4  datetime, @date5  datetime, @date6  datetime, @date7  datetime, @date8  datetime, @date9  datetime, @date10 datetime ) as return ( select      max(datevalue)  max_date, min(datevalue)  min_date from        ( values  (@date1), (@date2), (@date3), (@date4), (@date5), (@date6), (@date7), (@date8), (@date9), (@date10) );
create table dates ( number int primary key , date1 datetime , date2 datetime , date3 datetime , cost int ) values  ( 1, '1/1/2008', '2/4/2008', '3/1/2008', 10 ) values  ( 2, '1/2/2008', '2/3/2008', '3/3/2008', 20 ) values  ( 3, '1/3/2008', '2/2/2008', '3/2/2008', 30 ) values  ( 4, '1/4/2008', '2/1/2008', '3/4/2008', 40 );
select  number , max(ddate) maxdate , cost from    dates unpivot ( ddate for ndate in ( date1, date2, date3 ) ) as u cost;
select  number , ( select    max(ddate) maxdate from      ( select    d.date1 as ddate union select    d.date2 union select    d.date3 cost from    dates d;
as ( select   number , max(case rn else date3 from     dates a union select 2 union select 3 ) select  dates.number , maxd.maxdate , dates.cost from    dates drop table dates;
select case when date1 >= date2 and date1 >= date3 then date1 else                                        date1 end as mostrecentdate;
select  max(date_columns) as max_date from    ( (select   date1 as date_columns from     data_table         ) union ( select  date2 as date_columns from    data_table ) union ( select  date3 as date_columns from    data_table );
select  max(mostrecentdate) from    ( select    case when date1 >= date2 and date1 >= date3 then date1 and date2 >= date3 then date2 and date3 >= date2 then date3 else date1 end as mostrecentdate from      data_table;
select greatest(col1, col2 ...) from table;
create table dates ( number int, date1 datetime, date2 datetime, date3 datetime ) select max(datemaxes) from ( select (select max(date1) from dates) date1max, (select max(date2) from dates) date2max, (select max(date3) from dates) date3max drop table dates;
select (select from ( values (max(field2)) ) from mytable1;
create function [dbo].[inlinemax] (@v1 float,@v2 float,@v3 float,@v4 float) as begin set @val = 0 select @val= max(value) from @tableval end;
select max(maxdt) maxdt from tbl;
select mostrecentdate from sourcetable;
select iif(@date1>@date2, iif(@date1>@date3,@date1,@date3), iif(@date2>@date3,@date2,@date3)) as mostrecentdate;
select case when date1 > coalesce(date2,'0001-01-01') and date1 > coalesce(date3,'0001-01-01') then date1 else date3 end as mostrecentdate from (values;
select (select max(salval) from( values (max(salary1)),(max(salary2)),(max(salary3)),(max(salary4)))alias(salval)) as largest_val from employeesalary;
select max(salvalue) from(values (10001),(5098),(6070),(7500))alias(salvalue);
select case true case true when max(row2) >= max(row3) then max(row2) else max(row3) end end from yourtable;
( id int, name varchar(30), value int ) ( id int, result varchar(max) ) select id from @source set @id = (select min(id) from @target) set @result = null select @result = case when @result is null then '' else @result + ', ' end + s.name + ':' + convert(varchar(30),s.value) from @source s where id = @id update @target set result = @result where id = @id set @id = (select min(id) from @target where @id < id) end  select * from @target;
create table #yourtable ([id] int, [name] char(1), [value] int) select [id], stuff(( select ', ' + [name] + ':' + cast([value] as varchar(max)) from #yourtable where (id = results.id) from #yourtable results drop table #yourtable;
select name, listagg(type, '; ') within group(order by name) from table;
as ( select outputid, schme + ' ('+descr+')', rn=row_number() over (partition by outputid order by schme, descr) from @t ) as ( select outputid, convert(varchar(max),combined), 1 from cte where rn=1 union all select cte2.outputid, convert(varchar(max),cte2.finalstatus+', '+cte.combined), cte2.rn+1 from cte2 ) select outputid, max(finalstatus) from cte2 group by outputid;
create table #yourtable ( [id] int, [name] char(1), [value] int ) select [id], replace(replace(replace( (select [name] + ':' + cast([value] as varchar(max)) as a from   #yourtable where  ( id = results.id ) from   #yourtable results drop table #yourtable;
create table #yourtable ([id] int, [name] varchar(max), [value] int) select  [id], stuff(( select ', ' + cast([name] as varchar(max)) from #yourtable where (id = results.id) from    #yourtable results drop table #yourtable;
create table foo ( id int, name char(1), value char(1) values  (1, 'a', '4'), (1, 'b', '8'), (2, 'c', '9');
select  id, dbo.group_concat(name + ':' + value) as [column] from    dbo.foo;
select stuff( ( select ', ' + x from (select 'xxx' x union select 'yyyy') tb );
select ', ' + x from (select 'xxx' x union select 'yyyy') tb;
select [id],  case when max( [name]) = min( [name]) then else  select ', ' + [name] + ':' + cast([value] as varchar(max)) from #yourtable where (id = results.id) end  from #yourtable results;
select id, string_agg(concat(name, ':', [value]), ', ') from #yourtable;
select t.id from #yourtable t select ', ' + [name] + ':' + cast([value] as varchar(max)) from #yourtable where (id = t.id);
select t3.dept, replace(replace(t3.ename,'{"ename":"',''),'"}','') as ename_list from ( select dept, (select ename as [ename] from employee t2 where t2.dept=t1.dept from employee t1;
select 1 n, 1 g, 1 v union all select 2 n, 1 g, 2 v union all select 3 n, 2 g, 3 v ) select g ( select ', ' + cast(v as varchar(max)) from t sub_t where sub_t.g = main_t.g ) from t main_t;
create table #yourtable ([id] int, [name] char(1), [value] int) select [id], stuff(( select ', ' + [name] + ':' + cast([value] as varchar(max)) -- concatonates each application : value set from #yourtable where (id = results.id and name = results.[name] ) from #yourtable results select [id],[name] , --these are acting as the group by clause select ', '+  cast([value] as varchar(max)) -- concatonates the values for each id name combination from #yourtable where (id = results.id and name = results.[name] ) from #yourtable results drop table #yourtable;
create table temptablename like tablename;
create index ix_all_id on tablename(cellid,attributeid,entityrowid,value);
drop table temptablename;
create temporary table if not exists _temp_duplicates as (select dub.id from table_with_duplications dub group by dub.field_must_be_uniq_1, dub.field_must_be_uniq_2 having count(*)  > 1);
delete from table_with_duplications where id in (select id from _temp_duplicates);
create table tmp_employee like employee;
alter table tmp_employee add unique(ssn);
create table tmp_jobs like jobs;
alter table tmp_jobs add unique(site_id, title, company);
create table tmp_employee like employee;
alter table tmp_employee add unique(ssn);
create table tmp_employee like employee;
alter table tmp_employee add unique(ssn);
alter table tmp_employee add column n_duplicates int default 0;
create table tmp_employee like employee;
alter table tmp_employee add unique(ssn);
create table tmp_employee like employee;
alter table tmp_employee add unique(ssn);
alter table tmp_employee add column n_duplicates int default 0;
create table tmp_employee2 like tmp_employee;
drop table tmp_employee;
delete t1 from contacts t1 contacts t2 where;
create table temp_table like table1;
alter table temp_table add unique(title, company,site_id);
drop table old_table1;
alter table mytable add tokeep boolean;
alter table mytable add constraint preventdupe unique (mycol1, mycol2, tokeep);
update ignore mytable set tokeep = true;
delete from mytable where tokeep is null;
alter table mytable drop tokeep;
create table tabletoclean_temp like tabletoclean;
alter table tabletoclean_temp add unique index (fontsinuse_id);
drop table tabletoclean;
delete t1 from table_name t1 join table_name t2 where t1.id < t2.id and;
select t1.* from table_name t1 inner join (select count(*) as c,id from table_name group by id) t2 on t1.id = t2.id where t2.c > 1 group by t1.id;
delete t1 from tablename t1 where t1.id < t2.id and;
delete t1 from tablename t1 inner join tablename t2 where t1.id < t2.id and t1.column1 = t2.column1 and t1.column2 = t2.column2;
create table temp_table like my_table;
delete from my_table where id not in (select id from temp_table);
drop table temp_table;
delete from tablename where id in ( select id from ( select id, row_number() over(partition by column1, column2 order by id) rn from output where rn > 1 );
drop table table_name_copy;
create table table_name_copy like table_name;
select * from table_name drop table table_name;
alter table table_name_copy rename to table_name;
delete from job s where rowid < any where s.site_id = k.site_id and;
delete from job s where rowid not in where s.site_id = k.site_id and;
delete from jobs c1 where not c1.location = 'paris' and  c1.site_id > 64218 and exists ( select * from jobs c2 where c2.site_id = c1.site_id and   c2.company = c1.company and   c2.location = c1.location and   c2.title = c1.title and   c2.site_id > 63412 and   c2.site_id < 64219 );
create table your_table_deduped like your_table;
select * from your_table index2_id;
alter table `your_table` add unique `unique_index` (`index1_id`, `index2_id`);
drop table your_table_with_dupes;
alter table table add `merged` varchar( 40 ) not null ;
update table set merged` = md5(concat(`col1`, `col2`, `col3`)) alter ignore table table add unique index idx_name (`merged`);
delete `a` from `jobs` as `a`, `jobs` as `b` where -- important: ensures one version remains and (`a`.`title` = `b`.`title` or `a`.`title` is null and `b`.`title` is null) and (`a`.`company` = `b`.`company` or `a`.`company` is null and `b`.`company` is null) and (`a`.`site_id` = `b`.`site_id` or `a`.`site_id` is null and `b`.`site_id` is null);
delete `a` from `jobs` as `a`, `jobs` as `b` where -- important: ensures one version remains and `a`.`title` <=> `b`.`title` and `a`.`company` <=> `b`.`company` and `a`.`site_id` <=> `b`.`site_id`;
delete t1 from my_table t1, my_table t2 where t1.id < t2.id and t1.my_field = t2.my_field and t1.my_field_2 = t2.my_field_2 and ...;
create index temp_idx on jobs(site_id, company, title, location);
( select * from jobs having count(1) > 1 union select * from jobs having count(1) = 1 select * from jobs where id not in select count(1) as jobs, (select count(1) from jobs_dupes) + (select count(1) from jobs_uniques) as sum from jobs;
delete from table where table.idtable in  ( select max(idtable) from idtable having count(*) > 1);
delete from jobs where jobs.id in  ( select max(id) from jobs having count(*) > 1);
alter ignore table jobs add unique index idx_name (site_id, title, company);
create temporary table tmptable (id int);
select  id from    yourtable yt where   exists ( select  * from    yourtabe yt2 where   yt2.title = yt.title and yt2.company = yt.company and yt2.site_id = yt.site_id and yt2.id > yt.id delete from    yourtable where   id in (select id from tmptable);
delete from yourtable using yourtable, tmptable where yourtable.id=tmptable.id;
select id, abc = stuff ( ( select ',' + name from temp1 as t2 where t2.id = t1.id from temp1 as t1;
select ',' + name from temp1 as t2 where t2.id = 42 -- pick a random id from the table;
select ',' + name from temp1;
select abc = stuff(( select ',' + name from temp1 from temp1;
select id,  abc = stuff( (select ',' + name from temp1 t1 where t1.id = t2.id;
select id, string_agg(name, ',') as abc from temp1;
select x.id, stuff((select ','+ z.name from @temp z where x.id =z.id for xml path('')),1,1,'') from @temp x;
select id, abc = stuff( (select ',' + name from temp1 for xml path ('')), 1, 1, '' ) from temp1 group by id;
select * from mytable for xml path('mytable');
name from temp1;
select id, name from temp1;
select  from temp1 from temp1;
abc = (select from temp1 from temp1 abc = (select from temp1 from temp1 group by id;
select id, abc = (select from temp1 ) from temp1 group by id;
select * into x_tbl from tbl;
create table x_tbl as select * from tbl;
create table account ( account_number  char(10), balance integer);
update account set balance = 1000 where account_number = 01;
where name='jon';
select datediff(day, '17530101', datecolumn) % 7 + 1 as mondaybasedday;
select datediff(day, '17530107', datecolumn) % 7 + 1 as sundaybasedday;
select format(getdate(), 'dddd');
create function [dbo].[getdayinweek](@inputdatetime datetime, @weekstartday int) as begin end;
set datefirst 1;
select @@datefirst create table #test (datum datetime) select  substring('sun,mon,tue,wed,thu,fri,sat,sun,mon,tue,wed,thu,fri,sat', (datepart(weekday,datum)+@@datefirst-1)*4+1,3),datum from #test;
set @d=getdate();
set @dow=((datepart(dw,@d) + @@datefirst-2) % 7+1);
create procedure [dbo].[proc_getprojectdeploymenttimesheetdata] @todate date as begin select p.projectname + ' ( ' + st.time +' '+'-'+' '+et.time +' )' as projectdeatils, datename(dw,pts.startdate) as 'day' from projecttimesheet pts join projects p on pts.projectid=p.id join timing st on pts.starttimingid=st.id join timing et on pts.endtimingid=et.id where pts.startdate >= @fromdate and pts.startdate <= @todate end;
select  case datepart(weekday,getdate()) end;
select datename(dw,getdate()) -- friday select datepart(dw,getdate()) -- 6;
set @defaultdatefirst = @@datefirst select  [@defaultdatefirst] = @defaultdatefirst set datefirst @defaultdatefirst select datename(dw,getdate()) -- saturday select datepart(dw,getdate()) -- 7 set datefirst 2 select datename(dw,getdate()) -- saturday select datepart(dw,getdate()) -- 5 <-- it's not 7! set datefirst @defaultdatefirst;
create table temp street varchar(10));
select length(city), length(street) from temp;
select case when divisor=0 then null else dividend / divisor end ,,,;
select dividend / nullif(divisor, 0) ...;
if exists (select * from dbo.sysobjects where  name = 'safedivide') drop function safedivide;
create function dbo.safedivide( @numerator decimal(38,19), @divisor decimal(39,19)) select @p_product = null;
if ( @divisor is not null and @divisor <> 0 and @numerator is not null ) select @p_product = @numerator / @divisor;
select dividend / isnull(nullif(divisor,0), 1) as result from table;
select club_id, males, females, males/females as ratio from school_clubs;
select club_id, males, females, males/nullif(females, 0) as ratio from school_clubs;
select coalesce(dividend / nullif(divisor,0), 0) from sometable;
set arithabort off set ansi_warnings off;
update table1 set col1 = col2 / isnull(nullif(col3,0),1);
select a / nullif(b, 0) from t;
create function dbo.divide(@numerator real, @denominator real) select 'numerator = 0' division, dbo.fn_corp_divide(0,16) results union all select 'denominator = 0', dbo.fn_corp_divide(16,0) union all select 'numerator is null', dbo.fn_corp_divide(null,16) union all select 'denominator is null', dbo.fn_corp_divide(16,null) union all select 'numerator & denominator is null', dbo.fn_corp_divide(null,null) union all select 'numerator & denominator = 0', dbo.fn_corp_divide(0,0) union all select '16 / 4', dbo.fn_corp_divide(16,4) union all select '16 / 3', dbo.fn_corp_divide(16,3) case when @denominator = 0 then else @numerator / @denominator end end go;
set pct = iif(valuea != 0, total / valuea, 0);
select iif(valuea != 0, total / valuea, 0) as pct from tablename;
case when [denominator] = 0 then null --or any value or sub case else [numerator]/[denominator] end as divisionproblem;
update table_name set column_name = replace(column_name, 'oldstring', 'newstring');
update table_name set column_name = replace (column_name , 'oldstring' ,'newstring') where column_name like 'oldstring%';
select replace('this value from table', 'table',  'table but updated');
update publication set doi = replace(doi, '10.7440/perifrasis', '10.25025/perifrasis') where doi like '10.7440/perifrasis%';
set @xml = cast((select [column] as 'td','', ,[startdate] as 'td' from [table] select replace((emailtemplate), '[@xml]', @xml) as newtemplate from [dbo].[template] where id = 1;
update url_table set parameters = replace ( cast(parameters as varchar(max)), 'india', 'bharat') where url_id='150721_013359670';
select replace(imagepath, '~/', '../') as newimagepath from tblmytable;
update table set path = replace(path, 'oldstring', 'newstring') where path = 'oldstring';
update customreports_ta set vchfilter = replace(cast(vchfilter as nvarchar(max)), '\\ingl-report\templates', 'c:\customer_templates') where cast(vchfilter as nvarchar(max)) like '%\\ingl-report\templates%';
update my_table set path = replace(path, 'oldstring', 'newstring');
update [table] set [column] = replace([column], '/foo/', '/bar/');
create or replace function concat_return_row_count(tbl_name text, column_name text, value int);
select string_agg('drop table if exists "' || tablename || '" cascade', ';') from pg_tables where schemaname != $$pg_catalog$$ and tablename like $$rm_%$$;
select company_id, listagg(employee, ', ') as employees from employee_table;
select company_id, string_agg(employee, ', ') from employees;
select company_id, string_agg(employee, ', ') from mytable group by company_id;
create aggregate textcat_all( basetype    = text, sfunc       = textcat, stype       = text, initcond    = '' select company_id, textcat_all(employee || ', ') from mytable;
select company_id, string_agg(employee, ', ') from mytable;
select company_id, string_agg(employee, ', ' order by employee) from mytable;
select string_agg(actor_name, ', ' order by first_appearance);
select company_id, array_to_string(array_agg(employee), ', ') from mytable;
select string_agg(name, '; ') as semi_colon_separated_names from things;
select string_agg(name, '; ' order by name) as semi_colon_separated_names from things;
create function string_agg_transfn(text, text, text) if $1 is null then else return $1 || $3 || $2;
create aggregate string_agg(text, text) ( sfunc=string_agg_transfn, stype=text;
create aggregate textcat_all( basetype    = text, sfunc       = textcat, stype       = text, initcond    = '';
create aggregate;
create function commacat(acc text, instr text) returns text as $$ if acc is null or acc = '' then else return acc || ', ' || instr;
create function commacat_ignore_nulls(acc text, instr text) returns text as $$ if acc is null or acc = '' then else return acc || ', ' || instr;
create or replace function concat2(text, text) returns text as ' select case when $1 is null or $1 = \'\' then $2 else $1 || \' / \' || $2 create aggregate concatenate ( sfunc = concat2, basetype = text, stype = text, initcond = '';
select company_id, concatenate(employee) as employees from ...;
select itemid, case itemdescription when '' then itemname else itemname || ' (' || itemdescription || ')' end from items;
create aggregate array_accum (anyelement) ( sfunc = array_append, stype = anyarray, initcond = '{}' select array_to_string(array_accum(name),'|') from table group by id;
select custom_aggregate(my.special_strings) from (select special_strings, grouping_column from a_table;
select company_id, array_to_string(array_agg(employee), ',') from mytable;
select company_id, string_agg(employee, ', ') from mytable;
select * from localtable, [otherservername].[otherdb].[dbo].[othertable];
select * from [server2name].[thedb].[theowner].[thetable];
select * from table1 select * from [server1].[database].[dbo].[table1];
select * from linkedservername.databasename.ownername.tablename;
exec sp_addlinkedserver @server='ip,port\instancename';
exec sp_addlinkedsrvlogin 'ip,port\instancename', 'false', null, 'remote_db_loginname', 'remote_db_pass';
select col1, col2, col3 from [ip,port\instancename].[linkeddbname].[linkedtblschema].[linkedtblname];
select top 2 * from dbo.tblhamdoonsoft  tbl1 inner join;
exec sp_addlinkedserver @server='srv_name', @srvproduct=n'', @provider=n'sqlncli', @datasrc=n'aaa.bbb.ccc.ddd';
exec sp_addlinkedsrvlogin 'srv_name', 'false', null, 'your_remote_db_login_user', 'your_remote_db_login_password';
select * from [srv_name].your_remote_db_name.dbo.your_table;
select * from [sys].[servers];
select * from [server name or ip addresses ].databasename.dbo.tblname;
select * from openrowset('sqlncli', 'server=your server;trusted_connection=yes;','select * from table1') as a union select * from openrowset('sqlncli', 'server=another server;trusted_connection=yes;','select * from table1') as a;
select * from [servername(ip)].[databasename].[dbo].[tablename];
select id, group_concat(name separator ' ') from table group by id;
select id, group_concat( string separator ' ') from table group by id;
select id, group_concat(cast(name as char)) from table group by id;
set group_concat_max_len=100000000;
select pub_id,group_concat(cate_id separator ' ') from book_mast group by pub_id;
select id, group_concat(name separator ' ') from table group by id;
->     group_concat(distinct test_score;
select id, group_concat(coalesce(name,'') separator ' ') from table;
select field_1, field_2, field_2, random() as ordering from big_table where some_conditions ordering limit 1000;
select * from table order by random() limit 1000;
create extension tsm_system_rows;
select * from table;
select * from table_name limit 1;
select * from mytable tablesample system (5);
select * from your_table where r > ( select ( select reltuples::bigint as estimate from   pg_class where  oid = 'public.your_table'::regclass) * random() );
create materialized view id_values_randomized as select id from id_values;
update id_values set used = true where id_values.id in from id_values_randomized r inner join id_values i on i.id = r.id where (not i.used) limit 5);
select your_columns from your_table order by random();
select your_columns from your_table order by random() limit 1;
select * from table where random() < 0.01;
select * from table order by random() limit 1000;
where random() < 0.1;
select * from table where random() < 0.01 limit 1000;
select count(*) as ct              -- optional from   big;
select reltuples as ct from pg_class where oid = 'schema_name.big'::regclass;
select 1       as min_id           -- minimum id <= current min id ) select * from  ( select p.min_id + trunc(random() * p.id_span)::integer as id from   params p join   big using (id) limit  1000;                           -- trim surplus;
select * from  ( select distinct 1 + trunc(random() * 5100000)::integer as id from   generate_series(1, 1100) g join   big using (id) limit  1000;
select * from  ( select 1 + trunc(random() * 5100000)::int as id from   generate_series(1, 1030)  -- 1000 + few percent - adapt to your needs limit  1030                      -- hint for query planner join   big b using (id)             -- eliminate miss union                               -- eliminate dupe select b.* from  ( select 1 + trunc(random() * 5100000)::int as id from   random_pick r             -- plus 3 percent - adapt to your needs limit  999                       -- less than 1000, hint for query planner join   big b using (id)             -- eliminate miss ) select * from   random_pick limit  1000;  -- actual limit;
create or replace function f_random_sample(_limit int = 1000, _gaps real = 1.03) select c.reltuples * _gaps from   pg_class c where  c.oid = 'big'::regclass);
select * from  ( select 1 + trunc(random() * _estimate)::int from   generate_series(1, _surplus) g limit  _surplus           -- hint for query planner join   big using (id)        -- eliminate misses union                        -- eliminate dupes select * from  ( select 1 + trunc(random() * _estimate)::int from   random_pick        -- just to make it recursive limit  _limit             -- hint for query planner join   big using (id)        -- eliminate misses ) select * from   random_pick limit  _limit;
end $func$  language plpgsql volatile rows 1000;
select * from f_random_sample();
select * from f_random_sample(500, 1.05);
select * from big tablesample system ((1000 * 100) / 5100000.0);
select * from big tablesample system_rows(1000);
select concat('select ''', table_name ,''' as tablename, count(*) as rowcount from ' , table_name , ' union all ')  as tr from;
select table_name, sum(table_rows) from information_schema.tables where table_schema = '{your_db}';
select concat( 'select * from (\n', group_concat( single_select separator ' union\n'), '\n ) q order by q.exact_row_count desc') as sql_query from ( select concat( 'select "', table_name, '" as table_name, count(1) as exact_row_count from `', table_schema, '`.`', table_name, '`' from information_schema.tables where table_schema = 'your_schema_name' and table_type = 'base table';
set @table_schema = database();
set group_concat_max_len=131072;
set @selects = null;
select group_concat( 'select "', table_name,'" as table_name, count(*) as table_rows from `', table_name, '`' from information_schema.tables where table_schema = @table_schema and engine = 'innodb' and table_type = "base table";
select concat_ws('\nunion\n', concat('select table_name, table_rows from information_schema.tables where table_schema = ? and engine <> "innodb" and table_type = "base table"'), @selects) into @selects;
select table_schema 'database', sum(data_length + index_length) as 'dbsize', sum(table_rows) as dbrows, sum(auto_increment) as dbautoinccount from information_schema.tables;
select table_schema 'database', sum(data_length + index_length) as 'dbsize', greatest(sum(table_rows), sum(auto_increment)) as dbrows from information_schema.tables;
select count(distinct t1.id) + from firsttable t1, secondtable t2, thirdtable t3;
select concat( 'select "', table_name, '" as table_name, count(*) as exact_row_count from `', table_schema, '`.`', table_name, '` union ' ) from information_schema.tables where table_schema = '**my_schema**';
select "func" as table_name, count(*) as exact_row_count from my_schema.func union select "general_log" as table_name, count(*) as exact_row_count from my_schema.general_log union select "help_category" as table_name, count(*) as exact_row_count from my_schema.help_category union select "help_keyword" as table_name, count(*) as exact_row_count from my_schema.help_keyword union select "help_relation" as table_name, count(*) as exact_row_count from my_schema.help_relation union select "help_topic" as table_name, count(*) as exact_row_count from my_schema.help_topic union select "host" as table_name, count(*) as exact_row_count from my_schema.host union select "ndb_binlog_index" as table_name, count(*) as exact_row_count from my_schema.ndb_binlog_index union;
select table_name, table_rows from `tables` where `table_rows` >=0;
end sql_2.finish end ;
table users has 7328974 rows.;
create definer=`root`@`127.0.0.1` procedure `count_all_records_by_table`() select table_name from information_schema.tables where table_schema = database();
drop table if exists tcounts;
create temporary table tcounts ( table_name char(255), record_count int if done = 0 then set @sql_txt = concat("insert into tcounts(select '" , tname  , "' as table_name, count(*) as record_count from ", tname, ")");
select * from tcounts;
select sum(record_count) as total_database_record_ct from tcounts;
select table_name,sum(table_rows) from information_schema.tables where table_schema = 'your_db';
select concat('select "', table_schema, '.', table_name, '" as `schema.table`, count(*) from ', table_schema, '.', table_name, ' union ') as 'query row' from information_schema.tables union select '(select null, null limit 0);';
select ifnull(table_schema,'total') "database",tablecount from (select count(1) tablecount,table_schema from information_schema.tables where table_schema not in ('information_schema','mysql');
if [ ! -z "$4" ]; then else pat="" if [ $tot -lt 0 ]; then else c=`mysql -u "$un" -p"$pw" "$db" -e "select count(*) from $t"`;
select table_name, table_rows from information_schema.tables where table_schema = '**your schema**';
select sum(table_rows) from information_schema.tables where table_schema = '{your_db}';
select t1.id from table1 t1 where t2.id is null;
where t2.id is null;
select * from t2 where constrained_field not in ( select distinct t.constrained_field from t2 );
create view authorizeduserprojectview as select t1.username as username, t1.email as useremail, p.id as projectid, (select m.role from userproject m where m.projectid = p.id and m.userid = t1.id) as role from authorizeduser as t1, project as p;
select * from authorizeduserprojectview where projectid = 49;
select * from bigtable where smalltable.id is null;
select ifnull(`price`.`fprice`,100) as fprice,product.productid,productname from `products` left join `price` on;
select * from employee where id not in(select e.id from employee e inner join salary s on e.id=s.id);
select * from employee e;
select * from employee e;
select id  from  table_1 except select distinct (table1_id) table1_id from table_2;
select count(*) from table_1 where id in (select id  from  table_1 except select distinct (table1_id) table1_id from table_2);
select t1.id from table1 t1 where not exists (select t2.id from table2 t2 where t1.id = t2.id);
select id from table1 where foreign_key_id_column not in (select id from table2);
create or replace function oftool_fkey_missing_indexes () src_table     regclass, fk_columns    varchar, table_size    varchar, fk_constraint name, dst_table     regclass ) as $$ select -- source table having ta foreign key declaration   pg_catalog.pg_relation_size(tc.conrelid)   from pg_catalog.pg_constraint tc join pg_catalog.pg_attribute ta on ta.attnum = tx.attnum and ta.attrelid = tc.conrelid where not exists ( -- is there ta matching index for the constraint? select 1 from pg_catalog.pg_index i where i.indrelid = tc.conrelid and tc.conrelid, tc.conname, tc.confrelid pg_catalog.pg_relation_size(tc.conrelid) desc;
select * from oftool_fkey_missing_indexes();
values ( 'a', 'error' ), ( 'r', 'restrict' ), ( 'c', 'cascade' ), ( 'n', 'set null' ), ( 'd', 'set default' ) fk_list as ( select pg_constraint.oid as fkoid, conrelid, confrelid as parentid, conname, relname, nspname, fk_actions_update.action as update_action, fk_actions_delete.action as delete_action, conkey as key_cols from pg_constraint join pg_class on conrelid = pg_class.oid join pg_namespace on pg_class.relnamespace = pg_namespace.oid join fk_actions as fk_actions_update on confupdtype = fk_actions_update.code join fk_actions as fk_actions_delete on confdeltype = fk_actions_delete.code where contype = 'f' fk_attributes as ( select fkoid, conrelid, attname, attnum from fk_list join pg_attribute and attnum = any( key_cols ) fk_cols_list as ( select fkoid, array_agg(attname) as cols_list from fk_attributes index_list as ( select indexrelid as indexid, pg_class.relname as indexname, indrelid, indkey, indpred is not null as has_predicate, pg_get_indexdef(indexrelid) as indexdef from pg_index join pg_class on indexrelid = pg_class.oid where indisvalid fk_index_match as ( select fk_list.*, indexid, indexname, indkey::int[] as indexatts, has_predicate, indexdef, array_length(key_cols, 1) as fk_colcount, array_length(indkey,1) as index_colcount, round(pg_relation_size(conrelid)/(1024^2)::numeric) as table_mb, cols_list from fk_list join fk_cols_list using (fkoid) and (indkey::int2[])[0:(array_length(key_cols,1) -1)] @> key_cols fk_perfect_match as ( select fkoid from fk_index_match where (index_colcount - 1) <= fk_colcount and not has_predicate and indexdef like '%using btree%' fk_index_check as ( select 'no index' as issue, *, 1 as issue_sort from fk_index_match where indexid is null union all select 'questionable index' as issue, *, 2 from fk_index_match where indexid is not null and fkoid not in ( select fkoid from fk_perfect_match) parent_table_stats as ( select fkoid, tabstats.relname as parent_name, (n_tup_ins + n_tup_upd + n_tup_del + n_tup_hot_upd) as parent_writes, round(pg_relation_size(parentid)/(1024^2)::numeric) as parent_mb from pg_stat_user_tables as tabstats join fk_list fk_table_stats as ( select fkoid, (n_tup_ins + n_tup_upd + n_tup_del + n_tup_hot_upd) as writes, seq_scan as table_scans from pg_stat_user_tables as tabstats join fk_list ) select nspname as schema_name, relname as table_name, conname as fk_name, issue, table_mb, writes, table_scans, parent_name, parent_mb, parent_writes, cols_list, indexdef from fk_index_check join parent_table_stats using (fkoid) join fk_table_stats using (fkoid) where table_mb > 9 and ( writes > 1000 or parent_writes > 1000 or parent_mb > 10 );
select n.nspname  as "schema" from pg_catalog.pg_class c join pg_catalog.pg_namespace n on n.oid        = c.relnamespace join pg_catalog.pg_index i     on i.indexrelid = c.oid join pg_catalog.pg_class t     on i.indrelid   = t.oid where c.relkind = 'i' and n.nspname not in ('pg_catalog', 'pg_toast') and pg_catalog.pg_table_is_visible(c.oid) n.nspname;
where something like 'bla%' or something like '%foo%' or something like 'batz%';
from yourtable                y;
select distinct * from @x x where x.x like '%abc%' or x.x like '%b%' select distinct x.* from @x             x;
select t.somefield from yourtable t join #temptablewithconditions c on t.something like c.conditionvalue;
select ... from sometable join (select 'bla%' as pattern union all select '%foo%' union all select 'batz%' union all select 'abc';
select fish.* from fish join dbo.split('%ass,%e%',',') as splits;
where contains(t.something, 'bla or foo or batz', 1) > 0;
where contains(t.something, '"bla*" or "foo*" or "batz*"');
where col like any( subselect );
where col like all( subselect );
where something + '%' in ('bla', 'foo', 'batz') or '%' + something + '%' in ('tra', 'la', 'la');
where something + '%' in (select col from table where ....);
create  function [dbo].[fn_split](@text varchar(8000), @delimiter varchar(20)) ( position int identity primary key, value varchar(8000) ) as begin set @index = -1 set @index = charindex(@delimiter , @text) if (@index = 0) and (len(@text) > 0) end if (@index > 1) set @text = right(@text, (len(@text) - @index)) end else set @text = right(@text, (len(@text) - @index)) end return end;
select * from my_table inner join (select value from fn_split('abc,mop',',')) as split_table on my_table.column_name like '%'+split_table.value+'%';
@subwhere nvarchar(max) set @subwhere = stuff( ( select ' or personname like ''' + [nametoselect] + '%''' from [namestoselect] t for xml path('') set @sql ='select from [persons] where gender = @gender and birthdate = @birthdate and (' + @subwhere + ')' set @params = ' @gender nchar(1), @birthdate date' @gender, @birthdate;
set @arc_checknum = 'abc,135,med,asfsdfsf,axx' select ' and (a.arc_checknum like ''%' + replace(@arc_checknum,',','%'' or a.arc_checknum like ''%') + '%'')'';
and (a.arc_checknum like '%abc%' or a.arc_checknum like '%135%' or a.arc_checknum like '%med%' or a.arc_checknum like '%asfsdfsf%' or a.arc_checknum like '%axx%');
select [name] from usr join (values ('hotmail'),('gmail'),('live')) as mytable(mycolumn) on email like '%'+mytable.mycolumn+'%';
select  * from    table t inner join ( select * from (values('bla'),('foo'),('batz')) as list(col);
select  * from    table t where contains(t.column, '"bla*" or "foo*" or "batz*"');
select * from customer where last_name [ not ] like any ('a%', 'e%') [ escape '!' ];
select * from customer where last_name like 'a%' or last_name like 'e%';
select * from t where c like any (array['a%', '%b']);
select * from t where c like any ('{"do%", "%at"}');
select * from like_example where subject like any ('%jo%oe%','t%e');
set @dashboard = 'p1%,p7%' select * from project p join string_split(@dashboard, ',') as sp on p.projectnumber like sp.value;
like any ('%abc%','%pqr%','%xyz%');
select * from random_table a where (lower(a.tran_1_dsc) like ('%american%express%centurion%bank%') or lower(a.tran_1_dsc) like ('%bofi%federal%bank%') or lower(a.tran_1_dsc) like ('%american%express%bank%fsb%')) select * from random_table  a where lower(a.tran_1_dsc) like any '%bofi%federal%bank%', '%american%express%bank%fsb%');
set ansi_nulls on set quoted_identifier on create or alter function lichen ( -- add the parameters for the function here @delimiter nchar(1) = ';', @colidentifier nvarchar(64), @argstring nvarchar(256) ) as begin if not @delimiter = @delimit set @delimit = @delimiter if charindex(@delimit, @argstring) > 1  -- check for the like in delimiter select @linecount = count(*) from @lichentable if @leadingand = 1 set @result = ' and (' else set @result = ' (' if (@loopcount = 1) -- the first loop does not get the or in front select @result = concat(@result, ' ', @colidentifier, ' like ''', line, '''') from @lichentable where id = @loopcount else  -- but all subsequent loops do select @result = concat(@result, ' or ', @colidentifier, ' like ''', line, '''') from @lichentable where id = @loopcount set @loopcount = @loopcount + 1     -- increment loop end -- end loop through @lichentable set @result = concat(@result, ' )') end  -- end 'like in' branch having found a delimiter else -- no delimiter was provided if @leadingand = 1 set @result = concat(' and ', @colidentifier, ' like ''' + @argstring + '''') else set @result = concat(' ', @colidentifier, ' like ''' + @argstring + '''') end     -- end "no delimiter found" branch end  -- end lichen function;
select [dbo].[lichen] ( default        -- @leadingand, bit, default: 1 );
and ( foo.bar like '01%' or foo.bar like '02%' or foo.bar like '%03%' );
select [dbo].[lichen] ( default        -- @leadingand, bit, default: 1 );
and foo.bar like '01%';
( 'ask not what your country can do for you.' ), ( 'cupcakes are the new hotness.' );
( 'hotness' ), ( 'cupcakes' );
select * from @example e where exists ( select * from @filter f where e.sampletext like '%' + searchtext + '%' );
select * from table where something like ('bla% %foo% batz%');
where exists (select 1 from table(ku$_vcnt('bla%', '%foo%', 'batz%')) where something like column_value);
create type my_collection as table of varchar2(4000);
select * from tb_your t1 where substring(t1.something, 1,3) in ('bla', 'foo', 'batz');
select * from database.table where lower(drug_name) like any ('{%cillin%,%cyclin%,%xacin%,%mycine%,%cephal%}');
select 'success !!!' result from dual where regexp_like('three', 'one|two|three|four|five');
select 'success !!!' result from dual where regexp_like('ten', 'one|two|three|four|five');
where exists (select 1 from (select 'bla%' pattern from dual union all select '%foo%'        from dual union all select 'batz%'        from dual) where something like pattern);
where exists (select 1 from table_of_patterns t where something like t.pattern);
select * from db where date >= '20100401'  (format of date yyyymmdd);
select * from dbo.march2010 a where cast(a.date as date) >= '2017-03-22';
select * from dbo.march2010 a where cast(a.date as datetime) >= '2017-03-22 06:49:53.840';
select * from dbo.march2010 a where a.date >= start1;
select * from dbo.march2010 a where a.date >= '2010-04-01';
select * from dbo.march2010 a where a.date >= convert(datetime, '2010-04-01' );
select * from dbo.march2010 a where a.date >= 2005;
select * from dbo.march2010 a where a.date >= '2010-04-01';
select t1.datname as db_name, pg_size_pretty(pg_database_size(t1.datname)) as db_size from pg_database t1;
select pg_size_pretty(pg_database_size('database name'));
select pg_size_pretty(pg_relation_size('table_name'));
select d.datname as name,  pg_catalog.pg_get_userbyid(d.datdba) as owner, case when pg_catalog.has_database_privilege(d.datname, 'connect') then pg_catalog.pg_size_pretty(pg_catalog.pg_database_size(d.datname)) else 'no access' end as size from pg_catalog.pg_database d case when pg_catalog.has_database_privilege(d.datname, 'connect') then pg_catalog.pg_database_size(d.datname) else null end desc -- nulls first limit 20;
select datname as databasename then pg_catalog.pg_size_pretty(pg_catalog.pg_database_size(datname)) else 'no access for you' end as databasesize from pg_catalog.pg_database case when pg_catalog.has_database_privilege(datname, 'connect') then pg_catalog.pg_database_size(datname) else null end desc;
select pg_size_pretty(pg_database_size('name of database'));
select datname from pg_database where datistemplate = false end loop;
select pg_database.datname as "database_name", pg_size_pretty(pg_database_size(pg_database.datname)) as size_in_mb from pg_database order by size_in_mb desc;
select convert (varchar(10), columnname) from tablename;
select ltrim(columnname) from tablename;
select cast(your_column_name as varchar(10)) from your_table_name;
select str(field_name) from table_name;
select convert(varchar(10), field_name) from table_name;
select distributor_id, count(*) total, sum(case when level = 'exec' then 1 else 0 end) execcount, sum(case when level = 'personal' then 1 else 0 end) personalcount from yourtable select a.distributor_id, (select count(*) from mytable where level='personal' and distributor_id = a.distributor_id) as personalcount, (select count(*) from mytable where level='exec' and distributor_id = a.distributor_id) as execcount, (select count(*) from mytable where distributor_id = a.distributor_id) as totalcount from mytable a ;
if object_id (n't1', n'u') is not null drop table t1 create table t1 (f1 int) select sum(case when f1 = 1 then 1 else 0 end), sum(case when f1 = 2 then 1 else 0 end), sum(case when f1 = 3 then 1 else 0 end), sum(case when f1 = 4 then 1 else 0 end) from t1 select (select count(*) from t1 where f1 = 1), (select count(*) from t1 where f1 = 2), (select count(*) from t1 where f1 = 3), (select count(*) from t1 where f1 = 4);
create clustered index t1f1 on t1(f1);
update statistics t1;
select distributor_id, count(*) total, sum(level = 'exec') execcount, sum(level = 'personal') personalcount from yourtable;
select a.distributor_id, (select count(*) from mytable where level='personal' and distributor_id = a.distributor_id) as personalcount, (select count(*) from mytable where level='exec' and distributor_id = a.distributor_id) as execcount, (select count(*) from mytable where distributor_id = a.distributor_id) as totalcount from (select distinct distributor_id from mytable) a ;
select distributor_id, count() from ... union select count() as exec_count from ... where level = 'exec' union select count(*) as personal_count from ... where level = 'personal';
select distributor_id, count(*) from ... group by level;
select distributor_id, count(*) as total, count(if(level='exec',1,null)), count(if(level='personal',1,null)) from sometable;
select distributor_id, count(*) as total, sum(case when level = 'exec' then 1 else 0 end) as execcount, sum(case when level = 'personal' then 1 else 0 end) as personalcount from yourtable;
select 'table1', count (*) from table1 union select 'table2', count (*) from table2 union select 'table3', count (*) from table3 union select 'table4', count (*) from table4 union select 'table5', count (*) from table5 union select 'table6', count (*) from table6 union select 'table7', count (*) from table7;
select distributor_id, count(*) total, sum(case when level = 'exec' then 1 else 0 end) over() execcount, sum(case when level = 'personal' then 1 else 0 end) over () personalcount from yourtable;
select count(*) as anc,(select count(*) from patient where sex='f')as patientf,(select count(*) from patient where sex='m') as patientm from anc;
select count(*) as anc,(select count(*) from patient where patient.id=anc.patientid)as patientf,(select count(*) from patient where sex='m') as patientm from anc;
select count(distinct columnname) as columnnamecount from tablename;
select count(distinct column_name) as some_alias from table_name;
select count(distinct column_name) from table as column_name_count;
select count(distinct my_col) from my_table;
select count(*) from ( select distinct column1,column2,column3,column4 from abcd;
select [columnname], count([columnname]) as countof from [tablename];
select column_name, count(*) from table_name group by column_name order by 2 desc;
select count(distinct(column_name)) from tablename;
select count(distinct(column_name)) as columndatacount from table_name where somecondition=true;
select column_name, count(column_name) over (partition by column_name) from table_name group by column_name ;
create table a(a varchar(10), b varchar(10), d date , unique(a,b));
values (null, null, now()),('a', null, now()),(null, 'b', now()),('c', 'b', now());
create table b(id int primary key, ref_a varchar(10), ref_b varchar(10));
alter table b add constraint b_fk foreign key (ref_a, ref_b) alter table b drop constraint if exists b_fk; -- cleanup alter table b add constraint b_fk foreign key (ref_a, ref_b) delete from b; alter table b drop constraint if exists b_fk; -- cleanup alter table b add constraint b_fk foreign key (ref_a, ref_b);
create table tbl_country ( country_id varchar2 (50) not null ) ;
alter table tbl_country add constraint country_pk primary key ( country_id ) ;
create table tbl_province( province_id varchar2 (50) not null , country_id  varchar2 (50) alter table tbl_province add constraint province_pk primary key ( province_id ) ;
alter table tbl_province add constraint province_country_fk foreign key ( country_id ) references tbl_country ( country_id ) ;
drop table table_name;
drop table table_name;
if sqlcode != -942 then end if;
create table "ims"."max" "name" varchar2(20 byte), constraint "max_pk" primary key ("id");
select dbms_metadata.get_ddl('table','dept','scott') into v_ddl from dual;
if sqlcode = -31603 then else raise;
select count(*) from   dba_tables where  owner = 'schema_name' and table_name = 'employee_table';
if table_exist = 1 then end if;
select into cant count(*) from dba_tables where table_name='table_name';
if count>0 then drop table tablename;
select @count=count(*) from all_tables where table_name='table_name';
if @count>0 drop table tablename;
select count(*) into c from user_tables where table_name = upper('table_name');
if c = 1 then end if;
if sqlcode != -942 then end if;
if sqlcode != -2289 then end if;
if sqlcode != -942 then end if;
if sqlcode != -4080 then end if;
if sqlcode != -1418 then end if;
if sqlcode != -904 and sqlcode != -942 then end if;
if sqlcode != -2024 then end if;
if sqlcode != -12003 then end if;
if sqlcode != -4043 then end if;
if sqlcode != -2443 and sqlcode != -942 then end if;
if sqlcode != -27475 then end if;
if sqlcode != -1918 then end if;
if sqlcode != -4043 then end if;
if sqlcode != -4043 then end if;
if sqlcode != -4043 then end if;
if sqlcode != -959 then end if;
if sqlcode != -1434 then end if;
if sqlcode != -942 then end if;
select count(*) into v_counter from dba_users where upper(username)=upper('userschema01');
if v_counter > 0 then end if;
create user userschema01 identified by pa$$word default tablespace users;
select count(*) into v_counter from all_tables where upper(table_name)=upper('orders') and upper(owner)=upper('userschema01');
if v_counter > 0 then end if;
create or replace procedure delobject(objname varchar2,objtype varchar2) if objtype = 'table' then select count(*) into v_counter from user_tables where table_name = upper(objname);
if v_counter > 0 then end if;
if objtype = 'procedure' then select count(*) into v_counter from user_objects where object_type = 'procedure' and object_name = upper(objname);
if v_counter > 0 then end if;
if objtype = 'function' then select count(*) into v_counter from user_objects where object_type = 'function' and object_name = upper(objname);
if v_counter > 0 then end if;
if objtype = 'trigger' then select count(*) into v_counter from user_triggers where trigger_name = upper(objname);
if v_counter > 0 then end if;
if objtype = 'view' then select count(*) into v_counter from user_views where view_name = upper(objname);
if v_counter > 0 then end if;
if objtype = 'sequence' then select count(*) into v_counter from user_sequences where sequence_name = upper(objname);
if v_counter > 0 then end if;
select * from test where text like '%something%' limit 1;
select count(*) as count from test where text like '%something%;
select exists(select 1 from test where text like '%something%');
select exists(select 1 from test where text like '%something%' limit 1);
select * from test2 where id ='321321' limit 1;
select count(*) as count from test2 where id ='321321';
select exists(select 1 from test2 where id ='321321');
select exists(select 1 from test2 where id ='321321' limit 1);
select exists(select * from table1 where ...);
select * from table where condition=value select exists(select * from table where condition=value) select count(*) from table where condition=value limit 1) select exists(select * from table where condition=value limit 1);
select 1 from my_table where *indexed_condition* limit 1;
select * from my_table where *indexed_condition* limit 1;
select exists(select * from my_table where *indexed_condition*);
select exists(select 1 from my_table where *indexed_condition*);
select ifnull(`id`, count(*)) from where ...;
exec sp_serveroption 'sqlservername', 'data access', true;
select  *  from openquery(sqlservername, 'exec dbname..myproc @parameters');
logdate datetime, processinfo nvarchar(max), [text] nvarchar(max) ) select logdate as dateoccured, processinfo as pinfo, [text] as message from @tblvar if object_id('tempdb..#temp') is not null  drop table #temp;
create table #temp ( logdate datetime, processinfo nvarchar(55), text nvarchar(max) ) select * from #temp;
exec sp_serveroption 'serverx', 'data access', true;
set @studentid = 'student01';
set @cmd = 'select * from openquery([serverx], ''set fmtonly off; set nocount on; execute mydatabase.dbo.mystoredproc ' + @studentid + ''') where somefield = somevalue';
select top(1)* from openquery( [server], 'set fmtonly off; set nocount on; execute  [database].[dbo].[storedprocedure]  value,value ');
( firstcolumn int );
exec [dbo].[mystoredprocedure];
select * from @mytabletype;
create function myproc();
select * from myproc();
create function funcname (@para1 para1_type, @para2 para2_type , ... );
select * from funcname ( @para1 , @para2 );
select  *  from where somefield = anyvalue;
select * from @t where ...;
create table #getversionvalues ( [index] int, [name]  sysname, internal_value  int, character_value sysname ) select * from #getversionvalues drop table #getversionvalues;
select ...fieldlist... from openrowset('sqlncli', 'connection string', 'name of sp') where ...;
from models where areaid = 'south coast');
select top 1 @modelid = m.modelid from models m where m.areaid = 'south coast';
select @modelid =m.modelid from   models m where  m.areaid = 'south coast';
set @modelid = (select modelid from models where areaid = 'south coast') select @modelid;
declare @test int = (select 1) set @test = (select 1) set @test2 = (select a from (values (1),(2)) t(a)) -- throws error select @test = (select 1);
set @modelid = (select top(1) modelid from models where areaid = 'south coast');
select top(1)@modelid = modelid from models where areaid = 'south coast';
select @modelid = modelid from models where areaid = 'south coast';
select @modelid = m.modelid from models m where m.areaid = 'south coast';
set @modelid = (select m.modelid from models m where m.areaid = 'south coast');
values 'joe', 'o''brien';
values ('joe', 'o''brien');
select first, last from person where last = 'o''brien';
values ('joe', 'o''brien');
[first] nvarchar(200), [last] nvarchar(200) ) values ('joe', 'o''brien') select * from @person;
values 'joe', concat('o',char(39),'brien');
create table t4000 (a nvarchar(4000) null);
create table tmax (a nvarchar(max) null);
select top 1000000 @abc4 from master.sys.all_columns ac1, master.sys.all_columns ac2;
select top 1000000 @abc from master.sys.all_columns ac1, master.sys.all_columns ac2;
set statistics time on;
set statistics io on;
select * from dbo.t4000;
select * from dbo.tmax;
@starttime datetime;
select @starttime = getdate();
select top 1000000 from master.sys.all_columns ac1, master.sys.all_columns ac2;
select testtime='10', duration = datediff(ms,@starttime,getdate());
@starttime datetime;
select @starttime = getdate();
select top 1000000 from master.sys.all_columns ac1, master.sys.all_columns ac2;
select testtime='4000', duration = datediff(ms,@starttime,getdate());
@starttime datetime;
select @starttime = getdate();
select top 1000000 from master.sys.all_columns ac1, master.sys.all_columns ac2;
select testtime='max', duration = datediff(ms,@starttime,getdate());
create table [dbo].[busdata]( [id] [int] identity(1,1) not null, [recordid] [nvarchar](max) null, [companyname] [nvarchar](max) not null, [firstname] [nvarchar](max) not null, [lastname] [nvarchar](max) not null, [address] [nvarchar](max) not null, [city] [nvarchar](max) not null, [county] [nvarchar](max) not null, [state] [nvarchar](max) not null, [zip] [nvarchar](max) not null, [phone] [nvarchar](max) not null, [country] [nvarchar](max) not null, [npa] [nvarchar](max) null, [nxx] [nvarchar](max) null, [xxxx] [nvarchar](max) null, [currentrecord] [nvarchar](max) null, [totalcount] [nvarchar](max) null, [status] [int] not null, [changedate] [datetime] not null;
create table [dbo].[busdata]( [id] [int] identity(1,1) not null, [recordid] [nvarchar](50) null, [companyname] [nvarchar](50) not null, [firstname] [nvarchar](50) not null, [lastname] [nvarchar](50) not null, [address] [nvarchar](50) not null, [city] [nvarchar](50) not null, [county] [nvarchar](50) not null, [state] [nvarchar](2) not null, [zip] [nvarchar](16) not null, [phone] [nvarchar](18) not null, [country] [nvarchar](50) not null, [npa] [nvarchar](3) null, [nxx] [nvarchar](3) null, [xxxx] [nvarchar](4) null, [currentrecord] [nvarchar](50) null, [totalcount] [nvarchar](50) null, [status] [int] not null, [changedate] [datetime] not null;
from django.db import connection;
select "auth_user"."id", "auth_user"."password", "auth_user"."last_login", "auth_user"."is_superuser", "auth_user"."username", "auth_user"."first_name", "auth_user"."last_name", "auth_user"."email", "auth_user"."is_staff", "auth_user"."is_active", "auth_user"."date_joined" from "auth_user" where "auth_user"."id" = 1;
from django.conf import settings from django.db import connection;
from django_print_sql import print_sql # e.g. some complex foreign key lookup, # or analyzing a drf serializer's performance;
from django_print_sql import print_sql_decorator;
from django.db import connections from app_name import models from django.utils import timezone;
from django.db import connection;
from django.db import connection;
from django.db import connection if not sql[0]: sql = sql[1:];
from .utils import sql_logger;
select sc.name as 'field', isc.data_type as 'type', isc.character_maximum_length as 'length', sc.is_nullable as 'null', i.is_primary_key as 'key', sc.is_identity as 'identity' from sys.columns as sc and isc.column_name = sc.name where sc.object_id = object_id('dbo.expenses');
exec sp_help tablename;
exec sp_columns mytable;
select * from information_schema.columns where table_name = 'aspnet_membership';
select a.[name] from ( select column_name                                     as [name] else data_type end                                             as [type] from information_schema.columns where table_name = @objectname ( select cast(value as nvarchar)                        as [comments] from ::fn_listextendedproperty ('ms_description', 'user', 'dbo', 'table', @objectname, 'column', default) a.[ordinal_position];
if object_id('sp_desc', 'p') is not null drop procedure sp_desc create procedure sp_desc ( @tablename  nvarchar(128) select @dbname = parsename(@tablename, 3);
if @dbname is null select @dbname = db_name();
select @schemaname = parsename(@tablename, 2);
if @schemaname is null select @schemaname = schema_name();
select @objectname = parsename(@tablename, 1);
if @objectname is null select @objectid = object_id(@dbname + '.' + @schemaname + '.' + @objectname);
if @objectid is null select @tmptablename = '#tmp_desc_' + cast(@@spid as varchar) + replace(replace(replace(replace(cast(convert(char, getdate(), 121) as varchar), '-', ''), ' ', ''), ':', ''), '.', '');
set @sqlcmd = ' create table ' + @tmptablename + ' ( [name]              nvarchar(128) not null select a.[name] from ( select column_name                                     as [name] else data_type end                                             as [type] from information_schema.columns where table_name = ''' + @objectname + ''' ( select cast(value as nvarchar)                        as [comments] from ::fn_listextendedproperty (''ms_description'', ''user'', ''' + @schemaname + ''', ''table'', ''' + @objectname + ''', ''column'', default) a.[ordinal_position];
select * from ' + @tmptablename + ';' exec sp_executesql @sqlcmd;
exec sys.sp_ms_marksystemobject sp_desc;
exec sp_desc 'yourdb.yourschema.yourtable';
exec sp_desc 'yourtable';
select * from information_schema.columns where table_name = 'tablename';
select  c.table_schema as schemaname, c.table_name as tablename, t.table_type as tabletype, c.ordinal_position as ordinal, c.column_name as columnname, cast(case when is_nullable = 'yes' then 1 else 0 end as bit) as isnullable, data_type as typename, isnull(character_maximum_length, 0) as [maxlength], cast(isnull(numeric_precision, 0) as int) as [precision], isnull(column_default, '') as [default], cast(isnull(datetime_precision, 0) as int) as datetimeprecision, isnull(numeric_scale, 0) as scale, cast(columnproperty(object_id(quotename(c.table_schema) + '.' + quotename(c.table_name)), c.column_name, 'isidentity') as bit) as isidentity, cast(case when columnproperty(object_id(quotename(c.table_schema) + '.' + quotename(c.table_name)), c.column_name, 'isidentity') = 1 then 1 else 0 end as bit) as isstoregenerated, cast(case when pk.ordinal_position is null then 0 else 1 end as bit) as primarykey, isnull(pk.ordinal_position, 0) primarykeyordinal, cast(case when fk.column_name is null then 0 else 1 end as bit) as isforeignkey from    information_schema.columns c u.table_name, u.column_name, u.ordinal_position from   information_schema.key_column_usage u and u.table_name = tc.table_name and u.constraint_name = tc.constraint_name where  constraint_type = 'primary key') pk and c.table_name = pk.table_name and c.column_name = pk.column_name u.table_name, u.column_name from   information_schema.key_column_usage u and u.table_name = tc.table_name and u.constraint_name = tc.constraint_name where  constraint_type = 'foreign key') fk and c.table_name = fk.table_name and c.column_name = fk.column_name and c.table_name = t.table_name where c.table_name not in ('edmmetadata', '__migrationhistory');
select  fk.name as fk_table, fkcol.name as fk_column, pk.name as pk_table, pkcol.name as pk_column, object_name(f.object_id) as constraint_name, schema_name(fk.schema_id) as fkschema, schema_name(pk.schema_id) as pkschema, pkcol.name as primarykey, k.constraint_column_id as ordinal_position from    sys.objects as pk and f.key_index_id = i.index_id and k.referenced_column_id = pkcol.column_id and k.parent_column_id = fkcol.column_id;
select  s.name as [schema], t.name as [table], c.name as [column], value as [property] from    sys.extended_properties as ep and ep.minor_id = c.column_id where   class = 1;
create procedure [dbo].[describe] ( @searchstr nvarchar(max) ) as begin select concat([column_name],' ',[data_type],' ',[character_maximum_length],' ', (select case [is_nullable] when 'no' then 'not null' else 'null' end), (select case when [column_default] is null then '' else concat(' default ',[column_default]) end) from information_schema.columns where table_name like @searchstr end;
select * from   information_schema.columns where table_name = 'tablename';
select top 0 * from table_name;
select col_length('tablename', 'colname');
exec sp_help 'myschema.mytable';
select  col.name,  case typ.name else typ.name end datatype,   case when col.is_nullable = 0 then 'not null ' else '' end + case when col.is_identity = 1 then 'identity' else '' end constraints,  from    sys.key_constraints kc inner join where kc.type = 'pk' and tb.name = @tname and sic.column_id = col.column_id),'') pk,  from    sys.foreign_key_columns fkc inner join where t.name = tab.name and c.name = col.name),'') fk,  from sys.extended_properties where major_id = tab.object_id and minor_id = col.column_id),'') comment from sys.columns col inner join where tab.name = @tname and typ.name != 'sysname';
select c.column_name, c.is_nullable, c.data_type, tc.constraint_type, c.column_default from information_schema.columns as c where c.table_name = '<table name>';
exec sp_blitzindex @tablename='mytable';
exec sp_help 'dbo.table_name';
exec sp_help table_name;
if object_id('tempdo.dob.#primary_key', 'u') is not null drop table #primary_key select cons_t.table_catalog, cons_t.table_schema, cons_t.table_name, cons_c.column_name, cons_t.constraint_type, cons_t.constraint_name from information_schema.table_constraints as cons_t join information_schema.constraint_column_usage as cons_c on cons_c.constraint_name= cons_t.constraint_name select sma.name as [schema name], st.name as [table name], sc.column_id as [column order], sc.name as [column name], pkt.constraint_type, pkt.constraint_name, sc.system_type_id, stp.name as [data type], sc.max_length, sc.precision, sc.scale, sc.is_nullable, sc.is_masked from sys.tables  as st join sys.schemas as sma on sma.schema_id = st.schema_id join sys.columns as sc on sc.object_id = st.object_id join sys.types as stp on stp.system_type_id = sc.system_type_id and pkt.table_name = st.name and pkt.column_name = sc.name;
exec [servername].[databasename].dbo.sp_columns 'tablename';
maxbytesize=8000, isinvarianttoduplicates=true, isinvarianttonulls=true, isinvarianttoorder=true, isnullifempty=true)] if (!value.isnull) if (!this.list.contains(value)) if (this.list.count == 0);
select dbo.commadelimit(x.value) [delimited] from ( select 'd' [value] union all select 'b' [value] union all select 'b' [value] -- intentional duplicate union all select 'a' [value] union all select 'c' [value];
select     empname, projids = replace from project_members where  empname = a.empname from         project_members a where     empname is not null;
select empname, projids= replace( (select replace(projid, ' ', '-somebody-puts-microsoft-out-of-his-misery-please-') as [data()] from project_members where empname=a.empname for xml path('')), ' ', ' / '), '-somebody-puts-microsoft-out-of-his-misery-please-', ' ') from project_members a where empname is not null group by empname;
set @result = '';
select @result = @result + name + ' ' from master.dbo.systypes;
select rtrim(@result);
select stuff( (select ',' + column_name from table_name;
select a.project_id,a.project_name,stuff((select n'/ ' + first_name + ', '+last_name from projects_v where a.project_id=project_id from projects_v a;
select table_name, left(column_names , len(column_names )-1) as column_names from information_schema.columns as extern ( select column_name + ',' from information_schema.columns as intern where extern.table_name = intern.table_name;
as (select distinct table_name from   information_schema.columns) select table_name, left(y.column_names, len(y.column_names) - 1) as column_names from   extern from   information_schema.columns as intern where  extern.table_name = intern.table_name;
drop table if exists #project_members;
create table #project_members( empname        varchar(20) not null, projid         varchar(20) not null);
('andy', 'b391'), ('andy', 'x010'), ('tom', 'a100'), ('tom', 'a510');
select empname, (select pm_json.projid from #project_members pm_json where pm.empname=pm_json.empname from #project_members pm;
"projjson": { { "projid": "b391" }, { "projid": "x010" } { "projjson": { { "projid": "a510" };
{"projid":"b391"},{"projid":"x010"}]}},{"empname":"tom","projjson": select oj.empname, noj.projid from openjson(@json) with (empname        varchar(20), projjson       nvarchar(max) as json) oj;
drop table if exists #project_members_with_json;
create table #project_members_with_json( empname        varchar(20) unique not null, projjson       nvarchar(max) not null);
select empname, (select pm_json.projid from #project_members pm_json where pm.empname=pm_json.empname from #project_members pm;
select wj.empname, oj.projid from #project_members_with_json wj;
select distinct empname, newcolumnname=stuff((select ','+ convert(varchar(10), projid ) from returns where empname=t.empname for xml path('')) , 1 , 1 , '' ) from returns t;
select distinct empname, newcolumnname=stuff((select ','+ projid from returns where empname=t.empname for xml path('')) , 1 , 1 , '' ) from returns t;
exec p_example 42;
set showplan_text on set showplan_all on set showplan_xml on set statistics profile on set statistics xml on -- the is the recommended option to use;
set <<option>> off;
select usecounts, cacheobjtype, objtype, text, query_plan from sys.dm_exec_cached_plans;
exec startcapture @@spid, @traceid output exec sp_help 'sys.objects' /*<-- call your stored proc of interest here.*/ exec stopcapture @traceid;
create procedure startcapture @traceid int output as declare @maxfilesize bigint = 5 exec sp_trace_create @traceid output, 0, @filepath, @maxfilesize, null exec sp_trace_setevent @traceid, 122, 1, 1 exec sp_trace_setevent @traceid, 122, 22, 1 exec sp_trace_setevent @traceid, 122, 34, 1 exec sp_trace_setevent @traceid, 122, 51, 1 exec sp_trace_setevent @traceid, 122, 12, 1 exec sp_trace_setfilter @traceid, 12, 0, 0, @spid exec sp_trace_setstatus @traceid, 1;
create  procedure stopcapture as with  xmlnamespaces ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' as sql), cte as (select cast(textdata as varchar(max)) as textdata, objectid, objectname, eventsequence, /*costs accumulate up the tree so the max should be the root*/ from   fn_trace_getinfo(@traceid) fn 'float') as estimatedtotalsubtreecost from   xplan.nodes('//sql:relop') t(relop)) ca where  property = 2 and textdata is not null and objectname not in ( 'stopcapture', 'fn_trace_getinfo' ) objectid, objectname, eventsequence) select objectname, sum(estimatedtotalsubtreecost) as estimatedtotalsubtreecost from   cte objectname exec sp_trace_setstatus @traceid, 0 exec sp_trace_setstatus @traceid, 2;
create event session [getexecutionplan] on server add event sqlserver.query_post_execution_showplan( action(package0.event_sequence,sqlserver.plan_handle,sqlserver.query_hash,sqlserver.query_plan_hash,sqlserver.session_id,sqlserver.sql_text,sqlserver.tsql_frame,sqlserver.tsql_stack)),  add event sqlserver.error_reported( action(package0.event_sequence,sqlserver.client_app_name,sqlserver.database_id,sqlserver.plan_handle,sqlserver.query_hash,sqlserver.query_plan_hash,sqlserver.session_id,sqlserver.sql_text,sqlserver.tsql_frame,sqlserver.tsql_stack) where ([package0].[greater_than_uint64]([sqlserver].[database_id],(4)) and [package0].[equal_boolean]([sqlserver].[is_system],(0)))), add event sqlserver.module_end(set collect_statement=(1) where ([package0].[greater_than_uint64]([sqlserver].[database_id],(4)) and [package0].[equal_boolean]([sqlserver].[is_system],(0)))), add event sqlserver.rpc_completed( action(package0.event_sequence,sqlserver.client_app_name,sqlserver.database_id,sqlserver.plan_handle,sqlserver.query_hash,sqlserver.query_plan_hash,sqlserver.session_id,sqlserver.sql_text,sqlserver.tsql_frame,sqlserver.tsql_stack) where ([package0].[greater_than_uint64]([sqlserver].[database_id],(4)) and [package0].[equal_boolean]([sqlserver].[is_system],(0)))), add event sqlserver.sp_statement_completed(set collect_object_name=(1) where ([package0].[greater_than_uint64]([sqlserver].[database_id],(4)) and [package0].[equal_boolean]([sqlserver].[is_system],(0)))), add event sqlserver.sql_batch_completed( action(package0.event_sequence,sqlserver.client_app_name,sqlserver.database_id,sqlserver.plan_handle,sqlserver.query_hash,sqlserver.query_plan_hash,sqlserver.session_id,sqlserver.sql_text,sqlserver.tsql_frame,sqlserver.tsql_stack) where ([package0].[greater_than_uint64]([sqlserver].[database_id],(4)) and [package0].[equal_boolean]([sqlserver].[is_system],(0)))), add event sqlserver.sql_statement_completed( action(package0.event_sequence,sqlserver.client_app_name,sqlserver.database_id,sqlserver.plan_handle,sqlserver.query_hash,sqlserver.query_plan_hash,sqlserver.session_id,sqlserver.sql_text,sqlserver.tsql_frame,sqlserver.tsql_stack) where ([package0].[greater_than_uint64]([sqlserver].[database_id],(4)) and [package0].[equal_boolean]([sqlserver].[is_system],(0)))) add target package0.ring_buffer;
select p.name as productname, nondiscountsales = (orderqty * unitprice), discounts = ((orderqty * unitprice) * unitpricediscount) from production.product as p;
select p.query_plan from sys.dm_exec_requests as r r.plan_handle, r.statement_start_offset, r.statement_end_offset) as p;
select tag = 1, parent = null, [showplanxml!1!!xmltext] = query_plan from sys.dm_exec_text_query_plan( -- set these variables or copy values @statement_start_offset, @statement_end_offset);
set showplan_all on;
select p.id from post p where exists ( select 1 from post_comment pc where pc.post_id = p.id and );
set showplan_all off;
set statistics io, time, profile on;
table 'worktable'. scan count 0, logical reads 0, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0. table 'post'. scan count 0, logical reads 116, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0. table 'post_comment'. scan count 1, logical reads 5, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.;
set statistics io, time, profile off;
alter table tablename alter column columnname drop not null;
alter table merchant_pending_functions modify([column]  not null);
alter table tablename alter column columnname set null;
alter table merchant_pending_functions modify column `numberoflocations` int null;
alter table merchant_pending_functions modify column `numberoflocations` int;
alter table merchant_pending_functions;
alter table merchant_pending_functions modify numberoflocations int null;
alter table mytable modify(mycolumn null);
alter table mytable alter column mycolumn drop not null;
alter table merchant_pending_functions alter column numberoflocations int null;
alter table merchant_pending_functions modify numberoflocations int;
select address_id, customer, address, partn from  /* big hairy sql */ ... ) update dummy set customer = subquery.customer, address  = subquery.address, partn    = subquery.partn from subquery where dummy.address_id = subquery.address_id;
update json_source_tabcol as d set isnullable = a.is_nullable from information_schema.columns as a where a.table_name =d.table_name and a.table_schema = d.table_schema and a.column_name = d.column_name;
select e.id, e.postcode from employees e where e.id=1 ) update employee_location set lat=lc.lat, longitude=lc.longi from cte where employee_location.id=cte.id;
update <table1> set customer=<table2>.customer, address=<table2>.address, partn=<table2>.partn from <table2> where <table1>.address_id=<table2>.address_i;
update <table1> set customer=subquery.customer, address=subquery.address, partn=subquery.partn from ( select address_id, customer, address, partn from  /* big hairy sql */ ... where dummy.address_id=subquery.address_id;
update <table1> set customer=<table2>.customer, address=<table2>.address, partn=<table2>.partn from <table2> as t2 join <table3> as t3 where <table1>.address_id=<table2>.address_i;
select address_id, customer, address, partn from <table1>;
) update <table-x> set customer = subquery.customer, address  = subquery.address, partn    = subquery.partn from subquery where <table-x>.address_id = subquery.address_id;
select address_id, customer, address, partn from <table1> as t1 join <table2> as t2 ) update <table-x> set customer = subquery.customer, address  = subquery.address, partn    = subquery.partn from subquery where <table-x>.address_id = subquery.address_id;
update dummy set customer=subquery.customer, address=subquery.address, partn=subquery.partn from (select address_id, customer, address, partn from  /* big hairy sql */ ...) as subquery where dummy.address_id=subquery.address_id;
update table t1 set column1 = t2.column1 from table t2 where t1.column2 = t2.column2;
update urls set url = replace(url, 'domain1.com/images/', 'domain2.com/otherfolder/');
update yourtable set url = replace(url, 'http://domain1.com/images/', 'http://domain2.com/otherfolder/') where url like ('http://domain1.com/images/%');
like ('...//domain1.com/images/%');
like ('%http://domain1.com/images/%');
update [table_name] set [field_name] =;
select sql_variant_property(cast(1 as numeric) + cast(1 as decimal),'basetype');
set nocount off;
create table ttable1 (n int);
create procedure procnocount as begin set nocount on update ttable1 set n=10-n end;
create procedure procnormal as begin update ttable1 set n=10-n end;
exec procnocount;
exec procnormal;
create procedure nocounton as set nocount on update mytable set somecolumn=somecolumn set @num = @num - 1 end go create procedure nocountoff as set nocount off update mytable set somecolumn=somecolumn set @num = @num - 1 end go;
exec nocountoff;
set nocount on values (1),(2),(3) delete top (1) from @test set @affectedrows = @@rowcount select @affectedrows as affectedrows;
end try end catch;
if @validationresult = 0 end ;
end  select @coumnname from tablename;
set @valid = 1 if -- condition(s) set @valid = 0 end  if @valid = 1 end;
if 1 = 1 begin end  if 1 = 1 begin end go select (1 / 0) as causeerror end try select error_message() as errormessage end catch;
if @error <> 0 begin ...;
set noexec on set noexec off -- turn execution back on; only needed in ssms, so as to be able;
set context_info  0x1 --just to make sure everything's ok set context_info 0x2 if context_info()<>0x2 select context_info() select 'this script must be run in sqlcmd mode! (to enable it go to (management studio) query->sqlcmd mode)\nplease abort the script!' end go;
if not exists (select * from sys.objects where object_id = object_id(n'[dbo].[sometable]') and type in (n'u'));
set noexec off if @@error != 0 set noexec on;
if @@error != 0 set noexec on;
set @finished = 1;
if @finished = 1 end else begin end;
select b.id as 'id', u.id as 'freelancer_id', u.name as where b.user_id = u.id and b.project_id = p.id;
select table1.column1 from table1 where table1 > 0 (or whatever you want to specify);
select products.product_id, product_name, price, created_at, image_name, categories.category_id, category_name,brands.brand_id, brand_name from products inner join categories using (category_id) inner join brands using(brand_id);
select a.p_name as [individual name],b.f_detail as [individual feature],c.pl_place as [individual location] from [dbo].[people] a [dbo].[feature] b on a.p_feature = b.f_id [dbo].[people_location] c on a.p_location = c.pl_id;
select * from personaddress a, person b, personadmin c where a.addressid like '97%' and b.lastname like 'test%' and b.genderid is not null and a.partyid = c.partyid and b.partyid = c.partyid;
select column_name1,column_name2,...... from tbl_name1,tbl_name2,tbl_name3 where tbl_name1.column_name = tbl_name2.column_name and tbl_name2.column_name = tbl_name3.column_name;
select * from table1 a join table2 b on a.id = b.id join table3 c on a.id = c.id;
select s.studentname from students s;
select     s.studentid from  dbo.studentsignup as s;
select empid,empname,managename,[management ],cityname from employees inner join managment;
select a.empname,a.empsalary,b.workstatus,b.bonus,c.dateofbirth from employee a, report b,birth c where a.empid=b.empid and a.empid=c.empid and b.empid='103';
select table1.col,table2.col,table3.col from table1 (table2 inner join table3 and //add any additional filters here;
from validationerror in validationerrors.validationerrors select new with { .propertyname = validationerror.propertyname, .errormessage = validationerror.errormessage, .classfullname = validationerrors.entry.entity [error].classfullname, [error].propertyname, [error].errormessage) end try;
validationerrors.entry.entity.gettype().fullname, validationerror.propertyname, validationerror.errormessage);
"class: {0}, property: {1}, error: {2}", validationerrors.entry.entity.gettype().fullname, validationerror.propertyname, validationerror.errormessage);
validationerror.propertyname, validationerror.errormessage);
if (inner.message.contains("datetime2")) where x.propertytype == typeof(datetime) || select x.name;
if (tryupdatemodel(theevent)) validationerrors.entry.entity.tostring(), validationerror.errormessage);
( name,.... values ( 'test',... );
select ident_current('tablename') as [ident_current];
select scope_identity() as [scope_identity];
select @@identity as [@@identity];
select @duplicataid =   (select scope_identity());
select t.[customerid] from @generated_keys as g join dbo.customers as t where @@rowcount > 0;
set rs=myconn.execute("insert into m2_votelist(producer_id,title,timeu) output inserted.id values ('gator','test',getdate())");
select * from files where id = scope_identity();
select scope_identity();
select distinct row_number() over (order by name), name from namestable select row_number() over (order by name), name from namestable;
select department, sum(amount) from purchases group by department;
select c from mytbl group by c, d;
select c, count(b) from mytbl group by c;
select name, sum(transaction) from mytbl group by name;
select name, count(*) as count from table group by name;
select distinct a, b, c from table;
select a, b, c from table group by a, b, c;
select count(distinct c) from mytbl;
select distinct count(c) from mytbl;
select rating, row_number() over (order by rating) as rn from film;
select distinct rating, row_number() over (order by rating) as rn from film;
select rating, row_number() over (order by rating) as rn from ( select distinct rating from film;
select distinct rating, dense_rank() over (order by rating) as rn from film;
select first_name || ' ' || last_name as name from customer;
select first_name || ' ' || last_name as name from customer;
select name from ( select first_name || ' ' || last_name as name from customer;
select * from student;
select distinct * from student;
select * from student group by branch;
select * from student group by id, branch, cgpa;
select  specialcolumn,sum(specialcolumn) from yourtablename group by specialcolumn;
select dateadd(month, datediff(month, 0, @mydate), 0) as startofmonth;
create function [dbo].[getfirstdayofmonth] ( @inputdate    datetime ) end go;
select dateadd(mm, datediff(mm,0,@date), 0);
select date_sub(ref_date, interval day(ref_date)-1 day) as day1;
select @mydate - day(@mydate) + 1;
select dateadd(day,1,eomonth(@mydate,-1));
select dateadd(day,(datepart(day,@mydate)-1)*(-1),@mydate) as firstofmonth;
select  cast(cast(year('2015-06-30') as varchar(4))+'-'+ cast(month('2015-06-30') as varchar(2))+'-01' as smalldatetime);
select cast(convert(varchar(6),getdate(),112) +'01' as datetime) as startofmonth;
select concat(datepart(yyyy,@mydate),'-',datepart(mm,@mydate),'-01');
select date_format(now(), '%y-%m-1');
select datefromparts(year(@mydate),month(@mydate),1);
select dateadd(m, datediff(m, 0, getdate()), 0);
select dateadd (day, -1 * (day(getdate()) - 1), getdate());
select convert (datetime, convert (date, dateadd (day, -1 * (day(getdate()) - 1), getdate())));
select dateadd(day, -(datepart(day,@date)+1,@date);
select dateadd(day, 1, eomonth(dateadd(month, -1, getdate()))) as firstdateofmonth;
select dateadd(day,1,eomonth(getdate(),-1)) as 'fd',cast(getdate()-1 as date) as 'ld';
select dateadd(month, -1, dateadd(day, 1, eomonth(getdate())));
select format(@mydate,'yyyy-mm-01 06:00') first_of_a_month;
set @startofmonth = dateadd(dd,1,eomonth(getdate(),-2));
set @startofmonth = dateadd(dd,1,eomonth(@mydate,-1));
select convert(date,format(@date,'yyyymm01'));
select @date =format(@date,'yyyymm01');
select [date]=@date;
select date_add(date_add(last_day(current_date-interval 1 day),interval 1 day),interval -1 month);
select dateadd(mm, -1,dateadd(dd, +1, eomonth(getdate()))) as firstday, eomonth(getdate()) as lastday;
select getdate()-datepart(day, getdate())+1 select dateadd(month,1,getdate())-datepart(day, getdate());
select dateadd(s,-1,dateadd(mm, datediff(m,0,getdate()),0)) select dateadd(s,-1,dateadd(mm, datediff(m,0,getdate())+1,0)) select dateadd(s,-1,dateadd(mm, datediff(m,0,getdate())+2,0));
select concat(left(curdate(),7),'-01');
select left(convert(varchar, getdate(),23),7)+'-01 00:00:00';
select datefromparts(year(@mydate),month(@mydate),'01');
select @date = getdate() select convert(varchar(25),dateadd(dd,-(day(@date)-1),@date),105) as value, 'first day of current month' as name union select convert(varchar(25),dateadd(dd,-(day(dateadd(mm,1,@date))), dateadd(mm,1,@date)),105), 'last day of current month';
create definer=`r`@`l` function `positionsmalltofloat`(s int);
create definer=`r`@`l` function `positionfloattosmall`(s decimal(10,7));
create table: create table `locations` ( `lat` int(10) unsigned not null, `lon` int(10) unsigned not null, `location` text, primary key (`lat`,`lon`) using btree, key `index_location` (`locationtext`(30));
somereallylongexpression );
alter table `sometable_sometable` add column `description` longtext null;
alter table `sometable_sometable` add column `title` varchar(64) null;
alter table `sometable_sometable` alter column `title` drop default;
alter table tablename convert to character set utf8 collate utf8_unicode_ci;
create table company_life_cycle__history -- (m-m) ( company_life_cycle_id tinyint unsigned not null, foreign key (company_life_cycle_id) references company_life_cycle(id) on delete    cascade on update cascade, company_id mediumint unsigned not null, foreign key (company_id) references company(id) on delete cascade on update cascade, activity_on date not null, primary key pk_company_life_cycle_history (company_life_cycle_id, company_id,activity_on), created_on datetime default null, updated_on datetime default null, created_by varchar(50) default null, updated_by varchar(50) default null;
constraint `fk_id` foreign key (`id`) references `table-a` (`id`);
set foreign_key_checks=0;
alter table other_db.tasks add constraint tasks_fk foreign key (user_id) references currrent_db.users (id);
`productcode` varchar(15) not null, `productname` varchar(70) not null, `productline` varchar(50) not null, `productscale` varchar(10) not null, `productvendor` varchar(50) not null, `productdescription` text not null, `quantityinstock` smallint(6) not null, `buyprice` decimal(10,2) not null, `msrp` decimal(10,2) not null, primary key (`productcode`), key `productline` (`productline`), constraint `products_ibfk_1` foreign key (`productline`) references `productlines` (`productline`);
`id` int(11) unsigned not null auto_increment, `productcode` varchar(15) default null, `old_price` decimal(20,2) not null, `new_price` decimal(20,2) not null, `added_on` datetime not null default current_timestamp, primary key (`id`), key `productcode` (`productcode`), constraint `price_logs_ibfk_1` foreign key (`productcode`) references `products` (`productcode`) on delete cascade on update cascade;
`id` int(11) unsigned not null auto_increment, `productcode` varchar(15) default null, `old_price` decimal(20,2) not null, `new_price` decimal(20,2) not null, `added_on` datetime not null default current_timestamp, primary key (`id`), key `productcode` (`productcode`), constraint `price_logs_ibfk_1` foreign key (`productcode`) references `products` (`productcode`) on delete cascade on update cascade;
select columndatatype from sys.syscolumns where referenceid = ( select tableid from sys.systables where tablename = 'your_tabel_name' and columnname= 'your_column_name');
select table_name, column_name, data_type and character_maximum_length > 0 then else '' end else '' end as declaration_type, case when is_nullable='no' then 'not ' else '' end + 'null' as nullable from information_schema.columns;
set rs = cn.openschema(adschemacolumns, array(empty, empty, ucase("table"), ucase("field")));
select table_name as 'tablename' from information_schema.columns where -- ...;
select [name]         = c.[name] case when tp.[name] in ('varchar', 'char') then tp.[name] + '(' + iif(c.max_length = -1, 'max', cast(c.max_length as varchar(25))) + ')' else tp.[name] end , [rawtype]      = tp.[name] from sys.tables t join sys.schemas s on t.schema_id = s.schema_id join sys.columns c on t.object_id = c.object_id join sys.types tp on c.user_type_id = tp.user_type_id where s.[name] = 'dbo' and t.[name] = 'mytable';
set @sql = 'select ''hi'' as greeting';
select * from master.sys.dm_exec_describe_first_result_set (@sql, null, 0);
select * from information_schema.columns where table_name = 'table_name';
exec sp_describe_first_result_set @query, null, 0;
select t.name, c.name from sys.tables t join sys.columns c on t.object_id = c.object_id join sys.types y on y.user_type_id = c.user_type_id where t.name = '';
select column_name 'column name', data_type 'data type' from information_schema.columns where table_name = 'yourtablename';
select data_type from information_schema.columns where table_name = 'yourtablename' and;
select column_name, data_type from information_schema.columns where table_name = 'yourtablename';
select typename from syscat.columns where tabschema='your_schema_name' and tabname='your_table_name' and colname='your_column_name';
select data_type from all_tab_columns where table_name = 'table name' -- in uppercase and column_name = 'column name' -- in uppercase;
exec sp_help yourtablename;
select table_name,column_name, data_type, character_maximum_length, is_nullable from information_schema.columns where table_name = 'your_table_name';
select .... into real_table_name;
select quotename(schema_name(tb.[schema_id])) as 'schema' from sys.columns c inner join sys.tables tb on tb.[object_id] = c.[object_id] where tb.[is_ms_shipped] = 0;
select type_name(system_type_id) from sys.columns where name = 'column_name' and [object_id] = object_id('[dbo].[table_name]');
if ($result = $mysqli -> query($sql)) {;
'product_id' => null, 'sku' => null, 'price' => null, ... );
( [0] => name );
if ($con) { if ($link) { select column_name from   information_schema.columns where  table_schema = '$db' and table_name = 'table_name'"; // change the table_name your own table name if (mysql_query($sql, $con)) {;
desc table_name;
select @ccommand := group_concat( column_name order by column_name separator ',\n') from information_schema.columns where table_schema = 'my_database' and table_name = 'my_table';
set @ccommand = concat( 'select ', @ccommand, ' from my_database.my_table;');
select column_name from information_schema.columns where table_name = 'tbl_name' from tbl_name;
select column_name from information_schema.columns where table_schema = 'my_database' and table_name = 'my_table';
select group_concat(column_name) from information_schema.columns where table_schema = 'my_database' and table_name = 'my_table';
select user,authentication_string,plugin,host from mysql.user;
alter user 'root'@'localhost' identified with mysql_native_password by 'password';
select user,authentication_string,plugin,host from mysql.user;
set password=...;
set authentication_string = password...;
select host,user,password from user where user = 'root';
update mysql.user set password = password('your_new_cleartext_password') where user = 'root' and host = 'localhost';
select host,user,password from user where user = 'root';
select host,user,password from user where user = 'root';
update mysql.user set password = password('your_new_cleartext_password') where user = 'root';
select host,user,password from user where user = 'root';
alter user 'root'@'localhost' identified with mysql_native_password by 'root';
alter user 'root'@'localhost' identified by 'newpassword';
update mysql.user set plugin = 'mysql_native_password' where user='root';
alter user 'root'@'localhost' identified by 'newpassword';
select * from employee where rec_date between '2017-09-01' and '2017-09-11';
create procedure dbo.get_data_by_dates ( @employeeid int = 1, @start_date date, @end_date date ) as select * from calculation where employeeid=@employeeid and test_date between @start_date and @end_date;
select * from tbluser where;
select * from tbluser where;
select * from tbluser where;
select * from tbluser where select * from tbluser where;
select date,totalallowance from calculation where employeeid=1 and date >= '2011/02/25' and date < dateadd(d, 1, '2011/02/27');
select date, ... from ... where date >= $start_month_day_1 and date < dateadd(m, 1, $end_month_day_1);
select firstname from students where dob >= '11 dec 2016';
select firstname from students where dob >= #11 dec 2016#;
select mydatetime from @datetimevalues where mydatetime between '2020-01-01t00:00:00' and '2020-01-01t23:59:59.999';
select mydatetime from @datetimevalues where mydatetime >= '2011-02-25t00:00:00' and mydatetime <= '2011-02-27t23:59:59.999';
select top 10 [id] from [dbo].[socials] where educ >= 3 or ezdevajdate  >= '1992/03/31' and ezdevajdate <= '2019/03/09' and marriagestatus = 1;
select * from table_name where col_date between '2011/02/25' and dateadd(s,-1,dateadd(d,1,'2011/02/27'));
select * from calculation where employeeid=1 and date between #2011/02/25# and #2011/02/27#;
select date, totalallowance from calculation where employeeid = 1 and date between to_date('2011/02/25','yyyy-mm-dd') and to_date ('2011/02/27','yyyy-mm-dd');
select date,totalallowance from calculation where employeeid=1 and date between '2011/02/25' and '2011/02/27 23:59:59.999';
select date,totalallowance from calculation where employeeid=1 and date >= '2011/02/25' and date < '2011/02/28';
select date,totalallowance from calculation where employeeid=1 and date >= '2011/02/25' and date <= '2011/02/27 23:59:59.999';
select date,totalallowance from calculation where employeeid=1 and date between '2011/02/25' and '2011/02/28';
set @approval_date =getdate();
select date,totalallowance from calculation where employeeid=1 and date between;
select date,totalallowance from calculation where employeeid=1 and date between;
where aa.auditdate>='1 september 2015' and aa.auditdate<='30 september 2015';
select date,totalallowance from calculation where employeeid=1 and convert(varchar(10),date,111) between '2011/02/25' and '2011/02/27';
select * from test where cast(addtime as datetime) between '2013/4/4' and '2014/4/4';
select * from tablename  where columname between curdate() and date_add(curdate(), interval 3 day);
select date,totalallowance from calculation where employeeid=1 and [date] between '2011/02/25' and '2011/02/27';
select date, totalallowance from calculation where employeeid = 1 and date between '2011/02/25' and '2011/02/27';
select date, totalallowance from calculation where employeeid = 1 and date >= '2011/02/25' and date <= '2011/02/27';
select clientid, max(transactiondate) as latestdate from transaction;
select * from select clientid, max(transactiondate) as latestdate from transaction;
select c.*, p.*, max(p.date) from customer c;
select * from customer c where pi.customer_id = c.id order by pi.id desc) as [lastpurchaseprice];
select customer.*, purchase.* from customer join ( select distinct on (customer_id) * from purchase;
select c.id, c.name, (select pi.price from purchase pi where pi.id = max(p.id)) as [lastpurchaseprice] from customer c inner join purchase p;
select  customer_id, max(date) maxdate from    purchase ) select  c.*, m.* from    customer c inner join;
select * from customer c c.id = p.customer_id and not exists ( select 1 from purchase p1 where p1.customer_id = c.id and p1.id > p.id ) );
select c.*, p1.* from customer c join purchase p1 on (c.id = p1.customer_id) where p2.id is null;
select  c.*, p.* from    customer c inner join ( select  customer_id, max(date) maxdate from    purchase and maxdates.maxdate = p.date;
select c.*, p.* from customer c inner join from purchase) p where p.r = 1;
delete from employees_temp where       employee_id = 299 last_name emp_last_name;
delete triggers;
delete is a dml command delete you can rollback delete = only delete- so it can be rolled back in delete you can write conditions using where clause;
delete from  employee select * from employee select * from employee;
delete from [sometable];
select name, phone_number from call a where a.phone_number not in (select b.phone_number from phone_book b);
select id from call select id from phone_number;
select distinct call.id from call where phone_book.id is null;
select t1.columnid, case when not exists( select t2.fieldtext from table t2 where t2.columnid = t1.columnid) then t1.fieldtext else t2.fieldtext end fieldtext from table1 t1, table2 t2;
select  * from    call where   phone_number not in (select phone_number from phone_book);
select * from   call where  not exists from   phone_book where  phone_book.phone_number = call.phone_number);
select * from   call where phone_book.phone_number is null;
select * from call where not exists (select 'x' from phone_book where;
select call.id, call.date, call.phone_number from call where phone_book.phone_number is null;
select call.* from call left join phone_book on;
from django.db.models import q;
from django.db.models import q;
first_name__startswith='r' last_name__startswith='d' );
in [5]: str(queryset.query) "auth_user"."is_superuser", "auth_user"."username", "auth_user"."first_name", "auth_user"."last_name", "auth_user"."email", "auth_user"."is_staff", "auth_user"."is_active", "auth_user"."date_joined" from "auth_user" where ("auth_user"."first_name"::text like r% or "auth_user"."last_name"::text like d%)';
in [9]: str(qs.query) "auth_user"."is_superuser", "auth_user"."username", "auth_user"."first_name", "auth_user"."last_name", "auth_user"."email", "auth_user"."is_staff", "auth_user"."is_active", "auth_user"."date_joined" from "auth_user" where ("auth_user"."first_name"::text like r% or "auth_user"."last_name"::text like d%)';
from django.db.models import q;
select *fieldlist* from foo..tblfoobar;
select * from sourcedb..mysourcetable;
select * from sourcedb..mysourcetable;
select columna, columnb from developerdb.dbo.customers;
select (name + ',') as tablecolumns from sys.columns where object_id = object_id('yourtablename');
select (name + ',') as tablecolumns from sys.columns where object_id = object_id('yourtablename') and is_identity = 0;
select * into <destination_table> from <servername>.<databasename>.dbo.<sourcetable>;
select url,status,recycle from alfestonlineold..url_details;
create table `test_pivot` ( `pid` bigint(20) not null auto_increment, `company_name` varchar(32) default null, `action` varchar(16) default null, `pagecount` bigint(20) default null, primary key (`pid`);
select  p.`company_name`, count( case when p.`action`='email' then 1 else null end ) as 'email', count( case when p.`action`='print' and p.`pagecount` = '1' then p.`pagecount` else null end ) as 'print 1 pages', count( case when p.`action`='print' and p.`pagecount` = '2' then p.`pagecount` else null end ) as 'print 2 pages', count( case when p.`action`='print' and p.`pagecount` = '3' then p.`pagecount` else null end ) as 'print 3 pages' from    test_pivot p;
select t3.name, sum(t3.prod_a) as prod_a, sum(t3.prod_b) as prod_b, sum(t3.prod_c) as    prod_c, sum(t3.prod_d) as prod_d, sum(t3.prod_e) as prod_e from (select t2.name as name, case when t2.prodid = 1 then t2.counts else 0 end  prod_a,  case when t2.prodid = 2 then t2.counts else 0 end prod_b,  case when t2.prodid = 3 then t2.counts else 0 end prod_c,  case when t2.prodid = 4 then t2.counts else 0 end prod_d,  case when t2.prodid = "5" then t2.counts else 0 end prod_e from (select partners.name as name, sales.products_id as prodid, count(products.name) as counts from test.sales left outer join test.partners on sales.partners_id = partners.id where sales.partners_id = partners.id and sales.products_id = products.id group by partners.name, prodid) t2) t3;
select companyname, sum(case when (action='email') then 1 else 0 end) as email, sum(case when (action='print' and pagecount=1) then 1 else 0 end) as print1pages, sum(case when (action='print' and pagecount=2) then 1 else 0 end) as print2pages, sum(case when (action='print' and pagecount=3) then 1 else 0 end) as print3pages from company companyname;
select company_name, sum(action = 'email')as email, sum(action = 'print' and pagecount = 1)as print1pages, sum(action = 'print' and pagecount = 2)as print2pages, sum(action = 'print' and pagecount = 3)as print3pages from t;
set @sql = null;
select group_concat(distinct 'sum(case when action = "', action,'"  and ', (case when pagecount is not null then concat("pagecount = ",pagecount) else pagecount is null end), ' then 1 else 0 end) as ', action, ifnull(pagecount,'') ) ) from t;
set @sql = concat('select company_name, ', @sql, ' from t;
select company_name from   tbl;
select table_record_id, group_concat(if(value_name='note', value_text, null)) as note from other_value where table_name = 'employee' and is_active = 'y' and is_deleted = 'n';
set @sql = null;
select group_concat( concat('sum( `action` = ''', action, '''',pc0,' ) as ',action,pc1) ) from ( select distinct `action`, if(`pagecount` is null,'',concat('page',`pagecount`)) as pc1, if(`pagecount` is null,'',concat(' and `pagecount` = ', pagecount, '')) as pc0 from `tab` set @sql = concat('select company_name,',@sql,' from `tab` group by company_name');
select sdes.session_id from sys.dm_exec_sessions as sdes  select db_name(dbid) as databasename select text as [processing-instruction(definition)] from sys.dm_exec_sql_text(sdec.most_recent_sql_handle) from sys.dm_exec_sql_text(sdec.most_recent_sql_handle) where sdes.session_id <> @@spid and sdest.databasename ='yourdatabasename';
select * from sys.dm_exec_sessions where status = 'running';
select conn.session_id, host_name, program_name, nt_domain, login_name, connect_time, last_request_end_time from sys.dm_exec_sessions as sess join sys.dm_exec_connections as conn;
set @dbname = '[yourdatabasename]' select db_name(dbid), count(dbid), loginame from sys.sysprocesses where dbid > 0 group by dbid, loginame select * from @spwho1 where dbname = @dbname exec sp_who2 'active' select * from @spwho2 where dbname = @dbname;
select db_name(dbid) as dbname, count(dbid) as numberofconnections, loginame as loginname from sys.sysprocesses where dbid > 0 dbid, loginame;
where find_in_set($needle,'column') > 0;
where `column` like '%{$needle}%';
select * from `table` where locate('{$needle}','column') > 0;
where `column` like '%$needle%';
select * from `table` where `column` like '%{$needle}%';
select * from `table` where instr(`column`, '{$needle}') > 0;
select top (@rows) * from employees;
select top (@top) * from <table_name>;
select top (@count) * from sometable;
set rowcount @top select * from sometable set rowcount 0;
set rowcount @top select * from sometable set rowcount 0;
set @count = 10 set @sql = n'select top ' + cast(@count as nvarchar(4)) + ' * from table' exec (@sql);
select  id , ( select top 1 from      subtable getutcdate() , 1 from    mytable;
select  id , ( select top 1 from      subtable where mytable.id>0 getutcdate() , 1 from    mytable;
select top 10 percent * from table1;
select * from table1 where (abs(cast( (binary_checksum(*) *;
select top [number] from table_name;
select top 10 percent * from table_name;
select top 10 percent * from table_name;
set @seed = year(getdate()) * month(getdate()) /* any other initial seed here */ select top 10 percent * from table_name;
select * from ( select *, abs(checksum(newid())) as rnd from mytable where rnd % 100 < 10        --10%;
select top 10 percent * from [yourtable] order by newid();
select  * from [yourtable] where [yourpk] in;
select `primary_key`, rand() from table order by rand() limit 5000;
select top 5000 * from [table] order by newid();
select top 1 percent * from [tablename] order by newid();
select * from [tablename] tablesample(1 percent);
select * from sales.salesorderdetail where 0.01 >= cast(checksum(newid(),salesorderid) & 0x7fffffff as float);
set statistics time on set statistics io on select top 1 percent number from numbers select number from numbers select number from numbers where 0.01 >= cast(checksum(newid(), number) & 0x7fffffff as float) set statistics io off set statistics time off;
select * from table1 where (abs(cast( (binary_checksum(*) *;
set statistics time on select top (@samplecount) * from [yourtable] tablesample(10 percent) set statistics time off;
select * from table_name limit [number];
select top 10 field1, ..., fieldn from table1;
select "myapp_mymodel"."id", ... from "myapp_mymodel";
from django.contrib.auth.models import user;
from django.db import connections;
select cname, max(avg) from makerar group by cname;
select cname, wmname, max(avg)  from makerar group by cname;
select m.cname, m.wmname, t.mx from ( select cname, max(avg) as mx from makerar;
select cname, wmname, max(avg) over (partition by cname) as mx from makerar;
select distinct /* distinct here matters, because maybe there are various tuples for the same max value */ from ( select cname, wmname, avg, row_number() over (partition by avg desc) as rn from makerar;
select t1.cname, t1.wmname, t2.max from makerar t1 join ( select cname, max(avg) max from makerar;
select cname, wmname, avg from ( select cname, wmname, avg, rank() from makerar) t where rank = 1;
distinct on (expression);
select distinct on (cname) from makerar cname, avg desc ;
select cname, (array_agg(wmname order by avg desc))[1], max(avg) from makerar group by cname;
select date(dateday) as pick_day, count(case when (apples = 'true' or oranges 'true') then fruit end)  as fruit_counter from pickings;
case when ((apples = 'true' or oranges 'true') then count(*) end) end as fruit_counter;
select * from makerar m1 where m1.avg = (select max(avg) from makerar m2 where m1.cname = m2.cname );
select * from sys.tables;
select * from sys.tables;
select table_name from information_schema.tables where table_type = 'base table' and table_catalog='dbname';
select table_name from information_schema.tables where table_type = 'base table' and table_schema='dbname';
select table_name from your_database.information_schema.tables where table_type = 'base table';
select * from user_tables;
select * from sys.tables;
select * from sys.tables;
exec sp_msforeachtable 'select ''?''';
select table_schema + '.' + table_name as 'schema.table' from information_schema.tables where table_type = 'base table' and table_catalog = 'dbname';
select table_name from databasename.information_schema.tables;
select t.table_name , t.engine , t.table_rows ,t.avg_row_length, t.index_length from;
select * from information_schema.tables;
select * from tab;
select table_name from tabs;
select table_name from information_schema.tables where (table_schema = 'dbname' or table_schema = 'schemaname');
select name from databasename.sys.tables;
select name from sys.tables where type_desc = 'user_table';
select * from trees where lower( trees.title ) like  '%elm%';
select * from trees where trees.`title` like '%elm%' collate utf8_general_ci;
select  * from    trees where   trees.`title` collate utf8_general_ci like '%elm%';
alter table trees set utf8 collate utf8_general_ci.;
select * from trees where trees.`title` ilike '%elm%';
select * from <table> where <key> like '%<searchpattern>%';
select * from <table> where lower(<key>) like lower('%<searchpattern>%');
from table_name where lower(column_name) like lower('%$string%')");
from table_name where lower(column_name) like lower(?);";
select name from gallery where convert(name using utf8) like _utf8 '%$q%';
set names `utf8`;
set collation_connection=utf8_general_ci;
set character_set_client=utf8;
set character_set_results=utf8;
select * from trees where trees.`title` ilike '%elm%';
drop table if exists category;
create table category ( id int auto_increment primary key, name varchar(20), parent_id int, constraint fk_category_parent foreign key (parent_id);
(20, 'category2', 19), (21, 'category3', 20), (22, 'category4', 21), (23, 'categorya', 19), (24, 'categoryb', 23), (25, 'categoryc', 23), (26, 'categoryd', 24);
drop procedure if exists getpath;
create procedure getpath(in cat_id int, out path text) set max_sp_recursion_depth = 255;
select name, parent_id from category where id=cat_id into catname, tempparent;
if tempparent is null then set path = catname;
else call getpath(tempparent, temppath);
set path = concat(temppath, '/', catname);
drop function if exists getpath;
create function getpath(cat_id int) returns text deterministic;
select id, name, getpath(id) as path from category;
select id, name, getpath(id) as path from category having path like 'category1/category2%';
select cat.* from categories_closure as cl where cl.ancestor = 20 and cl.depth > 0;
select     id, name, parent_id from       products where      parent_id = 19 union all select     p.id, p.name, p.parent_id from       products p ) select * from cte;
select  id, name, parent_id from    (select * from products (select @pv := '19') initialisation where   find_in_set(parent_id, @pv) and     length(@pv := concat(@pv, ',', id));
select  id, name from    products where   id like '19/%';
select      p6.parent_id as parent6_id, p5.parent_id as parent5_id, p4.parent_id as parent4_id, p3.parent_id as parent3_id, p2.parent_id as parent2_id, p1.parent_id as parent_id, p1.id as product_id, p1.name from        products p1 where       19 in (p1.parent_id, p2.parent_id, p3.parent_id, p4.parent_id, p5.parent_id, p6.parent_id);
select ... from table t join table pt on pt.id in (select i.id from table i where is_related(t.id,i.id));
select group_concat(lv separator ',') from ( select @pv:=( select group_concat(id separator ',') from table where parent_id in (@pv) join (select @pv:=1)tmp where parent_id in (@pv);
create definer=`root`@`localhost` function `get_lineage`(the_id int) returns text charset utf8 select _id,parent_id -- @n:=@n+1 as rownum,t1.* from (select @r as _id, (select @r := table_parent_id from table where table_id = _id) as parent_id, @l := @l + 1 as lvl from (select @r := the_id, @l := 0,@n:=0) vars, table m where @r <> 0 where t1.parent_id is not null set v_rec = v_rec+1;
if done then end if;
if v_rec = 1 then set v_res = v_papa_papa;
set v_res = concat(v_res,'-',v_papa);
select get_lineage(the_id);
select t1.name as lev1, t2.name as lev2, t3.name as lev3, t4.name as lev4 from category as t1 where t1.name = 'electronics';
select @pv:=category_id as category_id, name, parent from category join (select @pv:=19)tmp where parent=@pv;
select a.id,if(a.parent = 0,@varw:=concat(a.id,','),@varw:=concat(a.id,',',@varw)) as list from (select * from recursivejoin order by if(parent=0,id,parent) asc) a left join recursivejoin b on (a.id = b.parent),(select @varw:='') as c  having list like '%19,%';
select  id, name, parent_category from    (select * from category (select @pv := '2') initialisation where   find_in_set(parent_category, @pv) > 0 and     @pv := concat(@pv, ',', id);
select menu_name, (@id:=sub_menu_id ) as sub_menu_id, menu_id from ( select menu_id, menu_name, sub_menu_id from menu where menu_id = @id;
select @pv:=id as id, name, parent_id from products join (select @pv:=19)tmp where parent_id=@pv;
select @pv:=p1.id as id from products p1 join (select @pv:=19)tmp where p1.parent_id=@pv;
select  id, name, parent_id from    (select * from products (select @pv := '19') initialisation where   find_in_set(parent_id, @pv) > 0 and     @pv := concat(@pv, ',', id);
select * from my_table where path like '/19/20/21%' update my_table set path = replace(path, '/19/20', '/15/16') where path like '/19/20/%';
'10' => 'a', '100' => '2s', '1000' => 'rs', '10000' => '7ps', '100000' => '255s', '1000000' => 'lfls', '1000000000' => 'gjdgxs', '1000000000000' => 'cre66i9s';
select id,name,'' as subname,'' as subsubname,'' as subsubsubname from table1 where prent is null union select b.id,a.name,b.name as subname,'' as subsubname,'' as subsubsubname from table1 as a left join table1 as b on b.prent=a.id where a.prent is null and b.name is not null union select c.id,a.name,b.name as subname,c.name as subsubname,'' as subsubsubname from table1 as a left join table1 as b on b.prent=a.id left join table1 as c on c.prent=b.id where a.prent is null and c.name is not null union select d.id,a.name,b.name as subname,c.name as subsubname,d.name as subsubsubname from table1 as a left join table1 as b on b.prent=a.id left join table1 as c on c.prent=b.id left join table1 as d on d.prent=c.id where a.prent is null and d.name is not null;
`id`, `title`, `url`, `icon`, `class`, `parent_id`, `depth` select `id`, `title`, `url`, `icon`, `class`, `parent_id`, 1 as `depth` from     `route` where    `id` = :id union all select p.`id`, p.`title`, p.`url`, p.`icon`, p.`class`, p.`parent_id`, `depth` + 1 from `route` p ) select * from cte order by `depth` desc;
create database database_name;
create database your_database;
create database name;
update (select a.utl_id, b.utl1_id from trb_pi_joint a join trb_tpr b ) set utl_id=utl1_id;
update table1 set table1.value = (select table2.code from table2 where table1.value = table2.desc) where table1.updatetype='blah' and exists (select table2.code from table2 where table1.value = table2.desc);
update (select table1.value as old, table2.code as new from table1 where table1.updatetype='blah' set t.old = t.new;
update ( select t1.value, t2.code from table1 t1 where t1.updatetype='blah') set t1.value= t2.code;
select  t1.rowid as rid, t2.code from    table1 t1 join    table2 t2 where   table1.updatetype='blah' set trg.value = code;
update table1 set value = (select code from table2 where description = table1.value) where exists (select 1 from table2 where description = table1.value) and table1.updatetype = 'blah';
update table1 t1 set t1.value = where t1.value = t2.desc) where t1.updatetype='blah';
where table1.startdate > table2.start_date;
update table1  a set a.col1='y' where exists(select 1 from table2 b where a.col1=b.col1 and a.col2=b.col2 );
update ip_admission_request ip1 set ip1.wrist_band_print_status=0 where ip1.ip_adm_req_id        = from ip_admission_request ip and v.pat_id     =3702;
update some_table s set   (s.col1, s.col2) = (select x.col1, x.col2 from   other_table x where  x.key_value = s.key_value ) where exists             (select 1 from   other_table x where  x.key_value = s.key_value );
update (select bonus from employee_bonus b where e.bonus_eligible = 'n') t set t.bonus = 0;
update (select t.field a, s.field b from table_t t inner join table_s s set b = a;
select table2.code, table2.desc from table1 join table2 on table1.value = table2.desc where table1.updatetype = 'blah' update table1 set table1.value = sel.code where table1.updatetype = 'blah' and table1.value = sel.desc;
update set tt.number = st.number;
alter table my_table drop column_to_be_deleted;
alter table table01 drop columns col1, drop col2;
alter table table_name drop column column1, drop column column2,drop column column3;
alter table table_name drop column column1, add column column2 after column7;
alter table table_name drop column column1,column2,column3;
alter table student drop column name, number, city;
alter table tablename drop column column1, column2, column3;
alter table tablename drop column column1, column column2, column column3;
alter tbale tablename drop constraint df_tablename_column1, column column1;
alter table test;
alter table tablename drop (column1, column2, column3......);
drop <col_name>;
drop column <col_name>;
alter table table_name drop (column_name1, column_name2);
alter table table_name drop column column_name1, column_name2;
alter table table_name drop column_name1, drop column_name2;
alter table table_name drop column column_name1, drop column column_name2;
alter table ... rebuild;
create table test(a int,b int,c int);
alter table test drop(a,b);
alter table tablename drop column column1;
alter table tablename drop (column1, column2, column3......);
alter table tablename drop column col1, drop column col2 , drop column col3 ....;
create table test (a int, b int , c int, d int);
alter table test drop column b, d;
alter table ... rebuild;
alter table tablename drop column column1, column2;
drop { [ constraint ] constraint_name | column column } [ ,...n ];
alter table tablename drop column column1, drop column column2;
alter table tablename drop column1, drop column2;
select replace(convert(varchar, getdate(), 111),'/','-');
select cast( convert(varchar, getdate(), 101) as datetime) ;
select convert(varchar,d.datevalue,1-9);
select @day = datepart(day,@date) select @month = datepart(month,@date) select @year = datepart(year,@date);
select convert(varchar, @now, 23);
set @now = getdate() select convert(nvarchar(max), @now, 0) as output, 0 as style union select convert(nvarchar(max), @now, 1), 1 union select convert(nvarchar(max), @now, 2), 2 union select convert(nvarchar(max), @now, 3), 3 union select convert(nvarchar(max), @now, 4), 4 union select convert(nvarchar(max), @now, 5), 5 union select convert(nvarchar(max), @now, 6), 6 union select convert(nvarchar(max), @now, 7), 7 union select convert(nvarchar(max), @now, 8), 8 union select convert(nvarchar(max), @now, 9), 9 union select convert(nvarchar(max), @now, 10), 10 union select convert(nvarchar(max), @now, 11), 11 union select convert(nvarchar(max), @now, 12), 12 union select convert(nvarchar(max), @now, 13), 13 union select convert(nvarchar(max), @now, 14), 14 union select convert(nvarchar(max), @now, 20), 20 union select convert(nvarchar(max), @now, 21), 21 union select convert(nvarchar(max), @now, 22), 22 union select convert(nvarchar(max), @now, 23), 23 union select convert(nvarchar(max), @now, 24), 24 union select convert(nvarchar(max), @now, 25), 25 union select convert(nvarchar(max), @now, 100), 100 union select convert(nvarchar(max), @now, 101), 101 union select convert(nvarchar(max), @now, 102), 102 union select convert(nvarchar(max), @now, 103), 103 union select convert(nvarchar(max), @now, 104), 104 union select convert(nvarchar(max), @now, 105), 105 union select convert(nvarchar(max), @now, 106), 106 union select convert(nvarchar(max), @now, 107), 107 union select convert(nvarchar(max), @now, 108), 108 union select convert(nvarchar(max), @now, 109), 109 union select convert(nvarchar(max), @now, 110), 110 union select convert(nvarchar(max), @now, 111), 111 union select convert(nvarchar(max), @now, 112), 112 union select convert(nvarchar(max), @now, 113), 113 union select convert(nvarchar(max), @now, 114), 114 union select convert(nvarchar(max), @now, 120), 120 union select convert(nvarchar(max), @now, 121), 121 union select convert(nvarchar(max), @now, 126), 126 union select convert(nvarchar(max), @now, 127), 127 union select convert(nvarchar(max), @now, 130), 130 union select convert(nvarchar(max), @now, 131), 131;
select convert(nvarchar(11), getdate(), 0) union select convert(nvarchar(max), getdate(), 0);
set @dt = getdate() select convert(char(10),@dt,120);
set @mydatetime = '2008-05-03' select left(convert(varchar, @mydatetime, 120), 10);
select replace(convert(varchar(24),getdate(),103),'/','_') + '_'+;
set @datetime = '2018-11-23 10:03:23' select convert(varchar(100),@datetime,121 );
create function dbo.to_sap_datetime(@input datetime) as begin set @ret = coalesce(substring(replace(replace(replace(convert(varchar(26), @input, 25),'-',''),' ',''),':',''),1,14),'00000000000000');
select replace(convert(varchar, format(getdate(), n'dd/mm/yyyy hh:mm:ss tt')),'.', '/');
select col1 from tab order by isnull(col1), col1;
select col1 from tab order by if(col1 is null, 0, 1), col1 desc;
select col1 from tab order by isnull(col1) desc, col1;
select * from table;
select * from employees;
select * from employees;
select * from employees;
select smonecol1,somecol2 from somesch.sometab where somecol2 = 2101 and ( somecol1 is null ) union select smonecol1,somecol2 from somesch.sometab where somecol2 = 2101 and (  somecol1 is not null);
select * from employees;
select * from mytable order by nvl(mydate, to_date('1-1-1','dd-mm-yyyy'));
select mydate from mytable order by isnull(mydate,1) desc, mydate asc;
select * from some_table;
select mydate from mytable;
select s.student_id, last_name from student_classes sc where sc.class_id = x select c.class_id, name from student_classes sc where sc.student_id = y;
create table dbo.phonecalls ( id int identity(1, 1) not null, calltime datetime not null default getdate(), callerphonenumber char(10) not null ) create table dbo.tickets ( id int identity(1, 1) not null, createdtime datetime not null default getdate(), subject varchar(250) not null, notes varchar(8000) not null, completed bit not null default 0 ) create table dbo.phonecalls_tickets ( phonecallid int not null, ticketid int not null );
create table gov( gid number(6) primary key, name varchar2(25), address varchar2(30), termbegin date, termend date create table state( sid number(3) primary key, statename varchar2(15), population number(10), sgid number(4) references gov(gid), constraint gov_sdid unique (sgid);
create table vendor( vendornumber number(4) primary key, name varchar2(20), address varchar2(20), city varchar2(15), street varchar2(2), zipcode varchar2(10), contact varchar2(16), phonenumber varchar2(12), status varchar2(8), stampdate date create table inventory( item varchar2(6) primary key, description varchar2(30), currentquantity number(4) not null, vendornumber number(2) references vendor(vendornumber), reorderquantity number(3) not null;
create table class( classid varchar2(10) primary key, title varchar2(30), instructor varchar2(30), day varchar2(15), time varchar2(10) create table student( studentid varchar2(15) primary key, name varchar2(35), major varchar2(35), classyear varchar2(10), status varchar2(10) create table classstudentrelation( studentid varchar2(15) not null, classid varchar2(14) not null, foreign key (studentid) references student(studentid), foreign key (classid) references class(classid), unique (studentid, classid);
alter table post_comment add constraint fk_post_comment_post_id;
alter table post_details add constraint fk_post_details_id;
alter table post_tag add constraint fk_post_tag_post_id;
alter table post_tag add constraint fk_post_tag_tag_id;
select name, location, 1234 from courses where cid = $cid;
select name, location, 'whatever you want' from courses where cid = $ci;
select name, location, 1 from   courses where  cid = 2;
select name, location, 'whatever you want' from courses where cid = $ci;
select (name, location, gid) from courses where cid = $cid;
select column1, column2, column3 from table1 where condition;
select cast('qwerty' as char character set utf8) collate utf8_bin;
select  `col-1`,`col-2`;
select 1,2  union all select 1,2   union all select 1,2 ;
check constraint;
drop table if exists foo;
create table foo(name varchar(65535) not null)engine=innodb;
drop table if exists foo;
create table foo(name varchar(65533) not null)engine=innodb;
drop table if exists foo;
create table foo(name varchar(65533))engine=innodb;
drop table if exists foo;
create table foo(name varchar(65532))engine=innodb;
if (context.database.executesqlcommand(string.format("truncate table [{0}]", tablename)) == 1);
create procedure test_display as select firstname, lastname from tb_test;
exec test_display;
create procedure employee details as begin select * from employee end;
create procedure employee_insert as begin values (@employeeid, @name, @age, @mobile) end;
create procedure spgetperson create procedure spgetperson(@personid int) create procedure spgetperson(@personid int) as select firstname, lastname .... from people where personid = @personid;
create procedure <owner>.<procedure name> as ;
create procedure users_getuserinfo as  select * from [users] where isnull(@login,login)=login;
set ansi_nulls on set quoted_identifier on create procedure getemployee as begin set nocount on;
select firstname, lastname, birthdate, city, country from employees where employeeid = @employeeid end go;
set ansi_nulls on set quoted_identifier on alter procedure getemployee as begin set nocount on;
select firstname, lastname, birthdate, city, country from employees where employeeid = @employeeid end go;
drop procedure getemployee;
create procedure_name (para1 int,para2 decimal) as select * from tablename;
create procedure firsttest ( @inputa int ) as begin select 'a' + convert(varchar(10),@inputa) end go create procedure firsttest;2 ( @inputa int, @inputb int ) as begin select 'a' + convert(varchar(10),@inputa)+ convert(varchar(10),@inputb) end go;
exec firsttest 10 exec firsttest;2 20,30;
create procedure secondtest;2 ( @inputa int, @inputb int ) as begin select 'a' + convert(varchar(10),@inputa)+ convert(varchar(10),@inputb) end go;
create procedure dorepeat(p1 int) set @x = 0;
as begin set nocount on;
select businessentityid,              <<<----select statement to return one employee row loginid, jobtitle, hiredata, from humanresources.employee where businessentityid =@businessentityid     <<<---parameter used as criteria end;
update mytable set mycolumn=null where mycolumn='';
select * from mytable where mycolumn is null;
where col is null;
where col is not null;
select mycol from mytable where mycol is null;
select mycol from mytable where trim(coalesce(mycol, '')) = '';
select mycol from mytable where mycol is null or mycol =  '';
select * from my_table where nullif(some_col, '') is null;
select 0 is null ,  '' is null , null is null;
select isnull('  ') , isnull( null );
select * from table where some_col is null or some_col = '';
select * from t where some_col is null or some_col = ' ';
select * from t where nullif(some_col, ' ') is null;
where some_col > '';
select isnull(nullif(fieldname,''))  from tablename;
select * from my_table where isnull(nullif(some_col, ''));
select firstname from userdetails where trim(lastname) is null;
select firstname from userdetails where ltrim(rtrim(lastname)) is null;
select column_name from table_name where column_name in (null, '');
select if(field1 is null or field1 = '', 'empty', field1) as field1 from tablename;
select case when field1 is null or field1 = '' then 'empty' else field1 end as field1 from tablename;
select * from table where column_name like '';
select * from table where column_name not like '';
select * from table where column_name is null or column_name = '';
select * from table where column_name > = 0;
select * from table where length(rtrim(ltrim(column_name))) > 0;
select * from tbl where trim(ifnull(col,'')) <> '';
select * from table where some_col is not true;
select * from table where some_col is true;
create global temporary table t1 value varchar2(5), value2 varchar2(5) ) create global temporary table t2 value varchar2(5), value2 varchar2(5)) alter table t2 add constraint pk_lkp_migration_info primary key (id);
update set t2.value = t1.value, t2.value2 = t1.value2 select * from t2;
update tablename set val1 = in_val1, val2 = in_val2 where val3 = in_val3;
if ( sql%notfound ) then values (in_val1, in_val2, in_val3);
values (in_val1, in_val2, in_val3);
update tablename set val1 = in_val1, val2 = in_val2 where val3 = in_val3;
if ( sql%rowcount = 0 ) then insert into tablename values (in_val1, in_val2, in_val3);
create or replace procedure ups(xa number) as begin end ups;
drop table mergetest;
create table mergetest(a number, b number);
select * from mergetest;
values ('x', 123);
update t set    mystuff = 123 where  mykey = 'x';
then into else into customers select * from new_customers;
select 'area_in_common_use_double','area in common use','double', null, 9000, 9 from dual ) ( select * from b_building_property where id = 9 );
values ( 2097153,"smith", "john" );
select '028-01' cilt, '25' sayfa, '6' kutuk, '46603404838' mernis_no from dual update set b.cilt = e.cilt, b.sayfa = e.sayfa, b.kutuk = e.kutuk values (e.cilt, e.sayfa, e.kutuk, e.mernis_no);
procedure myproc ( ... values ( 2097153,"smith", "john" );
if exists(select * from sys.procedures where name like 'uspblacklistgetall') drop procedure uspblacklistgetall end go create procedure uspblacklistgetall;
if not exists (select * from sys.objects where type = 'p' and object_id = object_id('dbo.myproc')) alter procedure [dbo].[myproc] as ....;
if (object_id('myprocedure') is not null) drop procedure myprocedure;
if not exists (select * from sysobjects where name='my_procedure') begin end else begin end;
set ansi_nulls on set quoted_identifier on create -- view procedure function or anything you want ...;
if exists (select * from dbo.sysobjects where id = object_id('my_procedure')) drop procedure my_procedure end  set ansi_nulls on set quoted_identifier on create procedure [dbo].my_procedure ...;
select  * from    mytable where   @myvar ... end;
if exists ( select  * from    sys.objects where   object_id = object_id(n'myproc') and type in ( n'p', n'pc' ) ) drop  create ;
if exists ( select * from   sysobjects where  id = object_id(n'[dbo].[myproc]') and objectproperty(id, n'isprocedure') = 1 ) drop procedure [dbo].[myproc] end;
create or alter procedure dbo.myproc;
if not exists (select ss.name as schemaname, sp.name as storedproc from sys.procedures sp join sys.schemas ss on sp.schema_id = ss.schema_id where ss.name = 'dbo' and sp.name = 'mystoredproc') select @sql = 'create procedure [dbo].[mystoredproc] ( @myparam int ) as select @myparam' exec sp_executesql @sql end;
if object_id('schema.storedprocname') is not null drop procedure schema.storedprocname end go create procedure schema.storedprocname as  end;
create procedure [dbo].[spaddnewclass] @classname varchar(20),@classfee int as begin end  create procedure [dbo].[spaddnewsection] @sectionname varchar(20),@classid       int as begin end  create procedure test as begin select * from tblstudent end;
if exists (select 1 from information_schema.routines where routine_name = 'mysp' and routine_type = 'procedure');
drop procedure if exists;
drop { proc | procedure } [ if exists ] { [ schema_name. ] procedure } [ ,...n ];
create or alter procedure proctest as begin;
drop  procedure if exists dbo.[procname];
if not exists ( select * from sys.objects where object_id = object_id(n'[dbo].[uspmyprocedure]') ) exec sp_executesql n'create procedure [dbo].[uspmyprocedure] as select 1' end go alter procedure [dbo].[uspmyprocedure] as begin end;
if object_id('myprocedure', 'p') is not null drop procedure myprocedure;
select name from master..spt_values where type = 'o9t';
create table test( txt_col  varchar(10) not null ) select convert(varchar(10), row_number() over (order by (select 1))) r from master..spt_values a, master..spt_values b create index ix_test_data set statistics io on select txt_col from test where txt_col like '%10000' select txt_col from test where txt_col like '1%99' select txt_col from test where txt_col like '10000' select txt_col from test where txt_col = '10000' drop table test;
create table testtable ( varchar_name varchar(10), char_name char(10), val integer values ('a', 'a', 10), ('b', 'b', 20);
select 'varchar eq without space', val from testtable where varchar_name='a' union all select 'varchar eq with space', val from testtable where varchar_name='a ' union all select 'varchar like without space', val from testtable where varchar_name like 'a' union all select 'varchar like space', val from testtable where varchar_name like 'a ' union all select 'char eq without space', val from testtable where char_name='a' union all select 'char eq with space', val from testtable where char_name='a ' union all select 'char like without space', val from testtable where char_name like 'a' union all select 'char like with space', val from testtable where char_name like 'a ';
select 'cast none', val from testtable where char_name like 'a' union all select 'cast both', val from testtable where union all select 'cast col', val from testtable where cast(char_name as char) like 'a' union all select 'cast value', val from testtable where char_name like cast('a' as char);
select * from some_table where varcharcol = '' select * from some_table where varcharcol like '';
const uchar *s, size_t slen, const uchar *t, size_t tlen, my_bool t_is_prefix);
select * from store where quantity = 200;
select * from employees where name like 'chris%';
select * from employees where name = 'chris';
select * from employees where name like 'chris';
select * from employees where name = 'chris%';
select * from employees where name like 'chris%';
where login like '12345678';
where login ='12345678';
select *  from `table` where binary `column` = 'value';
select * from (select * from `table` where `column` = 'value') as firstresult where binary `column` = 'value';
select 'a' like 'a' select 'a' like binary 'a' select * from user where username like binary 'a';
select * from tb_app where binary android_package='com.mtime';
select *  from `table` where binary `column` = 'value';
select *  from `table` where `column` = binary 'value';
set psignal = set psuccess =(select in_usdsignal like binary psignal);
if psuccess = 1 then else /*your code if don't match*/ end if;
select * from `table` where `column` = convert('value' using utf8mb4) collate utf8mb4_bin;
alter table tablename change oldcolname newcolname datatype(length);
alter table tablename rename column oldcolname to newcolname datatype(length);
alter table table_name rename column old_col_name to new_col_name;
alter table `dbname`.`tablename` change column `old_columnname` `new_columnname` varchar(45) null default null ;
alter table table_name rename column old_col_name to new_col_name;
alter table categories change  type  category_type varchar(255);
alter table table_name;
alter table customer change customercity customer_city varchar(225);
alter table creditreportxml_temp change column applicationid applicantid int(11);
alter table *table_name* change column *old_column_name* *new_column_name* datatype();
alter table table_name change column_1 column_2 data_type;
alter table student change name first_name varchar(20);
alter table your_table_name rename column original_column_name to new_column_name;
alter table your_table_name change original_column_name new_col_name data_type;
alter table your_table_name change original_column_name new_col_name y_data_type after column_x;
select tag.title from tag join itemtag on tag.tagid = itemtag.tagid where itemtag.itemid = :id;
select tag.title from tag where tag.itemid = :id;
select tag.title, count(*) from tag join itemtag on tag.tagid = itemtag.tagid;
select tag.title, count(*) from tag;
select item.* from item join itemtag on item.itemid = itemtag.itemid join tag on itemtag.tagid = tag.tagid where tag.title = :title;
select item.* from item join tag on item.itemid = tag.itemid where tag.title = :title;
alter table table_name modify column column_name varchar (size);
alter table tab_name alter column col_name new_larger_data_type;
alter table alter column;
if columnproperty(object_id('employee', 'u'), 'salary', 'allowsnull')=0 alter table [employee] alter column [salary] numeric(22,5) not null else alter table [employee] alter column [salary] numeric(22,5) null;
alter table [table_name] alter column [column_name] varchar(150);
alter table employee alter column salary numeric(22,5);
alter table [employee] alter column [salary] numeric(22,5) not null;
select  (s.name)schemaname, (o.name)objectname, (o.type)objecttype,(o.type_desc)objectdesc,(so.category)category from    sys.objects o where s.name = @myschemaname and so.category=0 and o.type in ('p','pc','u','v','fn','if','tf','fs','ft','pk','tt') set @sql='';
if @objecttype in('fn', 'if', 'tf', 'fs', 'ft') set @sql=@sql+'drop function '+@myschemaname+'.'+@objectname+char(13) if @objecttype in('v') set @sql=@sql+'drop view '+@myschemaname+'.'+@objectname+char(13) if @objecttype in('p') set @sql=@sql+'drop procedure '+@myschemaname+'.'+@objectname+char(13) if @objecttype in('u') set @sql=@sql+'drop table '+@myschemaname+'.'+@objectname+char(13) end close cur;
set @sql=@sql+case when len(@sql)>0 then 'drop schema '+@myschemaname+char(13) else '' end;
drop schema public cascade;
create schema public;
select obj.object_id, s.name as schema_name, obj.name, obj.type, parent_object_id from sys.schemas s join sys.objects obj on obj.schema_id = s.schema_id where s.name = 'schema_name' and (type = 'p' or obj.type = 'v' or obj.type = 'u' or obj.type = 'f' or obj.type = 'fn') if @type = 'p' end  if @type = 'fn' end  if @type = 'f' set @parentobjname = (select name from sys.objects where object_id = @parentobjid) end  if @type = 'u' end  if @type = 'v' end fetch next from cur into  @objectid, @schemaname, @objectname,  @type, @parentobjid end close cur;
select * from all_objects where object_type ='table' and owner='schema_name';
select * from all_objects where object_type in ('sequence', 'procedure', 'package', 'function', 'view') and  owner='schema_name';
select * from all_objects where object_type in ('type') and  owner='schema_name';
select 'drop table "' || table_name || '" cascade constraints;' from user_tables union all select 'drop '||object_type||' '|| object_name || ';' from user_objects where object_type in ('view','package','sequence', 'procedure', 'function') union all select 'drop ' from user_objects where object_type in ('type');
exec sp_msforeachtable @command1="alter table ? nocheck constraint all" exec sp_msforeachtable @command1="alter table ? disable trigger all";
select 'drop table '+name from sys.tables where type='u';
select 'drop procedure '+name from  sys.procedures where type='p';
select [name], xtype from sysobjects where xtype in ('u', 'p', 'fn', 'if', 'tf', 'v', 'tr') -- configuration point 1 set @prefix = case @type end  set @sql = @prefix + ' ' + @name end ;
select 'alter table ' + table_name  +'  drop constraint ' + constraint_name  from information_schema.constraint_table_usage select 'drop procedure ' + specific_name  from information_schema.routines where specific_name not like 'sp%' and specific_name not like 'fn_%' select 'drop view ' + table_name  from information_schema.tables where table_type = 'view' select 'drop trigger ' + name from sysobjects where type = 'tr' select 'drop table ' + table_name  from information_schema.tables where table_type = 'base table';
select @name = (select top 1 [name] from sys.types where is_user_defined = 1 order by [name]) select @sql = 'drop type [dbo].[' + rtrim(@name) +']' exec (@sql) select @name = (select top 1 [name] from sys.types where is_user_defined = 1 and [name] > @name order by [name]) end go;
select 'drop table [' + schema_name(schema_id) + '].[' + name + ']' from sys.tables;
set @cursor = cursor fast_forward for select distinct sql = 'alter table ['+tc2.constraint_schema+'].[' + tc2.table_name + '] drop [' + rc1.constraint_name + ']' from information_schema.referential_constraints rc1 exec (@sql) end  select @sql = @sql + 'drop view ' + quotename(schema_name(schema_id)) + '.' + quotename(v.name) +';' + @crlf from   sys.views v select @sql = @sql + 'drop proc ' + quotename(schema_name(p.schema_id)) + '.' + quotename(p.name) +';' + @crlf from   [sys].[procedures] p exec sp_msforeachtable 'drop table ?' select distinct 'drop sequence ' + s.sequence_schema + '.' + s.sequence_name from information_schema.sequences s end  set @cursor = cursor fast_forward for select sql = 'drop schema ['+schemaname+']' from join information_schema.schemata s on s.schema_name = x.schemaname exec (@sql) end ;
select @tname = (select top 1 [name] from sys.objects where [type] = 'u' and [name] like n'tablename%' order by [name]) select @strsql = 'drop table [dbo].[' + rtrim(@tname) +']' exec (@strsql) select @tname = (select top 1 [name] from sys.objects where [type] = 'u' and [name] like n'tablename%'  and [name] > @tname order by [name]) end;
select @name = (select top 1 [name] from sys.types where is_user_defined = 1) select @sql = 'drop type [dbo].[' + rtrim(@name) +']' exec (@sql) select @name = (select top 1 [name] from sys.types where is_user_defined = 1) end go;
exec sp_cleandatabases @databasename='dbname';
drop database ???;
create database ???;
exec sp_msforeachtable 'drop table ?';
select @name = (select top 1 [name] from sysobjects where [type] = 'p' and category = 0 order by [name]) select @sql = 'drop procedure [dbo].[' + rtrim(@name) +']' exec (@sql) select @name = (select top 1 [name] from sysobjects where [type] = 'p' and category = 0 and [name] > @name order by [name]) end go select @name = (select top 1 [name] from sysobjects where [type] = 'v' and category = 0 order by [name]) select @sql = 'drop view [dbo].[' + rtrim(@name) +']' exec (@sql) select @name = (select top 1 [name] from sysobjects where [type] = 'v' and category = 0 and [name] > @name order by [name]) end go select @name = (select top 1 [name] from sysobjects where [type] in (n'fn', n'if', n'tf', n'fs', n'ft') and category = 0 order by [name]) select @sql = 'drop function [dbo].[' + rtrim(@name) +']' exec (@sql) select @name = (select top 1 [name] from sysobjects where [type] in (n'fn', n'if', n'tf', n'fs', n'ft') and category = 0 and [name] > @name order by [name]) end go select @name = (select top 1 table_name from information_schema.table_constraints where constraint_catalog=db_name() and constraint_type = 'foreign key' order by table_name) select @constraint = (select top 1 constraint_name from information_schema.table_constraints where constraint_catalog=db_name() and constraint_type = 'foreign key' and table_name = @name order by constraint_name) select @sql = 'alter table [dbo].[' + rtrim(@name) +'] drop constraint [' + rtrim(@constraint) +']' exec (@sql) select @constraint = (select top 1 constraint_name from information_schema.table_constraints where constraint_catalog=db_name() and constraint_type = 'foreign key' and constraint_name <> @constraint and table_name = @name order by constraint_name) end select @name = (select top 1 table_name from information_schema.table_constraints where constraint_catalog=db_name() and constraint_type = 'foreign key' order by table_name) end go select @name = (select top 1 table_name from information_schema.table_constraints where constraint_catalog=db_name() and constraint_type = 'primary key' order by table_name) select @constraint = (select top 1 constraint_name from information_schema.table_constraints where constraint_catalog=db_name() and constraint_type = 'primary key' and table_name = @name order by constraint_name) select @sql = 'alter table [dbo].[' + rtrim(@name) +'] drop constraint [' + rtrim(@constraint)+']' exec (@sql) select @constraint = (select top 1 constraint_name from information_schema.table_constraints where constraint_catalog=db_name() and constraint_type = 'primary key' and constraint_name <> @constraint and table_name = @name order by constraint_name) end select @name = (select top 1 table_name from information_schema.table_constraints where constraint_catalog=db_name() and constraint_type = 'primary key' order by table_name) end go select @name = (select top 1 [name] from sysobjects where [type] = 'u' and category = 0 order by [name]) select @sql = 'drop table [dbo].[' + rtrim(@name) +']' exec (@sql) select @name = (select top 1 [name] from sysobjects where [type] = 'u' and category = 0 and [name] > @name order by [name]) end go;
select * from sys.objects;
set @n = char(10) select @stmt = isnull( @stmt + @n, '' ) + from sys.procedures select @stmt = isnull( @stmt + @n, '' ) + from sys.check_constraints select @stmt = isnull( @stmt + @n, '' ) + from sys.objects where type in ( 'fn', 'if', 'tf' ) select @stmt = isnull( @stmt + @n, '' ) + from sys.views select @stmt = isnull( @stmt + @n, '' ) + from sys.foreign_keys select @stmt = isnull( @stmt + @n, '' ) + from sys.tables select @stmt = isnull( @stmt + @n, '' ) + from sys.types where is_user_defined = 1 exec sp_executesql @stmt;
from sys.objects             o left outer join where o.name is not null and isnull(o.is_ms_shipped, 0) = 0 and isnull(e.name, '') <> 'microsoft_database_tools_support' and ( o.type_desc = 'sql_stored_procedure' or o.type_desc = 'sql_scalar_function' ) set @sname = schema_name( @schema_id );
if @ftype = 'sql_stored_procedure' if @ftype = 'sql_scalar_function' end ;
create table employee (employeeid int);
select @employeeid = e.employeeid from dbo.employee e;
set @employeeid = (select e.employeeid from dbo.employee e);
set @employeeid = (select e.employeeid from dbo.employee e where e.employeeid = 1);
drop table employee;
select  @a = tbl.a from    ( select 1 a ) tbl where   1 = 2 select  @a set @a = ( select  tbl.a from    ( select 1 a) tbl where   1 = 2 ) select  @a;
set @var = 'joe' set @var = (select name from master.sys.tables where name = 'qwerty') select @var /* @var is now null */ set @var = 'joe' select @var = name from master.sys.tables where name = 'qwerty' select @var /* @var is still equal to 'joe' */;
if (rs.next()) {;
if (count >= 1) {;
if (rs != null);
select count(*);
if (rs.last()) {;
select count(*) from ...;
if (rs != null);
resultset.concur_read_only);
select mybool,myint,mychar,mysmallint,myvarchar from mytable where ...blahblah...;
resultset.concur_read_only);
select a, b from t;
select a, max(b) as x from t;
select col1, col2, sum(col3) totalsum from tablename;
select * from (select name, id from empoyee) visits in ([emp1], [emp2], [emp3];
@query  as nvarchar(max) select @cols = stuff((select ',' + quotename(my_key) from yt set @query = 'select id,' + @cols + ' from ( select id, my_key, val from yt ( sum(val);
exec dbo.rs_pivot_table @schema=dbo,@table=table_name,@column=column_to_pivot,@agg='sum([column_to_agg]),avg([another_column_to_agg]),', @sel_cols='column_to_select1,column_to_select2,column_to_select1',@new_table=returned_table_pivoted;
create procedure [dbo].[rs_pivot_table] @table sysname, @column sysname, @agg nvarchar(max), @sel_cols varchar(max), @new_table sysname, @add_to_col_name sysname=null as --exec dbo.rs_pivot_table dbo,##temporal1,tip_liq,'sum([val_liq]),sum([can_liq]),','cod_emp,cod_con,tip_liq',##temporal1pvt,'hola';
create table #pvt_column( pivot_col varchar(100) opp_agg varchar(5), col_agg varchar(100) if  exists (select * from sys.objects where object_id = object_id(@table) and type in (n'u')) set @ind_tmptbl=0;
else if object_id('tempdb..'+ltrim(rtrim(@table))) is not null set @ind_tmptbl=1;
if  exists (select * from sys.objects where object_id = object_id(@new_table) and type in (n'u')) or set @query='drop table '+@new_table+'';
select @query='select distinct '+@column+' from '+(case when @ind_tmptbl=1 then 'tempdb.' else '' end)+@schema+'.'+@table+' where '+@column+' is not null;';
exec (@query) select @aggdet=substring(@agg,1,charindex(',',@agg,1)-1);
set @agg=substring(@agg,charindex(',',@agg,1)+1,len(@agg)) end  select opp_agg,col_agg from @column_agg;
select pivot_col from #pvt_column;
select @query_col_pvt='isnull('+@opp_agg+'(case when '+@column+'='+quotename(@pivot_col,char(39))+' then '+@col_agg+ select @full_query_pivot=@full_query_pivot+@query_col_pvt+', ' end  end  select @full_query_pivot=substring(@full_query_pivot,1,len(@full_query_pivot)-1);
select @query='select '+@sel_cols+','+@full_query_pivot+' into '+@new_table+' from '+(case when @ind_tmptbl=1 then 'tempdb.' else '' end)+ exec (@query);
exec dbo.rs_pivot_table @schema=dbo,@table=##temporal1,@column=tip_liq,@agg='sum([val_liq]),avg([can_liq]),',@sel_cols='cod_emp,cod_con,tip_liq',@new_table=##temporal1pvt;
select * from ##temporal1pvt;
select @columnname= isnull(@columnname + ',','') + quotename(week) from (select distinct week from #storesales) as weeks set @dynamicpivotquery = from #storesales exec sp_executesql @dynamicpivotquery;
select storeid, week1=(select isnull(sum(xcount),0) from storecountsbyweek where storecountsbyweek.storeid=store.storeid and week=1), week2=(select isnull(sum(xcount),0) from storecountsbyweek where storecountsbyweek.storeid=store.storeid and week=2), week3=(select isnull(sum(xcount),0) from storecountsbyweek where storecountsbyweek.storeid=store.storeid and week=3) from store;
create table #yt ( [store] int, [week] int, [xcount] int ( [store], [week], [xcount] ) values (102, 1, 96), (101, 1, 138), (105, 1, 37), (109, 1, 59), (101, 2, 282), (102, 2, 212), (105, 2, 78), (109, 2, 97), (105, 3, 60), (102, 3, 123), (101, 3, 220), (109, 3, 87);
select * from ( select store, week, xcount from yt ( sum(xcount);
@query  as nvarchar(max) select @cols = stuff((select ',' + quotename(week) from yt set @query = 'select store,' + @cols + ' from ( select store, week, xcount from yt ( sum(xcount);
select * from yourtable;
select  * from    fiberbox f join    ( select '%1740%' as cond union all select '%1938%' as cond union all select '%1940%' as cond;
select  * from    fiberbox f where   exists ( select  1 from    ( select '%1740%' as cond union all select '%1938%' as cond union all select '%1940%' as cond where   f.fiberbox like cond );
select * from fiberbox where field regexp '1740|1938|1940';
select * from fiberbox where field like '%1740 %' or field like '%1938 %' or field like '%1940 %';
select * from fiberbox where field regexp '1740 |1938 |1940 ';
select * from fiberbox where field like '1740 %' or field like '%1938 ' or field like '%1940 % test';
select * from fiberbox where field regexp '^1740 |1938 $|1940 (.*) test';
select * from fiberbox where field like '%1740 %' or field like '%1938 %' or field not like '%1940 %' or field not like 'test %' or field = '9999';
select * from fiberbox where field regexp '1740 |1938 |^9999$' or field not regexp '1940 |^test ';
select * from fiberbox where field regexp '1740 |1938 ' or field not regexp '1940 |^test ' or field not like 'test %' or field = '9999';
select * from table where field regexp concat_ws("|",( "111", "222", "333";
select * from table where field regexp concat_ws("|", "111", "222", "333");
select fiberbox from fiberbox where fiberbox regexp '[1740|1938|1940]';
select fiberbox from fiberbox where fiberbox regexp '[174019381940]';
'val1', 'val2', 'val3' );
select * from fiberbox where fiber in('140 ', '1938 ', '1940 ');
modify innodb_buffer_pool_size value ; when load data , use 50% of os mem ;
set @@local.net_read_timeout=360;
set @@global.net_read_timeout=360;
set global interactive_timeout=60;
set global connect_timeout=60;
select * from information_schema.statistics where table_schema = '<schema>';
create index idx_customer_account_import_id on customer (account_import_id);
delete from table where mod(id,10) = 0;
delete from table where mod(id,10) != 0;
update customer set account_import_id = 1;
transactionconnectionquery() );
transactionconnectionquery() );
select a.i, a.j, count(*) as row_number from test a join test b on a.i = b.i and a.j >= b.j;
select col1, col2, ( select count(*) from table1 where col1 = t1.col1 and col2 = t1.col2 and col3 > t1.col3 from table1 t1;
( select 1 row_num, 1 some_val from any_table --dual in oracle union all select row_num+1, some_val+row_num from data where row_num < 20 -- any number ) select * from data where row_num between 5 and 10;
select  @row_num := if(@prev_value=concat_ws('',t.col1,t.col2),@row_num+1,1) as rownumber from table1 t, (select @row_num := 1) x, (select @prev_value := '') y;
drop function if exists `getfakeid`$$ create function `getfakeid`() returns int(11);
select getfakeid() as id, t.* from table t, (select @fakeid:=0) as t2;
select @i:=@i+1 as iterator, t.* from tablename as t, (select @i:=0) as foo;
select t.*, @rownum := @rownum + 1 as rank from your_table t, (select @rownum := 0) r;
select t0.col3 from table as t0 where t1.col1 is null;
select col1, col2, count(*) as introw from table1;
select @s:=@s+1 serial_no, tbl.* from my_table tbl, (select @s:=0) as s;
set @row_number=0;
select (@row_number := @row_number +1) as num,id,name from sbs;
select  @row_num := if(@prev_value=gender,@row_num+1,1) as rownumber age, gender, @prev_value := gender from person, (select @row_num := 1) x, (select @prev_value := '') y;
select * from ( select case when @partitionby_1 = l then @row_number:=@row_number+1 else @row_number:=1 end as i from ( select @row_number:=0,@partitionby_1:=null select 1 as n, 'a' as l union all select 1 as n, 'b' as l union all select 2 as n, 'b' as l union all select 2 as n, 'a' as l union all select 3 as n, 'a' as l union all select 3 as n, 'b' as l where i > 1;
case when @partitionby_1 = part1 and @partitionby_2 = part2 [...] then @row_number:=@row_number+1 else @row_number:=1 end as i from ( select @row_number:=0,@partitionby_1:=null,@partitionby_2:=null[...];
select a.i, a.j, ( select count(*) from test b where a.j >= b.j and a.i = b.i;
select @i:= @i+1 as arg_value_lookup_id,argument_name,value,description,current_timestamp,'admin',1,uuid() from temp_arg_value_lookup;
select col1, col2, col3 from ( select col1, col2, col3, @n := case when @v = make_set(3, col1, col2) then @n + 1 -- if we are in the same group else 1 -- next group starts so we reset the counter end as row_number, @v := make_set(3, col1, col2) -- we store the current value for next iteration from table1, (select @n := 0, @v := null) r -- helper table for iteration with startup values;
select @row_num := if(@prev_value= concat(`fk_business_unit_code`,`netiq_job_code`), @row_num+1, 1) as rownumber, `fk_business_unit_code`, `netiq_job_code`, `supervisor_name`, @prev_value := concat(`fk_business_unit_code`,`netiq_job_code`) from (select distinct `fk_business_unit_code`,`netiq_job_code`,`supervisor_name` from employee (select @row_num := 1) x, (select @prev_value := '') y;
create table table1( id int auto_increment primary key, col1 int,col2 int, col3 text);
values (1,1,'a'),(1,1,'b'),(1,1,'c'), (2,1,'x'),(2,1,'y'),(2,2,'z');
select col1, col2,col3, row_number() over (partition by col1, col2 order by col3 desc) as introw from table1;
set @row_number = 0;
select (@row_number:=@row_number + 1) as num, firstname, lastname from employees;
select (row number variable that uses partition variable), (assign partition variable);
select t.*, @r := case else 1 end as rn from t, (select @r := 0, @prevcol := null) x;
select t.*, row_number() over(partition by pcol1, pcol2, ... pcolx order by ocol1, ocol2, ... ocolx) rn from t;
select t.*, @r := case else 1 end as rn from t, (select @r := 0, @pcol1 := null, @pcol2 := null, ..., @pcolx := null) x;
select @pcol1 := cast(null as int), @pcol2 := cast(null as date);
select t.*, @rowid := @rowid + 1 as rowid from table t, (select @rowid := 0) dummy;
select t.*, case when <partition_field> = @rownum1 := @rownum1 + 1 end as rank from your_table t, (select @rownum1 := 0) r1, (select @rownum2 := 0) r2;
select * from orders where delivered=ordered;
select * from orders where delivered<>ordered;
create function [dbo].[ufn_equal_with_nulls] ( @i sql_variant, @d sql_variant ) as begin if @i is null set @in = 1 if @d is null set @dn = 1 if @in <> @dn if @in = 1 and @dn = 1 if @in = 0 and @dn = 0 and @i = @d end;
(1,2), (1,null), (null,1), (null,null) select *, [dbo].[ufn_equal_with_nulls](a,b) as [=] from @tmp select *,'equal' as [predicate] from @tmp where  [dbo].[ufn_equal_with_nulls](a,b) = 1 select *,'not equal' as [predicate] from @tmp where  [dbo].[ufn_equal_with_nulls](a,b) = 0;
select * from mytable where isnull(mycolumn, ' ') = ' ';
select case when not (1 = null or (1 is null and null is null)) then 1 else 0 end;
where a != b or (a is null and b is not null) or (a is not null and b is null);
select * from mytable where mycolumn != null;
select * from mytable where mycolumn <> null;
set ansi_nulls off;
set ansi_nulls off;
select * from scores limit 10;
select * from scores;
select distinct * from scores;
select * from scores limit 10;
from mytable where <various conditions> limit 10) union all  from mytable where <various conditions> limit 10);
select * from (select rank() over (order by some_value_column desc) as my_rank from mytable) subquery where my_rank <= 10;
update table set columnb = columna;
update table_name set where condition_if_necessary;
update table set columnb = columna;
update table set columnb = columna where table.column>0;
select * from table where column_name in;
select count(poid) from poitem where poid = 50 and rownum < any (select count(*)  from poitem where poid = 50) select count(poid) from poitem where poid in (50) having count(poid) > 1;
select * from emp where rowid not in;
select * from table_with_duplicates where rowid in from (select rowid, row_number() over ( partition by c1 || c2 || c3 from table_with_duplicates) t2 where nblines > 1);
select column_name, count(1) from table having count (column_name) > 1;
select   socialsecurity_number, count(*) no_of_rows from     socialsecurity having   count(*) > 1;
select oed.empid, count(oed.empid) from emp_dept oed where exists ( select * from  emp_dept ied where oed.rowid <> ied.rowid and;
select oed.empid, count(oed.empid) from emp_dept oed where exists ( select * from  emp_dept ied where oed.id <> ied.id and;
select * from table a where exists ( select 1 from table where column_name = a.column_name and rowid < a.rowid );
select column_name from table having count(*) > 1;
select column_name, count(column_name) from table_name having count(column_name) > 1;
select job_number, count(*) from jobs having count(*) > 1;
select <column>, count(*) from <table>;
select job_number, count(*) from jobs;
select count(j1.job_number), j1.job_number, j1.id, j2.id from   jobs j1 join jobs j2 on (j1.job_numer = j2.job_number) where  j1.id != j2.id;
select (`prod_code` * 1) as `prod_code` from product`;
select cast(prod_code as unsigned) from product;
select 8000,0,'multi 8000',1 from dual union all select 8001,0,'multi 8001',1 from dual;
procedure ins p_exch_nat_key integer, p_exch_date date, exch_rate number, p_from_curcy_cd varchar2, p_to_curcy_cd varchar2, p_exch_eff_date date, p_exch_eff_end_date date, p_exch_last_updated_date date);
exch_nat_key, exch_date, exch_rate, from_curcy_cd, to_curcy_cd, exch_eff_date, exch_eff_end_date, exch_last_updated_date) values (p_exch_wh_key, p_exch_nat_key, p_exch_date, exch_rate, p_from_curcy_cd, p_to_curcy_cd, p_exch_eff_date, p_exch_eff_end_date, p_exch_last_updated_date);
ins (2, 1, '28-aug-2008', .54, 'usd', 'gbp', '28-aug-2008', '28-aug-2008', '28-aug-2008'), ins (3, 1, '28-aug-2008', 1.05, 'usd', 'cad', '28-aug-2008', '28-aug-2008', '28-aug-2008'), ins (4, 1, '28-aug-2008', .68, 'usd', 'eur', '28-aug-2008', '28-aug-2008', '28-aug-2008'), ins (5, 1, '28-aug-2008', 1.16, 'usd', 'aud', '28-aug-2008', '28-aug-2008', '28-aug-2008'), ins (6, 1, '28-aug-2008', 7.81, 'usd', 'hkd', '28-aug-2008', '28-aug-2008', '28-aug-2008');
select 1 from dual;
select x, 'anyname' from dual;
values (id, given_name, family_name, title) values (id, admission_date) values (id, hired_date) select 4 id, 'ruth' given_name, 'fox' family_name, 'mrs' title, null hired_date, date'2009-12-31' admission_date from   dual union all select 5 id, 'isabelle' given_name, 'squirrel' family_name, 'miss' title , null hired_date, date'2014-01-01' admission_date from   dual union all select 6 id, 'justin' given_name, 'frog' family_name, 'master' title, null hired_date, date'2015-04-22' admission_date from   dual union all select 7 id, 'lisa' given_name, 'owl' family_name, 'dr' title, date'2015-01-01' hired_date, null admission_date from   dual ) select * from names;
id, column_a, column_b ) select table_a_seq.nextval, b.name, 123 from table_b b;
select charindex('char', 'my char');
select strmiddlename, case when instr(strmiddlename,' ',1,2) != 0 then substr(strmiddlename,1,1) || substr(strmiddlename,instr(strmiddlename,' ',1,1)+1,1)|| else substr(strmiddlename,1,1) end as firstletters from dual;
select substr(thatcolumn, 1, 1) as newcolumn from student;
set @result = substring(@somestring, 2, 3) select @result;
set @result = left(@somestring, 6) select @result;
select left(fname, 2) as firstname from dbo.namemaster;
select from something s where s.id in ( select distinct dcr.something_id from diff_cardinality_relationship dcr ) -- to keep same cardinality;
select from something s where exists ( select 1 from diff_cardinality_relationship dcr where dcr.something_id = s.id );
set @t1 = getdate();
select distinct u.profession from users u; --query with distinct set @t2 = getdate();
set @t1 = getdate();
select u.profession from users u group by u.profession; --query with group by set @t2 = getdate();
set statistics time on;
select distinct u.profession from users u; --query with distinct select u.profession from users u group by u.profession; --query with group by set statistics time off;
select u.profession from users u group by u.profession desc;
select distinct u.profession from users u;
select u.employer, count(u.id) as "total employees" from users u group by u.employer;
distinct u.employer;
select distinct u.profession from users u;
select u.profession from users u group by u.profession order by null;
select distinct id, name from some_query_with_joins select id, name from some_query_with_joins group by id;
select * from your_table where col1 and col2 and col3 and col4 and col5 is not null;
select distinct (  select title from test where title is not null limit 1  select body from test where body is not null limit 1 from test;
select col1, col2, ..., coln from yourtable where somecolumn is not null;
select col1, col2, ..., coln from yourtable where col1 is not null and col2 is not null and coln is not null;
select * from ( select col1 as col from yourtable union select col2 as col from yourtable union -- ... union select coln as col from yourtable where col is not null;
select * from table where yourcolumn is not null;
select * from table where not (yourcolumn <=> null);
select val1 as val from  your_table where val1 is not null union all select val2 from  your_table where val2 is not null;
select case idx end as val from   your_table join (select 1 as idx union all select 2) t having val is not null  /*can reference alias in having in mysql*/;
select * from table_name where column_name <> '';
select * from table where column is not null;
select * from table where column <>'';
select * from table where col is not null;
select * from users where user_id is not null;
select * from users where email_address is not null and mobile_number is not null;
select * from users where email_address is not null or mobile_number is not null;
select t.name, s.row_count from sys.tables t join sys.dm_db_partition_stats s and t.type_desc = 'user_table' and t.name not like '%dss%' and s.index_id in (0,1);
select sum(sdmvptns.row_count) as [dbrows] from sys.objects as sobj where sobj.type = 'u' and sobj.is_ms_shipped = 0 and sdmvptns.index_id < 2;
select table_name from information_schema.tables select @stmt = 'select @rowcount = count(*) from ' + @tablename exec sp_executesql @stmt, n'@rowcount int output', @rowcount=@rowcount output end ;
create table #counts ( table_name varchar(255), row_count int ) exec sp_msforeachtable @command1='insert #counts (table_name, row_count) select ''?'', count(*) from ?' select table_name, row_count from #counts order by table_name, row_count desc drop table #counts;
select sum(row_count) as total_row_count from #counts;
select table_name from information_schema.tables select @stmt = 'sp_spaceused ' + @tablename exec sp_executesql @stmt end ;
select count(*) from tablename;
set nocount on drop table #t;
create table #t ( [name] nvarchar(128), [rows] char(11), reserved varchar(18), data varchar(18), index_size varchar(18), unused varchar(18) select * into test from #t;
select  name, [rows], reserved, data, index_size, unused from test \ where ([rows] > 0) and (name like 'xxx%');
select @sql = coalesce(@sql + ' union all ', '') + ''' + t.name + ''' as ''table'', count(*) as count from ' + quotename(s.name) + '.' + quotename(t.name) from sys.schemas s s.name, t.name;
select o.name, i.rowcnt from sysindexes as i where i.indid < 2  and objectproperty(o.id, 'ismsshipped') = 0;
select o.name, ddps.row_count from sys.indexes as i and i.index_id = ddps.index_id where i.index_id < 2  and o.is_ms_shipped = 0 order by o.name;
select sc.name +'.'+ ta.name tablename, sum(pa.rows) rowcnt from sys.tables ta where ta.is_ms_shipped = 0 and pa.index_id in (1,0);
select @t = cast(count(1) as varchar(max));
select      schema_name(a.schema_id) + '.' + from        sys.objects a where       a.type = 'u';
select login, registration_date from users where ... ) select * from users where master_login = (select login from master_user) and (select registration_date from master_user) > ...;
select 5 into myvar;
drop table if exists tmp_table;
create table tmp_table as select * from yourtable where   id = myvar;
select * from tmp_table;
select * from sometable where name = :'myvar';
values (5, 'foo') ) select * from somewhere, myconstants where something = var1 or something_else = var2;
select 5::int as var into temp table myvar;
select * from somewhere s, myvar v where s.something = v.var;
set session my.vars.id = '1';
select * from person where id = current_setting('my.vars.id')::int;
create temp table tmp_table on commit drop as select * from yourtable where id = myvar;
select * from tmp_table;
constant_2_int as (values (100)) select * from some_table where table_column = (table constant_1_str) limit (table constant_2_int);
select * from constant_name;
table constant_name;
select  * from    somewhere where   something = $1;
delete from book b where b.author_id in (select a.id from author as a where a.name = :name);
select * from somewhere where something = :myvar;
create table xyz_new as select * from xyz where rownum = -1;
create table new_table as select * from old_table where 1=2;
create table new_table_name as(select * from old_table_name);
delete * from new_table_name.;
create table abc_new as select * from abc;
create table xyz_new as select * from xyz where 1=0;
set long 5000 select dbms_metadata.get_ddl( 'table', 'my_table_name' ) from dual;
select dbms_metadata.get_ddl( 'table', 'my_table_name', 'other_schema_name' ) from dual;
create table target_table as select * from source_table where 1=2;
select dbms_metadata.get_ddl('type','object_name','data_base_user') text from dual;
create table new_table as select * from old_table where 1=2 ;
replace ( dbms_lob.substr (dbms_metadata.get_ddl ('table', 'activity_log', 'oldschema')) );
create table bar as select * from foo;
select * into newtable from oldtable where 1 = 0;
create table <target_table> as select * from <source_table> where 1=2;
create table <target_table> as select * from <source_table>;
create table t1_temp for exchange with table t1;
select * from table where column like 'text%' or column like 'link%' or column like 'hello%' or column like '%world%' or;
select * from table where column like 'text%' or column like 'link%' or column like 'hello%' or column like '%world%';
select * from table where column in (1, 2, 3);
select * from table where column = 1 or column = 2 or column = 3;
select * from table where column like 'text%' or column like 'hello%' or column like 'that%';
select  * from    table t inner join ( select  'text%' col union select 'link%' union select 'hello%' union select '%world%';
select tbla.* from tbla;
select date(timestamp_column);
select timestamp_column::date;
select some_date::date from some_table;
create table sometable (t timestamp, d date);
update sometable set d = t; -- ok select * from sometable ;
select pg_catalog.date(t) from sometable;
select date(timestamp_field) from table;
select date(substring('2011/05/26 09:00:00' from 1 for 10));
create table test_table (timestamp_field timestamp);
select timestamp_field, date(timestamp_field) from test_table;
table t1 table t2;
select articleno, article, manufacturer from t1 join t2 on (t1.manufacturer_id =;
table year2006 table year2007 select articleno, article, price, manufactruer_id from year2006 union select articleno, article, price, manufacturer_id from year2007;
select 1 as [column1], 2 as [column2] union select 3 as [column1], 4 as [column2];
select a.column1, b.column2 from tablea a inner join tableb b on a.id = b.afkid;
select 1 as id, 3 as value union select 1 as id, 3 as value;
select * from (select 1 as id, 3 as value) t1 inner join (select 1 as id, 3 as value) t2 on t1.id = t2.id;
create function list(@status as char(1) = '') as return select * from test where status like '%' + @status '%';
create table tblstagingtable ( pkid bigint (identity,1,1), customerfirstname varchar(30), customerlastname varchar(30), customercitystatezip varchar(100), customercurrentbalance money ) create view vwstagingtable as select customerfirstname = cast(customerfirstname as char(30)), customerlastname = cast(customerlastname as char(30)), customercitystatezip = cast(customercitystatezip as char(100)), customercurrentbalance = cast(cast(customercurrentbalance as numeric(9,2)) as char(10)) select * from vwstagingtable;
( select * from ( values (1,   'foo-23',  'orange'), (2,   'bar-23',  'orange'), (3,   'foo-24',  'apple'), (4,   'foo-25',  'orange') ) as [testdata]([id],[sku],[product]) ) select * from [testdata] where [id] in ( select min([id]) from [testdata] );
where ([sku] like 'foo-%');
select distinct  [id] = ( select top 1 [id]  from @testdata y where y.[product] = x.[product]) from @testdata x;
select t.* from testdata t from testdata where sku like 'foo-%';
select dt.id, dt.sku, dt.product from (select from @testdata where  sku like 'foo-%' where dt.rowid=1;
select  * from    (select id, sku, product, row_number() over (partition by product order by id) as rownumber from   mytable where  sku like 'foo%') as a where   a.rownumber = 1;
select min (id) as 'id', min(sku) as 'sku', product from testdata where sku like 'foo%' -- if you want only the sku that matchs with foo%;
select * from [testdata] where [id] in ( select min([id]) from [testdata] where [sku] like 'foo-%' );
select * from [testdata] where id in(select distinct min(id) from [testdata] group by product);
create view dbo.mytestview select id, quantity from dbo.mytesttable;
update dbo.mytestview set quantity = 7 where id = 1;
select * from dbo.name_of_view;
select mycolumn from mytable where id = @id select mycolumn from mytable where id = @id select mycolumn  from mytable where id = @id select mycolumn from mytable where id = @id -- "some comment" select mycolumn from mytable where id = @id -- "some other comment";
select  left(nvpn           ,50)    as nvpn from [dashboard].[dbo].[mpnattributes] (nolock) mpna;
select foo, bar from my_table;
create type locationtabletype as table (...);
create procedure dbo.usp_insertproductionlocation;
select 'create type [table_name]type as table (' + string_agg(cast(field as varchar(max)), ',' + char(10)) + ');' as create_type from ( select top 5000 column_name + ' ' + data_type as field from information_schema.columns where table_name = '[table_name]';
if (attribute.dbtype.tolower().contains("varchar")) if (!string.isnullorempty(currentvalue) && maxlength != 0 && currentvalue.length > maxlength);
if (sqlexception.message == "string or binary data would be truncated.") //only for en windows - if you are running different window language, invoke the sqlexception.getmessage on thread with en culture else throw;
select a, b, c into #table1 from #table0 select a, b, c from #table2 union select a, c, b from #table3;
select '' as  period, * from transactions into #newtable;
bar int, baz int, index name (foo, bar, baz));
alter table t1 engine = innodb;
alter table t1 engine = myisam;
select  concat('alter table ',table_schema,'.', table_name, ' engine=innodb;') as sql_statements from    information_schema.tables where   table_schema not in ('mysql', 'information_schema', 'performance_schema', 'innodb', 'sys', 'tmp') and     `engine` = 'myisam' and     `table_type` = 'base table';
from information_schema.tables where table_schema = '{{ dbname }}' and engine = 'myisam';";
where table_schema = 'db_name' and engine = 'myisam'";
select concat('alter table ',table_name,' engine=innodb;') from information_schema.tables where engine='myisam' and table_schema = 'mydatabase';
drop procedure if exists converttoinnodb;
create procedure converttoinnodb() select table_name into @converttable from information_schema.tables where `table_schema` like database() and `engine` like 'myisam' order by table_name limit 1;
if @converttable is null then end if;
set @sqltext := concat('alter table `', database(), '`.`', @converttable, '` engine = innodb');
set @converttable = null;
end loop mainloop;
drop procedure if exists converttoinnodb;
set @database_name = 'integradb';
select  concat('alter table ', table_schema, '.', table_name, ' engine=innodb;') as sql_statements from    information_schema.tables as tb where   table_schema = @database_name and     `engine` = 'myisam' and     `table_type` = 'base table';
set @database_name = 'name_of_your_db';
select  concat('alter table `', table_name, '` engine=innodb;') as  sql_statements from information_schema.tables as tb where   table_schema = @database_name and `engine` = 'myisam' and `table_type` = 'base table' order by table_name desc;
if ($resultado){ if ($count == $ok){;
alter table table_name engine = innodb;
alter table     t_lade_tr           engine=innodb;
alter table     t_foro_detail_ms    engine=innodb;
alter table     t_ljk_ms            engine=innodb;
set @database_name = 'name_of_your_db';
select  concat('alter table `', table_name, '` engine=innodb;') as sql_statements from    information_schema.tables as tb where   table_schema = @database_name and     `engine` = 'myisam' and     `table_type` = 'base table';
select table_schema, table_name from information_schema.tables where engine = 'myisam';
select table_name from information_schema.tables where engine = 'myisam';
alter table arth_commentmeta           engine=innodb;
alter table arth_comments              engine=innodb;
alter table arth_links                 engine=innodb;
alter table arth_options               engine=innodb;
alter table arth_postmeta              engine=innodb;
alter table arth_posts                 engine=innodb;
alter table arth_term_relationships    engine=innodb;
alter table arth_term_taxonomy         engine=innodb;
alter table arth_terms                 engine=innodb;
alter table arth_usermeta              engine=innodb;
from django.core.management.base import basecommand from django.db import connections if row[1] != "innodb": result = cursor.execute("alter table %s engine=innodb" % row[0]);
where table_schema = 'your_database_name' and engine = 'myisam'";
from information_schema.tables where engine != 'innodb' and table_type='base table' and table_schema='name-of-database'" | mysql > convert.sql;
select concat('alter table ',table_schema,'.',table_name,' engine=innodb;') from information_schema.tables where engine = 'myisam';
delete from table where id not in ( select min(id) from table );
select 1, 'abc' union all select 2, 'abc' union all select 3, 'lmn' union all select 4, 'xyz' union all select 5, 'xyz' delete from @sampledata where id in ( select id from ( select id from @sampledata ) select * from @sampledata;
select[foo], [bar], row_number() over(partition by foo, bar order by baz) as [rn] from table ) delete cte where [rn] > 1;
create table favoritewithoutmenu ( favoritewithoutmenuid uuid not null, --primary key recipeid uuid not null, unique key (userid, recipeid) );
create unique index favo_3col_uni_idx on favorites (user_id, menu_id, recipe_id) where menu_id is not null;
create unique index favo_2col_uni_idx on favorites (user_id, recipe_id) where menu_id is null;
create unique index favorites_uniquefavorite on favorites;
alter table favorites add constraint check;
create table favorites;
if error_flag then update table_a set id= 8 where id = 1;
alter table yourschema.yourtable add (columnname number(1) default 0 not null);
alter table table_name add column_name_check char(1) default '1';
alter table table_name add constraint name_constraint;
select a.* from a left outer join b on a.key=b.key;
select a.* from a inner join b on a.key=b.key;
create table #test1 ( id int not null primary key, name varchar(50) not null ) create table #test2 ( id int not null primary key, name varchar(50) not null ) select * from #test1 t1 select * from #test1 t1 drop table #test1 drop table #test2;
select {fn curdate()};
select convert(varchar(10), getdate(),120);
floor( cast( getdate() as float ) ) as datetime );
select dateadd(d, datediff(d,0, [datecolumn]), 0), other.. from tbl;
select ... where somedate <= datediff(d, 0, getdate());
select convert(varchar(10), '2011-02-25 21:17:33.933', 120);
select dateadd(dd, 0, datediff(dd, 0, getdate()));
select convert(date, getdate(), 120);
select convert(datetime, convert(date, getdate())  );
select convert(datetime, convert(date, getdate()), 121);
select @vcurrentdate;
select  datefromparts(year(getdate()), month(getdate()), day(getdate())) as mynewdate;
select  datefromparts(year(getdate()), month(getdate()), 1) as mynewdate;
select convert(date,sysdatetime());
set @dateonly=convert(date,sysdatetime());
select * from helios.dbo.cba_srd_loan where loan_i in ('200312500') and convert(date, btch_time) = '2014-06-17';
select dateadd(day, datediff(day, 0, getdate()), 0);
select pg_get_serial_sequence(tablename,  columnname);
select pg_get_serial_sequence('demo', 'autoid');
alter sequence sequencename restart with value;
alter sequence "demo_autoid_seq" restart with 1453;
alter sequence product_id_seq restart with 1453;
select pg_get_serial_sequence('"schemaname"."tablename"', 'keycolumnname'); // output: "sequencekey";
select nextval('"schemaname"."sequencekey"'::regclass); // output 110;
select setval('"schemaname"."sequencekey"', 120);
select pg_get_serial_sequence('tablename', 'columnname');
select currval(pg_get_serial_sequence('tablename', 'columnname'));
select currval(tablename_columnname_seq);
alter sequence tablename_columnname_seq restart with 45;
alter table <table name> alter column <column name>;
alter sequence project_id_seq restart 3000;
select setval('project_id_seq', (select max(id) + 1 from project));
alter sequence product_id_seq restart with 1453;
select pg_get_serial_sequence('product', 'id');
table "public.product" column |  type   |                      modifiers;
select * from t;
select * from t;
select count(*) from table;
select a.id from tablea a where exists ( select * from tableb b where b.id = a.b_id);
update table1 set name = i.name, desc = i.desc where id = i.id and (name is null or desc is null);
( -- for more complicated queries you can use with clause here select * from table2 t1.desc = t2.desc;
update ( select * from t1 join t2 on t2.id = t1.id where id in ( select id from ( select id, col1, col2, ... from t2 ) );
update table set column = (select...);
update table2 set name = i.name, desc = i.desc where id = i.id;
update fp_active set state='e', last_date_maj = sysdate where (client,code) in (select (client,code) from fp_detail where valid = 1) ...;
update table1 t1 set t1.desc = (select t2.desc from table2 t2 where t2.id = t1.id) where t1.id in (select t2.id from table2 t2 where t2.id = t1.id);
update table1 t1 set (name, desc) = (select t2.name, t2.desc from table2 t2 where t1.id = t2.id) where exists ( select 1 from table2 t2 where t1.id = t2.id );
update (select t1.id, t1.name name1, t1.desc desc1, t2.name name2, t2.desc desc2 from table1 t1, table2 t2 where t1.id = t2.id) set name1 = name2, desc1 = desc2;
create sequence dummy_id_seq create table dummytable ( id bigint default nextval('dummy_id_seq'::regclass) not null, name character varying(50);
create table dummytable ( id serial not null, name character varying(50) );
create sequence public.your_sequence;
alter table only table alter column id set default nextval('your_sequence'::regclass);
update myschema.mytable set a_code=cast('c'||"ref_id" as text);
create sequence splog_adfarm_seq alter table fact_stock_data_detail_seq;
create table splog_adfarm ( splog_key    int unique not null, splog_value  varchar(100) not null;
nextval('splog_adfarm_seq'), 'is your family tree a directed acyclic graph?' nextval('splog_adfarm_seq'), 'will the smart cookies catch the crumb?  find out now!';
default, 'sufficient intelligence to outwit a thimble.';
create table epictable ( mytable_key    serial primary key, moobars        varchar(40) not null, foobars        date;
alter table your_table add column key_column bigserial primary key;
if _where == '': _where = '1=1';
select [firstname] end as [status]' if (@searchvalue = 'active') set @searchoption = ' where a.[status] = 1' end  if (@searchvalue = 'inactive') set @searchoption = ' where a.[status] = 0' end  if (@searchvalue = 'all') set @searchoption = ' where 1=1' end  set @sqlquery = @sqlquery + @searchoption;
select * from mytable where 1=1;
where 2=2 where 10=10 where 99=99;
select column1, column2 from my table where 1=1 {name} {age};
if (shouldfilterforbars) if (shouldfilterforbaz);
create view vtest as select from table where 1=1 and table.field=value and table.isvalid=true;
create view vtest as select from table where 1=1;
select * from tablename;
( select pi from constants update set circumference = 2 * sourcetable.pi * radius;
create table new_table_name as select * from old_table_name where 1 = 2;
and <condition>;
if productcategoryid <> 0 then end if if minimunprice > 0 then end if;
select a,b,c from t where a = ?;
select distinct a from t union all select '*' from sysibm.sysdummy1;
select a,b,c from t where ((a = ?) or (1==1));
select * from t;
select * from t where name = 'bob' and salary > 20000;
select * from t where 1=1;
select * from t where 1=1 and name = 'bob' and salary > 20000;
select @day = 1, @month = 2, @year = 2008 select dateadd(dd, @day-1, dateadd(mm, @month -1, dateadd(yy, @year - 2000, '20000101')));
select dateadd(day, @dayofmonth - 1, dateadd(month, @month - 1, dateadd(year, @year-1900, 0)));
select dateadd(yy, @year-1900, dateadd(m,  @month - 1, @dayofmonth - 1));
select dateadd(month, @month - 1, dateadd(year, @year-1900, @dayofmonth - 1));
if exists (select * from dbo.sysobjects where id = object_id(n'[dbo].[func_datefromparts]')) drop function [dbo].[func_datefromparts] create function [dbo].[func_datefromparts] ( @year int, @month int, @dayofmonth int, @hour int = 0,  -- based on 24 hour clock (add 12 for pm :) @sec int = 0 ) as begin dateadd(minute, @min, dateadd(hour, @hour, dateadd(day, @dayofmonth - 1, dateadd(month, @month - 1, dateadd(year, @year-1900, 0)))))) end ;
select dbo.func_datefromparts(2013, 10, 4, 15, 50, default);
select dateadd(month, (@year -1900)*12 + @month -1, @dayofmonth -1) + dateadd(ss, @hour*3600 + @minute*60 + @second, 0) + dateadd(ms, @millisecond, 0);
create function dbo.fndatetime2fromparts(@year int, @month int, @day int, @hour int, @minute int, @second int, @nanosecond int) as begin set @output = dateadd(year      , @year - 1900  , @output) set @output = dateadd(month     , @month - 1    , @output) set @output = dateadd(day       , @day - 1      , @output) set @output = dateadd(hour      , @hour         , @output) set @output = dateadd(minute    , @minute       , @output) set @output = dateadd(second    , @second       , @output) set @output = dateadd(ns        , @nanosecond   , @output) end;
select @day = 4, @month = 3, @year = 2011 select dateadd(mm, (@year - 1900) * 12 + @month - 1 , @day - 1);
select substring(convert(varchar,joingdate,103),7,4)as;
set dateformat dmy select cast('26-2-2015' as date) set dateformat ymd select cast('2015-2-26' as date);
select dateadd(day, 1, eomonth(@somedate, -1));
select concat ( right(replace(@date, ' ', ''), 4) ) select   right(replace(@date, ' ', ''), 4);
union select'15,3, 2007',null union select'18, 11 , 2007',null union select'22 , 11, 2007',null union select'30, 12, 2007  ',null update @table set datecolumn = concat ( right(replace(datestring, ' ', ''), 4) ) select id,datestring,datecolumn from @table;
select datefromparts(year, month, day) as coldate, col2, col3 from mytable where datefromparts(year, month, day) between @dateini and @dateend;
( customerid uniqueidentifier, firstname nvarchar(100), lastname nvarchar(100), email nvarchar(100) @tempcustomer select customerid, firstname, lastname, email from customer where customerid = @customerid;
( customerid uniqueidentifier, firstname nvarchar(100), lastname nvarchar(100), email nvarchar(100) select customerid, firstname, lastname, email from customer where customerid = @customerid;
select customerid from @tempcustomer;
select customerid, firstname, lastname, email from customer where customerid = @customerid;
select customerid from #tempcustomer;
select @var1 = field1, @var2 = field2, @var3 = field3 from table where condition;
select @table_name = convert(varchar(30), getdate(), 112) set @table_name = 'daily_snapshot_' + @table_name select var1, var2, var3 from my_view where string = ''strings must use double apostrophe'';
from customer where customerid = @customerid";
priceopen, pricelow, pricehigh, priceclose, tradingvolume, timeframe) select '2014-12-26 22:00', 120.369000000000, 118.864000000000, 120.742000000000, 120.494000000000, 86513, 'w' where not exists from fx_usdjpy where pricedate = '2014-12-26 22:00' and timeframe = 'w');
create table `table_name` ( `id` int(11) not null auto_increment, `name` varchar(255) not null, `address` varchar(255) not null, `tele` varchar(255) not null, primary key  (`id`);
select * from (select 'nazir', 'kolkata', '033') as tmp where not exists ( select name from table_name where name = 'nazir' select * from `table_name`;
select * from (select 'nazir', 'kolkata', '033') as tmp where not exists ( select name from table_name where name = 'nazir';
select * from (select 'santosh', 'kestopur', '044') as tmp where not exists ( select name from table_name where name = 'santosh' select * from `table_name`;
select id, guidd, timeadded, extradata from #table2 where not exists (select id, guidd from #table1 where #table1.id = #table2.id) values ([source].id, [source].guidd, [source].timeadded, [source].extradata);
select id, guidd, timeadded, extradata from #table2 select id, guidd, timeadded, extradata from #table1 select #table2.id, #table2.guidd, #table2.timeadded, #table2.extradata from #table2 where #table1.id is null;
select '18769', '2', 'alex' where not exists (select * from #table1 where id = '18769' and studentid = '2');
alter procedure [dbo].[emailsrecebidosinsert] @_assunto nvarchar(50), @_data nvarchar(30) ) as begin if not exists (select * from emailsrecebidos where de = @_de and assunto = @_assunto and data = @_data) values (@_de, @_assunto, @_data) end end;
values (@_de, @_assunto, @_data) where not exists ( select * from emailsrecebidos where de = @_de and assunto = @_assunto and data = @_data);
if not exists (select * from emailsrecebidos where de = @_de and assunto = @_assunto and data = @_data) values (@_de, @_assunto, @_data) end end;
create procedure [dbo].[emailsrecebidosinsert] @_assunto nvarchar(50), @_data nvarchar(30) ) as begin and s.assunte = t.assunto and s.data = t.data then insert (de, assunto, data) values (s.de, s.assunto, s.data);
alter procedure [dbo].[emailsrecebidosinsert] as begin values ([source].[de], [source].[assunto], [source].[data]);
alter procedure [dbo].[emailsrecebidosinsert] @_assunto nvarchar(50), @_data nvarchar(30) ) as begin select @_de, @_assunto, @_data select de, assunto, data from emailsrecebidos end;
where a.x = b.x(+);
where a.x *= b.x;
where a.x = b.x or a.x not in (select x from b);
select a.foo, b.foo from a, b where a.x = b.x(+);
select a.foo, b.foo from a, b where a.x *= b.x;
where tablea.id = tableb.a_id;
and tableb.id = tablec.b_id;
and tableb.id = tablec.b_id;
select * from table1, table2, ...;
select * -- for simplicity from company, department, employee where company.id *= department.companyid and department.id = employee.departmentid;
select * from company department inner join employee on department.id = employee.departmentid;
select * from company department inner join employee on department.id = employee.departmentid;
select name from bonus where sum(salary) > 200;
select name from bonus having sum(salary) > 200;
where my_indexed_row = 123;
having my_indexed_row = 123;
select 1 as result from t having count( distinct name ) = count( name );
select edc_country, count(*) from ed_centers having count(*) > 1;
select column_name, aggregate_function(column_name) from table_name where column_name operator value having aggregate_function(column_name) operator value;
select column_name, count( column_name ) as column_name_tally from table_name where column_name < 3 having count( column_name ) >= 3;
select column_name, column_name_tally from ( select column_name, count(column_name) as column_name_tally from table_name where column_name < 3 where column_name_tally >= 3;
select city, cnt=count(1) from address where state = 'ma';
select city, cnt=count(1) from address where state = 'ma' having count(1)>5;
select client_id, operation_date, row_number() count(*) over (partition by client_id order by client_id ) as operationctrbyclient from client_operations e;
select brand from items brand;
select item_nr from items brand;
select item_nr from items;
select t.data_key from mytable t;
select distinct t.data_key from mytable t;
create table table1 ( id int, name varchar(20) create table table2 ( id int, name varchar(20);
select * from table1 t1 select * from table (dbms_xplan.display);
select * from table1 t1, table2 t2 where t1.id = t2.id;
select * from table (dbms_xplan.display);
select * from table1 inner join table2 using (id);
select article from table1 order by publish_date desc fetch first 20 rows only;
select t.article from (select article, publish_date from table1;
select t.* from (select * from table1;
select article from table1 order by publish_date limit 0,10;
select * from tbl limit 5,10;  # retrieve rows 6-15;
select * from tbl limit 95,18446744073709551615;
select * from tbl limit 5;     # retrieve first 5 rows;
update table set (col1, col2) = (select val1, val2 from dual);
update table_name set field = replace(field, 'string-to-find', 'string-that-will-replace-it');
update table_name set field = replace(field, 'foo', 'bar') where instr(field, 'foo') > 0;
update table_name set `field_name` = replace(`field_name`,'your_old_string',concat('new_string',`other_field_value`,'after_if_needed'));
update table set field = replace(field, text_needs_to_be_replaced, text_required);
update student set student_name = replace(student_name, 'john', 'mark');
update table_name set field = replace(field, 'foo', 'bar') where field like '%foo%';
select first_column,listagg(second_column,',') listagg(third_column,',') from tablename;
select cpf || ';' || nome || ';' || telefone from ( select cpf from ( select distinct * from temp_bd;
select array_to_string( array(select distinct unnest(zip_codes) from table), ', ';
select field1, array_to_string(array_agg(field2), ',') from table1;
select id, string_agg(some_column, ',') from the_table;
select id_field, array_agg(value_field1), array_agg(value_field2) from data_table;
create aggregate array_agg (anyelement) ( sfunc = array_append, stype = anyarray, initcond = '{}';
select array_to_string(array(select a from b),', ');
values = activerecord::base.connection.exec_query("select * from clients");
select * from payment_details;
select * from clients;
where id = '1'").to_hash {"first_name"=>"eileen", "created_at"=>"2013-12-09 11:22:35.221282"};
[2, "title_2", "body_2"], ... {"id" => 2, "title" => "title_2", "body" => "body_2"}, ... end;
activerecord::base.send(:sanitize_sql_array, ["... your sql query goes here and ?, ?, ? are replaced...;", a, b, c]) end;
select username, max(date), value from tablename group by username, value;
select username, date, value from mytable mt from mytable and sub.date = mt.date;
select t.username, t.date, max( t.value ) value from your_table t join ( select username, max( date ) date from your_table;
select username, date, value from tablename where (username, date) in ( select username, max(date) as date from tablename );
select t.username, t.date, t.value from mytable t select username, max(date) as maxdate from mytable;
select * from ( select username, date, value, row_number() over(partition by username order by date desc) as rn from yourtable where t.rn = 1;
select * from reportstatus c from reportstatus ) m;
select * from mytable t1 where date = ( select max(date) from mytable t2 where t1.username=t2.username );
select t1.username, t1.date, value from mytable as t1 from mytable;
select * from mytable where rownum = 1;
select username, max(date) as date, value from mytable;
select distinct username, dates,value from tablename where  dates in (select  max(dates) from tablename group by username);
select distinct i.userid,i.statuscheck, l.username from internetstatus as i inner join login as l on i.userid=l.userid where nowtime in((select max(nowtime) from internetstatus group by userid));
select a.username, a.date, a.value, from yourtable a where a.date=b.maxdate;
select username, value from t where not exists ( select * from t as witness where witness.username = t.username and witness.date > t.date;
select username, value from ( select username, value, row_number() over (partition by username order by date desc) as rn from t where rn = 1;
select t.username, t.value from t select username, max(date) as date from t;
select username, value from t where w.username is null;
( select username, date, rank() over (partition by username order by date desc) as rnk from t ) select username, rnk from t where rnk = 1;
select max(date) as dates from assignment join paper_submission_detail on  assignment.paper_sub_id =;
select * from tabel1 where date= (select max(created_date) from tabel1);
select a.username, a.date, a.value from mytable a and a.date < b.date where b.username is null;
select * from table1 where lastest_date=(select max(latest_date) from table1 where user=yourusername);
create function dbo.userslocation() as return select gs.userid, max(gs.utcdatetime) 'lastdate' from usergps gs where year(gs.utcdatetime) = year(getdate()) select  gs.userid, sl.lastdate, gs.latitude , gs.longitude from usergps gs;
select * from   mytable;
select rno,name,dt_created from ( -- generates numbers in a column in sequence in the order of date select row_number() over (order by dt_created) as rno, name,dt_created from demotop where rno<3;
select rno,name,dt_created from ( --generates numbers in a column in sequence in the order of date for each name select row_number() over (partition by name order by dt_created) as rno, name,dt_created from demotop where rno<3;
select a.*, rownum from (select fname from mytbl order by fname desc) a where rownum = 1;
select * from (select fname from mytbl order by fname ) where rownum = 1;
select  max(fname) from mytbl;
select  min(fname) from mytbl;
select  fname from mytbl  where rownum = 1;
select  max(fname) from mytbl where rowid=(select  max(rowid) from mytbl);
select fname from mytbl where rownum = 1;
select max(fname) over (rank() order by some_factor) from mytbl;
select * from ( select fname from mytbl ) where rownum <= 1;
select * from (select * from mytbl order by fname ) where rownum = 1;
select x.* from (select fname from mytbl) x where rownum = 1;
select 'true' where 3 = 1 or 3 = 2 or 3 = 3 or 3 = null;
select 'true' where 3 <> 1 and 3 <> 2 and 3 <> null;
select 'true' where 3 <> null select 'true' where not (3 <> null);
select party_code from abc as a where party_code not in (select party_code from xyz where party_code = a.party_code);
( true char(4) default 'true' not null, check ( 3 in (1, 2, 3, null )), check ( 3 not in (1, 2, null )) select count(*) as tally from @t;
not in (subquery);
values ('s1', 'p1', null), ('s2', 'p1', 200), ('s3', 'p1', 1000);
from ( values ( 's1', 'p1', null ), ( 's2', 'p1', 200 ), ( 's3', 'p1', 1000 ) ) as t ( sno, pno, qty ) ) select distinct spx.sno from sp spx where spx.pno = 'p1' and 1000 not in ( select spy.qty from sp spy where spy.sno = spx.sno and spy.pno = 'p1';
from ( values ( 's1', 'p1', null ), ( 's2', 'p1', 200 ), ( 's3', 'p1', 1000 ) ) as t ( sno, pno, qty ) ) select distinct spx.sno from sp spx where spx.pno = 'p1' and not exists ( select * from sp spy where spy.sno = spx.sno and spy.pno = 'p1' and spy.qty = 1000;
from ( values ( 's1', 'p1' ), ( 's2', 'p1' ), ( 's3', 'p1' ) ) as t ( sno, pno ) spq as from ( values ( 's2', 'p1', 200 ), ( 's3', 'p1', 1000 ) ) as t ( sno, pno, qty ) ) select sno from spq where pno = 'p1' select sno from spq where pno = 'p1' and qty = 1000;
select blah from t where blah not in;
select * from (values (1), (2)) as tbl(col) where col in (null, 1);
select * from (values (1), (2)) as tbl(col) where not col in (null, 1);
select * from (values (1), (2)) as tbl(col) where not (col = null or col = 1);
alter table mytable add column mycolumn character varying(50) default 'whatever' not null;
alter table your_table_name add column new_column_name int;
alter table mytable add column mycolumn character varying(50) not null default 'foo';
alter table mytable alter column mycolumn drop default;
alter table mytable add column mycolumn character varying(50);
update mytable set mycolumn = timeofday();    -- just a silly example alter table mytable alter column mycolumn set not null;
create temporary table temp_table as select * from source_table where id=2;
update temp_table set id=null where id=2;
drop temporary table temp_table;
select field1, field2, uniqueid from mytable where uniqueid = @id;
select null, s.* from something as s where s.id = 1;
set nocount on select * into #temptable from <yourtable> where id = id update #temptable set id = null drop table #temptable;
create temporary table temp_table engine=memory select * from your_table where id=1;
update temp_table set id=0; /* update other values at will. */ drop table temp_table;
select c1, c2, ... from your_table where id = 1;
select 2, c1, c2, ... from your_table where id = 1;
create procedure `duplicaterows`(_schemaname text, _tablename text, _whereclause text, _omitcolumns text) select if(trim(_omitcolumns) <> '', concat('id', ',', trim(_omitcolumns)), 'id') into @omitcolumns;
select group_concat(column_name) from information_schema.columns where table_schema = _schemaname and table_name = _tablename and find_in_set(column_name,@omitcolumns) = 0 order by ordinal_position into @columns;
set @sql = concat('insert into ', _tablename, '(', @columns, ')', 'select ', @columns, ' from ', _schemaname, '.', _tablename, ' ',  _whereclause);
select * from mytable where id=42;
values (1, 2, 3, ..., 42);
values (mysequence.nextval, 2, 3, ..., 42);
set @i = @i + 1 end;
set @intflag = 1 set @intflag = @intflag + 1 end go;
set @a = @a + 1 end;
set @a = @a + 1 if @a < = 20 end;
set @cnt = @cnt + 1;
if @x<=10 goto way;
set @o = @o + ' ' set @j += 1 end  set @o = @o + ' *'  -- '*' set @k += 1 end set @i += 1 set @f = @f + @o + char(13) end print @f;
set @d = dateadd(day,1,@d) end print 'n';
@startofmonth date , @endofmonth date;
set @endofmonth = eomonth(getdate());
set @startofmonth = datefromparts(year(@today), month(@today), 1);
values  ( @startofmonth );
set @startofmonth = dateadd(day, 1, @startofmonth);
select  datelabel from    @datelist;
select @count=  count(*) from {table} select * from {table} set @i = @i + 1;
update table set column = cast(null as column type) where condition;
update news set title = cast(null as nvarchar(100)) where id = 50;
update table set columnname = null where [filter for record here];
update mytable set mycolumn = null;
update mytable set mycolumn = null where field = condition.;
unique creates an unclustered index of the column;
if (nullable.getunderlyingtype(t) != null) else if (t.isvaluetype) else isdbnull = val == null;
new sqlparameter("age_param", 45);
"ad.usp_userplaninfo @action, @ntid", //, @hpid", new sqlparameter("action", action), new sqlparameter("ntid", xntid)).tolist();
"exec getnewseqoffoodserving @param1, @param2", new sqlparameter("param1", param1), new sqlparameter("param2", param2);
new sqlparameter("age_param", 45);
new object[] { param1, param2, param3 }).tolist();
"exec procname @param1, @param2", new sqlparameter("param1", param1), new sqlparameter("param2", param2);
"myspname @param1, @param2, @param3", new sqlparameter("param1", param1), new sqlparameter("param2", param2), new sqlparameter("param3", param3);
new object[] { param1, param2, param3 });
new object[] { param1, param2, param3 }).tolist();
parameters).tolist();
param1, param2, param3).tolist();
dbtype = dbtype.string, value = "trans" dbtype = dbtype.string, value = "hltransnbr";
select your database -> tasks -> back up -> destination -> add -> apply '\\mymachine\mysharedfolder\backup_name.bak';
select max(a.mytablepkid) as maxpkid, a.somecolumn1 from mytable1 a ) select b.mytablepkid, b.somecolumn1, b.somecolumn2 max(b.numestado) from mytable1 b;
select t1.* from yourtable t1 ( select `group`, max(age) as max_age from yourtable;
select @rn :=  case when @prev_grp <> groupa then 1 else @rn+1 end as rn, @prev_grp :=groupa, person,age,groupa from   users,(select @rn := 0) r having rn=1;
select * from (select * from mytable order by `group`, age desc, person) x;
[group], age, rn= row_number() from yourtable)`;
select * from mytable where age in (select max(age) from mytable group by `group`) ;
select *, max(age) from mytable group by `group`;
select distinct on ("group") * from "mytable" order by "group", "age" desc;
select a.person, a.group, a.age from [table_name] a ( select `group`, max(age) as oldest from [table_name];
select o.* from `persons` o                    # 'o' from 'oldest person in group' where b.age is null                 # bigger age not found;
select person, group, group_concat( distinct age ) from sql_table;
create table p ( person nvarchar(10), gp int, age int values  ('bob', 1, 32);
values  ('jill', 1, 34);
values  ('shawn', 1, 42);
values  ('jake', 2, 29);
values  ('paul', 2, 36);
values  ('laura', 2, 39);
select  t.person, t.gp, t.age from    ( select *, row_number() over (partition by gp order by age desc) row from   p where   t.row = 1;
select o.*              -- > o for oldest table from people o , people t where o.grp = t.grp and;
select o1.* where from `persons` o where b.age is null) o1 (select o.* from `persons` o where b.age is null) o2 where o2.height is null;
select substring_index(group_concat(column_x order by column_y),',',1) as xyz, column_z from table_name;
select * from mytable where id not in ( select a.id from mytable as a join mytable as b on a. group = b. group and a.age < b.age );
select co.id, co.person, co.country from person co where ( select count(*) from person ci where  co.country = ci.country and co.id < ci.id;
select group,person,age, rownumber() over (partition by group order by age desc ,person asc) as rankforeachgroup from tablename where rankforeachgroup=1;
select o.* from `persons` o where b.age is null and c.id is null;
set @tables_like = null;
set @optimize = null;
set @show_tables = concat("show tables where", ifnull(concat(" `tables_in_", database(), "` like '", @tables_like, "' and"), ''), " (@optimize:=concat_ws(',',@optimize,`tables_in_", database() ,"`))");
set @optimize := concat('optimize table ', @optimize);
set @show_tables = null, @optimize = null, @tables_like = null;
set @tables_like = '%test%';
or die(mysql_error());
and table_type='base table';
if [ -z "$1" ] ; then;
set session group_concat_max_len = 99999999;
select group_concat(concat('optimize table `', table_name, '`;') separator '') as o from information_schema.tables where and table_name!='dual' and table_schema = '<your databasename>';
select name from usernames having count(*) > 1;
create table `table` ( `id` int(10) unsigned not null auto_increment, `value` int(10) unsigned not null, primary key (`id`), key `value` (`value`);
select `value` v from `table` where `value`>5; -- get 5 rows select `value` v from `table` having `value`>5; -- get 5 rows;
select `value` v from `table` where `v`>5;
select `value` v from `table` having `v`>5; -- get 5 rows;
select * from student where year(birthday)>1993; /*this will work as birthday is in database.if we use having in place of where too this will work*/ select student_id,(year(curdate())-year(birthday)) as age from student having age>20;
select * from table where id in (select id from split(@list_of_ids));
select * from table inner join (select id from split(@list_of_ids)) as list on list.id = table.id;
@"select * from (select 1 as id union all select 2 union all select 3) as x where id in @ids", new { ids = new int[] { 1, 2, 3 });
select * from (select 1 as id union all select 2 union all select 3) as x where id in (@ids1, @ids2, @ids3);
select name from [user] where [userid] in (@ids);
select name from [user] where [userid] in @ids;
union all select;
if (itemlist.count == 0) { return enumerable.empty<item>().tolist().asreadonly(); } "create table #items (itemid int not null primary key clustered);", transaction: transaction bulkcopytimeout = 3600 // ridiculously large select i.itemid, i.itemname from #items x inner join dbo.items i on x.itemid = i.itemid drop table #items;", transaction: transaction, commandtimeout: 3600 );
create type [dbo].[mytvp] as table([providerid] [int] not null);
select sysobjects.name as trigger_name from sysobjects where sysobjects.type = 'tr';
select sysobjects.name as trigger_name from sysobjects where sysobjects.type = 'tr';
select o.name as trigger_name from sysobjects as o where o.type = 'tr';
select [so].[name] as [trigger_name], user_name([so].[uid]) as [trigger_owner], user_name([so2].[uid]) as [table_schema], object_name([so].[parent_obj]) as [table_name], objectproperty( [so].[id], 'execisupdatetrigger') as [isupdate], objectproperty( [so].[id], 'execisdeletetrigger') as [isdelete], objectproperty( [so].[id], 'execisinserttrigger') as [isinsert], objectproperty( [so].[id], 'execisaftertrigger') as [isafter], objectproperty( [so].[id], 'execisinsteadoftrigger') as [isinsteadof], objectproperty([so].[id], 'execistriggerdisabled') as [disabled] from sysobjects as [so] where [so].[type] = 'tr';
select servername   = @@servername, databasename = db_name(), schemaname   = isnull( s.name, '' ), tablename    = isnull( o.name, 'ddl trigger' ), triggername  = t.name, defininion   = object_definition( t.object_id ) from sys.triggers t schemaname, tablename, triggername;
select [tgr].[name] as [trigger name], [tbl].[name] as [table name] from sysobjects tgr join sysobjects tbl where tgr.xtype = 'tr';
select      o.[name], c.[text] from        sys.objects as o where   o.[type] = 'tr';
select db_name() as databasename, s.name as schemaname, t.name as tablename, dbo.sysobjects.name as triggername, dbo.syscomments.text as sqlcontent, from dbo.sysobjects where dbo.sysobjects.xtype = 'tr' and dbo.sysobjects.name like 'permit_afterinsert' ---- <----- here;
select object_name(parent_id) table_or_viewnm, name triggernm, is_instead_of_trigger, is_disabled from sys.triggers where parent_class_desc = 'object_or_column' name ;
select tbl.name as table_name,trig.name as trigger_name,trig.is_disabled from [sys].[triggers] as trig inner join sys.tables as tbl on;
select [parent] = left((case when tr.parent_class = 0 then '(database)' else object_name(tr.parent_id) end), 32), [schema] = left(coalesce(object_schema_name(tr.object_id), '(none)'), 16), [trigger name] = left(tr.name, 32), [type] = left(tr.type_desc, 3), -- sql or clr [on?] = (case when tr.is_disabled = 0 then 'x' else ' ' end), [repl?] = (case when tr.is_not_for_replication = 0 then 'x' else ' ' end), [event] = left((case when tr.parent_class = 0 then (select top 1 left(te.event_group_type_desc, 40) from sys.trigger_events as te where te.object_id = tr.object_id) else ((case when tr.is_instead_of_trigger = 1 then 'instead of ' else 'after ' end)) + from sys.trigger_events as te where te.object_id = tr.object_id from sys.triggers as tr tr.parent_class, -- database triggers first;
select obj.name as tbl,trg.name,sm.definition,'<br>' from sys.objects obj where obj.type='u';
select distinct o.[name] as [table] from    [sysobjects] o join    [sysobjects] tr where   tr.[type] = 'tr' select distinct o.[name] as [table], tr.[name] as [trigger] from    [sysobjects] o join    [sysobjects] tr where   tr.[type] = 'tr';
select sysobjects.name as trigger_name   ,object_name(parent_obj) as table_name ,s.name as table_schema from sysobjects where sysobjects.type = 'tr';
select object_name(parent_id) as table_name, * from [database_name].sys.triggers;
select sysobjects.name as trigger_name from sysobjects where sysobjects.type = 'tr' select object_name(parent_id) as table_name from sys.triggers;
create table [dbo].[versions]( [id] [uniqueidentifier] not null, [date] [varchar](100) null, [server] [varchar](100) null, [database] [varchar](100) null, [user] [varchar](100) null, [object] [varchar](100) null, [action] [varchar](100) null, [code] [varchar](max) null, constraint [pk_versions] primary key clustered ( [id] asc alter table [dbo].[versions] add  constraint [df_versions_id]  default (newid()) for [id] drop trigger [db_versions_trigger] on all server create trigger [db_versions_trigger] on all server for create_procedure, alter_procedure, drop_procedure, create_trigger, alter_trigger, drop_trigger, create_function, alter_function, drop_function, create_view, alter_view, drop_view, create_table, alter_table, drop_table as set nocount on set xact_abort off;
if object_id('db_versions.dbo.versions') is not null end end try end catch;
select sch.name as trigger_table_schema else '' end as trigger_type ( stuff ( ( select ', ' + type_desc as [text()] from sys.events as syse where syse.object_id = systrg.object_id ) from sys.triggers as systrg where (1=1) and ( -- systbl.name is null not ( systrg.name = 'trg_' + systbl.name  + '_insert_history' or systrg.name = 'trg_' + systbl.name  + '_update_history' or systrg.name = 'trg_' + systbl.name  + '_delete_history' ) ) sch.name;
select triggerrecord.name as triggername,parentrecord.name as fortablename from sysobjects triggerrecord where triggerrecord.xtype='tr';
select object_name(parent_object_id) as parent_table, object_name(object_id) trigger_table, * from sys.objects where type = 'tr';
create database t;
create table parent (id int not null, primary key (id) create table child (id int null, parent_id int null, foreign key (parent_id) references parent(id);
create database t;
create table parent (id int not null, primary key (id) create table child (id int null, parent_id int null, foreign key (parent_id) references parent(id) on delete cascade;
create table parent ( id int(10) unsigned not null, primary key (id) create table child ( id int(10) unsigned not null, parent_id int(10) unsigned default null, foreign key (parent_id) references parent(id) on delete cascade;
alter database database_name set offline with rollback immediate;
select @kill = @kill + 'kill ' + convert(varchar(5), session_id) + ';' from sys.dm_exec_sessions where database_id  = db_id('mydb');
select @kill = @kill + 'kill ' + convert(varchar(5), spid) + ';' from master..sysprocesses where dbid = db_id('mydb');
alter database [yourdatabasename] set  single_user with rollback immediate drop database [yourdatabasename];
alter database [yourdatabasename] set single_user with rollback immediate;
alter database [databasename] set single_user;
set @database = 'adventureworks2016ctp3' select spid from sys.sysprocesses where db_name(dbid) = @database set @sql = 'kill ' + cast(@spid as varchar(10)) + ';' exec (@sql) end ;
select @kill = @kill + 'kill ' + convert(varchar(5), session_id) + ';' from sys.dm_exec_sessions where database_id = db_id('<yourdb>');
exec sys.sp_executesql @kill;
from sys.dm_exec_sessions where database_id = @databaseid ) set @sql = ( select top 1 from sys.dm_exec_sessions where database_id = @databaseid exec sys.sp_executesql @sql;
select @kill = @kill + 'begin try kill ' + convert(varchar(5), spid) + ';' + ' end try begin catch end catch ;' from master..sysprocesses exec (@kill);
set @kill ='' select @kill = @kill + 'kill ' +  convert(varchar(5), session_id) + ';' from sys.dm_exec_sessions where login_name = 'usrdbtest' and datediff(hh,login_time,getdate()) > 1;
select spid, sp.[status], loginame [login], hostname, blocked blkby, sd.name dbname, cmd command, cpu cputime, memusage memory, physical_io diskio, lastwaittype lastwaittype, [program_name] programname, last_batch lastbatch, login_time logintime, 'kill ' + cast(spid as varchar(10)) as 'kill command' from master.dbo.sysprocesses sp join master.dbo.sysdatabases sd on sp.dbid = sd.dbid where sd.name not in ('master', 'model', 'msdb') select @sqlcommand = 'kill ' + cast(spid as varchar(10)) from master.dbo.sysprocesses sp join master.dbo.sysdatabases sd on sp.dbid = sd.dbid where sd.name not in ('master', 'model', 'msdb') exec sp_executesql @sqlcommand;
select @kill = @kill + 'kill ' + convert(varchar(5), req_spid) + ';' from master.dbo.syslockinfo where rsc_type = 2 and rsc_dbid  = db_id('mydb');
select @kill = @kill + 'kill ' + convert(varchar(5), session_id) + ';' from sys.dm_exec_sessions where database_id  = db_id('mydb');
select  distinct spid from    master..sysprocesses where   dbid = db_id('dbname') from    killcursor set     @execsql = 'kill ' + cast(@spid as varchar(50)) exec    (@execsql) from    killcursor end ;
alter table users add column verified tinyint unsigned default 0;
alter table table1 add column foo int default 0;
alter [online | offline] [ignore] table tbl_name add [column] (col_name column_definition,...);
alter table `tablename` add `new_col_name` int not null default 0;
alter table <table> add column <column> <type>;
alter table table_name add column_name int not null default 0;
alter table table_name add column_name int default 0;
alter table engagete_st.holidays add column `status` enum('a', 'd') default 'a' after `h_type`;
alter table my_table add column new_field tinyint(1) default 0;
alter table `table1` add column `foo` after `bar` int default 0;
create table [dbo].[be_categories]( [categoryid] [uniqueidentifier] rowguidcol  not null constraint [df_be_categories_categoryid]  default (newid()), [categoryname] [nvarchar](50) null, [description] [nvarchar](200) null, [parentid] [uniqueidentifier] null, constraint [pk_be_categories] primary key clustered ( [categoryid] asc;
create nonclustered index [ix_categories] on [dbo].[be_categories] ( [categoryname] asc;
exec sp_help 'dbo.mytable';
select table_name as [table] , column_name as [column] , table_catalog as [database], table_schema as [schema]  from information_schema.columns where table_schema = 'dbo';
select column_name, data_type, character_maximum_length from information_schema.columns where table_name = 'table_name';
select column_name,data_type,data_length from all_tab_columns where table_name = 'xxxx' and owner ='xxxxxxxxxx';
select o.name as tablename, c.name as columnname, o.[type], s.name as schemaname, o.type_desc from sys.objects as o where o.type_desc='user_table' and c.name='yourcolumnname' --if comment this line,show all columns o.name, c.column_id;
select column_name from user_tab_cols where table_name = 'mytablename';
select * from information_schema.columns where table_name = 'tablename';
select c.name from sys.objects o sys.columns c and o.name = 'table_name';
select column_name from information_schema.columns where table_name  = 'table_name';
select name from sysobjects where type = 'u';
select name from syscolumns where id=object_id('tablename');
select name from sys.columns where [object_id] = object_id('dbo.tablename');
select ... from customers join orders using (customer_id);
select * from generate_series( '2017-01-01'::timestamp, '2017-01-01'::timestamp + interval '1 month -1 day', interval '1 day';
select * from table1, table2;
select * from generate_series( '2017-01-01'::timestamp, '2017-01-01'::timestamp + interval '1 month -1 day', interval '1 day' join departments as d on day >= d.created_at;
select * from actor as a join film_actor as fa on a.actor_id = fa.actor_id join film as f on f.film_id = fa.film_id;
select * from actor join film_actor using (actor_id) join film using (film_id);
select * from actor;
select * from a left join b on <predicate> select a.*, b.* from a join b on <predicate> union all select a.*, null, null, ..., null from a where not exists ( select * from b where <predicate> );
select * from actor a, film_actor fa, film f where a.actor_id = fa.actor_id(+) and fa.film_id = f.film_id(+) select * from actor a, film_actor fa, film f where a.actor_id *= fa.actor_id and fa.film_id *= f.film_id;
select date '2017-01-01' + level - 1 from dual  select 'dept 1', date '2017-01-10' from dual union all select 'dept 2', date '2017-01-11' from dual union all select 'dept 3', date '2017-01-12' from dual union all select 'dept 4', date '2017-04-01' from dual union all select 'dept 5', date '2017-04-02' from dual ) select * from days;
select * from actor a where exists ( select * from film_actor fa where a.actor_id = fa.actor_id );
where a.actor_id = fa.actor_id;
select * from actor a where not exists ( select * from film_actor fa where a.actor_id = fa.actor_id );
select * from actor a where film_id is null;
select a.first_name, a.last_name, f.* from actor as a select f.title, sum(amount) as revenue from film as f join film_actor as fa using (film_id) join inventory as i using (film_id) join rental as r using (inventory_id) join payment as p using (rental_id) where fa.actor_id = a.actor_id -- join predicate with the outer query! limit 5;
select a.first_name, a.last_name, f.* from actor as a select f.title, sum(amount) as revenue from film as f join film_actor as fa on f.film_id = fa.film_id join inventory as i on f.film_id = i.film_id join rental as r on i.inventory_id = r.inventory_id join payment as p on r.rental_id = p.rental_id where fa.actor_id = a.actor_id -- join predicate with the outer query! limit 5;
select a.*, multiset ( select f.* from film as f join film_actor as fa using (film_id) where a.actor_id = fa.actor_id from actor;
select  * from table1 a;
select a.*, b.col1, b.col2          --but no b.foreignkeycolumn in select from table1 a;
select * from table1 a inner join table2 b on a.pk <= b.fk;
select * from table1 a1 inner join table1 a2 on a1.pk = a2.fk;
select * from table1 a full outer join table2 b on a.pk = b.fk;
select * from table1 a left outer join table2 b on a.pk = b.fk;
select * from table1 a right outer join table2 b on a.pk = b.fk;
select * from tablea cross join tableb;
select * from table1 a1 cross join table1 a2;
select * from table1 a1,table1 a2;
select column_name, data_type from information_schema.columns where table_name = 'your_table_name' and table_schema = 'your_schema_name;
select @col= coalesce(@col, '') + ',' + column_name from information_schema.columns where  table_name = 'mxlocations';
select @result=@result+''+columnname+' from ( select replace(col.name, ' ', '_') columnname, column_id columnid from sys.columns col join sys.types typ on where object_id = object_id('tblpracticetestsections');
select @result = @result + ' from ( select replace(col.name, ' ', '_') columnname, column_id columnid from sys.columns col join sys.types typ on where object_id = object_id(@tablename) set @result = @result  + ';
select * from <tablename> where 1=2;
select * from syscolumns where id=object_id('your_table');
if exists ( select * from syscolumns where id=object_id('your_table') and name='your_column' ) end;
create procedure [dbo].[usp_getcolumnname] as begin set nocount on if (@tablename is not null) select ordinal_position orderposition,column_name columnname from information_schema.columns where table_name =@tablename end end;
exec sp_columns [tablename];
select st.name, sc.name, sc.system_type_id from sys.tables st where st.name like '%tablename%';
select column_name from information_schema.columns where table_name = 'yourtablename';
select column_name from   your_db_name.information_schema.columns where  table_name = 'your_table_name' and table_schema = 'your_db_name';
select column_name, * from information_schema.columns where table_name = 'you-table-name' and table_catalog='your-database-name';
set fmtonly on select * from yourtable;
select table_name,table_schema,[column_name],[data_type] from  information_schema.columns where table_schema='dbo';
select * from information_schema.columns where table_name = n'tablename';
select objectname       = object_name(object_id) from sys.all_columns c where [object_id] = object_id('sys.server_permissions');
select * from sys.types;
select syscolumns.name, syscolumns.colid from sysobjects, syscolumns where sysobjects.id = syscolumns.id and;
select column_name,* from information_schema.columns where table_name = 'yourtablename' and table_schema='yourschemaname';
select syscolumns.name as [column], syscolumns.xusertype as [type], sysobjects.xtype as [objtype] from sysobjects syscolumns on sysobjects.id = syscolumns.id where sysobjects.xtype = 'u' and   sysobjects.name = 'mytablename';
select  ( select count(*) from   tab1 ( select count(*) from   tab2 from    dual;
select (select count(*) from tab1) count_1, (select count(*) from tab2) count_2 from dual;
select (select count(*) from table1) as count1, (select count(*) from table2) as count2;
select (select count(*) from table1) as count1, (select count(*) from table2) as count2;
select count(*) from (select tab1key as key from schema.tab1 union all select tab2key as key from schema.tab2 );
select sum(amount) from ( select count(*) amount from schema.tab1 union all select count(*) amount from schema.tab2 );
select 'table_1' as table_name, count(*) from table_1 union select 'table_2' as table_name, count(*) from table_2 union select 'table_3' as table_name, count(*) from table_3;
t2_count as (select count(*) c2 from t2) select c1, c2 from   t1_count, t2_count select c1, c2 from   (select count(*) c1 from t1) t1_count, (select count(*) c2 from t2) t2_count;
select count(distinct tab1.id) as count_t1, count(distinct tab2.id) as count_t2 from tab1, tab2;
select distinct(select count(*) from domain1.table1) "count1", (select count(*) from domain1.table2) "count2" from domain1.table1, domain1.table2;
select distinct(select count(*) from domain1.table1) "count1", (select count(*) from domain2.table1) "count2" from domain1.table1, domain2.table1;
select 'domain 1'"domain", count(*) from domain1.table1 union all select 'domain 2', count(*) from domain2.table1;
select decode(rownum, 1, '', ' union all ') || from all_tables where owner = :owner;
select 'tab1' as table_name, count(*) from tab1 union all select 'tab2' as table_name, count(*) from tab2 union all select 'tab3' as table_name, count(*) from tab3 union all select 'tab4' as table_name, count(*) from tab4;
select  (select count(*) from table1) + (select count(*) from table2) from    dual;
select @count = sum(data) from ( select count(*)  as data from #tempregion union select count(*)  as data from #tempmetro union select count(*)  as data from #tempcity union select count(*)  as data from #tempzips;
select count(*) from ( select distinct table_a.id  from table_a join table_c on table_a.id  = table_c.id   );
set @all = (select count(*) from tab1) + (select count(*) from tab2);
select (select count(*) from tab1) + (select count(*) from tab2);
select 'tblproducts' [tablename], count(p.id) [rowcount] from tblproducts p union all select 'tblproductsales' [tablename], count(s.id) [rowcount] from tblproductsales s select (select count(id) from   tblproducts) as productcount, (select count(id) from   tblproductsales) as salescount;
select t1.count_1,t2.count_2 from (select count(1) as count_1 from tab1) as t1, (select count(1) as count_2 from tab2) as t2;
select (select count(*) from table1 ) + as total from dual;
alter table mytable alter column mycolumn drop not null;
values ('yatrix', '1234 address stuff', '1112223333');
values ('yatrix', '1234 address stuff', '1112223333');
if exists (select * from sys.foreign_keys where object_id = object_id(n'dbo.fk_tablename_tablename2') and parent_object_id = object_id(n'dbo.tablename') ) alter table [dbo.tablename] drop constraint [fk_tablename_tablename2];
alter table [dbo].[tablename] drop constraint fk_tablename_tablename2;
if (object_id('dbo.fk_constraintname', 'f') is not null) alter table dbo.tablename drop constraint fk_constraintname end;
if = sql inline table-valued function;
if objectproperty(object_id(n'my_fk_name'),'isconstraint') =1 alter table dbo.tablename drop constraint my_fk_name;
select 'if  exists (select * from sys.foreign_keys where object_id = object_id(n''' + from sys.foreign_keys as fk where o.name = @tablename and s.name = @schemaname select ' if  exists (select * from sys.foreign_keys where object_id = object_id(n''' + from sys.foreign_keys as fk where o.name = @tablename and s.name = @schemaname;
create table t(id int primary key, parentid int constraint tpartnt foreign key references t(id)) alter table t drop constraint if exists tpartnt drop table if exists t;
if (select object_id from sys.foreign_keys where [name] = 'fk_tablename_tablename2') is not null alter table dbo.tablename drop constraint fk_tablename_tablename2 end;
select @constraintname = kcu.constraint_name from information_schema.referential_constraints as rc and kcu.constraint_schema = rc.constraint_schema and kcu.constraint_name = rc.constraint_name where kcu.table_name = 'table_name' and if @constraintname is not null exec('alter table table_name drop  constraint ' + @constraintname);
create function fngetforeignkeyname ( @parenttablename nvarchar(255), @parentcolumnname nvarchar(255), @referencedtablename nvarchar(255), @referencedcolumnname nvarchar(255) ) as begin select @name = fk.name  from sys.foreign_key_columns fc join sys.columns pc on pc.column_id = parent_column_id and parent_object_id = pc.object_id join sys.columns rc on rc.column_id = referenced_column_id and referenced_object_id = rc.object_id join sys.objects po on po.object_id = pc.object_id join sys.objects ro on ro.object_id = rc.object_id join sys.foreign_keys fk on fk.object_id = fc.constraint_object_id where po.object_id = object_id(@parenttablename) and end  select @name = dbo.fngetforeignkeyname('dbo.badges', 'badgereasontypeid', 'dbo.badgereasontypes', 'id') if @name is not null set @sql = 'alter table badges drop constraint ' + replace(@name,']', ']]') exec (@sql) end;
if exists(select 1 from sys.foreign_keys where parent_object_id = object_id(n'dbo.tablename')) select @fkeyremovequery='alter table dbo.tablename drop constraint [' + ltrim(rtrim([name])) + ']' from sys.foreign_keys where parent_object_id = object_id(n'dbo.tablename') end;
if (object_id('df_constraint') is not null) alter table [dbo].[tablename] drop constraint df_constraint end;
create table question_bank ( question_id uniqueidentifier primary key, question_exam_id uniqueidentifier not null, question_text varchar(1024) not null, question_point_value decimal, constraint fk_questionbank_exams foreign key (question_exam_id) references exams (exam_id);
constraint your_name_here foreign key (question_exam_id) references exams (exam_id);
alter table mytable add constraint mytable_mycolumn_fk foreign key ( mycolumn ) references myothertable(pkcolumn);
create table question_bank ( question_id uniqueidentifier primary key, question_exam_id uniqueidentifier not null constraint fk_exam_id foreign key references exams(exam_id), question_text varchar(1024) not null, question_point_value decimal;
alter table mytable add constraint mytable_mycolumn_fk foreign key ( mycolumn );
alter table mytable add constraint mytable_mycolumn_fk foreign key ( mycolumn );
create table productcategories ( id           int identity primary key, productid    int references products(id) );
if 0 < ( select count(*) from information_schema.tables where table_type = 'base table' and table_schema = 'dbo' and table_name = 't_sys_language_forms' ) if 0 = (select count(*) from t_sys_language_forms where lang_uid is null) alter table t_sys_language_forms alter column lang_uid uniqueidentifier not null if 1 >= (select top 1 count(*) as cnt from t_sys_language_forms group by lang_uid order by cnt desc) if 0 = ( select count(*) from information_schema.table_constraints where constraint_type = 'primary key' and table_schema = 'dbo' and table_name = 't_sys_language_forms' ) alter table t_sys_language_forms add constraint pk_t_sys_language_forms primary key clustered (lang_uid asc) if 0 = (select count(*) from information_schema.referential_constraints where constraint_name = 'fk_t_zo_sys_language_forms_t_sys_language_forms') alter table t_zo_sys_language_forms with nocheck add constraint fk_t_zo_sys_language_forms_t_sys_language_forms foreign key(zolang_lang_uid) references t_sys_language_forms(lang_uid);
end -- end uniqueness check else print 'fsck, this column has duplicate keys, and can thus not be changed to primary key...' end -- end null check else print 'fsck, need to figure out how to update null value(s)...' end;
alter table [schema].[tablename] add foreign key (columnname) references [tablename](columnname) alter table [dbo].[usermaster] add foreign key (city_id) references [dbo].[citymaster](city_id);
create table exams ( exam_id int primary key, exam_name varchar(50), );
create table question_bank ( question_id int primary key, question_exam_id int not null, question_text varchar(1024) not null, question_point_value decimal, constraint question_exam_id_fk;
alter table foreign_key_table_name add constraint;
alter table foreignkeytable add constraint `foreignkeytable_foreignkeycolumn_fk`;
alter table tblemployee add constraint tblemployee_departmentid_fk;
create function dbo.trim(@string varchar(max)) end go;
select replace('helloreplacethingsgoing','replace','how');
update tablename set columnname = replace(columnname, ' ', '');
create table tbl_removeextraspaces ( rno int );
select [rno] from tbl_removeextraspaces;
update table_foo set column_bar  = replace(ltrim(rtrim(column_bar)), '  ', '');
update table_name set  "column_name"=replace("column_name", ' ', ''); //remove white space update table_name set  "column_name"=replace("column_name", '\n', ''); //remove newline update table_name set  "column_name"=replace("column_name", '\t', ''); //remove all tab;
select common.ufn_removewhitespace(' 234   asdf   wefwef 3  x   ', default) as s;
alter function common.removewhitespace ( @pstring nvarchar(max), @pwhitespacecharsopt nvarchar(max) = null -- default: tab, lf, cr, space ) @pwhitespacecharsopt, char(9) + char(10) + char(13) + char(32));  -- tab, lf, cr, space @nonwhitespacepattern nvarchar(30) = '%[^' + @whitespacechars + ']%', @previousstring nvarchar(max) = '';
set @previousstring = @pstring;
if (@whiteindex > 0) set @pstring = end end return @pstring;
create function replaceall ( @originalstring varchar(8000), @stringtoremove varchar(20), @stringtoputinplace varchar(20) ) as begin set @resultstr = @originalstring set @resultstr = replace(@resultstr, @stringtoremove, @stringtoputinplace) end;
update tbtest set description = dbo.replaceall(description, '  ', ' ') where id = 14225;
values ('  ey     y select col_1 as input, ltrim(rtrim( replace( replace( replace( replace( replace( replace( replace( replace( replace( replace( replace(col_1,char(10),' ') from @tbl;
set @input_val = '      c               a                         ' set @output_val = @input_val set @output_val = replace(@input_val, char(32), '') end ;
create function udf_removespaces (@input_val    varchar(8000)) as begin set @output_val = @input_val set @output_val = replace(@input_val, char(32), '') end  end;
update a set status_reason_code = whatever.dbo.udf_removespaces(status_reason_code) from whatever..acct_info a where a.somevalue = @somevalue select whatever.dbo.udf_removespaces(status_reason_code) from whatever..acct_info a where a.somevalue = @somevalue;
create function removeallspaces ( @inputstr varchar(8000) ) as begin set @resultstr = @inputstr set @resultstr = replace(@inputstr, ' ', '') end;
select dbo.removeallspaces('aa  aaa       aa aa                 a');
update tablename set colname = replace(ltrim(rtrim(colname)), '  ', ' ') where colname like '%  %';
set @mytable = 'mytable' select column_name, row_number() over(order by column_name) as id into #tempcols from information_schema.columns where   data_type in ('varchar', 'nvarchar') and table_name = @mytable select @tri = count(*) from #tempcols select @i = 0 set @comma = ', ' select @trimmer = 'update [dbo].[' + @mytable + '] set ' if (@i = @tri) set @comma = '' end select  @trimmer = @trimmer + char(10)+ '[' + column_name + '] = ltrim(rtrim([' + column_name + ']))'+@comma from    #tempcols where id = @i select @i = @i+1 end  exec sp_executesql @trimmer drop table #tempcols;
select * from table where ltrim(rtrim(username)) = ltrim(rtrim("bob alias baby"));
select replace(replace(replace(replace(mobileno,'-',''),'(',''),')',''),' ','') from employeecontactnumber;
select replace(fld_or_variable, ' ', '');
create table #t ( c char(8), v varchar(8)) ('a a  '  , 'a a  '  ), ('  a a'  , '  a a'  ), ('  a a  ', '  a a  ') select '"' + c + '"' [in], '"' + replace(c, ' ', '') + '"' [out] from #t union all select from #t;
in             out;
select replace (' hello , how are you ?', ' ', '' );
select * from a_table where attribute = 'k' collate latin1_general_cs_as;
alter table table1 alter column column1 varchar(200);
alter table table1 alter column column1 varchar(200);
select * from a_table where hashbytes('sha1', attribute) = hashbytes('sha1', 'k');
create table t ( c [nvarchar](100) not null unique, );
set xact_abort on -- turns on rollback if t-sql statement raises a run-time error. select * from t; -- check before. select * from t; -- check after. delete t;
values ('tidd130', 130), ('tidd230', 230) update [test].[dbo].[t1] set [title] = n'az2' ,[avg] = 1 where [dbo].[t1].[title] = n'az' end try end catch;
alter table table_name add unique key;
then insert ignore into table_name;
where [yourpk] not in (select [yourpk] from [databasename1].dbo.[tablename1]);
( select $column1, $column2, $column3 where not exists ( select 1 from table where column1 = $column1 and column2 = $column2 and column3 = $column3 ) );
select $column1, $column2, $column3 from table;
if exists (select * from bookings where flightid = @id) end else begin end;
set ansi_nulls on set quoted_identifier on alter procedure [dbo].[cjso_updatecustomerlogin] ( @customerid as int, @username as varchar(25), @password as binary(16) ) as begin if isnull((select customerid from tblonline_customeraccount where customerid = @customerid), 0) = 0 [customerid], [username], [password], [lastlogin] /* customerid - int */ @customerid, /* username - varchar(25) */ @username, /* password - binary(16) */ @password, /* lastlogin - datetime */ null ) end else begin update  [tblonline_customeraccount] set     username = @username, password = @password where   customerid = @customerid end  end;
select @rowcount=@@rowcount if @rowcount=0;
if exists(select 1 from information_schema.tables t where t.table_name = 'bookings') drop table bookings end go create table bookings( flightid    int identity(1, 1) primary key, ticketsmax    int not null, ticketsbooked int not null ) select * from bookings;
and t.ticketsmax > (t.ticketsbooked + s.ticketstobook) update set t.ticketsbooked = t.ticketsbooked + s.ticketstobook select * from bookings;
if not exists (select * from table with (updlock, rowlock, holdlock) where ...) else /* update */;
select @par1, @par2 where not exists (select col1,col2 from tablename where col1=@par1 and col2=@par2);
select 'cem' where not exists (select username from members where username='cem');
select result1,picture,bittot from  all_tempnogos2results11 if not exists (select * from all_tempnogos2results11_uniq with (updlock, rowlock, holdlock) where all_tempnogos2results11_uniq.result1 = @mystat6 and all_tempnogos2results11_uniq.bittot = @mystat6b ) end ;
select t.name, i.rows as [rowcount] from   sys.tables as t where t.name = 'your_table_name';
select sum(p.rows) from sys.partitions as p where t.name = n'yourtablenamehere' and s.name = n'dbo' and p.index_id in (0,1);
select count(id) from mytable;
select reltuples as approximate_row_count from pg_class where relname = 'table_name';
select count(*) from transactions;
select convert(bigint, rows) from sysindexes where id = object_id('transactions') and indid < 2;
select cast(p.rows as float) from sys.tables as tbl and p.index_id=idx.index_id where ((tbl.name=n'transactions' and schema_name(tbl.schema_id)='dbo'));
select sum (row_count) from sys.dm_db_partition_stats where object_id=object_id('transactions') and (index_id=0 or index_id=1);
select count(1) from tablelarge;
select count_big(1) from tablelarge;
select top(1) <primarykeyfield> from <table> order by <primarykeyfield> desc;
select count(pk) from t where pk < 250000000 select count(pk) from t where pk >= i*250000000 and pk < (i+1)*250000000 select count(pk) from t where pk > (n-1)*250000000;
create table counter_table (minpk integer, maxpk integer, cnt integer, slaveid integer);
select sum(cnt) from ( select * from counter_table_slave_1 union select * from counter_table_slave_2 union ... );
select count(*) ...;
update t set n = n + 1;
update t set n = n - 1;
select n from t;
select @max = row_count from sys.dm_db_partition_stats where object_name(object_id) = 'tbl_highorder';
select rows from sysindexes where id = object_id('tablename') and indid <2;
select count(*) from mybigtable with (nolock);
select total_rows= sum(st.row_count) from sys.dm_db_partition_stats st where object_name(object_id) = 'mybigtable' and (index_id < 2);
select count(*);
select o.name, ddps.row_count from sys.indexes as i and i.index_id = ddps.index_id where i.index_id < 2 and o.is_ms_shipped = 0;
select <table_name>, num_rows, last_analyzed from user_tables;
select count(*) from tablename;
select /*+ parallel(a) */  count(1) from table_name a;
select [from] from table;
select table.[from] from table;
select [select] from [table];
select [from] as transferfrom -- or something else more suitable from tablename;
select "from" from "table";
select  [from] from < ur_tablename>;
select * from your_tablename;
create table alpha1 as ( sel from beta1;
update `survey` set survey.values='yes,no' where (question='did you agree?');
select distinct table.from as a from table;
select tablename.from from tablename;
select `from` from table;
select [from] from <table>;
select * from tablename order by random() limit 5;
select top 1 column_name from dbo.table tablesample(1 percent);
select * from table1 where (abs(cast( (binary_checksum;
select @minvalue = min(id), @maxvalue = max(id) from [table];
set @randomid1 = ((@maxvalue + 1) - @minvalue) * rand() + @minvalue set @randomid2 = ((@maxvalue + 1) - @minvalue) * rand() + @minvalue set @randomid3 = ((@maxvalue + 1) - @minvalue) * rand() + @minvalue set @randomid4 = ((@maxvalue + 1) - @minvalue) * rand() + @minvalue set @randomid5 = ((@maxvalue + 1) - @minvalue) * rand() + @minvalue select * from [table] el where el.id in (@randomid1, @randomid2, @randomid3, @randomid4, @randomid5);
select @minvalue = min(id), @maxvalue = max(id) from [table];
select 1 union all select n+1 from cte where n < @numitems ) select cast( @range * rand(cast(newid() as varbinary(100))) + @minvalue as int) tp from cte;
select * from #nt ntt drop table #nt;
select artist||' - '||title as song from song;
select concat(concat(artist, ' - '), title) as song from song;
select artist||' - '||title as song from song;
select concat(concat(artist, ' - '), title) as song from song;
select top 10 percent * from table1 order by newid();
select top 5 id, name from customernames;
select column from table limit 1;
select column from table limit 1;
select top 1 column from table;
select column, rand() as idx from table;
select column from where rownum = 1;
select column from table;
select top 1 column from table;
select top 5 id, name from customernames order by newid();
select id, name from customer limit 5;
select c.name 'column name', t.name 'data type', c.max_length 'max length', c.precision , c.scale , c.is_nullable, isnull(i.is_primary_key, 0) 'primary key' from sys.columns c sys.types t on c.user_type_id = t.user_type_id where c.object_id = object_id('yourtablename');
select column_name, data_type, character_maximum_length, numeric_precision, datetime_precision, is_nullable from information_schema.columns where table_name='tablename';
exec sp_columns mytable;
select c.column_name, c.data_type, c.character_maximum_length, c.numeric_precision, c.is_nullable, tc.constraint_name from information_schema.columns as c and tc.table_name = c.table_name and tc.constraint_type = 'primary key' where c.table_name = 'table';
select c.column_name, c.data_type, c.character_maximum_length from information_schema.columns as c select ccu.constraint_name from information_schema.table_constraints as tc join information_schema.constraint_column_usage as ccu where tc.table_schema = c.table_schema and tc.table_name = c.table_name and tc.constraint_type = 'primary key' and ccu.column_name = c.column_name where c.table_name = 'table';
select column_name, data_type, character_maximum_length, is_nullable from information_schema.columns ic where table_name = 'tablename' and column_name = 'columnname';
if exists (select 1 from information_schema.tables where table_type = 'base table' and table_name = 'table') select cols.column_name, cols.data_type, cols.character_maximum_length, (select 'yes' from information_schema.table_constraints tc join information_schema.key_column_usage kcu and tc.constraint_type = 'primary key' and kcu.table_name = tc.table_name and kcu.constraint_name = tc.constraint_name and kcu.column_name = cols.column_name) as keyx from information_schema.columns cols where table_name = 'table' order by keyx desc, column_name end;
select c.name as [column name], t.name as [type name], tbl.name as [table name] from sys.columns c where c.object_id = object_id('yourtablename1') and t.name like '%yoursearchdatatype%' union (select t.name as [type name], tbl.name as [table name] from sys.columns c where c.object_id = object_id('yourtablename2') and t.name like '%yoursearchdatatype%') union (select t.name as [type name], tbl.name as [table name] from sys.columns c where c.object_id = object_id('yourtablename3') and t.name like '%yoursearchdatatype%');
select col.table_catalog as [database] else 1 end as bit)as isnullable from information_schema.columns as col from sys.indexes as i join sys.index_columns as ic on i.object_id = ic.object_id and i.index_id = ic.index_id join sys.objects as o on i.object_id = o.object_id and c.column_id = ic.column_id where i.is_primary_key = 1)as pk on col.table_name = pk.table_name and col.table_schema = pk.table_schema and col.column_name = pk.column_name where col.table_name = 'yourtablename' and col.table_schema = 'dbo';
select c.name 'column name', t.name, t.name + case when t.name in ('char', 'varchar','nchar','nvarchar') then '('+ case when c.max_length=-1 then 'max' else convert(varchar(4),  case when t.name in ('nchar','nvarchar') then  c.max_length/2 else c.max_length end ) end +')' then '('+ convert(varchar(4),c.precision)+',' else '' end as "ddl name", c.max_length 'max length in bytes', c.precision , c.scale , c.is_nullable, isnull(i.is_primary_key, 0) 'primary key' from sys.columns c sys.types t on c.user_type_id = t.user_type_id where c.object_id = object_id('yourtablename');
select t.name as [table name] from sys.objects as t join sys.columns as c join sys.types as p and c.[user_type_id] = p.[user_type_id] where t.type_desc='user_table' and t.name = 'inventorystatus';
exec sp_describe_first_result_set n'select * from [tablename]';
select column_name, is_nullable, data_type, character_maximum_length from information_schema.columns where table_name = '<name_of_table_or_view>';
select c.name as 'column name', t.name + '(' + cast(c.max_length as varchar(50)) + ')' as 'datatype', case when  c.is_nullable = 0 then 'null' else 'not null' end as 'constraint' from sys.columns c join sys.types t where c.object_id    = object_id('tablename');
select c.name 'column name', t.name 'data type', iif(t.name = 'nvarchar', c.max_length / 2, c.max_length) 'max length', c.precision 'precision', c.scale 'scale', iif(c.is_nullable = 0, 'no', 'yes') 'nullable', iif(isnull(i.is_primary_key, 0) = 0, 'no', 'yes') 'primary key' from sys.columns c sys.types t on c.user_type_id = t.user_type_id where c.object_id = object_id('yourtablename');
select tbl.name, fld.[column name],fld.[constraint],fld.datatype from sys.all_objects as tbl left join t.name + '(' + cast(c.max_length as varchar(50)) + ')' as 'datatype', case when  c.is_nullable = 0 then 'null' else 'not null' end as 'constraint' from sys.columns c join sys.types t where ( tbl.[type]='u' and tbl.[is_ms_shipped] = 0);
create table dbo.dummytable ( id int not null identity(0,1) primary key, msg varchar(80) null create index nc_dummytable_id on dummytable(id);
create or alter procedure dbo.gettablecolumns ( @schemaname nvarchar(128), @tablename nvarchar(128) ) as begin set nocount on;
( select i.object_id, ic.column_id from sys.indexes i join sys.index_columns ic on i.object_id = ic.object_id and i.index_id = ic.index_id where i.is_primary_key = 1 ) select c.name as column_name, t.name as typename, c.max_length as maxlength, c.precision, c.scale, c.is_nullable, is_primary_key = case when ct.column_id is not null then 1 else 0 end from sys.columns c join sys.types t on t.user_type_id = c.user_type_id where c.object_id = object_id(quotename(@schemaname) + '.' + quotename(@tablename)) end go exec dbo.gettablecolumns 'dbo', 'dummytable';
( select department, max(salary) as maxsalary from test ) select t.* from test t join cte c on c.department=t.department where t.salary=c.maxsalary;
select 1 as [mynum], 'a num' as [label] union all select [mynum]+1,[label] from [cte_example] where [mynum] <=  10 ) select * from [cte_example] union select sum([mynum]), 'sum_all' from [cte_example] union select sum([mynum]), 'sum_odd' from [cte_example] where [mynum] % 2 = 1 union select sum([mynum]), 'sum_even' from [cte_example] where [mynum] % 2 = 0;
( select top(5000) message_compressed, message, exception_compressed, exception from logs where id >= 5519694 ) update  cte set     message_compressed = compress(message), exception_compressed = compress(exception);
( select question_text, (select count(*) from answers a where a.question_id = q.id) as number_of_answers from questions q ) select * from cte where number_of_answers > 0;
( select [quiz_id] from [questions] union all  select q.[quiz_id] from [answers] a inner join [questions] q on q.quiz_id = a.quiz_id and q.id = a.question_id ) select quiz_id, question_id, is_question, (case when answer is null then question_text else answer end) as name from cte;
select mytable.* from mytable ) select * from cte where rn = 1;
as ( body of common table expression );
create table employee([eid] [int] identity(10,5) not null,[name] [varchar](50) null) create table dept(eid int,deptname varchar(100));
as ( select employee.eid,name,deptname from employee ) select * from cte_example;
as ( select eid,deptname from dept ) delete from cte_example where eid=10 and deptname ='payroll';
update tableb set tableb.value = ( select tablea.value from tablea where tablea.name = tableb.name );
select * into temptable from table1;
update table1 set table1.filename = (select filename from temptable where temptable.id = table1.id);
create definer=`my_procedure`@`%` procedure `rescue`() select count(*) from tablea into n;
select namea,valuea from tablea limit i,1 into cur_name,cur_value;
update tableb set nameb=cur_name where valueb=cur_value;
update    cities c, city_langs cl set       c.fakename = cl.name where     c.id = cl.city_id;
update tableb t1 set t1.name = t2.name where t2.name = 'joe';
update tableb t1 set t1.name = t2.name;
update tableb t1 set t1.value = t2.value;
update tableb set tableb.value = if(tablea.value > 0, tablea.value, tableb.value) where tablea.name = 'joe';
update tableb set tableb.value = ( select tablea.value from tablea where tablea.name = tableb.name;
select * from `objects` where (date_time_field between '2010-01-30' and '2010-09-29');
select * from `objects` where (date_time_field between '2010-01-30 00:00:00' and '2010-09-29 00:00:00');
select * from `objects` where (date(date_time_field) between '2010-01-30' and '2010-09-29');
select * from table_name where date(date_field) between '2016-12-01' and '2016-12-10';
select * from `objects` where (cast(date_field as datetime) between cast('2010-09-29 10:15:55' as datetime) and cast('2010-01-30 14:15:55' as datetime));
select * from `objects` where (cast(date_field as date) between '2010-09-29' and;
select * from table_name where created_at_column  >=   lower_date  and  created_at_column <= upper_date;
select * from table_name where created_at_column  >=   '2018-09-01 00:00:00'  and  created_at_column <= '2018-09-05 23:59:59';
select * from `objects` where  (date_field between '2010-01-30 14:15:55' and '2010-09-29 10:15:55');
select * from `objects` where (date_field between '2010-01-30 14:15:55' and '2010-09-29 10:15:55');
select * from table between `lowerdate` and `upperdate`;
select * from `objects` where  (date_field between '2010-01-30 14:15:55' and '2010-09-29 10:15:55');
select t.relname as table_name from pg_class t, pg_class i, pg_index ix, pg_attribute a where t.oid = ix.indrelid and i.oid = ix.indexrelid and a.attrelid = t.oid and a.attnum = any(ix.indkey) and t.relkind = 'r' and a.attrelid = '"dblegal".tbassettype'::regclass t.relname, i.relname;
create table test (a int, b int, c int, constraint pk_test primary key(c, a, b));
select i.relname as index_name, ix.indisunique as is_unique, a.attname as column_name, from pg_class c where c.oid='public.test'::regclass::oid;
select t.relname as table_name, i.relname as index_name, array_position(ix.indkey,a.attnum) pos, a.attname as column_name from pg_class t join pg_index ix on t.oid = ix.indrelid join pg_class i on i.oid = ix.indexrelid join pg_attribute a on a.attrelid = t.oid and a.attnum = any(ix.indkey) where t.relkind = 'r' and t.relname like 'orders';
select n.nspname as schema_name, t.relname as table_name, i.relname as index_name, a.attname as column_name, 1 + array_position(ix.indkey, a.attnum) as column_position from pg_catalog.pg_class t join pg_catalog.pg_attribute a on t.oid    =      a.attrelid join pg_catalog.pg_index ix    on t.oid    =     ix.indrelid join pg_catalog.pg_class i     on a.attnum = any(ix.indkey) and i.oid    =     ix.indexrelid join pg_catalog.pg_namespace n on n.oid    =      t.relnamespace where t.relkind = 'r' t.relname, i.relname, array_position(ix.indkey, a.attnum) ) select * from ind_cols where schema_name = 'test' and table_name  = 'indextest';
select t.relname table_name, ix.relname index_name, indisunique, indisprimary, regexp_replace(pg_get_indexdef(indexrelid), '.*\((.*)\)', '\1') columns from pg_index i join pg_class t on t.oid = i.indrelid join pg_class ix on ix.oid = i.indexrelid where t.relname like 'test%';
select t.relname as table_name from pg_class t join pg_index ix join pg_class i join pg_attribute a and a.attnum = any(ix.indkey) where t.relkind = 'r' and t.relname like 'test%';
create or replace function getindices(_table_name varchar) select t.relname::varchar as table_name, i.relname::varchar as index_name, a.attname::varchar as column_name from pg_class t, pg_class i, pg_index ix, pg_attribute a where t.oid = ix.indrelid and i.oid = ix.indexrelid and a.attrelid = t.oid and a.attnum = any(ix.indkey) and t.relkind = 'r' and t.relname = _table_name t.relname, i.relname;
select * from getindices('<my_table>');
select table_name, index_name, string_agg(column_name, ',') from ( select t.relname as table_name, i.relname as index_name, a.attname as column_name, (select i from (select row_number() from unnest(indkey) with ordinality as a(v)) a where v = attnum) from pg_class t, pg_class i, pg_index ix, pg_attribute a where t.oid = ix.indrelid and i.oid = ix.indexrelid and a.attrelid = t.oid and a.attnum = any (ix.indkey) and t.relkind = 'r' and t.relname like 'tablename';
select n.nspname as "schema", c.relname as "name", case c.relkind when 'r' then 'table' when 'v' then 'view' when 'i' then 'index' when 's' then 'sequence' when 's' then 'special' end as "type", u.usename as "owner", c2.relname as "table" from pg_catalog.pg_class c join pg_catalog.pg_index i on i.indexrelid = c.oid join pg_catalog.pg_class c2 on i.indrelid = c2.oid where c.relkind in ('i','') and n.nspname not in ('pg_catalog', 'pg_toast') and pg_catalog.pg_table_is_visible(c.oid) and c2.relname like '%agg_transaction%' --table name and nspname = 'edjus' -- schema name;
create unique index unique_user_name_index on users (lower(name));
select row_number() over (order by c.relname), c.relname as index, t.relname as table, array_to_string(array_agg(a.attname), ', ') as column_names from pg_class c join pg_index i on c.oid = i.indexrelid and c.relkind='i' and c.relname not like 'pg_%' join pg_class t on t.oid = i.indrelid;
create or replace view v_table_indexes as select n.nspname  as "schema" from pg_catalog.pg_class c join pg_catalog.pg_namespace n on n.oid        = c.relnamespace join pg_catalog.pg_index i on i.indexrelid = c.oid join pg_catalog.pg_class t on i.indrelid   = t.oid join pg_attribute a on a.attrelid = t.oid and a.attnum = any(i.indkey) where c.relkind = 'i' and n.nspname not in ('pg_catalog', 'pg_toast') and pg_catalog.pg_table_is_visible(c.oid) n.nspname n.nspname;
create index ui1 on table1 (coalesce(col1,''),coalesce(col2,''),col3);
select * from pg_indexes where tablename = 'mytable';
table "pg_catalog.pg_class" column      |   type    | modifiers;
create table test (a int, b int, c int, constraint pk_test primary key(a, b));
create table test2 (a int, b int, c int, constraint uk_test2 unique (b, c));
create table test3 (a int, b int, c int, constraint uk_test3b unique (b), constraint uk_test3c unique (c), constraint uk_test3ab unique (a, b));
select pg_get_indexdef(indexrelid) from pg_index where indrelid = 'test'::regclass;
create unique index pk_test on test using btree (a, b) select pg_get_indexdef(indexrelid) from pg_index where indrelid = 'test2'::regclass;
create unique index uk_test2 on test2 using btree (b, c) select pg_get_indexdef(indexrelid) from pg_index where indrelid ='test3'::regclass;
create unique index uk_test3b on test3 using btree (b) create unique index uk_test3c on test3 using btree (c) create unique index uk_test3ab on test3 using btree (a, b);
create table test (a int, b int, c int, constraint pk_test primary key(a, b));
create table test2 (a int, b int, c int, constraint uk_test2 unique (b, c));
create table test3 (a int, b int, c int, constraint uk_test3b unique (b), constraint uk_test3c unique (c),constraint uk_test3ab unique (a, b));
select t.relname as table_name, i.relname as index_name, a.attname as column_name from pg_class t, pg_class i, pg_index ix, pg_attribute a where t.oid = ix.indrelid and i.oid = ix.indexrelid and a.attrelid = t.oid and a.attnum = any(ix.indkey) and t.relkind = 'r' and t.relname like 'test%' t.relname, i.relname;
select t.relname as table_name, i.relname as index_name, array_to_string(array_agg(a.attname), ', ') as column_names from pg_class t, pg_class i, pg_index ix, pg_attribute a where t.oid = ix.indrelid and i.oid = ix.indexrelid and a.attrelid = t.oid and a.attnum = any(ix.indkey) and t.relkind = 'r' and t.relname like 'test%' t.relname, i.relname t.relname, i.relname;
select table_name, index_name, array_agg(column_name) from ( select t.relname as table_name, i.relname as index_name, a.attname as column_name, unnest(ix.indkey) as unn, a.attnum from pg_class t, pg_class i, pg_index ix, pg_attribute a where t.oid = ix.indrelid and i.oid = ix.indexrelid and a.attrelid = t.oid and a.attnum = any(ix.indkey) and t.relkind = 'r' and t.relnamespace = <oid of the schema you're interested in> t.relname, i.relname, generate_subscripts(ix.indkey,1)) sb where unn = attnum;
table |     column     |          type          | notnull |  index_name  | is_index | primarykey | uniquekey | default;
select c.relname as table, f.attname as column, pg_catalog.format_type(f.atttypid,f.atttypmod) as type, f.attnotnull as notnull, i.relname as index_name, case when i.oid<>0 then 't' else 'f' end as is_index, case when p.contype = 'p' then 't' else 'f' end as primarykey, case when p.contype = 'u' then 't' else 'f' end as uniquekey, case when f.atthasdef = 't' then d.adsrc end as default  from pg_attribute f join pg_class c on c.oid = f.attrelid join pg_type t on t.oid = f.atttypid where c.relkind = 'r'::char and n.nspname = 'public'  -- replace with schema name and f.attnum > 0;
create or replace view view_index as select n.nspname  as "schema" from pg_catalog.pg_class c join pg_catalog.pg_namespace n on n.oid        = c.relnamespace join pg_catalog.pg_index i on i.indexrelid = c.oid join pg_catalog.pg_class t on i.indrelid   = t.oid where c.relkind = 'i' and n.nspname not in ('pg_catalog', 'pg_toast') and pg_catalog.pg_table_is_visible(c.oid) n.nspname;
from sqlalchemy.sql import text text("""select * from users where name=:name""");
from collections import namedtuple;
from sqlalchemy.orm import sessionmaker, scoped_session;
from sqlalchemy import text;
from sqlalchemy.sql import text text('select * from employees where employeegroup = :group'), group = employeegroup) text("select * from employees where employeegroup = 'staff'"));
from flask import flask from flask_sqlalchemy import sqlalchemy from sqlalchemy import text;
select town, count(town), sum(count(town)) over () total_count from user;
select town, count(town), (select count(town) from user) as total_count from user;
select town, count(town) from user;
set @numofusers = select count(*) from user select distinct town, @numofusers from user;
select ccode, count(empno) from company_details;
select count(distinct user_id) from answers_votes where answer_id in (694,695);
select town, (select count(*) from user) `count` from user group by town;
select count(distinct town) from user;
select count(*) from ( /* number of times each town appears in user. */ select town, count(*) from user;
select town, count(town) as total from user;
select  province, total_cities from       ( select  distinct province  from  canada ) as provinces;
select  town, total_users from       ( select  distinct town  from  canada ) as towns;
select a.*, (select count(b.name) from table_name as b where condition) as totcount from table_name  as a where where condition;
select  isnull(town,'total') town, count(*) cnt from    user;
thisid int ) values ( 1, 1 ), ( 1, 2 ), ( 2, 2 ), ( 1, 1 );
if object_id('tempdb..#this') is not null drop table #this;
create table #this ( thisid int not null select * from @baddata;
as (select * from @baddata) select * from this_cte;
select c.constraint_name from information_schema.referential_constraints c join information_schema.key_column_usage x join information_schema.key_column_usage y and y.constraint_name = c.unique_constraint_name;
select tc.constraint_name, tc.table_name, kcu.column_name, ccu.table_name as foreign_table_name, ccu.column_name as foreign_column_name from information_schema.table_constraints as tc join information_schema.key_column_usage as kcu join information_schema.constraint_column_usage as ccu where constraint_type = 'foreign key' and ccu.table_name='yourtablenamehere';
select att2.attname as "child_column", cl.relname as "parent_table", att.attname as "parent_column", conname from (select unnest(con1.confkey) as "child", con1.confrelid, con1.conrelid, con1.conname from pg_class cl join pg_namespace ns on cl.relnamespace = ns.oid join pg_constraint con1 on con1.conrelid = cl.oid where cl.relname = 'child_table' and ns.nspname = 'child_schema' and con1.contype = 'f' join pg_attribute att on join pg_class cl on join pg_attribute att2 on;
select table_name, column_name from information_schema.key_column_usage where constraint_name in (select constraint_name from information_schema.referential_constraints where unique_constraint_name = 'table_name_pkey');
select r.conname from pg_catalog.pg_constraint r, information_schema.constraint_table_usage ct where r.contype = 'f' and r.conname = ct.constraint_name;
select o.conname as constraint_name, (select nspname from pg_namespace where oid=m.relnamespace) as source_schema, m.relname as source_table, (select a.attname from pg_attribute a where a.attrelid = m.oid and a.attnum = o.conkey[1] and a.attisdropped = false) as source_column, (select nspname from pg_namespace where oid=f.relnamespace) as target_schema, f.relname as target_table, (select a.attname from pg_attribute a where a.attrelid = f.oid and a.attnum = o.confkey[1] and a.attisdropped = false) as target_column from pg_constraint o left join pg_class f on f.oid = o.confrelid left join pg_class m on m.oid = o.conrelid where o.contype = 'f' and o.conrelid in (select oid from pg_class c where c.relkind = 'r');
create view foreign_keys_view as select tc.table_name, kcu.column_name, ccu.table_name as foreign_table_name, ccu.column_name as foreign_column_name from information_schema.table_constraints as tc join information_schema.key_column_usage as kcu on tc.constraint_name = kcu.constraint_name join information_schema.constraint_column_usage as ccu on ccu.constraint_name = tc.constraint_name where constraint_type = 'foreign key';
select * from foreign_keys_view where table_name='yourtablenamehere';
select tc.table_schema, tc.constraint_name, tc.table_name, kcu.column_name, ccu.table_schema as foreign_table_schema, ccu.table_name as foreign_table_name, ccu.column_name as foreign_column_name from information_schema.table_constraints as tc join information_schema.key_column_usage as kcu and tc.table_schema = kcu.table_schema join information_schema.constraint_column_usage as ccu and ccu.table_schema = tc.table_schema where tc.constraint_type = 'foreign key' and tc.table_name='mytable';
select conname, pg_catalog.pg_get_constraintdef(r.oid, true) as condef from pg_catalog.pg_constraint r where r.conrelid = '16485' and r.contype = 'f' order by 1;
where r.conrelid = 'mytable'::regclass;
where r.conrelid = 'myschema.mytable'::regclass;
select  current_catalog as "database", "pg_constraint".conrelid::regclass::text as "primary_table_name", "pg_constraint".confrelid::regclass::text as "foreign_table_name",  ( string_to_array( ( string_to_array( pg_get_constraintdef("pg_constraint".oid), '(' ) ')' )   string_to_array( pg_get_constraintdef("pg_constraint".oid), '(' )  from pg_constraint as "pg_constraint" join pg_namespace as "pg_namespace" on "pg_namespace".oid = "pg_constraint".connamespace where --fkey and pkey constraints and "pg_namespace".nspname = current_schema() and "pg_constraint".conrelid::regclass::text in ('whatever_table_name');
select  * from information_schema.key_column_usage where constraint_catalog=current_catalog and table_name='your_table_name' and position_in_unique_constraint notnull;
select conname, attname from pg_catalog.pg_constraint c join pg_catalog.pg_attribute a on a.attrelid = c.conrelid and a.attnum = any (c.conkey) where attrelid = 'schema.table_name'::regclass;
select conname, conrelid, confrelid, unnest(conkey)  as conkey, unnest(confkey) as confkey from pg_constraint where contype = 'f' -- and confrelid::regclass = 'your_table'::regclass ) select fk.conname as constraint_name, fk.confrelid::regclass as referenced_table, af.attname as pkcol, fk.conrelid::regclass as referencing_table, a.attname as fkcol from foreign_keys fk join pg_attribute af on af.attnum = fk.confkey and af.attrelid = fk.confrelid join pg_attribute a on a.attnum = conkey and a.attrelid = fk.conrelid;
select fks.table_name as foreign_key_table_name from information_schema.table_constraints fks -- foreign keys and fks.table_schema = kcu_foreign.table_schema and fks.table_name = kcu_foreign.table_name and fks.constraint_name = kcu_foreign.constraint_name and rc.constraint_schema = fks.constraint_schema and rc.constraint_name = fks.constraint_name and rc.unique_constraint_schema = pks.constraint_schema and rc.unique_constraint_name = pks.constraint_name and pks.table_schema = kcu_primary.table_schema and pks.table_name = kcu_primary.table_name and pks.constraint_name = kcu_primary.constraint_name and kcu_foreign.ordinal_position = kcu_primary.ordinal_position -- this joins the columns where fks.table_schema = 'dbo' -- replace with schema name and fks.table_name = 'your_table_name' -- replace with table name and fks.constraint_type = 'foreign key' and pks.constraint_type = 'primary key';
select conrelid::regclass as table_from, conname, pg_get_constraintdef(oid) as condef from pg_catalog.pg_constraint r;
select o.oid where a.attrelid = m.oid and a.attnum = o.conkey[1] and a.attisdropped = false) as source_column where oid=f.relnamespace) as target_schema where a.attrelid = f.oid and a.attnum = o.confkey[1] and a.attisdropped = false) as target_column from pg_constraint o where 1=1 and o.contype = 'f' and o.conrelid in (select oid from pg_class c where c.relkind = 'r');
select ss.conname constraint_name, a.attname column_name, ss.refnamespace fk_table_schema, ss.reflname fk_table_name, af.attname fk_column_name from  pg_attribute a, pg_attribute af, (select r.oid roid, c.conname, rf.relname reflname, information_schema._pg_expandarray(c.conkey) x, nrf.nspname refnamespace, rf.oid rfoid, information_schema._pg_expandarray(cf.confkey) xf from pg_namespace nr, pg_class r, pg_constraint c, pg_namespace nrf, pg_class rf, pg_constraint cf where nr.oid = r.relnamespace and r.oid = c.conrelid and rf.oid = cf.confrelid and c.conname = cf.conname and nrf.oid = rf.relnamespace and nr.nspname = $1 and r.relname = $2) ss where ss.roid = a.attrelid and a.attnum = (ss.x).x and not a.attisdropped and ss.rfoid = af.attrelid and af.attnum = (ss.xf).x and not af.attisdropped;
select tc.table_schema, tc.constraint_name, tc.table_name, kcu.column_name, ccu.table_schema as foreign_table_schema, ccu.table_name as foreign_table_name, ccu.column_name as foreign_column_name from information_schema.table_constraints as tc join information_schema.key_column_usage as kcu and tc.table_schema = kcu.table_schema join (select row_number() over (partition by table_schema, table_name, constraint_name order by row_num) ordinal_position, table_schema, table_name, column_name, constraint_name from   (select row_number() over (order by 1) row_num, table_schema, table_name, column_name, constraint_name from   information_schema.constraint_column_usage and ccu.table_schema = tc.table_schema and ccu.ordinal_position = kcu.ordinal_position where tc.constraint_type = 'foreign key' and tc.table_name = 'mytable';
select source_table::regclass, source_attr.attname as source_column, target_table::regclass, target_attr.attname as target_column from pg_attribute target_attr, pg_attribute source_attr, (select source_table, target_table, source_constraints[i] source_constraints, target_constraints[i] as target_constraints from (select conrelid as source_table, confrelid as target_table, conkey as source_constraints, confkey as target_constraints, generate_series(1, array_upper(conkey, 1)) as i from pg_constraint where contype = 'f' where target_attr.attnum = target_constraints and target_attr.attrelid = target_table and;
select source_column from foreign_keys where source_table = 'employee'::regclass and target_table = 'permission'::regclass;
select con.constraint_name, att2.attname as "child_column", cl.relname as "parent_table", att.attname as "parent_column", con.child_table, con.child_schema from (select unnest(con1.confkey) as "child", con1.conname as constraint_name, con1.confrelid, con1.conrelid, cl.relname as child_table, ns.nspname as child_schema from pg_class cl join pg_namespace ns on cl.relnamespace = ns.oid join pg_constraint con1 on con1.conrelid = cl.oid where  con1.contype = 'f' join pg_attribute att on join pg_class cl on join pg_attribute att2 on where cl.relname like '%parent_table%';
select c.conname as constraint_name, (select n.nspname from pg_namespace as n where n.oid=c.connamespace) as constraint_schema,  ( select string_agg(quote_ident(a.attname), ', ' order by t.seq) from ( select row_number() over (rows unbounded preceding) as seq, attnum from unnest(c.conkey) as t(attnum)  ( select string_agg(quote_ident(a.attname), ', ' order by t.seq) from ( select row_number() over (rows unbounded preceding) as seq, attnum from unnest(c.confkey) as t(attnum)  case confupdtype when 'r' then 'restrict' when 'c' then 'cascade' when 'n' then 'set null' when 'd' then 'set default' when 'a' then 'no action' else null end as on_update, case confdeltype when 'r' then 'restrict' when 'c' then 'cascade' when 'n' then 'set null' when 'd' then 'set default' when 'a' then 'no action' else null end as on_delete, case confmatchtype::text when 'f' then 'full' when 'p' then 'partial' when 'u' then 'simple' when 's' then 'simple' else null end as match_type,  -- in earlier postgres docs, simple was 'u'nspecified, but current versions use 's'imple.  text cast is required. from pg_catalog.pg_constraint as c select pg_class.oid, quote_ident(pg_namespace.nspname) || '.' || quote_ident(pg_class.relname) as name from pg_class inner join pg_namespace on pg_class.relnamespace=pg_namespace.oid select pg_class.oid, quote_ident(pg_namespace.nspname) || '.' || quote_ident(pg_class.relname) as name from pg_class inner join pg_namespace on pg_class.relnamespace=pg_namespace.oid where c.contype = 'f' order by 1;
database = dbhelper.getwritabledatabase();
database = dbhelper.getwritabledatabase();
if (cursor != null) { if (cursor.movetofirst()){;
strftime('%y-%m-%d %h:%m:%f', '2014-03-01 13:01:01.123'), strftime('%y-%m-%d %h:%m:%f', '2014-03-01 13:01:01.123'), strftime('%y-%m-%d %h:%m:%f', '2014-03-01 13:01:01.123') strftime('%y-%m-%d %h:%m:%f', '2014-03-01 13:01:01.126'), strftime('%y-%m-%d %h:%m:%f', '2014-03-01 13:01:01.126'), strftime('%y-%m-%d %h:%m:%f', '2014-03-01 13:01:01.126');
where col1 between;
where col1 between;
where col1 between;
where col1 between;
if (date != null) {;
if (cursor.isnull(index)) {;
"yyyy-mm-dd hh:mm:ss");
if (timetoformat != null) { if (date != null) { when + timezone.getdefault().getoffset(when), flags);
"//** your request**//", null, null, "timestamp", null);
select fieldlist;
set @loopvar = (select min(thekey) from thetable) set @loopvar = (select min(thekey) from thetable where @loopvar < thekey) end;
select * from blah where (blah.name = @name or @name is null) and (blah.purpose = @purpose or @purpose is null);
from employee t1, department t2, job t3, ...;
"multimedia", "office", "text", "executable", "archive") default null, img_major_mime enum("unknown", "application", "audio", "image", "text", "video", "message", "model", "multipart") not null default "unknown",;
select firstname + ' ' + lastname as "full name", case userrole else "user" end as "user's role", case signedin else "logged out" end as "user signed in?", convert(varchar(100), lastsignon, 101) as "last sign on", datediff('d', lastsignon, getdate()) as "days since last sign on", addrline1 + ' ' + addrline2 + ' ' + addrline3 + ' ' + 'xxx-xx-' + substring( convert(varchar(9), ssn), 6, 4) as "social security #" from users;
select some_column, ... from some_table;
select item1, item2, item3 from table2 where table2.item1 = a.col2 end foreach end foreach;
select col1, col2, col3, item1, item2, item3 from table1, table2 where table2.item1 = table1.col2 end foreach;
from tablea, tableb where;
from tablea inner join tableb on;
select case @problem then 'create a table for lookup and add to your from clause.' then 'fix the data in the database' then 'apply formating in the presentation layer.' then 'good, but in reporting you should probably be using cross tab, matrix or pivot templates' else 'you probably found another case for no case but now i have to edit my code instead of enriching the data...' end;
select firstname + ' ' + lastname as "full name", case userrole when 2 then "admin" when 1 then "moderator" else "user" end as "user's role", case signedin when 0 then "logged in" else "logged out" end as "user signed in?", convert(varchar(100), lastsignon, 101) as "last sign on", datediff('d', lastsignon, getdate()) as "days since last sign on", addrline1 + ' ' + addrline2 + ' ' + addrline3 + ' ' + city + ', ' + state + ' ' + zip as "address", 'xxx-xx-' + substring(convert(varchar(9), ssn), 6, 4) as "social security #" from users;
select personid, firstname, lastname, age from people where lastname like 's%' delete from #tmppeople where firstname = 'john' delete from #tmppeople where firstname = 'jon' delete from #tmppeople where age > 35 update people set firstname = 'fred' where personid in (select personid from #tmppeople);
select emp.empno, dept.deptno from emp join dept on dept.deptno = emp.deptno;
select ... from data where record.state in ( select stateid from state where name in 'approved for public', 'published to public', 'archived';
select stateid from state where name in 'approved for public', 'published to public', 'archived' ) select  ... from data, valid_states where data.state = valid_states.state;
select ... from data join states using (state) where states.state in  ('published to test', 'approved for public', 'published to public', 'archived' );
select distinct;
create view my_view as select * from table1 join table2 on (...) join table3 on (...);
select col1, col2 from my_view where col3 = 123;
create or replace force view price (part_number, price_list, list_version ...) as select sp.mkt_part_number, sp.price_list, sp.list_version, sp.min_price, sp.unit_price, sp.max_price, ...;
create table mytable( id integer primary key, email text unique;
where cast(getdate() as date) between cast(logintime as date) and cast(logouttime as date);
select * from tbl where start between '2010-04-01 00:00:00' and '2010-05-01 00:00:00';
where mydatetime between '20160601' and dateadd(millisecond, -3, '20160701');
where mydatetime between '20160601 00:00:00.000' and '20160630 23:59:59.997';
where mydatetime >= '20160601' and mydatetime < '20160701';
between '20090101' and '20090131';
between '20090101 00:00:00' and '20090131 00:00:00';
between '20090101 00:00:00' and '20090131 23:59:59' --wrong! (see update!);
between (firstday) and (lastday 23:59:59);
create table #test (c1 date) select * from #test where c1 between @startdate and @enddate drop table #test create table #test1 (c1 int) select * from #test1 where c1 between @r1 and @r2 drop table #test1;
select count(convert(char(10), dtcreatedate, 103) ),convert(char(10), dtcreatedate, 103) from dbo.tbltobecounted;
select  cast(datetime_field as date), count(*) as count from table group by cast(datetime_field as date);
select to_char(columnname, 'dd/mon/yyyy'), count(*) from table_name group by to_char(createddate, 'dd/mon/yyyy');
select "count of" from;
select product.id as product_id;
select product.id 'product_id';
set global sql_mode=ansi_quotes;
set quoted_identifier on;
select orgname, id, count(*) as dupes from organizations having count(*) > 1;
select n1.* from mytable n1 where n1.id <> n2.id;
create table #employee ( id          int, first_name  nvarchar(100), last_name   nvarchar(300) );
select distinct * from   #employee;
select row_number() from   #employee ) select * from   #deleteemployee where  rnum > 1 select distinct * from   #employee;
select distinct * from   #employee;
alter table #employee add uniq_id int identity(1, 1) select * from   #employee where  uniq_id < ( select max(uniq_id) from   #employee a2 where  #employee.id = a2.id and #employee.first_name = a2.first_name and #employee.last_name = a2.last_name ) alter table #employee drop column uniq_id select distinct * from   #employee;
drop table #employee;
( select *,rn=row_number() over (partition by orgname order by orgname desc) from organizations ) select * from cte where rn>1;
select o.orgname, oc.dupecount, o.id from organizations o select orgname, count(*) as dupecount from organizations having count(*) > 1;
select orgname, count(*), max(id) as dupes from organizations having (count(*) > 1);
select o.id, o.orgname, d.intcount from ( select orgname, count(*) as intcount from organizations having count(*) > 1;
select id, orgname from ( select orgname, id, row_number() over (partition by orgname order by id) as introw from organizations where introw != 1;
select o.id, o.orgname, d.intcount from ( select orgname, count(*) as intcount, min(id) as minid from organizations having count(*) > 1 where d.minid != o.id;
select orgname, count(*) as dupes, id from organizations where orgname in ( select orgname from organizations having (count(*) > 1) );
select * from [employees];
as ( select name,emailid,row_number() over(partition by name,emailid order by id) as duplicate from [employees] ) select * from mycte;
select name,emailid,count(name) as duplicate from  [employees] group by name,emailid;
select orgname,id, rn = row_number()over(partition by orgname order by id) from organizations ) delete from cte where rn > 1;
select o.id,o.orgname, oc.dupecount, oc.id,oc.orgname from organizations o select max(id) as id, orgname, count(*) as dupecount from organizations having count(*) > 1;
select * from (select orgname,id, row_number() over(partition by orgname order by id desc) rownum from organizations )tbl where rownum>1;
select column_name, count(column_name) from table_name having count (column_name) > 1;
select a.orgname,b.duplicate, a.id from organizations a select orgname, count(*) as duplicate from organizations having count(*) > 1;
as ( select orgname,row_number() over(partition by orgname order by orgname) as repeatcount from dbo.organizations ) select t.*,e.id from organizations   e where t.repeatcount>1;
select count(empcode),empcode from tbl_employees where status=1;
select student_name,student_id ,count(*) c from student group by student_id,student_name having c>1;
select x.studid, y.stdname, y.dupecount from student as x inner join from student as a inner join where (a.studid like '2018%') and (b.studstatus = 4) having (count(*) > 1)) as y on x.stdname = y.stdname inner join where (x.studid like '2018%') and (z.studstatus = 4);
select name,count(*) as count from tablename;
select name, count(*) as num from your_table name count(*) desc;
select name, count(1) as count from tablename;
where exists(select * from ...);
select boss.boss_id, count(subordinate.*) from boss;
select boss.boss_id, count(*) from boss;
select count(*);
select count(emp) from emp;
select count() from emp;
select boss.boss_id, count(subordinate) from boss;
create table fruit -- orm-friendly name ( fruit_id int not null, fruit varchar(50), /* same name as table name, and let's say, someone forgot to put not null */ color varchar(50) not null );
select count(fruit) from fruit;
select boss.boss_id, count(subordinate) from boss;
select boss.boss_id, count(subordinate.*) from boss;
select count(1) from tbl;
select boss.boss_id, count(subordinate.1) from boss;
select boss.boss_id, count(1) from boss;
select boss.boss_id, count(subordinate.boss_id) from boss;
select boss.boss_id, count(*) from boss;
select boss.boss_id, count(subordinate.boss_id) from boss;
select boss.boss_id, count(subordinate.*) from boss;
select boss.boss_name, count(subordinate) from boss;
select boss.boss_name, count(subordinate.1) from boss;
select boss.boss_name, count(1) from boss;
exists (select * ...;
exists (select 1 ...;
and eliminating null values. if one or more null values are;
where datalength(column) > 0;
where column <> '';
create table t ( c varchar(10) values      ('a'), (''), ('    '), (null);
select * from   t where  c <> '';
where nullif(your_column, '') is not null;
where your_column <> '';
where your_column <> '' and your_column is not null;
where (field is not null and field <> '');
where isnull(field,'') <> '';
where column <> '' where len(column) > 0 where nullif(ltrim(rtrim(column)), '') is not null;
select iif(null    > '', 'true', 'false'); -- false (null) select iif(''      > '', 'true', 'false'); -- false (empty string) select iif(' '     > '', 'true', 'false'); -- false (space) select iif('    '  > '', 'true', 'false'); -- false (tab) select iif(' select iif('xxx'   > '', 'true', 'false'); -- true select 'x   x' -- tab select 'x;
select * from [tablename] where column_name!='' and column_name is not null;
select user_name from user_master where upper(user_name) like '%me%';
create index nlsci1_gen_person );
select user_name from my_table where nlssort(user_name, 'nls_sort = latin_ci') = nlssort('%abc%', 'nls_sort = latin_ci');
where regexp_like(name, 'string$', 'i');
select * from my_table where upper(column_1) = upper('my_string');
select * from my_table where lower(column_1) = lower('my_string');
create index my_index on my_table ( lower(column_1) );
select * from my_table where lower(column_1) like lower('my_string') || '%';
select * from my_table where regexp_like(column_1, '^my_string$', 'i');
select * from my_table where regexp_like(column_1, 'my_string', 'i');
alter session set nls_sort=binary_ci;
alter session set nls_comp=linguistic;
create index my_linguistc_index on my_table;
create table tab1(i int primary key, name varchar2(100));
select /*csv*/ * from tab1 where name = 'john' ;
select /*csv*/ * from tab1 where name collate binary_ci = 'john' ;
select /*csv*/ * from tab1 where name like 'j%';
select /*csv*/ * from tab1 where name collate binary_ci like 'j%';
create table `test` ( `id` int(11) unsigned not null auto_increment, `event_id` int(11) default null, `event_title` varchar(50) default null, `date` date default null, `location` varchar(50) default null, `url` varchar(200) default null, primary key (`id`), unique key `event_id` (`event_id`,`event_title`,`date`,`location`,`url`);
`url`) values (null, '1', 'bbq', '2018-07-27', null, null);
`url`) values (null, '1', 'bbq', '2018-07-27', null, null);
`url`) values (null, '1', 'bbq', '2018-07-28', '', '');
`url`) values (null, '1', 'bbq', '2018-07-28', '', '');
select  * from    mytable where   mytext = ?;
select  * from    mytable where   mytext is null;
where somefield = '';
if databaserow.title:;
select round(630/60.0,2), cast(round(630/60.0,2) as numeric(36,2));
select format(minutes/60.0, 'n2');
set @floatexchrate=(select convert(decimal(10, 2), 0.2548712)) select  @floatexchrate;
select cast((630/60.0) as  decimal(16,2));
select ename, sal, round(((sal * .15 + comm) /12),2) from emp where job = 'salesman';
select substr(enddttm,1, 9), extract(day from (enddttm)), enddttm, begindttm,  (enddttm - begindttm),substr(begindttm, 1,15), substr((enddttm - begindttm), 12, 8), round((substr((enddttm - begindttm), 12, 2)* 3600 + substr((enddttm - begindttm), 15, 2)*60 +  substr((enddttm - begindttm), 18, 2)),2) as seconds, round((substr((enddttm - begindttm), 12, 2)* 60 + substr((enddttm - begindttm), 15, 2) +  substr((enddttm - begindttm), 18, 2)/60 ), 2)as minutes, round((substr((enddttm - begindttm), 12, 2) + substr((enddttm - begindttm), 15, 2)/60 +  substr((enddttm - begindttm), 18, 2)/3600 ),2)  as hours;
select str(ceiling(123.415432875), 6, 2);
select 1548/100 select 1548/100.0;
set @porcentaje = (convert(decimal,abs(8700)) * 100) / convert(decimal,abs(37020)) select @porcentaje;
select round(@number,2);
select convert(numeric(38, 2), minutes/60.0) from ....;
select convert(minutes/60.0, decimal(65, 2)) from ....;
select cast(round([amount 1]/60,2) as decimal(10,2)) as total;
select account_id, open_emp_id from account;
select salesman_name, sum(sales) from sales group by 1;
select * from mytable;
from users where firstname = 'john'), 1, 0) as doesjohnexist;
select case select 1 from [mytable] as [myrecord]) then cast(1 as bit) else cast(0 as bit) end;
select count(1) from mytable where ...;
select top 1 * from mytable where ...;
select 1 from mytable where... limit 1;
select count(1) from mytable where ...;
where [not] exists;
select 1 from mytable where <mycondition>;
if [not] exists ( select 1 from mytable where ... );
if not exists ( select 1 from users where firstname = 'john' and lastname = 'smith' ) end;
select 1 from table_name where unique_key = value;
select count(1) from table_name where unique_key = value;
select count(*);
create role esumit;
alter user esumit with superuser;
alter default privileges in schema my_schema alter default privileges in schema my_schema;
create function grant_all_in_schema (schname name, grant_to name) returns integer as $$ select c.relname from pg_class c join pg_namespace s on c.namespace = s.oid where s.nspname = schname end loop;
select string_agg(format('grant usage on schema %i to my_user', nspname), '; ') from   pg_namespace where  nspname <> 'information_schema' -- exclude information schema and ... and    nspname not like 'pg\_%'        -- ... system schemas end $$;
select count (distinct documentid), count (distinct documentsessionid) from documentoutputitems;
select sum(decode(count(*),1,1,1)) from documentoutputitems group by documentid, documentsessionid;
select sum(case when count(i)=1 then 1 else 1 end) from documentoutputitems i group by i.documentid, i.documentsessionid;
select documentid, documentsessionid, count(*) as c from documentoutputitems;
select count(distinct (documentid, documentsessionid)) from documentoutputitems;
select * from documentoutputitems where (documentid, documentsessionid) in (('a', '1'), ('b', '2'));
select distinct documentid as i,  documentsessionid as s , count(*) from documentoutputitems;
select code, id, title, name from mytable a;
select count(1) from (select distinct col1, col2 from mytable where code = a.code...);
select count(distinct(col1 || col2)) from mytable where code = a.code...;
select count(distinct documentid || documentsessionid) from  documentoutputitems;
select count(distinct cast(documentid as binary(4)) + cast(documentsessionid as binary(4))) from documentoutputitems;
select count(distinct concat(documentid, documentsessionid)) from documentoutputitems;
select count(distinct documentid, documentsessionid) from documentoutputitems;
select count(*) from documentoutputitems;
2  select distinct deptno, job from emp;
select col1 + '*' + col2 from t23;
select count(distinct documentid, documentsessionid) from documentoutputitems;
select count(distinct documentid) from documentoutputitems;
select count(distinct convert(varchar(15),documentid)+'|~|'+convert(varchar(15), documentsessionid)) from documentoutputitems;
as ( select (0) from documentoutputitems ) select count(*) as numberofdistinctrows from internalquery;
select count(distinct (checksum(documentid,documentsessionid)) + checksum(reverse(documentid),reverse(documentsessionid)) ) from documentoutputitems;
select count(distinct checksum(value1, value2, ..., valuen) + checksum(valuen, value(n-1), ..., value1));
select count(distinct cast(documentid as varchar)+'-'+cast(documentsessionid as varchar)) from documentoutputitems;
select count(distinct documentid) as count1, count(distinct documentsessionid) as count2 from documentoutputitems;
create procedure [dbo].[createcode] ( @tablename sysname = '', @befor varchar(max)='public class  @tablename @templet varchar(max)=' @after varchar(max)=' ) as begin set @befor =replace(@befor,'@tablename',@tablename) set @result=@befor select @result = @result from ( select column_id, replace(col.name, ' ', '_') columnname, typ.name as sqltype, typ.max_length, is_identity, pkk.ispk, case typ.name else 'unknown_' + typ.name end + case when col.is_nullable=1 and typ.name not in ('binary', 'varbinary', 'image', 'text', 'ntext', 'varchar', 'nvarchar', 'char', 'nchar') then '?' else '' end columntype, isnull(coldesc.coldesc,'') as columndesc from sys.columns col join sys.types typ on ( select c.name  as 'columnname', case when dd.pk is null then 'false' else 'true' end ispk from        sys.columns c join    sys.tables  t   on c.object_id = t.object_id from information_schema.key_column_usage as k and k.constraint_name = c.constraint_name and k.constraint_catalog = c.constraint_catalog and k.constraint_schema = c.constraint_schema where k.table_name = @tablename) as dd where       t.name = @tablename select top 1 cast(value as nvarchar(max)) as coldesc from sys.extended_properties where major_id = col.object_id and minor_id = columnproperty(major_id, col.name, 'columnid') where object_id = object_id(@tablename) set @result=@result+@after select @result end;
exec [createcode] @tablename='book',@templet =';
exec [createcode] @tablename='book'  ;
exec [createcode] @tablename='book',@templet =';
exec [createcode] @tablename='book' @templet  =' @after  =';
alter function [dbo].[propercase] (@cstringtoproper varchar(8000)) as begin select @cstringtoproper = stuff(lower(@cstringtoproper) , 1 , 1 , upper(left(@cstringtoproper , 1))) select @cstringtoproper = stuff(@cstringtoproper , @position , 2 , upper(substring(@cstringtoproper , @position , 2))) select @cstringtoproper = replace(@cstringtoproper, '_','') end;
create function [dbo].[getentityobject] (@namespace nvarchar(max), @tablename nvarchar(max), @entityname nvarchar(max))  returns nvarchar(max) as begin set @result = @result + 'using system;' + char(13) + char(13) if (@namespace is not null)  begin set @result = @result + 'namespace ' + @namespace  + char(13) + '{' + char(13)  end set @result = @result + '[table(name: ' + char(34) + @tablename + char(34) + ')]' + char(13) set @result = @result + 'public class ' + @entityname + char(13) + '{' + char(13) set @result = @result + '#region instance properties' + char(13) select @result = @result + char(13)     + '[column(name: ' + char(34) + originalcolumnname + char(34) + ', typename = ' + char(34) + datatype select dbo.propercase (c.column_name)   as columnname case c.is_nullable case c.is_nullable case c.is_nullable case c.is_nullable case c.is_nullable case c.is_nullable case c.is_nullable case c.is_nullable case c.is_nullable case c.is_nullable case c.is_nullable case c.is_nullable case c.is_nullable case c.is_nullable case c.is_nullable case c.is_nullable case c.is_nullable case c.is_nullable else 'object' end as columntype from    information_schema.columns c where   c.table_name = @tablename) t order by t.ordinal_position set @result = @result + char(13) + '#endregion instance properties' + char(13) set @result = @result  + '}' + char(13) if (@tablename is not null)  begin set @result = @result + char(13) + '}'  end;
select @result = @result + ' from ( select replace(col.name, ' ', '_') columnname, column_id columnid, case typ.name else 'unknown_' + typ.name end columntype, case when col.is_nullable = 1 and typ.name in ('bigint', 'bit', 'date', 'datetime', 'datetime2', 'datetimeoffset', 'decimal', 'float', 'int', 'money', 'numeric', 'real', 'smalldatetime', 'smallint', 'smallmoney', 'time', 'tinyint', 'uniqueidentifier') then '?' else '' end nullablesign from sys.columns col join sys.types typ on where object_id = object_id(@tablename) set @result = @result  + ' commandtype = commandtype.storedprocedure, commandtext = "storedprocedureselectall" select @liststatement = @liststatement + ' from ( select replace(col.name, ' ', '_') columnname, column_id columnid, case typ.name else 'unknown_' + typ.name end columntype, case when col.is_nullable = 1 and typ.name in ('bigint', 'bit', 'date', 'datetime', 'datetime2', 'datetimeoffset', 'decimal', 'float', 'int', 'money', 'numeric', 'real', 'smalldatetime', 'smallint', 'smallmoney', 'time', 'tinyint', 'uniqueidentifier') then '?' else '' end nullablesign from sys.columns col join sys.types typ on where object_id = object_id(@tablename) select @liststatement = @liststatement +' commandtype = commandtype.storedprocedure, commandtext = "storedprocedureselectindividual" if (reader.read()) select @getindividual = @getindividual + ' from ( select replace(col.name, ' ', '_') columnname, column_id columnid, case typ.name else 'unknown_' + typ.name end columntype, case when col.is_nullable = 1 and typ.name in ('bigint', 'bit', 'date', 'datetime', 'datetime2', 'datetimeoffset', 'decimal', 'float', 'int', 'money', 'numeric', 'real', 'smalldatetime', 'smallint', 'smallmoney', 'time', 'tinyint', 'uniqueidentifier') then '?' else '' end nullablesign from sys.columns col join sys.types typ on where object_id = object_id(@tablename) select @getindividual = @getindividual +' commandtype = commandtype.storedprocedure, commandtext = "storedprocedureinsert" select @insertstatement = @insertstatement + ' from ( select replace(col.name, ' ', '_') columnname, column_id columnid, case typ.name else 'unknown_' + typ.name end columntype, case when col.is_nullable = 1 and typ.name in ('bigint', 'bit', 'date', 'datetime', 'datetime2', 'datetimeoffset', 'decimal', 'float', 'int', 'money', 'numeric', 'real', 'smalldatetime', 'smallint', 'smallmoney', 'time', 'tinyint', 'uniqueidentifier') then '?' else '' end nullablesign from sys.columns col join sys.types typ on where object_id = object_id(@tablename) select @insertstatement = @insertstatement +' commandtype = commandtype.storedprocedure, commandtext = "storedprocedureupdate" select @updatestatement = @updatestatement + ' from ( select replace(col.name, ' ', '_') columnname, column_id columnid, case typ.name else 'unknown_' + typ.name end columntype, case when col.is_nullable = 1 and typ.name in ('bigint', 'bit', 'date', 'datetime', 'datetime2', 'datetimeoffset', 'decimal', 'float', 'int', 'money', 'numeric', 'real', 'smalldatetime', 'smallint', 'smallmoney', 'time', 'tinyint', 'uniqueidentifier') then '?' else '' end nullablesign from sys.columns col join sys.types typ on where object_id = object_id(@tablename) select @updatestatement = @updatestatement +';
select @result = @result + ' from ( select replace(col.name, ' ', '_') columnname, column_id columnid, case typ.name else 'unknown_' + typ.name end columntype, case when col.is_nullable = 1 and typ.name in ('bigint', 'bit', 'date', 'datetime', 'datetime2', 'datetimeoffset', 'decimal', 'float', 'int', 'money', 'numeric', 'real', 'smalldatetime', 'smallint', 'smallmoney', 'time', 'tinyint', 'uniqueidentifier') then '?' else '' end nullablesign from sys.columns col join sys.types typ on where object_id = object_id(@tablename) ( select c.name  as 'columnname', case when dd.pk is null then 'false' else 'true' end ispk from        sys.columns c join    sys.tables  t   on c.object_id = t.object_id from information_schema.key_column_usage as k and k.constraint_name = c.constraint_name and k.constraint_catalog = c.constraint_catalog and k.constraint_schema = c.constraint_schema where k.table_name = @tablename) as dd where       t.name = @tablename where pkk.columnname = t.columnname set @result = @result  + ';
set @cursor = cursor fast_forward for select distinct tablename = rc1.table_name from information_schema.tables rc1 where rc1.table_schema = @schema set @result = '[table(name = "' + @schema + '.' + @tablename + '")] select @result = @result + ' from ( select replace(col.name, ' ', '_') columnname, col.column_id columnid, case typ.name else 'unknown_' + typ.name end columntype, case when col.is_nullable = 1 and typ.name in ('bigint', 'bit', 'date', 'datetime', 'datetime2', 'datetimeoffset', 'decimal', 'float', 'int', 'money', 'numeric', 'real', 'smalldatetime', 'smallint', 'smallmoney', 'time', 'tinyint', 'uniqueidentifier') then '?' else '' end nullablesign, case when pk.constraint_name is not null and ic.column_id is not null then '(isprimarykey = true, isdbgenerated = true)' else '' end prikey from sys.columns col join sys.types typ on col.system_type_id = typ.system_type_id and col.user_type_id = typ.user_type_id select  k.table_name , k.column_name , k.constraint_name from    information_schema.table_constraints as c join information_schema.key_column_usage as k on c.table_name = k.table_name and c.constraint_catalog = k.constraint_catalog and c.constraint_schema = k.constraint_schema and c.constraint_name = k.constraint_name where c.constraint_type = 'primary key' where col.object_id = object_id(@schema + '.' + @tablename) set @result = @result  + ' end ;
set @before =replace(@before,'@tablename',@tablename) set @result=@before select @result = @result from ( select column_id, replace(col.name, ' ', '_') columnname, typ.name as sqltype, typ.max_length, is_identity, pkk.ispk, case typ.name else 'unknown_' + typ.name end + case when col.is_nullable=1 and typ.name not in ('binary', 'varbinary', 'image', 'text', 'ntext', 'varchar', 'nvarchar', 'char', 'nchar') then '?' else '' end columntype, isnull(coldesc.coldesc,'') as columndesc from sys.columns col join sys.types typ on ( select c.name  as 'columnname', case when dd.pk is null then 'false' else 'true' end ispk from        sys.columns c join    sys.tables  t   on c.object_id = t.object_id from information_schema.key_column_usage as k and k.constraint_name = c.constraint_name and k.constraint_catalog = c.constraint_catalog and k.constraint_schema = c.constraint_schema where k.table_name = @tablename) as dd where       t.name = @tablename select top 1 cast(value as nvarchar(max)) as coldesc from sys.extended_properties where major_id = col.object_id and minor_id = columnproperty(major_id, col.name, 'columnid') where object_id = object_id(@tablename) set @result=@result+@after select @result;
set @result = @result + 'using system;' + char(13) + char(13) if (@tableschema is not null) set @result = @result + 'namespace ' + @tableschema  + char(13) + '{' + char(13) end  set @result = @result + 'public class ' + @tablename + char(13) + '{' + char(13) set @result = @result + '#region instance properties' + char(13) select @result = @result + char(13) from (select case c.data_type else 'int64' end when 'binary' then 'byte[]' else 'bool' end when 'char' then 'string' else 'datetime' end when 'datetime' then case c.is_nullable else 'datetime' end when 'datetime2' then case c.is_nullable else 'datetime' end when 'datetimeoffset' then case c.is_nullable else 'datetimeoffset' end when 'decimal' then case c.is_nullable else 'decimal' end when 'float' then case c.is_nullable else 'single' end when 'image' then 'byte[]' else 'int' end when 'money' then case c.is_nullable else 'decimal' end when 'nchar' then 'string' else 'decimal' end when 'nvarchar' then 'string' else 'double' end when 'smalldatetime' then case c.is_nullable else 'datetime' end when 'smallint' then case c.is_nullable else 'int16' end when 'smallmoney' then case c.is_nullable else 'decimal' end when 'text' then 'string' else 'timespan' end when 'timestamp' then 'byte[]' else 'byte' end when 'uniqueidentifier' then case c.is_nullable else 'guid' end when 'varbinary' then 'byte[]' else 'object' end as columntype, c.ordinal_position from information_schema.columns c where c.table_name = @tablename and isnull(@tableschema, c.table_schema) = c.table_schema) t set @result = @result + char(13) + '#endregion instance properties' + char(13) set @result = @result  + '}' + char(13) if (@tableschema is not null) set @result = @result + char(13) + '}' end ;
select distinct ' public property ' + columnname + ' as ' + columntype as prop from ( select replace(col.name, ' ', '_') columnname,  column_id, case typ.name end columntype from sys.columns col join sys.types typ on col.system_type_id = typ.system_type_id where object_id = object_id(@tablename) end close props;
select @result = @result + ' from ( select replace(col.name, ' ', '_') columnname, column_id, case typ.name else 'unknown_' + typ.name end + case when col.is_nullable=1 and 'binary', 'varbinary', 'image', 'text', 'ntext', 'varchar', 'nvarchar', 'char', 'nchar') then '?' else '' end as [columntype] from sys.columns col join sys.types typ on where object_id = object_id(@tablename) set @result = @result  + ';
set @schema := 'schema_name';
set @table := 'table_name';
set group_concat_max_len = 2048;
select concat('public class ', @table, '\n{\n', group_concat(a.property_ separator '\n'), '\n}') class_ from (select '\tpublic ', case when data_type = 'bigint' then 'long' else '_unknown_' column_name, ' {get; set;}') as property_ from information_schema.columns where table_name = @table and table_schema = @schema) a;
set @result = 'using system;' + @crlf + @crlf + select @result = @result replace(@privateprop replace(@publicprop from ( select  c.column_name   as columnname case c.is_nullable case c.is_nullable case c.is_nullable case c.is_nullable case c.is_nullable case c.is_nullable case c.is_nullable case c.is_nullable case c.is_nullable case c.is_nullable case c.is_nullable case c.is_nullable case c.is_nullable case c.is_nullable case c.is_nullable case c.is_nullable case c.is_nullable case c.is_nullable else 'object' end as columntype from    information_schema.columns c where   c.table_name = @tablename and isnull(@schema, c.table_schema) = c.table_schema select @result = @result + @crlf +;
if (string.isnullorempty(propertyname)) "propertyname cannot be null or empty.");
if (!iscached) propertyname, new propertychangedeventargs(propertyname));
/// regardless of whether the event was raised or not. if (handler != null) if (propinfo == null) // so alert the developer of the problem. error_msg, propertyname, type.fullname);
select @result = @result from ( select replace(col.name, ' ', '_') columnname, column_id, case typ.name else 'unknown_' + typ.name end + case when col.is_nullable=1 and typ.name not in ('binary', 'varbinary', 'image', 'text', 'ntext', 'varchar', 'nvarchar', 'char', 'nchar') then '?' else '' end columntype, coldesc.coldesc as columndesc from sys.columns col join sys.types typ on select top 1 cast(value as nvarchar(max)) as coldesc from sys.extended_properties where major_id = col.object_id and minor_id = columnproperty(major_id, col.name, 'columnid') where object_id = object_id(@tablename) set @result = @result  + ';
set @result = @result + select @result = @result + ' from ( select replace(col.name, ' ', '_') columnname, column_id, case typ.name else 'unknown_' + typ.name end columntype from sys.columns col join sys.types typ on where object_id = object_id(@tablename) set @result = @result + ' select @result = @result + ' ( select replace(col.name, ' ', '_') columnname, column_id, case typ.name else 'unknown_' + typ.name end columntype from sys.columns col join sys.types typ on where object_id = object_id(@tablename) set @result = @result  + ';
select @result = @result + ' from ( select replace(col.name, ' ', '_') columnname, column_id columnid, case typ.name else 'unknown_' + typ.name end columntype, case when col.is_nullable = 1 and typ.name in ('bigint', 'bit', 'date', 'datetime', 'datetime2', 'datetimeoffset', 'decimal', 'float', 'int', 'money', 'numeric', 'real', 'smalldatetime', 'smallint', 'smallmoney', 'time', 'tinyint', 'uniqueidentifier') then '?' else '' end nullablesign from sys.columns col join sys.types typ on where object_id = object_id(@tablename) set @result = @result  + ';
alter table ... set logged;
if err != nil {;
select * from table;
select pagename, count(distinct ipaddress) as visit_count from log_visitors group by pagename order by visit_count desc;
select concat (col1, '_', col2) as group1 ... group by group1;
select purchases.address_id, purchases.* from "purchases" where "purchases"."product_id" = 1 group by address_id, purchases.purchased_at order purchases.purchased_at desc;
from app import db from app.models import purchases from sqlalchemy.orm import aliased from sqlalchemy import desc distinct = db.session.query(alias);
select address_id, purchased_at, product_id, row_number() over (partition by address_id order by purchased_at desc) as row_number from purchases where product_id = 1) select address_id, purchased_at, product_id from purchase_data where row_number = 1;
select * from from "purchases" where "purchases"."product_id" = 1 order by address_id desc );
select t1.* from purchases t1 join ( select address_id, max(purchased_at) max_purchased_at from purchases where product_id = 1;
select * from ( select distinct on (address_id) * from purchases where product_id = 1;
select * from  ( select distinct on (address_id) * from   purchases where  product_id = 1;
select * from  ( select distinct on (address_id) * from   purchases where  product_id = 1;
desc nulls last;
select distinct on (address_id) from "purchases" where "purchases"."product_id" = 1 partition by address_id order by purchases.purchased_at desc;
select meta_val from `table` where meta_key = 'name' and uid = 1 order by meta_id desc;
update q set q.title = 'test' from hold_table q where q.id = 101;
( select id, title from hold_table where id = 101 ) update updatecte set title = 'test';
select * from table1 left join table2 ...;
select * from table2 right join table1 ...;
select * from table1 left join table2 on table1.id = table2.id;
select * from table1 right join table2 on table1.id = table2.id;
if table1.rows.count > table2.rows.count then else ' right join end if;
select fields from tablea --left;
select fields from tableb;
select * from table1 t1 left join table2 t2 on t1.id=t2.id;
select * from table2;
select column_name from table1 inner join table2 on table1.column_name = table2.column_name;
select tablea.firstname,tablea.lastname,tableb.place from tablea inner join tableb on tablea.id = tableb.id2;
select column_name(s) from table1 left join table2 on table1.column_name = table2.column_name;
select tablea.firstname,tablea.lastname,tableb.place from tablea left join tableb on tablea.id = tableb.id2;
select column_name(s) from table1 right join table2 on table1.column_name = table2.column_name;
select tablea.firstname,tablea.lastname,tableb.place from tablea right join tableb on tablea.id = tableb.id2;
select column_name(s) from table1 full outer join table2 on table1.column_name = table2.column_name;
select tablea.firstname,tablea.lastname,tableb.place from tablea full join tableb on tablea.id = tableb.id2;
select <select_list> from table_a a where a.key is null and b.key is null;
select convert(datetime, switchoffset(datetimefield, datepart(tzoffset, datetimefield at time zone 'eastern standard time')));
create function tolocaltime(@dtutc datetime, @timezoneid nvarchar(256)) as begin set @dtlocal = @dtutc at time zone @timezoneid end go;
select cast('2017-02-08 09:00:00.000' as datetime) at time zone 'eastern standard time' select cast('2017-08-08 09:00:00.000' as datetime) at time zone 'eastern standard time';
set @mydate2=getdate() select @mydate2 as mydate, dateadd(minute, datediff(minute,getdate(),@mydate2),getutcdate());
set ansi_nulls on set quoted_identifier on create function [dbo].[convertutctoeastern] ( @dtstartdate datetime ) as begin set @working = @dtstartdate set @working = case when month(@working) between 4 and 10 then dateadd(hh,-4,@working) else dateadd(hh,-5,@working) end set @returned = @working end ;
create function [dbo].[uf_adjust_offset] ( @dt_utc datetime2(7) ) as begin @year int, @current_offset int, @offset_since int, @offset int, @yearmonth varchar(8), @changeoffsetdate datetime2(7) select @current_offset = datediff(hh, getutcdate(), getdate()) select @month = datepart(month, @dt_utc) if @month < 3 or @month > 10 begin set @offset_since = 1 goto jmp end if @month > 3 and @month < 10 begin set @offset_since = 2 goto jmp end select @year = datepart(yyyy, @dt_utc) if @month = 3 set @yearmonth = cast(@year as varchar) + '-03-' (@yearmonth + '27 03:00:00.000000'),(@yearmonth + '26 03:00:00.000000'),(@yearmonth + '25 03:00:00.000000') select @changeoffsetdate = giorno from @lastweek where  datepart(weekday, giorno) = 1 if @dt_utc < @changeoffsetdate set @offset_since = 1 end else begin set @offset_since = 2 end end  if @month = 10 set @yearmonth = cast(@year as varchar) + '-10-' (@yearmonth + '27 03:00:00.000000'),(@yearmonth + '26 03:00:00.000000'),(@yearmonth + '25 03:00:00.000000') select @changeoffsetdate = giorno from @lastweek where  datepart(weekday, giorno) = 1 if @dt_utc > @changeoffsetdate set @offset_since = 1 end else begin set @offset_since = 2 end end  if @current_offset < @offset_since begin set @offset = 1 end else if @current_offset > @offset_since set @offset = -1 else set @offset = 0 end;
create function [dbo].[uf_convert] ( @dt_utc datetime2(7) ) as begin select @offset = dbo.uf_adjust_offset(@dt_utc) if @dt_utc >= '9999-12-31 22:59:59.9999999' set @dt_utc = '9999-12-31 23:59:59.9999999' else set @dt_utc = (select dateadd(mi, datediff(mi, getutcdate(), getdate()), @dt_utc) ) if @offset <> 0 set @dt_utc = dateadd(hh, @offset, @dt_utc) end;
set @dt = getutcdate() -- gmt equivalent;
select [inputtime] = @dt;
create function [dbo].[fn_utc_to_est] ( @utc datetime, @standardoffset int ) as begin @ssm datetime, -- second sunday in march set @ssm = dateadd(dd,7 + (6-(datediff(dd,0,dateadd(mm,(year(getdate())-1900) * 12 + 2,0))%7)),dateadd(mm,(year(getdate())-1900) * 12 + 2,0))+'02:00:00' set @fsn = dateadd(dd, (6-(datediff(dd,0,dateadd(mm,(year(getdate())-1900) * 12 + 10,0))%7)),dateadd(mm,(year(getdate())-1900) * 12 + 10,0)) +'02:00:00' if @utc between @ssm and @fsn set @standardoffset = @standardoffset + 1 set @dst = dateadd(hour,@standardoffset,@utc) end;
create function [dbo].[fn_utc_to_dst] ( @utc datetime, @standardoffset int ) as begin @ssm datetime, -- second sunday in march set @ssm = datename(year,@utc) + '0314' set @ssm = dateadd(hour,2 - @standardoffset,dateadd(day,datepart(dw,@ssm)*-1+1,@ssm)) set @fsn = datename(year,@utc) + '1107' set @fsn = dateadd(second,-1,dateadd(hour,2 - (@standardoffset + 1),dateadd(day,datepart(dw,@fsn)*-1+1,@fsn))) if @utc between @ssm and @fsn set @standardoffset = @standardoffset + 1 set @dst = dateadd(hour,@standardoffset,@utc) end;
if (utc.isnull);
create function fnconvertutctimetoesttime( @utctime as datetime ) as begin end go select dbo.fnconvertutctimetoesttime ('2020-3-8 5:00:00.000') select dbo.fnconvertutctimetoesttime ('2020-11-1 4:00:00.000');
select [myutcdate] + getdate() - getutcdate() from [dbo].[mytable];
select * from pg_timezone_names;
( select 1 as i union all  select i + 1 from cte_utc where (i + 1) < 32767 ( select *, dense_rank()over(partition by [year], [month], [weekday] order by utc) weekdayindex from cte_utc select 0 as [hour] union all select [hour] + 1 from cte_hours where [hour] < 23 ) select d.* from cte_utc_dates d, cte_hours h where ([month] = 3 and [weekday] = 1 and weekdayindex = 2 )-- dst start or ([month] = 11 and [weekday] = 1 and weekdayindex = 1 )-- dst end utc;
select yourdatetimecolumn at time zone 'eastern standard time' from yourtable;
select convert(datetime2, switchoffset(convert(datetimeoffset, getdate()), datename(tzoffset, getdate() at time zone 'eastern standard time'))) from yourtable;
case --when it's between march and november, it is summer time which is -6 from utc then dateadd ( hour , -6 , utc.field ) and datepart ( day , utc.field ) >= 14 then --however, if utc is before 9am on that sunday, then it's before 2am mountain which means it's still winter daylight time. case when datepart ( weekday , utc.field ) = 1 and utc.field < '9:00' then dateadd ( hour , -7 , utc.field ) else dateadd ( hour , -6 , utc.field ) end when month ( utc.field ) = 3 and ( datepart ( weekday , utc.field ) + 7 ) <= datepart ( day , utc.field ) then --according to the date, it's moved onto summer daylight, but we need to account for the hours leading up to 2am if it's sunday case when datepart ( weekday , utc.field ) = 1 and utc.field < '9:00' then dateadd ( hour , -7 , utc.field ) else dateadd ( hour , -6 , utc.field ) end --when it's november and the weekday is greater than the calendar date, it's still summer so -6 from the time and datepart ( weekday , utc.field ) > datepart ( day , utc.field ) then dateadd ( hour , -6 , utc.field ) and datepart ( weekday , utc.field ) <= datepart ( day , utc.field ) case when datepart ( weekday , utc.field ) = 1 and utc.field < '8:00' then dateadd ( hour , -6 , utc.field ) else dateadd ( hour , -7 , utc.field ) end --if the date doesn't fall into any of the above logic, it's winter daylight, -7 else dateadd ( hour , -7 , utc.field ) end;
create function dbo.getisttime ( @utcdate datetime ) as begin end go;
select to_char(cast((from_tz(cast(to_date('2018-10-27 21:00', 'yyyy-mm-dd hh24:mi') as timestamp), 'utc') at  time zone 'eet') as date), 'yyyy-mm-dd hh24:mi') utc_to_eet from dual;
select to_char(cast((from_tz(cast(column_name as timestamp), 'utc') at  time zone 'eet') as date), 'yyyy-mm-dd hh24:mi') utc_to_eet from table_name;
set @date = getdate();
set @zulutime = dateadd(second, datediff(second, getdate(), getutcdate()), @date);
set @datestring =  format(@zulutime, 'yyyy-mm-ddthh:mm:ssz', 'en-us' ) select @datestring;
create function [dbo].[global_convert_utctimeto_localtime] ( @localtimezone        varchar(50), @utcdatetime          datetime ) as begin select @converteddatetime =@utcdatetimeattimezone 'utc' at time zone@localtimezone end go;
select yourutccolumn at time zone 'utc' at time zone 'eastern standard time' as from   yourtable;
select * from sys.time_zone_info;
create function [dbo].[fn_utc_to_dst] ( @utc datetime, @standardoffset int ) as begin @ssm datetime, -- second sunday in march set @ssm = datename(year,@utc) + '0314' set @ssm = dateadd(hour,2,dateadd(day,datepart(dw,@ssm)*-1+1,@ssm)) set @fsn = datename(year,@utc) + '1107' set @fsn = dateadd(second,-1,dateadd(hour,2,dateadd(day,datepart(dw,@fsn)*-1+1,@fsn))) if @utc between @ssm and @fsn set @standardoffset = @standardoffset + 1 set @dst = dateadd(hour,@standardoffset,@utc) end ;
alter function udftolocaltime ( @utcdatetime    as datetime ) as begin select @year       = year(@utcdatetime) if @mar1day = 1 set @mardiff = 7 else set @mardiff = 15 - @mar1day if @nov1day = 1 set @novdiff = 0 else set @novdiff = 8 - @nov1day select @dststart   = dateadd(day, @mardiff, @mar1) if @utcdatetime >= @dststart and @utcdatetime < @dstend set @utcoffset = @utcoffset + 1 set @pstdatetime = dateadd(hour, @utcoffset, @utcdatetime) end go;
select mt.starttime as startutc, dateadd(hh, tzstart.offset, mt.starttime) as startlocal, tzstart.ishr2 from mytable mt;
create function [dbo].[utctolocal] ( @p_utcdatetime datetime ) as begin end;
select dateadd(ms, datediff(ms, getutcdate(), getdate()), mytable.utccolumn) as columninlocaltime from mytable;
select convert(datetime, switchoffset(convert(datetimeoffset, mytable.utccolumn), datename(tzoffset, sysdatetimeoffset()))) as columninlocaltime from mytable;
select dateadd(mi, datediff(mi, getutcdate(), getdate()), mytable.utccolumn) as columninlocaltime from mytable;
select top (@foo) a from table order by a select top (select count(*) from somewhere else) a from table order by a select top (@foo + 5 * 4 / 2) a from table order by a;
select top (@top) * from tablename;
select top 10 select top (10) select top (@rows) set rowcount @max select * from ... set rowcount 0;
alter default privileges in schema public;
create function blob2txt (blobfield varchar(255)) returns longtext end $$;
alter table mytable add column field1_new text not null, add column field2_new text not null;
update mytable set field2_new = convert(field2 using utf8);
alter table mytable drop column field1, drop column field2;
alter table mytable change column field2_new field2 text;
alter table `table_name` change column `column_name` `column_name` longtext null default null ;
select blobfield, convert(blobfield using utf16), convert(convert(blobfield using utf16), binary), cast(blobfield  as char(10000) character set utf16), cast(cast(blobfield  as char(10000) character set utf16) as binary);
select blobfield, to_base64(blobfield), from_base64(to_base64(blobfield));
select convert(column using utf8) from;
select column from;
select rs.field1,rs.field2 from ( select field1,field2, row_number() from table;
select city, country, population from (select city, country, population, @country_rank := if(@current_country = country, @country_rank + 1, 1) as country_rank, @current_country := country from cities where country_rank <= 10;
select * from t select top 10 u.* from u where u.t_id = t.t_id;
id      int , section int, moment  date (   2   ,   1   , '2014-01-02'), (   3   ,   1   , '2014-01-03'), (   4   ,   1   , '2014-01-04'), (   5   ,   1   , '2014-01-05'),  (   7   ,   2   , '2014-02-07'), (   8   ,   2   , '2014-02-08'), (   9   ,   2   , '2014-02-09'), (   10  ,   2   , '2014-02-10'),  (   12  ,   3   , '2014-03-12'), (   13  ,   3   , '2014-03-13'), (   14  ,   3   , '2014-03-14'), (   15  ,   3   , '2014-03-15');
select top 1 with ties from @t case when row_number() over(partition by section order by moment) <= 2 then 0 else 1 select top 1 with ties from @t case when row_number() over(partition by section order by moment) <= 3 then 0 else 1 select top 1 with ties from @t case when row_number() over(partition by section order by moment desc) <= 3 then 0 else 1;
select x1.section from example x1 where ( select count(*) from example x2 where x2.section = x1.section and x2.subsection <= x1.subsection;
create table example ( id int, section varchar(25), subsection varchar(25) );
select [articleid], row_number() over ( partition by [articlecategoryid] from [dbo].[articles] ) select [articles].* from [topcategoryarticles] left join where [topcategoryarticles].[order] = 1;
select r.* from ( select r.*, row_number() over(partition by r.[sectionid] from [records] r where r.rn <= 10;
select *, row_number() partition by [group_by_field] from [table_name] ) select * from topten where rowno <= 10;
select * from things t where t.thingid in ( select top 10 thingid from things tt where tt.section = t.section and tt.thingdate = @date ) and t.thingdate = @date;
select top 10 * from table where section=1 union select top 10 * from table where section=2 union select top 10 * from table where section=3;
select rs.field1,rs.field2 from ( select field1,field2, rank() from table;
select a.* from articles as a having count(*) <= 10;
select country, city, sum(total) totalcityorders from international_orders with (nolock) where companyid = 884501253109 having country = 'mx';
select empname, sum(bonus) from employees having sum(bonus) > 5000;
select  l.lectid, fname, lname from lecturers l join lecturers_specialization s on l.lectid=s.lectid having count(s.expertise)>=all;
create table [dbo].[stackoverflow_329931_a]( [id] [int] identity(1,1) not null, [col2] [nchar](10) null, [col3] [nchar](10) null, [col4] [nchar](10) null, constraint [pk_stackoverflow_329931_a] primary key clustered ( [id] asc create table [dbo].[stackoverflow_329931_b]( [id] [int] identity(1,1) not null, [col2] [nchar](10) null, [col3] [nchar](10) null, [col4] [nchar](10) null, constraint [pk_stackoverflow_329931_b] primary key clustered ( [id] asc set @table1_name = 'stackoverflow_329931_a' set @table1_prefix = 'a_' set @table2_name = 'stackoverflow_329931_b' set @table2_prefix = 'b_' set @join_condition = 'a.[id] = b.[id]' set @crlf = char(13) + char(10) select @a_columnlist = coalesce(@a_columnlist + @crlf + ',', '') + 'a.[' + column_name + '] as [' + @table1_prefix + column_name + ']' from information_schema.columns where table_name = @table1_name select @b_columnlist = coalesce(@b_columnlist + @crlf + ',', '') + 'b.[' + column_name + '] as [' + @table2_prefix + column_name + ']' from information_schema.columns where table_name = @table2_name set @sql = 'select ' + @a_columnlist + ' from [' + @table1_name + '] as a;
select a.*, b.*, c.* from table_a a join table_b b using (x) join table_c c using (y);
select " . prefixed_table_fields_wildcard($wpdb->posts, 'campaigns') . ", " . prefixed_table_fields_wildcard($wpdb->posts, 'venues') . " from $wpdb->posts as campaigns where 1 and campaigns.post_status = 'publish' and campaigns.post_type = 'campaign' limit 1;
select `campaigns`.`id` as `campaigns.id`, `campaigns`.`post_author` as `campaigns.post_author`, `campaigns`.`post_date` as `campaigns.post_date`, `campaigns`.`post_date_gmt` as `campaigns.post_date_gmt`, `campaigns`.`post_content` as `campaigns.post_content`, `campaigns`.`post_title` as `campaigns.post_title`, `campaigns`.`post_excerpt` as `campaigns.post_excerpt`, `campaigns`.`post_status` as `campaigns.post_status`, `campaigns`.`comment_status` as `campaigns.comment_status`, `campaigns`.`ping_status` as `campaigns.ping_status`, `campaigns`.`post_password` as `campaigns.post_password`, `campaigns`.`post_name` as `campaigns.post_name`, `campaigns`.`to_ping` as `campaigns.to_ping`, `campaigns`.`pinged` as `campaigns.pinged`, `campaigns`.`post_modified` as `campaigns.post_modified`, `campaigns`.`post_modified_gmt` as `campaigns.post_modified_gmt`, `campaigns`.`post_content_filtered` as `campaigns.post_content_filtered`, `campaigns`.`post_parent` as `campaigns.post_parent`, `campaigns`.`guid` as `campaigns.guid`, `campaigns`.`menu_order` as `campaigns.menu_order`, `campaigns`.`post_type` as `campaigns.post_type`, `campaigns`.`post_mime_type` as `campaigns.post_mime_type`, `campaigns`.`comment_count` as `campaigns.comment_count`, `venues`.`id` as `venues.id`, `venues`.`post_author` as `venues.post_author`, `venues`.`post_date` as `venues.post_date`, `venues`.`post_date_gmt` as `venues.post_date_gmt`, `venues`.`post_content` as `venues.post_content`, `venues`.`post_title` as `venues.post_title`, `venues`.`post_excerpt` as `venues.post_excerpt`, `venues`.`post_status` as `venues.post_status`, `venues`.`comment_status` as `venues.comment_status`, `venues`.`ping_status` as `venues.ping_status`, `venues`.`post_password` as `venues.post_password`, `venues`.`post_name` as `venues.post_name`, `venues`.`to_ping` as `venues.to_ping`, `venues`.`pinged` as `venues.pinged`, `venues`.`post_modified` as `venues.post_modified`, `venues`.`post_modified_gmt` as `venues.post_modified_gmt`, `venues`.`post_content_filtered` as `venues.post_content_filtered`, `venues`.`post_parent` as `venues.post_parent`, `venues`.`guid` as `venues.guid`, `venues`.`menu_order` as `venues.menu_order`, `venues`.`post_type` as `venues.post_type`, `venues`.`post_mime_type` as `venues.post_mime_type`, `venues`.`comment_count` as `venues.comment_count` from wp_posts as campaigns where 1 and campaigns.post_status = 'publish' and campaigns.post_type = 'campaign' limit 1 ( [0] => stdclass object ( [campaigns.id] => 33 ) );
select '' as table1_dummy, table1.*, '' as table2_dummy, table2.*, '' as table3_dummy, table3.* from table1 join table2 on table2.table1id = table1.id join table3 on table3.table1id = table1.id;
if (!$result) return false; // mysql_error() could be used outside;
create or replace function mkaview(schema varchar, tab varchar, prefix varchar) where table_schema = schema and table_name = tab end loop;
end $$ language plpgsql;
select * from mkaview('public', 'person', 'p_');
select * from avp_person;
select @asstatements = isnull(@asstatements + ', ','') + quotename(table_name) + '.' + quotename(column_name) + ' as ' + '[' + table_name + '.' + column_name + ']' from information_schema.columns where table_name = 'table_a' or table_name = 'table_b';
select a.*, b.* from table_a a join table_b b using (some_id);
if (!$result) {;
select s.* from statements s;
if (key.startswith(prefix_indicator)) { if (row[key] !== '') { delete row[key] if (row[key] !== '') { delete row[key] delete row[key];
prefix_indicator, stop_prefix_indicator, } = require('./basedao') {name: prefix_indicator + 'my_prefix_'}, {name: 'foo'}, {name: stop_prefix_indicator}, {name: 'baz'}, ] [prefix_indicator + 'my_prefix_']: '', foo: 'bar', [stop_prefix_indicator]: '', baz: 'spaz' my_prefix_foo: 'bar', baz: 'spaz', };
select row_to_json(tab1.*),tab1_json, row_to_json(tab2.*) tab2_json from tab1 join tab2 on tab2.t1id=tab1.id;
select email, login_id from table having count(email) > 1;
select * from table where email in ( select email from table group by email having count(*) > 1 and email != '' );
select email, count(*) as c from table;
select * from   member where  email in (select email from   member where  login_id = abcd.user@hotmail.com);
select * from member where email = (select email from member where login_id = john123@hotmail.com);
select rollid, count(*) as c from `tblstudents` having c > 1;
select email from mytable group by email having count(*) >1;
select email from table having count(*) > 1;
select email, count(*) as c from table having c > 1;
select * from table where email in ( select email from table );
select * from information_schema.tables;
where table_schema = 'information_schema';
select * from pg_tables where schemaname = 'information_schema';
select table_name from information_schema.tables where table_schema='public';
select table_name from information_schema.tables where table_schema = 'xxx' and table_type = 'base table';
select * from information_schema.tables;
select * from information_schema.tables;
select * from information_schema.tables where table_schema not in ('information_schema', 'pg_catalog');
select * from information_schema.tables where table_schema not in ('information_schema', 'pg_catalog') and;
select column_list from <alias_name>[,table_name];
<alias_name_b> as(sql_subquery_statement_from_alias_name_a or sql_subquery_statement ) select <column_list> from <alias_name_a>, <alias_name_b> [,table_names];
select * from employee where id < 20 union all select * from employee where sex = 'm';
select * from yourtable ou where (select count(*) from yourtable inr where inr.sid = ou.sid) > 1;
select column1, column2, count(*) from yourtable having count(*) > 1;
select (yourtable.*)::text, count(*) from yourtable having count(*) > 1;
select tn1.id, array_agg(tn2.id) as duplicate_entries, from table_name tn1 join table_name tn2 on and tn1.sid = tn2.sid and tn1.user_id = tn2.user_id and tn1.cid = tn2.cid and tn1.id <> tn2.id;
select tn1.id, array_agg(tn2.id) as duplicate_entries, from table_name tn1 join table_name tn2 on and tn1.sid = tn2.sid and tn1.user_id = tn2.user_id and tn1.cid = tn2.cid and tn1.id <> tn2.id select ds.id from dupe_set ds where not exists;
select * from ( select id, row_number() over(partition by column1, column2 order by id asc) as row from tbl where dups.row > 1;
select year, count(id) from your_table having count(id) > 1;
delete from your_table a using your_table_again b where a.year=b.year and a.id<b.id;
( .... lalala as ( .... );
( select inc.[rectime],inc.[sql] as [str] from ( select a.[rectime] as [rectime],x.[sql] as [sql] from [eventview] as a where patindex('%' + a.[col] + '%', x.[sql]) > 0 lalala as ( select inc.[rectime],inc.[sql] as [str] from ( select a.[rectime] as [rectime],x.[sql] as [sql] from [eventview] as a where patindex('%' + a.[col] + '%', x.[sql]) > 0 );
delete from aaa as a ccc as c where a.id = b.id and a.id = c.id and a.uid = 12345 and c.gid = 's434sd4';
delete from m_productprice where m_product_id in ( select b.m_product_id from   m_productprice  b where  c.upc = '7094' and    b.m_pricelist_version_id = '1000020' );
delete from m_productprice b where b.m_product_id = c.m_product_id and b.m_pricelist_version_id = '1000020';
delete from m_productprice b where b.m_product_id = c.m_product_id and;
delete from m_productprice where m_pricelist_version_id='1000020' and from m_product where upc = '7094');
delete from m_productprice where  m_pricelist_version_id='1000020' and m_product_id in (select m_product_id from   m_product where  upc = '7094');
alter table myoldtable add column newcolumn text;
alter table myoldtable add constraint myoldtable_oldcolumn_newcolumn_key unique (oldcolumn, newcolumn);
alter table myoldtable drop constraint myoldtable_oldcolumn_newcolumn_key;
alter table myoldtable drop column newcolumn;
create table example ( a integer, b integer, c integer, unique (a, c));
create table sometable ( id serial primary key, col1 int not null, col2 int not null, unique (col1, col2) );
create table sometable ( col1 int not null, col2 int not null, primary key (col1, col2) );
alter table sometable add unique (col1, col2);
from ' + @tablename + 'with (nolock) ' +;
create proc searchalltables ( @searchstr nvarchar(100) ) as begin create table #results (columnname nvarchar(370), columnvalue nvarchar(3630)) set nocount on set  @tablename = '' set @searchstr2 = quotename('%' + @searchstr + '%','''') set @columnname = '' set @tablename = ( select min(quotename(table_schema) + '.' + quotename(table_name)) from     information_schema.tables where         table_type = 'base table' and    quotename(table_schema) + '.' + quotename(table_name) > @tablename and    objectproperty( object_id( quotename(table_schema) + '.' + quotename(table_name) ) set @columnname = ( select min(quotename(column_name)) from     information_schema.columns where         table_schema    = parsename(@tablename, 2) and    table_name    = parsename(@tablename, 1) and    data_type in ('char', 'varchar', 'nchar', 'nvarchar', 'int', 'decimal') and    quotename(column_name) > @columnname ) if @columnname is not null exec ( 'select ''' + @tablename + '.' + @columnname + ''', left(' + @columnname + ', 3630) from ' + @tablename + 'with (nolock) ' + ) end end end  select columnname, columnvalue from #results end;
select c.table_schema + '.' + c.table_name, c.column_name from information_schema.columns c join information_schema.tables t where c.data_type in ('varchar','nvarchar') -- searching only in these column types set @search='john' end ;
set nocount on set  @tablename = '' set @searchstr2 = quotename('%' + @searchstr + '%','''') set @columnname = '' set @tablename = ( select min(quotename(table_schema) + '.' + quotename(table_name)) from     information_schema.tables where         table_type = 'base table' and    quotename(table_schema) + '.' + quotename(table_name) > @tablename and    objectproperty( object_id( quotename(table_schema) + '.' + quotename(table_name) ) set @columnname = ( select min(quotename(column_name)) from     information_schema.columns where         table_schema    = parsename(@tablename, 2) and    table_name    = parsename(@tablename, 1) and    data_type in ('char', 'varchar', 'nchar', 'nvarchar', 'int', 'decimal', 'ntext', 'xml') and    quotename(column_name) > @columnname ) if @columnname is not null exec ( 'select ''' + @tablename + '.' + @columnname + ''', left((cast(' + @columnname + ' as nvarchar(max))), 3630) from ' + @tablename + ' (nolock) ' + ) end end end  select columnname, columnvalue from @results;
alter proc dbo.db_compare_searchalltables_sp ( @searchstr nvarchar(100), @tablename nvarchar(256) = '' ) as begin if parsename(@tablename, 2) is null set @tablename = 'dbo.' + quotename(@tablename, '"') set nocount on set @searchstr2 = quotename('%' + @searchstr + '%','''') if @tablename <> '' set @columnname = ( select min(quotename(column_name)) from     information_schema.columns where         table_schema    = parsename(@tablename, 2) and    table_name    = parsename(@tablename, 1) and    data_type in ('char', 'varchar', 'nchar', 'nvarchar') and    quotename(column_name) > @columnname ) if @columnname is not null exec ( 'select ''' + @tablename + '.' + @columnname + ''', left(' + @columnname + ', 3630) from ' + @tablename + ' with (nolock) ' + ) end end else while @tablename is not null set @columnname = '' set @tablename = ( select min(quotename(table_schema) + '.' + quotename(table_name)) from     information_schema.tables where         table_type = 'base table' and    quotename(table_schema) + '.' + quotename(table_name) > @tablename and    objectproperty( object_id( quotename(table_schema) + '.' + quotename(table_name) ) set @columnname = ( select min(quotename(column_name)) from     information_schema.columns where         table_schema    = parsename(@tablename, 2) and    table_name    = parsename(@tablename, 1) and    data_type in ('char', 'varchar', 'nchar', 'nvarchar') and    quotename(column_name) > @columnname ) if @columnname is not null exec ( 'select ''' + @tablename + '.' + @columnname + ''', left(' + @columnname + ', 3630) from ' + @tablename + ' with (nolock) ' + ) end end end  select columnname, columnvalue from @results end;
create or replace function searchalltables(_search text) returns table( txt text ) as $funct$ where    data_type = ''text'' and          table_schema = ''public'' ' into __count;
select case when row_number() over (order by table_name) < __count then else 'select ''' || table_name ||'.'|| column_name || ''' as tbl, "'  || column_name || '" as col from "public"."' || "table_name" || '" where "'|| "column_name" || '" ilike ''%' || _search  || '%''' end as txt from     information_schema.columns where    data_type = 'text' and          table_schema = 'public';
end $funct$ language plpgsql;
set nocount on set  @tablename = '' set @searchstr2 = quotename('%' + @searchstr + '%','''') set @columnname = '' set @tablename = ( select min(quotename(table_schema) + '.' + quotename(table_name)) from     information_schema.tables where         table_type = 'base table' and    quotename(table_schema) + '.' + quotename(table_name) > @tablename and    objectproperty( object_id( quotename(table_schema) + '.' + quotename(table_name) ) set @columnname = ( select min(quotename(column_name)) from     information_schema.columns where         table_schema    = parsename(@tablename, 2) and    table_name    = parsename(@tablename, 1) and    data_type in ('char', 'varchar', 'nchar', 'nvarchar', 'int', 'decimal') and    quotename(column_name) > @columnname ) if @columnname is not null exec ( 'select ''' + @tablename + '.' + @columnname + ''', left(' + @columnname + ', 3630) from ' + @tablename + ' (nolock) ' + ) end end end  select columnname, columnvalue from @results;
@table_name     sysname, @table_id       int, @column_name    sysname, @sql_string     varchar(2000) set @search_string = 'stringtosearch' and system_type_id in (167, 175, 231, 239) set @sql_string = 'if exists (select * from ' + @table_name + ' where [' + @column_name + '] like ''%' + @search_string + '%'') print ''' + @table_name + ', ' + @column_name + '''' end  end ;
if object_id('sp_keywordsearch', 'p') is not null drop proc sp_keywordsearch create procedure sp_keywordsearch @keyword nvarchar(100) as begin columnname nvarchar(max)) @tablename nvarchar(300), @columnname nvarchar(300), @count int set @tablecursor = cursor local scroll for select  n'select @count = count(1) from [dbo].[' + t.table_name + '] with (nolock) where cast([' + c.column_name + t.table_name, c.column_name from    information_schema.tables as t with (nolock) where   t.table_type = 'base table' and set @count = 0 exec sys.sp_executesql n'@count int output', @count output if @count > 0 values  (@tablename, @columnname) end  end  set @tablecursor = cursor local scroll for select  substring(tb.sql, 1, len(tb.sql) - 3) as sql, tb.tablename, substring(tb.columns, 1, len(tb.columns) - 1) as columns from    (select r.tablename, (select r2.columnname + ', ' from @result as r2 where r.tablename = r2.tablename for xml path('')) as columns, 'select * from ' + r.tablename + ' with (nolock) where ' + from   @result as r2 where  r.tablename = r2.tablename from   @result as r select  @tablename as [table], @columnname as columns end  end;
set serveroutput on;
if empty_varchar2 is null then end if;
if '' is null then end if;
if empty_char is null then end if;
select ceil(count(*)/2) from data;
select max(val) from (select val from data order by val limit @middlevalue) x;
select avg(dd.val) as median_val from ( select d.val, @rownum:=@rownum+1 as `row_number`, @total_rows:=@rownum from data d, (select @rownum:=0) r where d.val is not null where dd.row_number in ( floor((@total_rows+1)/2), floor((@total_rows+2)/2) );
select floor((3+1)/2),floor((3+2)/2); -- when total_rows is 3, avg rows 2 and 2 select floor((4+1)/2),floor((4+2)/2); -- when total_rows is 4, avg rows 2 and 3;
select avg(val) from having sum(sign(1-sign(if(y.val-x.val=0 and x.id != y.id, sign(x.id-y.id), y.val-x.val)))) in (round((count(*))/2), round((count(*)+1)/2));
select x.val from data x, data y having sum(sign(1-sign(y.val-x.val)))/count(*) > .5 limit 1;
select ((substring_index(substring_index(group_concat(val order by val), ',', floor(1+((count(val)-1) / 2))), ',', -1)) as median from table;
select avg(middle_values) as 'median' from ( select t1.median_column as 'middle_values' from ( select @row:=@row+1 as `row`, x.median_column from median_table as x, (select @row:=0) as r where 1 ( select count(*) as 'count' from median_table x where 1 where t1.row >= t2.count/2 and t1.row <= ((t2.count/2) +1)) as t3;
drop procedure if exists median;
create procedure median (table_name varchar(255), column_name varchar(255), where_clause varchar(255)) if where_clause is null or where_clause = '' then set where_clause = 1;
set @sql = concat( "select avg(middle_values) as 'median' from ( select t1.", column_name, " as 'middle_values' from ( select @row:=@row+1 as `row`, x.", column_name, " from ", table_name," as x, (select @row:=0) as r where ", where_clause, " order by x.", column_name, " ( select count(*) as 'count' from ", table_name, " x where ", where_clause, " where t1.row >= t2.count/2 and t1.row <= ((t2.count/2)+1)) as t3;
select `t1`.`".$column."` as `percentile` from ( select @rownum:=@rownum+1 as `row_number`, `d`.`".$column."` from `".$table."` `d`,  (select @rownum:=0) `r` ( select count(*) as `total_rows` from `".$table."` `d` where 1 and `t1`.`row_number`=floor(`total_rows` * ".$percentile.")+1;
if (!empty($result)) {;
drop table if exists table_median;
create table table_median (id integer(11),val integer(11));
(2, 4), (3, 5), (3, 2), (4, 5), (4, 12), (4, 1), (4, 7);
select id, avg(val) as median from ( select id, val from ( select -- create an index n for every id if(@a mod o.c=0, o.c, @a) as n, o.id, o.val, -- the number of elements for every id from ( select t_o.id, val, c from table_median t_o inner join count(1) as c from table_median id t_o.id,val where if( -- if there is an even number of elements n = c div 2 or n = (c div 2)+1,  c = 1, n = 1, n = c div 2 + 1 ) ) id;
( select *, count(*) over () as cnt, row_number() over (order by val) as rownum from yourtable ) select id, val from numbered where rownum in ((cnt+1)/2, (cnt+2)/2);
select x.val from data x, data y having sum(sign(1-sign(y.val-x.val))) = (count(*)+1)/2;
select count(*) from table --find the number of rows;
select val from table order by val asc limit median_row,1;
select cast (avg(val) as decimal(10,4)) from ( select val, row_number() over( order by val ) -1 as rn, count(1) over () -1 as cnt from station where rn in (floor(cnt/2),ceiling (cnt/2));
select avg(t1.val) as median_val from (select val, row_number() over(order by val) as rownum from data) t1, (select count(*) as num_records from data) t2 where t1.row_num in floor((t2.num_records + 2) / 2));
select count(*) as total_rows, if(count(*)%2 = 1, cast(substring_index(substring_index( group_concat(val order by val separator ','), ',', 50/100 * count(*)), ',', -1) as decimal), round((cast(substring_index(substring_index( group_concat(val order by val separator ','), ',', 50/100 * count(*) + 1), ',', -1) as decimal) + cast(substring_index(substring_index( group_concat(val order by val separator ','), ',', 50/100 * count(*)), ',', -1) as decimal)) / 2)) as median, avg(val) as average from data;
set @ct := (select count(1) from station);
select avg(a.val) as median from where (select @row := @row + 1) between @ct/2.0 and @ct/2.0 +1;
select avg(val) as median from ( select d1.val from data d1 cross join data d2 having abs(sum(sign(d1.val-d2.val))) in (0,1);
having sum(case when d1.val=d2.val then 1 else 0 end)>=;
set @rowindex := -1;
select avg(g.grade) from (select @rowindex:=@rowindex + 1 as rowindex, grades.grade as grade from grades where g.rowindex in (floor(@rowindex / 2) , ceil(@rowindex / 2));
create table employees(salary int);
select * from employees;
select salary from employees  order by salary;
set @cnt=(select count(*) from employees);
set @middle_no=ceil(@cnt/2);
set @odd_even=null;
select avg(salary) from;
select key_field, avg(value_field) median_value from ( select key_field, value_field, rankf from ( select key_field, value_field, rankf from ( select key_field, value_field from ( select key_field, value_field from ( -- some expensive query where rankf-rankr between -1 and 1;
select case when mod(c,2)=0 then round(sum(lat_n),4) else round(sum(lat_n)/2,4) end as med from (select lat_n, @r := @r+1, @r as id from station order by lat_n) a where id >= floor(c) and id <=ceil(c);
create table med(id integer);
select (min(count)+max(count))/2 from from med) then cast(b.id as float)end as count from med b) c;
select cast(avg(id) as float) from;
select our_id, avg(1.0 * our_val) as median from ( select our_id, our_val, count(*) over (partition by our_id) as cnt, row_number() over (partition by our_id order by our_val) as rn from our_table where rn in ((cnt + 1)/2, (cnt + 2)/2) group by our_id;
select m.median_col from median_table m where;
select <value> as val from <table> order by val limit 1 offset <half>;
select median(val) from data;
set @median_counter = (select floor(count(*)/2) - 1 as `median_counter` from `data`);
set @median = concat('select `val` from `data` order by `val` limit ', @median_counter, ', 1');
set @median = concat( 'select `val` from `data` order by `val` limit ', (select floor(count(*)/2) - 1 as `median_counter` from `data`), ', 1';
select `columna`, substring_index(substring_index(group_concat(`columnb` order by `columnb`), ',', ceiling((count(`columnb`)/2))), ',', -1) medianofcolumnb from `tablec`;
set session group_concat_max_len = 10000;
substring_index ( group_concat(pos order by cast(pos as signed integer) desc separator ';') from table_name;
select avg(tmp.val) as median_val from (select intab.val, @rows := @rows + 1 as rownum from data as intab,  (select @rows := -1) as init where 2 > 1 where tmp.rownum in (floor(@rows / 2), ceil(@rows / 2));
select cast(substring_index(substring_index( group_concat(field_name order by field_name separator ','), ',', 50/100 * count(*) + 1), ',', -1) as decimal) as `median` from table_name;
set group_concat_max_len = 10485760; #10mb max length;
select avg(t1.x) from table t1, table t2 having sum(sign(t1.x - t2.x)) = 0;
select substring_index( substring_index( group_concat(field order by field), ',', (( round( length(group_concat(field)) - replace( group_concat(field), ',', '' ) ) ',', -1 ) from table;
select period, avg(middle_values) as 'median' from ( select t1.sale_price as 'middle_values', t1.row_num, t1.period, t2.count from ( select @last_period:=@period as 'last_period', @period:=date_format(sale_date, '%y-%m') as 'period', if (@period<>@last_period, @row:=1, @row:=@row+1) as `row_num`, x.sale_price from listings as x, (select @row:=0) as r where 1 select count(*) as 'count', date_format(sale_date, '%y-%m') as 'period' from listings x where 1 where row_num >= (count/2) and row_num <= ((count/2) + 1);
( select p.year_of_birth from dbo.person p overallstats (avg_value, stdev_value, min_value, max_value, total) as ( select avg(1.0 * count_value) as avg_value, stdev(count_value) as stdev_value, min(count_value) as min_value, max(count_value) as max_value, count(*) as total from rawdata aggdata (count_value, total, accumulated) as ( select count_value, count(*) as total, sum(count(*)) over (order by count_value rows unbounded preceding) as accumulated from rawdata ) select o.total as count_value, o.min_value, o.max_value, o.avg_value, o.stdev_value, min(case when d.accumulated >= .50 * o.total then count_value else o.max_value end) as median_value, min(case when d.accumulated >= .10 * o.total then count_value else o.max_value end) as p10_value, min(case when d.accumulated >= .25 * o.total then count_value else o.max_value end) as p25_value, min(case when d.accumulated >= .75 * o.total then count_value else o.max_value end) as p75_value, min(case when d.accumulated >= .90 * o.total then count_value else o.max_value end) as p90_value from aggdata d;
drop table test.test_median create table test.test_median as select 'book' as grp, 4 as val union all select 'book', 7 union all select 'book', 2 union all select 'book', 2 union all select 'book', 9 union all select 'book', 8 union all select 'book', 3 union all select 'note', 11 union all select 'bike', 22 union all select 'bike', 26;
select grp, substring_index( substring_index( group_concat(val order by val), ',', count(*)/2 ), ',', -1) as the_median, group_concat(val order by val) as all_vals_for_debug from test.test_median;
if ($rowcount % 2 == 0 && !empty($medianrow)) { limit {$medianrow},{$offset}";
if ($even) { else { if ($even) {;
select your_dimension, avg(t1.val) as median_val from ( select @rownum:=@rownum+1 as `row_number`, if(@dim <> d.your_dimension, @rownum := 0, null), @dim := d.your_dimension as your_dimension, d.val from data d,  (select @rownum:=0) r, (select @dim := 'something_unreal') d where 1 ( select d.your_dimension, count(*) as total_rows from data d where 1 where 1 and t1.row_number in ( floor((total_rows+1)/2), floor((total_rows+2)/2) );
select * from   json_array_elements( '[{"name": "toby", "occupation": "software engineer"}, {"name": "zaphod", "occupation": "galactic president"} ]' where elem->>'name' = 'toby';
select data->'images'->'thumbnail'->'url' as thumb from instagram;
code: 1, value: 2012, description: 'year of producction' { code: 2, value: 30, description: 'length';
select data->'params'->0 as data from smart_elements;
select data->'params'->0->'type' as data from smart_elements;
select datename(month, dateadd(month, @mydate-1, cast('2008-01-01' as datetime)));
select datename(month, str(year(getdate()), 4) + replace(str(@month, 2), ' ', '0') + '01');
select datename( month , dateadd( month , @monthnumber , 0 ) - 1 );
select datename( month , dateadd( month , @monthnumber , -1 ) );
select to_char(to_date(v_month_num,'mm'),'month')  from dual;
set @monthnumber=datepart(month,getdate()) select datename( month , dateadd( month , @monthnumber , 0 ) - 1 );
select datename(month ,getdate());
select datename(m, str(2) + '/1/2011');
select datename(m, str([column_name]) + '/1/2011');
set @integer = 6;
select datename(m, str(@integer) + '/1/2011');
select (datename( month , dateadd( month , @metricmonthnumber - 1 , '1900-01-01' ) )) as metricmonthname from tablename;
select to_char(current_date,'dd month yyyy') from dual;
select datename(month, getdate()) as 'month name';
select convert(varchar(3), date, 100)  as month from mytable.;
select datename(month,dateadd(month, -3,getdate()));
select monthname(curdate());
select monthname('2013-12-12');
select monthname(<fieldname>) as "month name" from <tablename> where <condition>;
select datename(m,getdate());
select convert(char(3), datename(month, getdate()));
select datename( month , dateadd( month , @monthnumber , -1 ));
set @date='2015/1/4 00:00:00' select cast(datename(month,@date )  as char(3))as 'month name';
select datename(m, dateadd(m, @monthnumber, -1));
create function getmonth (@num int) as begin from @intmonth i where i.num = @num) end go select dbo.getmonth(4) as [month] select dbo.getmonth(5) as [month] select dbo.getmonth(6) as [month];
set ansi_nulls on set quoted_identifier on create function [dbo].[fn_getmonthfromdate] as begin set @monthpart = month(@date) if @monthpart = 1 end else if @monthpart = 2 end else if @monthpart = 3 end else if @monthpart = 4 end else if @monthpart = 5 end else if @monthpart = 6 end else if @monthpart = 7 end else if @monthpart = 8 end else if @monthpart = 9 end else if @monthpart = 10 end else if @monthpart = 11 end else if @monthpart = 12 end return null end;
select monthname(concat('1970-',[month int val],'-01'));
select monthname(concat('1970-',4,'-01'));
select datename(month, getdate());
select datename(mm,dateadd(mm,@month - 1,0));
select year(created_at), monthname(created_at) from users;
select format(datefromparts(1900, @month_num, 1), 'mmmm', 'en-us');
select format(datefromparts(1900, @month_num, 1), 'mmm', 'en-us');
create function fn_month_num_to_name ( @month_num tinyint ) as begin end;
select round(avg(some_column)::numeric,2) from table;
create function round(float,int) returns numeric as $$ select round($1::numeric,$2);
select round(1/3.,4); -- 0.3333 numeric;
create function round(float, text, int default 0) select case when $2='dec' then round($1::numeric,$3)::float else 'nan'::float  -- like an error message;
select round(1/3.,'dec',4);   -- 0.3333 float! select round(2.8+1/3.,'dec',1); -- 3.1 float! select round(2.8+1/3.,'dec'::text); -- need to cast string? pg bug;
select date,(wind_speed/3.6)::numeric(7,1) from readings;
select to_char (2/3::float, 'fm999999990.00');
select round (2/3::decimal, 2)::text;
select trunc(14.568,2);
select trunc(your_var::numeric,2);
select round(cast(some_column as numeric),2) from table;
alter table foo nocheck constraint all;
alter table foo nocheck constraint ck_foo_column;
alter table foo check constraint all;
alter table foo check constraint fk_something;
update myupdatedtable set somecol = somecol, fkcol = fkcol, etc = etc;
create procedure pr_disable_triggers_v2 as declare @sql varchar(500) select  t.table_name as tablename from    information_schema.tables t set @sql = 'alter table ' + @tableschema + '.[' + @tablename + '] ' if @disable = 1 set @sql = @sql + ' disable trigger all' else set @sql = @sql + ' enable trigger all' end ;
alter table tablename nocheck constraint all alter table tablename with check check constraint all exec sp_msforeachtable 'alter table ? nocheck constraint all' exec sp_msforeachtable 'alter table ? with check check constraint all';
select '{1}'   && '{1,2,3}'::int[];  -- true select '{1,4}' && '{1,2,3}'::int[];  -- true select '{4}'   && '{1,2,3}'::int[];  -- false;
select value_variable != any('{1,2,3}'::int[]);
select value_variable != all('{1,2,3}'::int[]);
select value_variable = any ('{1,2,3}'::int[]);
select * from table where id not in (select unnest(exception_list_ids) from table2);
from table1 t1 join table2 t2 on t1.other_name::text[] @> array[t2.panel::text];
select * from your_table where array_column ::text ilike any (array['%text_to_search%'::text]);
select 1 where any('{hello}'::text[]) = 'hello';
select 1 where 'hello' = any('{hello}'::text[]);
alter table employees modify column empname varchar(50) after department;
alter table employees change column empname empname varchar(50) after department;
alter table employees;
alter table userorder;
set @neighboringcolumn = '<your column should come after this column>';
select concat("alter table `",t.table_name,"` change column `",column_name,"` from information_schema.columns c, information_schema.tables t where c.table_schema = '<your schema name>' and c.column_name = '<column to move>' and c.table_schema = t.table_schema and c.table_name = t.table_name and t.table_type = 'base table' and @neighboringcolumn in (select column_name from information_schema.columns c2 where c2.table_name = t.table_name);
delete from blah;
select name, address for employee union select customer_name, address from customer;
select name as user_name, address for employee union select customer_name as user_name, address from customer;
select id,name,age from student where age < 15 union all select * from (select id,name,age from student where name like "%a%");
union (select a from t2 where a=11 and b=2 order by a limit 10);
select pass1.* from from table_a as tbla order by 2) as pass1 union all select pass2.* from from table_b as tblb order by 2) as pass2;
( select 1 as [sortindex], id,name,age from student where age < 15  ( select 2 as [sortindex], id,name,age from student where name like "%a%"  ( select * from juveniles union select * from astudents ) select * from allstudents;
select id,name,age from ( select id,name,age from student where age < 15 ) union all select id,name,age from student where name like "%a%";
select id,name,age, 1 as roworder from student where age < 15 union select id,name,age, 2 as roworder from student where name like "%a%";
select id,name,age from student where age < 15 union select id,name,age from student where name like '%a%';
select id,name,age from student where age < 15 union all select id,name,age from ( select id,name,age from student where name like "%a%" );
select 'foo' union select item as `foo` from mytable;
select id,name,age from ( select id,name,age from student where age < 15 union select id,name,age from student where name like "%a%";
select id,name,age from student where age < 15 union select id,name,age from student where name like "%a%";
alter table tablename add newcolumn int update tablename set newcolumn=existingcolumnname alter table tablename drop column existingcolumnname;
exec sp_rename 'tablename.oldcolumn' , 'newcolumnname', 'column' update tablename set newcolumnname=value where condition;
update syscolumns set colstat = 0 --turn off bit 1 which indicates identity column where id = object_id('table_name') and name = 'column_name' exec sp_configure 'allow update', 0;
select 'update ['+c.table_name+'] set ['+column_name+']=['+column_name+']+1000000' from information_schema.columns as c join information_schema.tables as t on t.table_name=c.table_name and t.table_schema=c.table_schema and t.table_type='base table' where column_name like 'caseid' order by ordinal_position;
set identity_insert dbo.tablename on ( tableid, columnname1, columnname2, columnname3 ) values ( tableid_value, columnname1_value, columnname2_value, columnname3_value ) set identity_insert dbo.tablename off;
select identity (int, 1, 1) as id, column1, column2 from dbo.oldtable;
set identity_insert yourtable on;
select * from yourtable delete from yourtable select id+1 as updatedid --put any other update logic to the id here drop table #tmpyourtable set identity_insert yourtable off;
select columns into newtable from yourtable;
alter table tablename add id mediumint not null auto_increment key;
if ( column.autoincrement ) case "int16": case "sbyte": case "int64": case "decimal": else { if ( bfirst ) else { if (myrow[column.columnname].tostring() == "true") else if (myrow[column.columnname].tostring() == "false") else if(myrow[column.columnname] == system.dbnull.value) else if(column.datatype.tostring().equals("system.string")) else values.append (myrow[column.columnname].tostring());
if ( bidentity ) values = new stringbuilder ( "values (" );
set identity_insert yourtable {on|off};
set identity_insert yourtable on delete from yourtable where id=3 set identity_insert yourtable off;
set identity insert;
set identity_insert dbo.tool on;
update table set identity_column_name = some value;
set identity_insert yourtable on;
set identity_insert yourtable off;
exec common.usp_difftablerows '#t1', '#t2';
exec common.usp_difftablerows @ptable1          = 'xdb.xsh.table2', @porderbycsvopt   = null,  -- order the results;
alter proc [common].[usp_difftablerows] @ptable1          varchar(300), @porderbycsvopt   nvarchar(1000) = null,  -- order the results as /*--------------------------------------------------------------------------------------------------------------------- if (substring(@ptable0, 1, 1) = '#') set @ptable0 = 'tempdb..' + @ptable0; -- object_id test below needs full names for temp tables if (substring(@ptable1, 1, 1) = '#') set @ptable1 = 'tempdb..' + @ptable1; -- object_id test below needs full names for temp tables if (object_id(@ptable0) is null) if (object_id(@ptable1) is null) create table #columngathering ( name nvarchar(300) not null, sequence int not null, tablearg tinyint not null @sql          nvarchar(4000), @sqltemplate  nvarchar(4000) = select name, column_id as sequence, $tablearg$ as tablearg from sys.columns c where object_id = object_id(''$table$'', ''u'') set @sql = replace(replace(replace(@sqltemplate, '$tablearg$', 0), '$database$', (select databasename from common.ufn_splitdbidentifier(@ptable0))), '$table$', @ptable0);
if (@pdebug = 1) exec sp_executesql @sql;
set @sql = replace(replace(replace(@sqltemplate, '$tablearg$', 1), '$database$', (select databasename from common.ufn_splitdbidentifier(@ptable1))), '$table$', @ptable1);
if (@pdebug = 1) exec sp_executesql @sql;
if (@pdebug = 1) select * from #columngathering;
select name, min(sequence) as sequence, convert(bit, iif(min(tablearg) = 0, 1, 0)) as intable0, convert(bit, iif(max(tablearg) = 1, 1, 0)) as intable1 from #columngathering having (     @ponlycsvopt is not null and name in (select value from common.ufn_usvtonvarcharkeytable(@ponlycsvopt, default))) or (     @ponlycsvopt is null and @pignorecsvopt is not null and name not in (select value from common.ufn_usvtonvarcharkeytable(@pignorecsvopt, default))) or (     @ponlycsvopt is null and @pignorecsvopt is null) if (exists (select 1 from #columns where intable0 = 0 or intable1 = 0)) select 1; -- without this the debugging info doesn't stream sometimes select * from #columns order by sequence;
end  if (@pdebug = 1) select * from #columns order by sequence;
-- '*', ( select substring((select ',' + ac.name from #columns ac if (@pdebug = 1) end  set @sqltemplate = ' b as (select ~, row_number() over (partition by ~ order by (select null)) -1 as duplicates from $b$) select 0 as sourcetable, ~ from ( select * from a select * from b union all select 1 as sourcetable, ~ from ( select * from b select * from a set @sql = replace(replace(replace(replace(@sqltemplate, '$a$', @ptable0), '$b$', @ptable1), '~', @columns), '$orderby$', coalesce(@porderbycsvopt, @columns + ', sourcetable') if (@pdebug = 1) exec sp_executesql @sql;
end try if (xact_state() = -1) end catch create function common.trim ( @poriginalstring nvarchar(max), @pcharstotrim nvarchar(50) = null -- specify null or 'default' for whitespae ) as /*-------------------------------------------------------------------------------------------------- ( select patindex(n'%[^' + effcharstotrim + n']%', @poriginalstring) as [firstchar], patindex(n'%[^' + effcharstotrim + n']%', reverse(@poriginalstring)) as [lastchar], len(@poriginalstring + n'~') - 1 as [actuallength] from ( select effcharstotrim = coalesce(@pcharstotrim, nchar(0x09) + nchar(0x20) + nchar(0x0d) + nchar(0x0a)) ) select substring(@poriginalstring, [firstchar], ((cte.[actuallength] - [lastchar]) - [firstchar] + 2) --[firstchar], --((cte.[actuallength] - [lastchar]) + 1) as [lastchar] from cte;
create function [common].[ufn_usvtonvarcharkeytable] ( @pcsvlist     nvarchar(max), @pseparator   nvarchar(1) = ','       -- can pass keyword 'default' when calling using ()'s ) @textpos  int, @chunklen smallint, @str      nvarchar(4000), @tmpstr   nvarchar(4000), @leftover nvarchar(4000), @csvlist nvarchar(max) = iif(@pseparator not in (char(13), char(10), char(13) + char(10)), replace(replace(@pcsvlist, char(13), ''), char(10), ''), @pcsvlist); -- remove newlines set @textpos = 1 set @leftover = '' set @chunklen = 4000 - len(@leftover) set @tmpstr = ltrim(@leftover + substring(@csvlist, @textpos, @chunklen)) set @textpos = @textpos + @chunklen set @pos = charindex(@pseparator, @tmpstr) set @str = substring(@tmpstr, 1, @pos - 1) set @str = (select trimmedstring from common.trim(@str, default));
set @tmpstr = ltrim(substring(@tmpstr, @pos + 1, len(@tmpstr))) set @pos = charindex(@pseparator, @tmpstr) end  set @leftover = @tmpstr end  set @str = (select trimmedstring from common.trim(@leftover, default));
if @str <> '' end go create function common.ufn_splitdbidentifier(@pidentifier nvarchar(300)) ( instancename          nvarchar(300) not null, databasename          nvarchar(300) not null, schemaname            nvarchar(300), basename              nvarchar(300) not null, fulltempdbbasename    nvarchar(300),            -- non-null for tempdb (e.g. #abc____...) databasewasspecified  bit not null, schemawasspecified    bit not null, iscurrentinstance     bit not null, iscurrentdatabase     bit not null, istempdb              bit not null, orgidentifier         nvarchar(300) not null union all select * from common.ufn_splitdbidentifier('s.t') union all select * from common.ufn_splitdbidentifier('d.s.t') union all select * from common.ufn_splitdbidentifier('i.d.s.t') union all select * from common.ufn_splitdbidentifier('#d') union all select * from common.ufn_splitdbidentifier('tempdb..#d');
select * from common.ufn_splitdbidentifier('illegal name');
set @firstdot = iif(@firstdot = 0, 0, len(@name) - @firstdot + 1);
set @seconddot = iif(@seconddot = 0, 0, len(@name) - @seconddot + 1);
set @thirddot = iif(@thirddot = 0, 0, len(@name) - @thirddot + 1);
set @fourthdot = iif(@fourthdot = 0, 0, len(@name) - @fourthdot + 1);
null, substring(@name, @seconddot + 1, @firstdot - @seconddot - 1));
null, substring(@name, @thirddot + 1, @seconddot - @thirddot - 1));
null, substring(@name, @fourthdot + 1, @thirddot - @fourthdot - 1));
select coalesce(@instname, '[' + @@servername + ']') as instancename, coalesce(@dbname,     iif(left(@basename, 1) = '#', 'tempdb', db_name())) as databasename, coalesce(@schemaname, iif(left(@basename, 1) = '#', 'dbo', schema_name())) as schemaname, @basename as basename, iif(left(@basename, 1) = '#', ( select [name] from tempdb.sys.objects where object_id = object_id('tempdb..' + @basename) null) as fulltempdbbasename, iif(@instname is null, 0, 1) instancewasspecified, iif(@dbname is null, 0, 1) databasewasspecified, iif(@schemaname is null, 0, 1) schemawasspecified ) select i.instancename, i.databasename, i.schemaname, i.basename, i.fulltempdbbasename, i.instancewasspecified, i.databasewasspecified, i.schemawasspecified, iif(i.instancename = '[' + @@servername + ']', 1, 0) as iscurrentinstance, iif(i.databasename = db_name(), 1, 0) as iscurrentdatabase, iif(left(@basename, 1) = '#', 1, 0) as istempdb, @name as orgidentifier from input i;
select col1,col2,col3 from db1..tb1 select col1,col2,col3 from db2..tb1 select col1,col2,col3 from db2..tb1 select col1,col2,col3 from db1..tb1;
select * from table2) union all (   select 'table2' as source, * from table2 select * from table1);
select 'table1' as source, * from table2) union all (   select 'table2' as source, * from table2 select 'table2' as source, * from table1);
select 'table1-only' as src, t1.* from ( select * from table1 select * from table2 union all select 'table2-only' as src, t2.* from ( select * from table2 select * from table1;
select [first name], count(1) e from (select * from [temp test data] union all select * from [temp test data 2]) a group by [first name] having e = 1;
select [first name], [last name], max(_tabloc) as _tabloc from ( select [first name], [last name], 't1' as _tabloc from table1 union all select [first name], [last name], 't2' as _tabloc from table2 having count(1)=1;
select count (*) from tbl_a select count (*) from tbl_b select * into #demo from tbl_a union all select * from tbl_b select distinct * from #demo;
select @data1 = ( select * from (select * from test1 except select * from test2) as a ) select @data2 = ( select * from (select * from test2 except select * from test1) as a ) select t.c.value('../@id', 'bigint') as id, t.c.value('local-name(.)', 'nvarchar(128)') as name, t.c.value('.', 'nvarchar(max)') as value from @data1.nodes('data/@*') as t(c) select t.c.value('../@id', 'bigint') as id, t.c.value('local-name(.)', 'nvarchar(128)') as name, t.c.value('.', 'nvarchar(max)') as value from @data2.nodes('data/@*') as t(c) ) select isnull(c1.id, c2.id) as id, isnull(c1.name, c2.name) as name, c1.value as value1, c2.value as value2 from cte1 as c1 where not ( c1.value is null and c2.value is null or );
select a.* from a where b.c is null;
select a.*, b.* from a where a.c is null or b.c is null;
select * from table2) union all (   select * from table2 select * from table1);
select [first name], [last name] from [temp test data] as td exception join [data] as d on;
( name varchar(30), age decimal(23,0) ) ('katrina', 21), ('samia', 22), ('hui ling', 25), ('yumie', 29);
set tg.age=sc.age;
values ('helen', 24), ('katrina', 21), ('samia', 22), ('hui ling', 25), ('yumie', 29);
values ('helen', 24), ('katrina', 21), ('samia', 22), ('hui ling', 25), ('yumie', 29) ...;
select mt.section, mt1.count as active, mt2.count as inactive from mytable mt mt1.count, mt2.count;
select m.typeid, m1.highbid, m2.lowask, m1.highbid - m2.lowask as diff, 100*(m1.highbid - m2.lowask)/m2.lowask as diffpercent from mkttrades m m1.highbid, m2.lowask;
create extension;
create extension tablefunc;
create table t (section char(1), status varchar(10), count integer);
select row_name as section, category_1::integer as active, category_2::integer as inactive from crosstab('select section::text, status, count::text from t',2) as ct (row_name text, category_1 text, category_2 text);
select section, sum(case status when 'active' then count else 0 end) as active, --here you pivot each status value as a separate column explicitly from t;
create extension;
create extension if not exists tablefunc;
create table tbl ( section   text;
select * from   crosstab( 'select section, status, ct from   tbl;
select * from   crosstab( 'select section, status, ct from   tbl;
create table test_crosstab( section text, <br/>status text, <br/>count numeric) select * from crosstab( <br/>'select section;
create temp table t ( section   text select section, (obj ->> 'active')::int as active, (obj ->> 'inactive')::int as inactive from (select section, json_object_agg(status,ct) as obj from t;
update foobar set column_a = case end where column_b in ('123','345');
update ... from;
update test as t set from (values ('345', 2) where c.column_b = t.column_b;
update test as t set column_c = c.column_c from (values ('345', 2, '+++') where c.column_b = t.column_b;
update users as u set -- postgres ftw first_name = u2.first_name, last_name = u2.last_name from (values (2, 'robert@duncan.info', 'robert', 'duncan') where u2.id = u.id;
update reports set is_default = case when report_id = 123 then true end where account_id = 321;
drop table if exists results_dummy;
create table results_dummy (id int, status text, created_at timestamp default now(), updated_at timestamp default now());
select unnest(array[1,2,3,4,5]::int[]) as id, unnest(array['a','b','c','d','e']::text[]) as status;
select * from results_dummy;
update results_dummy as rd set    status=new.status, updated_at=now() from (select unnest(array[1,2,5]::int[]) as id,unnest(array['a`','b`','e`']::text[]) as status) as new where rd.id=new.id;
select * from results_dummy;
update results_dummy as rd set    status=new.status, updated_at=now() from (select unnest(:1::int[]) as id,unnest(:2::text[]) as status) as new where rd.id=new.id;
update table_name set column_1 = case when any_column = value and any_column = value then column_1_value end, column_2 = case when any_column = value and any_column = value then column_2_value end, column_3 = case when any_column = value and any_column = value then column_3_value end, .;
create table xxx ( id varchar(64), is_enabled boolean update public.xxx as pns set is_enabled         = u.is_enabled from ( values ( '3', false '1', true '2', false ) where u.id = pns.id;
select * from xxx;
update public.xxx as pns set is_enabled         = u.is_enabled from ( select '3' as id, false as is_enabled union select '1' as id, true as is_enabled union select '2' as id, false as is_enabled where u.id = pns.id;
update test as t set from (values ('345', 2) where t.column_b = c.column_b::text;
info.name, date(user.registration), info.news from user, info where user.id = info.id ";
select strftime("%y-%d-%m", col_name, 'unixepoch') as col_name;
select from_unixtime(user.registration, '%y-%m-%d %h:%i:%s') as 'date_formatted';
select * from order child where parent.customerid is null;
delete order from order child where parent.customerid is null;
values (6811034679,'bengt','carlberg',10);
alter table  tbldomare with nocheck add foreign key (persnr);
select fk_column from fk_table where fk_column not in;
alter table tbldomare add foreign key (persnr);
select  sum(val) from    ( select  nvl(1, length(rawtohex(sys_guid()))) as val from    dual );
select  sum(val) from    ( select  coalesce(1, length(rawtohex(sys_guid()))) as val from    dual );
select nvl('a',sysdate) from dual;
select coalesce('a',sysdate) from dual;
select coalesce(1, my_sequence.nextval) as answer from dual;
select nvl('','',1) from dual;
select coalesce('','','1') from dual;
select nvl('abc',10) from dual;
select coalesce('abc',10) from dual;
select coalesce(a, sysdate) from (select null as a from dual union select null as a from dual;
select nvl(a, sysdate) from (select null as a from dual union select null as a from dual;
select purchase_price, min_price, nvl(purchase_price + (purchase_price * 0.10), min_price)    as nvl_sales_price, coalesce(purchase_price + (purchase_price * 0.10), min_price,50) as coalesce_sales_price from price_list;
create table tt(a, b) as select level, mod(level,10) from dual alter table tt add constraint ix_tt_a primary key(a);
create index ix_tt_b on tt(b);
select * from tt where a=nvl(:1,a) and b=:2;
select * from tt where a=coalesce(:1,a) and b=:2;
select `users`.`first_name`, `users`.`last_name`, `users`.`email`, @postcode as `guaranteed_postcode` from `users` left outer join `locations` where (@postcode := substring(`locations`.`raw`,-6,4)) not in ( select `postcode` from `postcodes` where `region` in ( 'australia' ) );
select * from ( select `users`.`first_name`, `users`.`last_name`, `users`.`email`, substring(`locations`.`raw`,-6,4) as `guaranteed_postcode` from `users` left outer join `locations` where guaranteed_postcode not in --this is where the fake col is being used ( select `postcode` from `postcodes` where `region` in ( 'australia' ) );
select `users`.`first_name`,`users`.`last_name`,`users`.`email`,substring(`locations`.`raw`,-6,4) as `guaranteed_postcode` from `users` left outer join `locations` where substring(`locations`.`raw`,-6,4) not in #this is where the fake col is being used ( select `postcode` from `postcodes` where `region` in ( 'australia' ) );
select `users`.`first_name`, `users`.`last_name`, `users`.`email`, substring(`locations`.`raw`,-6,4) as `guaranteed_postcode` from `users` left outer join `locations` where substring(`locations`.`raw`,-6,4) not in #this is where the fake col is being used ( select `postcode` from `postcodes` where `region` in ( 'australia' ) );
select * from (select col1, col2,...) as t where t.calcalias > 0;
create table oldtable (field1 varchar(10), field2 integer, field3 float) select top 1 * into newtable from oldtable;
create table newtable (field1 varchar(10), field2 integer, field3 float);
create table newtable (field1 varchar(10), field2 integer, field3 integer);
select col1, col2 into #a -- <<== creates temporary table from   tablename;
select  col1, ....., col@      -- <<== select as many columns as you want from    [source table name];
select * into newtable from oldtable;
select [column name] into [new table] from [source table];
select .... from source_table;
select * into new_table  from  old_table;
alter table mycustomers alter column companyname varchar(20) null;
alter table [table name] alter column [column name] [data type] null;
alter table your_table alter column your_column nvarchar(42) null;
alter table public.contract_termination_requests alter column management_company_id drop not null;
alter table table_name change column_name column_name int(11) null;
alter table [table name] modify column [column name] [data type] null;
select case when sc.max_length = '-1' and st.name in ('char','decimal','nvarchar','varchar') then 'alter table  [' + so.name + '] alter column [' + sc.name + '] ' + st.name + '(max) null' then 'alter table  [' + so.name + '] alter column [' + sc.name + '] ' + st.name + '(' + cast(sc.max_length as varchar(4)) + ') null' else 'alter table  [' + so.name + '] alter column [' + sc.name + '] ' + st.name + ' null' end as query from sys.columns sc where so.type = 'u' and st.name <> 'timestamp';
if exists (select 1 from information_schema.columns where alter table dbname.schemaname.tablename alter column columnname [data type] null end;
select @cadena = @cadena + 'exec spapi ' + ltrim(id) + ';' from sysobjects;
select @sql = (select distinct 'exec dbo.sp_s2_laser_to_cache ' + from dim_machine where iscurrent = 1 exec sp_executesql @sql;
id int identity(1,1), parent nvarchar(128), child nvarchar(128));
values ('some name',  'child name');
values ('some other name', 'some other child name');
select @parentname = parent, @childname = child from @menus where id = @id;
exec myprocedure @parent=@parentname, @child=@childname;
select @id = min(id) from @menus where id > @id;
select top 1 @menuid = menuid from @menuids;
exec myprocedure @menuid=@menuid;
delete from @menuids where menuid = @menuid;
select field1, field2 from sometable where someotherfield is null exec uspyoursproc @field1, @field2 end ;
select user_id from users where (my criteria) select @maxi = @@rowcount, @i = 1 select @userid = userid from @tableusers where myrowcount = @i exec prmystoredproc @userid select  end;
select udfmyfunction(user_id), someotherfield, etc from mytable where whatevercondition;
select col1, col2 from tablename where ...;
select * from foo;
select * from foo;
select * from foo;
select fieldname from tablename;
select "fieldname" from "tablename";
select distinct table_name, constraint_name, column_name, r_table_name, position, constraint_type from   (select uc.table_name, uc.constraint_name, cols.column_name, (select table_name from   user_constraints where  constraint_name = uc.r_constraint_name) r_table_name, (select column_name from   user_cons_columns where  constraint_name = uc.r_constraint_name and position = cols.position)           r_column_name, cols.position, uc.constraint_type from   user_constraints uc where  constraint_type != 'c') and column_name = '&&columnname' and prior column_name = r_column_name;
a.constraint_name, a.table_name, b.column_name, a.status from   all_constraints a join   all_cons_columns b on b.constraint_name = a.constraint_name where  a.constraint_type = 'r' and exists( select 1 from   all_constraints where  constraint_name=a.r_constraint_name and constraint_type in ('p', 'u') and table_name = :object_name and owner = :object_owner);
select constraint_name as pk_name, table_name from all_constraints where owner = user and constraint_type = 'p' ) select ac.table_name || ' table has a foreign key called ' || upper(ac.constraint_name) from all_constraints ac where ac.owner = user and ac.constraint_type = 'r' and ac.table_name = nvl(upper(:table_name), ac.table_name);
select table_name from all_constraints where constraint_type = 'r' -- "referential integrity" and r_constraint_name in from all_constraints where table_name = 'emp' and constraint_type in ('u', 'p') -- "unique" or "primary key";
select owner,constraint_name,constraint_type,table_name,r_owner,r_constraint_name from all_constraints where constraint_type='r' and r_constraint_name in (select constraint_name from all_constraints where constraint_type in ('p','u') and table_name='[your table]');
select c.constraint_name, c.constraint_type, c2.constraint_name, c2.constraint_type, c2.table_name from dba_constraints c join dba_constraints c2 on (c.r_constraint_name = c2.constraint_name) where c.table_name = <table_of_interest> and c.constraint_type = 'r';
select table_name, constraint_name, status, owner from all_constraints where r_owner = :r_owner and constraint_type = 'r' and r_constraint_name in ( select constraint_name from all_constraints where constraint_type in ('p', 'u') and table_name = :r_table_name and owner = :r_owner );
a.table_name, a.constraint_name, a.status from   all_constraints a where  a.constraint_type = 'r' and exists( select 1 from   all_constraints where  constraint_name=a.r_constraint_name and constraint_type in ('p', 'u') and table_name = :object_name and owner = :object_owner);
where ordernumber like case when isnumeric(@ordernumber) = 1 then else '%' + @ordernumber end;
where ordernumber like case when isnumeric(@ordernumber)=1 then @ordernumber else '%' + @ordernumber end;
where (isnumeric(@ordernumber) and or (not isnumeric(@ordernumber) and;
where ordernumber = case then convert(int, @ordernumber) else -9999 -- some numeric value that just cannot exist in the column end or firstname like case then '%' + @ordernumber else '' end;
if (isnumeric(@ordernumber)) = 1 select * from table where @ordernumber = ordernumber end else begin select * from table where ordernumber like '%' + @ordernumber end;
create procedure sp_case as select person.hobbies from person where person.id = case @bool then 30 then 42;
if @lsttransdt is null set @openqty=0 end else begin select   @openqty=isnull(sum(closingqty),0) from  productanddepotwisemonitoring where   pcd=@pcd and ptpcd=@ptpcd and transdt=@lsttransdt end;
if (select count(*) from production.product where name like 'touring-3000%' ) > 5 else print 'there are 5 or less touring-3000 bicycles.' ;
if (select count(*) from production.product where name like 'touring-3000%' ) > 5 set @bikecount = from production.product where name like 'touring-3000%');
set @avgweight = from production.product where name like 'touring-3000%');
end else begin set @avgweight = from production.product where name like 'touring-3000%' );
set @number = 50 if @number > 100 else begin if @number < 10 else print 'the number is medium' end ;
where (isnumeric(@ordernumber) = 1 and ordernumber = @ordernumber) or (isnumeric(@ordernumber) = 0 and ordernumber like '%' + @ordernumber + '%');
where  vfl.createddate >= case when @fromdate is null then vfl.createddate else  @fromdate end and vfl.createddate<=case when @todate is null then vfl.createddate else @todate end;
where ordernumber like case when isnumeric(@ordernumber) = 1 then @ordernumber else  '%' + @ordernumber end;
create stored procedure getusers @siteid int = null as begin select * from users where countryid  = case when isnumeric(@countryid) = 1 then @countryid else countryid end and;
alter table persion drop primary key;
alter table persion drop constraint 'constraint name';
alter table persion add primary key (persionid,pname,pmid);
alter table persion add constraint pk_persion primary key (persionid,pname,pmid);
alter table table_name drop index `primary`, add primary key (column1, column2,..);
alter table table_name add primary key(`persionid`,`pname`,`pmid`);
alter table <table name> add constraint <constraint name> primary key <columnname>;
alter table dept add constraint pk_dept primary key (deptno);
alter table tblpersons drop constraint <constraint_name> alter table tblpersons drop constraint p_id;
alter table tblpersion add primary key (p_id,lastname);
alter table dbo.persion add constraint pk_persionid primary key nonclustered (pmid, persionid);
alter table persion add primary key(persionid,pname,pmid);
if 0 < ( select count(*) from information_schema.tables where table_type = 'base table' and table_schema = 'dbo' and table_name = 't_sys_language_forms' ) if 0 = (select count(*) from t_sys_language_forms where lang_uid is null) alter table t_sys_language_forms alter column lang_uid uniqueidentifier not null if 1 >= (select top 1 count(*) as cnt from t_sys_language_forms group by lang_uid order by cnt desc) if 0 = ( select count(*) from information_schema.table_constraints where constraint_type = 'primary key' and table_schema = 'dbo' and table_name = 't_sys_language_forms' ) alter table t_sys_language_forms add constraint pk_t_sys_language_forms primary key clustered (lang_uid asc) end -- end uniqueness check else print 'fsck, this column has duplicate keys, and can thus not be changed to primary key...' end -- end null check else print 'fsck, need to figure out how to update null value(s)...' end;
alter table `table name` add primary key (`column name`) ;
alter table persion drop constraint <constraint_name> alter table persion add primary key (persionid,pname,pmid);
select object_name(object_id) as nameofconstraint from sys.objects where object_name(parent_object_id)='persion' and type_desc like '%constraint';
alter table dbo.persion drop constraint pk_persionid;
alter table dbo.persion add pmid bigint identity;
alter table dbo.persion add constraint pk_persionid primary key nonclustered (pmid, persionid);
create table temp ( date datetime, category varchar(3), amount money @query  as nvarchar(max);
set @cols = (select string_agg(category,',') from (select distinct category from temp where category is not null)t);
set @query = 'select date, ' + @cols + ' from ( select date from temp ( max(amount) drop table temp;
create table test_table ( date nvarchar(10), category char(3), amount money );
@pivotcolumnnames as nvarchar(max), @pivotselectcolumnnames as nvarchar(max) select @pivotcolumnnames= isnull(@pivotcolumnnames + ',','') from (select distinct category from test_table) as cat select @pivotselectcolumnnames from (select distinct category from test_table) as cat set @dynamicpivotquery = from test_table exec sp_executesql @dynamicpivotquery;
create procedure [dbo].[usp_dynamic_pivot] ( @static_column varchar(255), @pivot_column varchar(255), @value_column varchar(255), @table varchar(255), @aggregate varchar(20) = null ) as  set nocount on;
@sqlstring nvarchar(max), @pivot_sql_string nvarchar(max), @tempvarcolumns nvarchar(max), @tablesql nvarchar(max) if isnull(@aggregate,'') = '' set @aggregate = 'max' end  set @pivot_sql_string =    'select top 1 stuff((select distinct '', '' + cast(''[''+convert(varchar,'+ @pivot_column+')+'']''  as varchar(50)) [text()] from '+@table+' where isnull('+@pivot_column+','''') <> '''' from '+@table+' ma set @avaiable_to_pivot = (select * from @tab) set @tempvarcolumns = (select replace(@avaiable_to_pivot,',',' nvarchar(255) null,') + ' nvarchar(255) null') set @sqlstring = 'declare @return_table table ('+@static_column+' nvarchar(255) null,'+@tempvarcolumns+') select * from ( select ' + @static_column + ' , ' + @pivot_column + ', ' + @value_column + ' from '+@table+' ) a ( '+@aggregate+'('+@value_column+') select * from @return_table' exec sp_executesql @sqlstring end;
create table temp ( date datetime, category varchar(3), amount money );
exec [dbo].[usp_dynamic_pivot] 'date','category','amount','dbo.temp','sum' exec [dbo].[usp_dynamic_pivot] 'date','category','amount','dbo.temp','max' exec [dbo].[usp_dynamic_pivot] 'date','category','amount','dbo.temp','avg' exec [dbo].[usp_dynamic_pivot] 'date','category','amount','dbo.temp','min';
@maxcols as nvarchar(max), @query  as nvarchar(max) select @cols = stuff((select ',' + quotename(codigoformapago) from po_formaspago select @maxcols = stuff((select ',max(' + quotename(codigoformapago) + ') as ' + quotename(codigoformapago) from po_formaspago set @query = 'select codigoproducto, denominacionproducto, ' + @maxcols + ' from ( select codigoproducto, denominacionproducto, ' + @cols + ' from ( select p.codigoproducto as codigoproducto, p.denominacionproducto as denominacionproducto, fpp.cantidadcuotas as cantidadcuotas, fpp.idformapago as idformapago, fp.codigoformapago as codigoformapago from pr_producto p ( max(cantidadcuotas);
create table #temp ( date datetime, category varchar(3), amount money ) select @cols = @cols + quotename(category) + ',' from (select distinct category from #temp ) as tmp select @cols = substring(@cols, 0, len(@cols)) --trim "," at end set @query = ( select date, amount, category from #temp ( max(amount) for category in (' + @cols + ') drop table #temp;
create table temp ( date datetime, category varchar(3), amount money ) @query  as nvarchar(max);
set @cols = stuff((select distinct ',' + quotename(c.category) from temp c set @query = 'select date, ' + @cols + ' from ( select date from temp ( max(amount) drop table temp;
select idfield, datefield, namefield from yourrealtable;
select t.id, t.date, t.name from yourtable t;
select otherid, otherdate, othername from physicaltable;
select id, date, name from physical_table;
select col1, col2, col3 from othertable;
select col1, col2, col3 from othertable;
drop table #tmp_table select new_acc_no, count(new_acc_no) as count1 from table where unit_id = '0007' having count(new_acc_no) > 1;
select  id , date , name into #temp from [tablename];
if object_id('tempdb..#mytable') is not null drop table #mytable select b.val as 'bvals' from othertable as b;
select * from table;
select * into #temptable from originaltable;
drop table #temptable;
create table #mytempemployeetable(tempuserid  varchar(max), tempusername  varchar(max) );
select * from #mytempemployeetable;
delete from #mytempemployeetable;
drop table #mytempemployeetable;
create table #tempstudent(tempid  int, tempname  varchar(max) ) select * from #tempstudent;
select id, studname  into #tempstudent from students where id =1 select * from #tempstudent;
select id, date, name from physical_table;
if object_id('tempdb.dbo.#temptable') is not null drop table #temptable;
select * from table where update_date::date >= '2013-05-03' and update_date::date <= '2013-05-03' -> will return result;
select * from table where update_date;
select * from table where update_date >= '2013-05-03'::date and update_date < ('2013-05-03'::date + '1 day'::interval);
select * from table where to_date(to_char(timespancolumn,'yyyy-mm-dd'),'yyyy-mm-dd') = to_timestamp('2018-03-26', 'yyyy-mm-dd');
select a.*, b.*, c.*;
and c.bc_id = b.bc_id;
and b.bc_id = c.bc_id;
select a.x, a.y, a.z from a;
create or replace view my_view as select student_name, student_no, class_year from student_table where student_class = 10;
set date_parm = '2009';
select student_name, student_no, class_year from my_view where class_year = %date_parm;
create table foo( id int identity(1,1), dummy varchar(100) ) create table foolog( id int identity(2,2), logtext varchar(100) ) create trigger insertfoo on foo after insert as end  select scope_identity(), @@identity;
set @pad_characters = '0000000000' select right(@pad_characters + @str, 10);
select right(@padstr + @str, @len);
select right(replicate(@padchar, @len) + @str, @len);
create function [dbo].[f_pad_before](@string varchar(255), @desired_length integer, @pad_character char(1)) case when len(@string) < @desired_length then replace(space(@desired_length - len(@string)), ' ', @pad_character) + @string else @string end )) end;
select dbo.f_pad_before('aaa', 10, '_');
alter   function [dbo].[fspadleft](@var varchar(200),@padchar char(1)='0',@len int) as begin end;
alter function [dbo].[fspadright](@var varchar(200),@padchar char(1)='0', @len int) returns varchar(201) as end;
select stuff(@str, 1, 0, replicate('0', @n - len(@str)));
select @string = '0' + @string end;
create function padleft( @string varchar(8000) as begin end;
set @value = round(@value,2) * 100;
create date    : november 1, 2012 create function [dbo].[svfn_ams_pad_string] ( @mystr varchar(25), @length int, @padchar char(1) = null ) as begin set @padchar = isnull(@padchar, '0');
select @result = right(substring(replicate('0', @length), 1, (@length + 1) - len(rtrim(@mystr))) end;
select format(@n, 'd10') as padwithzeros;
set statistics time on select format(n, 'd10') as padwithzeros from tally set statistics time off;
set statistics time on select right('0000000000'+ rtrim(cast(n as varchar(5))), 10) from tally set statistics time off;
select [@longeststringvalue]=@longeststringvalue, [@maxlengthofpaddedstring]=@maxlengthofpaddedstring;
@stringvalue varchar(max);
select top(1) @stringvaluerowid = rowid, @stringvalue = stringvalue from @stringvalues where rowid > isnull(@stringvaluerowid, 0) if (@@rowcount = 0) end  select * from @testingresults;
create function padstringtrim ( @inputstr varchar(500), @finallength int, @padchar varchar (1), @padside varchar(1) ) as begin set @padding = replace(@padding, 'x', @padchar) set @inputstr = rtrim(ltrim(@inputstr)) if len(@inputstr) > @finallength else if(@finallength > len(@inputstr)) if @padside = 'l' set @inputstr = right(@padding + @inputstr, @finallength) else if @padside = 'r' set @inputstr = left(@inputstr + @padding, @finallength) end ;
if len(@string)=@length if charindex('.',@string)>0 select @resp = case sign(@string) else -- nros positivos grandes con decimales end end else begin select @resp = case sign(@string) else -- nros positivos grandes con decimales end end end else if charindex('.',@string)>0 select @resp =case sign(@string) else --ntos positivos con decimales end end else begin select @resp = case sign(@string) else -- nros positivos sin decimales end end return @resp;
create or alter function code.fnconvert_padleft( @in_str nvarchar(1024), @pad_length int, @pad_char nchar(1) = ' ', @rtn_null nvarchar(1024) = '') as begin end go create or alter function code.fnconvert_padright( @in_str nvarchar(1024), @pad_length int, @pad_char nchar(1) = ' ', @rtn_null nvarchar(1024) = '') as begin end go set statistics time on select code.fnconvert_padleft('88',10,'0',''), code.fnconvert_padleft(null,10,'0',''), code.fnconvert_padleft(null,10,'0',null), code.fnconvert_padright('88',10,'0',''), code.fnconvert_padright(null,10,'0',''), code.fnconvert_padright(null,10,'0',null);
view or function 'updatable_view' is not updatable because the modification affects multiple base tables.;
update table1 t1, table2 t2 set t1.field = t1.field+2 where t1.id = t2.foreign_id and t2.id = '123414';
update table1 set table1.lastname = 'dr. xxxxxx' from table1 t1, table2 t2 where t1.id = t2.id and t1.id = '011008';
update table2 set table2.waprrs = 'start,stop' from table1 t1, table2 t2 where t1.id = t2.id and t1.id = '011008';
update table1 set table1.lastname = 'dr. xxxxxx' where table1.field = '010008';
update table2 set table2.waprrs = 'start,stop' from table2 join @ids i on i.id = table2.id;
update table1, table2 set table1.lastname="dr. xxxxxx", table2.waprrs="start,stop" where table1.id=table2.id and table1.id="010008";
set @cnsreq=(select min(requisicionesdt.cnsreq) from requisicionesdt requisiciones and requisiciones.cnsreq = requisicionesdt.cnsreq and requisicionesdt.idreq = requisiciones.id where requisiciones.cnsrqdt = requisiciones.cnsrqdt and requisiciones.idrqdt = requisicionesdt.id) select requisiciones.cnsreq, requisiciones.id, requisiciones.cnsrqdt from requisiciones requisicionesdt and requisiciones.cnsreq = requisicionesdt.cnsreq and requisicionesdt.idreq = requisiciones.id where requisiciones.cnsrqdt = requisiciones.cnsrqdt and requisiciones.idrqdt = requisicionesdt.id and requisiciones.cnsreq = @cnsreq update requisicionesdt set  requisicionesdt.cnsreq=null, requisicionesdt.idreq=null from requisiciones inner join requisicionesdt where requisiciones.cnsrqdt = requisiciones.cnsrqdt and requisiciones.idrqdt = requisicionesdt.id and requisiciones.cnsreq = @cnsreq update requisiciones set requisiciones.cnsrqdt=null, requisiciones.idrqdt=null from requisiciones inner join requisicionesdt where requisiciones.cnsrqdt = requisiciones.cnsrqdt and requisiciones.idrqdt = requisicionesdt.id and requisiciones.cnsreq = @cnsreq set @id2=(select min(requisicionesdt.id) from requisicionesdt where isnull(requisicionesdt.idreq,0)<>0) delete from requisicionesdt where requisicionesdt.id=@id2 set @idcnsreq=(select min (requisiciones.id)from requisiciones where requisiciones.cnsrqdt is null and requisiciones.idrqdt is null) set @finalcnsreq=(select min (requisiciones.cnsreq)from requisiciones where requisiciones.cnsrqdt is null and requisiciones.idrqdt is null) set @finalcnsrqdt=(select min(requisicionesdt.cnsrqdt) from requisiciones where requisiciones.cnsrqdt is null and requisiciones.idrqdt is null) set @idcnsrqdt=(select min (requisicionesdt.id)from requisiciones where requisiciones.cnsrqdt is null and requisiciones.idrqdt is null) update requisiciones set requisiciones.cnsrqdt = @finalcnsrqdt, requisiciones.idrqdt=@idcnsrqdt from requisiciones where requisicionesdt.cnsrqdt = @finalcnsrqdt and requisicionesdt.id = @idcnsrqdt;
update table1 t1 join table2 t2 on t1.id = t2.id set t1.lastname='dr. xxxxxx', t2.waprrs='start,stop' where t1.id = '010008';
create table company ( company_id int not null, company_name varchar(50), primary key (company_id) create table user ( user_id int, user_name varchar(50), company_id int, index company_id_idx (company_id), foreign key (company_id) references company (company_id) on...;
select * from table1;
select * from table1 table2;
select * from table1 table2 or (table1.room_number is null and table2.room_number is null);
select * from tablea as a inner join tableb as b using (column1);
select * from tablea as a inner join tableb as b on a.column1 = b.column1;
select * from tablea natural join tableb;
union corresponding;
select * from s natural join sp;
select s.sno, sname, status, city, pno, qty from s inner join sp select s.*, pno, qty from s inner join sp select sp.*, s.sname, s.status, s.city from s inner join sp select s.*, pno, qty from s, sp where s.sno = sp.sno;
and natural join :;
select  from a, b left join dkcd on  where ;
select  from (a, b) left join dkcd on  where ;
select  from a, (b left join dkcd on ) where ;
select distinct a.maxa, b.mahuyen, a.tenxa, b.tenhuyen, isnull(dkcd.tong, 0) as tongdkcd from phuongxa a select maxa, count(*) as tong from khaosat where convert(datetime, ngaylap, 103) between 'sep 1 2011' and 'sep 5 2011' where a.maxa <> '99';
select advisors.first_name, advisors.last_name...and so on.;
select .... from dkcd a;
select dbo.prd.name from dbo.product prd;
select prd.name from dbo.product prd;
select mycol1, mycol2 mycol3 from sometable;
where s.some_column = ?;
delete from commenttag where [dbo].commenttag.noteid = [dbo].fetchedtagtransferdata.issueid;
delete from commenttag where [dbo].commenttag.noteid = (select noteid from fetchedtagtransferdata);
select o.operationid, o.operatingdate, p.pasid, p.name as patientname, o.operationalunitid, f.name as operasjonsprogram,  o.theaterid as stueid, t.name as stuenavn, o.status as operasjonsstatus from operation o where (p.name like '%male[0-9]%' or p.name like '%kfemale [0-9]%');
select a.name,a.date from [logininfo].[dbo].[tablea] as a join [logininfo].[dbo].[tablea] as b;
select a.name,a.date from [logininfo].[dbo].[tablea] as a join [logininfo].[dbo].[tablea] as b;
select distinct phuongxa.maxa , quanhuyen.mahuyen , phuongxa.tenxa , quanhuyen.tenhuyen , isnull(dkcd.tong, 0) as tongdkcd from    phuongxa , quanhuyen count(*) as tong from      khaosat where     convert(datetime, ngaylap, 103) between 'sep 1 2011' and 'sep 5 2011' where   phuongxa.maxa <> '99' and left(phuongxa.maxa, 2) = quanhuyen.mahuyen;
select... ) select rcte.name, ... from rcte inner join customer;
create table #bla(id int,id2 int) select count(*),count(id),count(id2) from #bla;
select column_a, count(distinct column_b) from table having count(distinct column_b) > 1;
select count(websiteurl), count(id), count(*) from users;
( customerid int null ) select  count(*) as 'allrowscount' from    @table select  count(customerid) as 'onlynotnullcounts' from    @table;
and value = "toyota";
if (modelyear <> 0)     commandtext += " and year="+modelyear if (manufacturer <> "") commandtext += " and value="+quotedstr(manufacturer) if (color <> "")        commandtext += " and color="+quotedstr(color) if (california)         commandtext += " and hascatalytic=1";
if (modelyear <> 0) if (whereclause <> "") if (manufacturer <> "") if (whereclause <> "") if (color <> "") if (whereclause <> "") if (california) if (whereclause <> "") if (whereclause <> "");
select * from car_table where 1=1;
and someother filter;
select * from car_table where 1=1 and color="blue";
if ($cond == "age"){;
if ($cond == "age"){;
select * from car_table where 0=0 and value="toyota";
as ( select row_number() over (order by [date]), [date] from @dates as ( select row_number() over (order by [time]), [time] from @times ) select dates.[date] + times.[time] from dates join times on times.id = dates.id;
select dateadd(day, 0, datediff(day, 0, your_date_column)) + from your_table;
select combined = mydate + mytime from mytable;
set @dateonly = '07 aug 2009 00:00:00' set @timeonly = '01 jan 1899 10:11:23' select dateadd(dd, 0, datediff(dd, 0, @dateonly)) select dateadd(day, -datediff(day, 0, @timeonly), @timeonly) select cast( dateadd(dd, 0, datediff(dd, 0, @dateonly)) + ' ' + as datetime);
set @d = '2009-03-12 00:00:00.000';
set @t = '1899-12-30 12:30:00.000';
set @d = '2009-03-12';
set @t = '12:30:00.000';
select @d + cast(@t as datetime);
select cast(cast(datecolumn as date) as datetime) + cast(timecolumn as datetime) from yourtable;
select cast(your_date_column as date) + cast(your_time_column as datetime) from your_table;
select cast(@datefield as datetime) + cast(@timefield as datetime);
select cast(@fechaactual as datetime) + cast(@horainicioturno as datetime);
select cast(concat(@date, ' ', @time) as datetime2(7));
select cast(concat(cast(datefield as varchar), ' ', cast(timefield as varchar)) as datetime) as datewithtime from tablename;
select s.salesid from salestbl s where cast(cast(s.saledate  as date) as datetime) + cast(cast(s.salecreateddate as time) as datetime);
select  hostid, (select value from tabletest where itemname='a' and hostid = t1.hostid) as a, (select value from tabletest where itemname='b' and hostid = t1.hostid) as b, (select value from tabletest where itemname='c' and hostid = t1.hostid) as c from tabletest as t1;
select history.*, coalesce(sum(case when itemname = "a" then itemvalue end), 0) as a, coalesce(sum(case when itemname = "b" then itemvalue end), 0) as b, coalesce(sum(case when itemname = "c" then itemvalue end), 0) as c from history;
select  hostid, t2.value as a, t3.value as b, t4.value as c from tabletest as t1;
select * from history;
select * from history_itemvalue_pivot;
create view history_extended as ( select history.*, case when itemname = "a" then itemvalue end as a, case when itemname = "b" then itemvalue end as b, case when itemname = "c" then itemvalue end as c from history select * from history_extended;
create view history_itemvalue_pivot as ( select hostid, sum(a) as a, sum(b) as b, sum(c) as c from history_extended select * from history_itemvalue_pivot;
create view history_itemvalue_pivot_pretty as ( select hostid, coalesce(a, 0) as a, coalesce(b, 0) as b, coalesce(c, 0) as c from history_itemvalue_pivot select * from history_itemvalue_pivot_pretty;
select cemetery.cemetery_id as "cemetery_id", group_concat(distinct(names.name)) as "cemetery_name", cemetery.latitude as latitude, cemetery.longitude as longitude, c.contact_info, d.direction_type, d.directions from cemetery ( select cemetery_contact.cemetery_id as cid, group_concat(contacts.name, char(32), phone.number) as contact_info from cemetery_contact ) as c on c.cid = cemetery.cemetery_id ( select cemetery_id as did, group_concat(direction_type.direction_type) as direction_type, group_concat(directions.value , char(13), char(9)) as directions from directions ) as d on d.did  = cemetery.cemetery_id;
select h.hostid, sum(ifnull(h.a,0)) as a, sum(ifnull(h.b,0)) as b, sum(ifnull(h.c,0)) as  c from ( select hostid, case when itemname = 'a' then itemvalue end as a, case when itemname = 'b' then itemvalue end as b, case when itemname = 'c' then itemvalue end as c from history;
select group_concat(distinct 'ifnull(sum(case when itemname = ''', itemname, ''' then itemvalue end),0) as `', itemname, '`' ) from history;
set @sql = concat('select hostid, ', @sql, ' from history;
set session group_concat_max_len = 1000000;
drop table if exists history;
create table history itemname varchar(5), itemvalue int);
(2,'c',40),(2,'d',5), (3,'a',14),(3,'b',67),(3,'d',8);
select hostid, sum( if( itemname = 'a', itemvalue, 0 ) ) as a, sum( if( itemname = 'b', itemvalue, 0 ) ) as b, sum( if( itemname = 'c', itemvalue, 0 ) ) as c from bob hostid;
select distinct concat('<th>',itemname,'</th>') as column_name_table_header from history order by 1;
select hostid from history order by 1;
select hostid from history group by hostid order by 1;
create table pivot_table;
select * from pivot_table;
create extension tablefunc;
create extension hstore;
select sal, rank() over(order by sal desc) as rank, dense_rank() over(order by sal desc) as denserank, row_number() over(order by sal desc) as rownumber from employee;
create table [dbo].#testtable( [id] [int] not null, [create_date] [date] not null, [info1] [varchar](50) not null, [info2] [varchar](50) not null, );
values (1, '1/1/09', 'blue', 'green') values (1, '1/2/09', 'red', 'yellow') values (1, '1/3/09', 'orange', 'purple') values (2, '1/1/09', 'yellow', 'blue') values (2, '1/5/09', 'blue', 'orange') values (3, '1/2/09', 'green', 'purple') values (3, '1/8/09', 'red', 'blue');
select * from #testtable;
select id, create_date, info1, info2, row_number() over (partition by id order by create_date desc) as rowid, rank() over(partition by id order by create_date desc)    as [rank] from #testtable;
select distinct;
select distinct v, row_number() over (order by v) row_number from t;
select distinct v, dense_rank() over (order by v) row_number from t;
select distinct;
select v, row_number() over (window) row_number, rank()       over (window) rank, dense_rank() over (window) dense_rank from t;
select item, name, sold, row_number() over(partition by item order by sold) as row from table_name;
as (select 1,1 union all select 1,1 union all select 1,1 union all select 1,2) select *, rank() over(partition by styleid order by id)       as 'rank', row_number() over(partition by styleid order by id) as 'row_number', dense_rank() over(partition by styleid order by id) as 'dense_rank' from   t;
alter table document modify column document_id int not null auto_increment;
alter table tbl_user modify column id int(10) auto_increment;
alter table yourtable drop column idcol alter table yourtable add idcol int identity(1,1);
alter table document;
create table emp( id varchar(20), ename varchar(20), salary float;
alter table emp modify column id int(10) auto_increment;
alter table document modify column id int(11) auto_increment;
alter table table_name modify column id datatype auto_increment;
alter table `document` modify column `document_id` int auto_increment;
alter table [table_name] modify column [column_name] [column_type] auto_increment;
alter table document modify column document_id int auto_increment;
alter table document modify column document_id int auto_increment primary key;
create table apim_log_request (transactionid varchar(50) default null);
alter table apim_log_request modify column transactionid int auto_increment;
alter table satellites modify column satelliteid int auto_increment primary key;
alter table satellites add id int identity constraint pk_yourtable primary key clustered;
set @id = 0 update satellites set @id = satelliteid = @id + 1;
alter table customers modify column customer_id bigint not null auto_increment;
set foreign_key_checks = 0;
set foreign_key_checks = 0;
alter table customers modify column customer_id bigint not null auto_increment;
set foreign_key_checks = 1;
alter table document modify column document_id int auto_increment;
alter table document alter column document_id int auto_increment;
alter table document modify column document_id int auto_increment;
alter table document modify document_id int auto_increment primary key;
alter table `document` modify column `document_id` int auto_increment;
alter table `document` modify `document_id` int auto_increment primary key;
alter table document;
alter table document;
end try if @@trancount > 0 end catch;
set xact_abort on;
end try if @@trancount > 0 end catch;
table "product": table "producttranslations";
select price, name, description from products where price < 100;
select p.price, pt.name, pt.description from products p join producttranslations pt where price < 100;
from _(products p) where price < 100");
select convert(int,@value);
select round(123.456, 2, 1);
select ceiling(@value),floor(@value);
select round(@value,2);
select 100.0019-(100.0019%.001);
select 123.456-(123.456%.001);
select cast((123.456-(123.456%.001)) as decimal (18,2));
select floor(71.950005666 * 10.0) / 10.0;
select cast(round(123.456,2,1) as decimal(18,2));
select @val = 123.456 select @val =  @val select @val;
select round(123.456, 2, 1)  will = 123.45 select round(123.456, 2, 0)  will = 123.46;
set @val = 123.456 select @val - round(@val,0,1);
select round(@val,0,1);
select @value as val, {fn truncate(@value, 2)} as result;
select round(@num-.005,2);
select truncate(max(lat_n),4) from station where lat_n < 137.23453;
select cast(value as decimal(10,2)) from table_name;
select cast(round(123.456,2,1) as decimal(18,2));
select round(235.415, 2, 1);
select round(235.415, 0, 1);
select cast(round(235.415, 0, 1) as int);
drop table if exists `role`;
create table `role` ( `id_role` bigint(20) unsigned not null auto_increment, `date_created` datetime, `date_deleted` datetime, `name` varchar(35) not null, `description` text, primary key (`id_role`) drop trigger if exists `role_date_created`;
create trigger `role_date_created` before insert set new.`date_created` = now();
create trigger `triggername` before insert on  `tablename` set new.datetimefield = now();
alter table `table_name` modify column `column_name` timestamp not;
create table foo ( creation_time      datetime default   current_timestamp, modification_time  datetime on update current_timestamp );
create table mytable ( mydate timestamp );
create table mytable ( mydate timestamp default current_timestamp );
alter table `table_name` modify `column_name` datetime not null default now();
alter table my_table modify created datetime(6) not null default now(6);
alter table my_table modify created datetime(6) not null default now();
alter table table_name;
create table `users` ( `id` int(11) not null auto_increment, `datecreated` datetime default current_timestamp, `dateupdated` datetime default current_timestamp on update current_timestamp, primary key (`id`), unique key `mobile_unique` (`mobile`);
select * from customers c and c.state = 'ny' and a.status = 1;
select * from customers c where c.state = 'ny' and a.status = 1;
select * from dbo.customers as cus where ord.orderdate >'20090515' select * from dbo.customers as cus and ord.orderdate >'20090515';
select * from dbo.customers as cus where ord.orderid is null;
select execquery.last_execution_time as [date time], execsql.text as [script] from sys.dm_exec_query_stats as execquery;
alter table parent_table engine=innodb;
create table `the_table` ( `id` int(11) not null,            /* no primary key index */ `name_fa` varchar(255) not null, `name_pa` varchar(255) not null alter table `the_table` add primary key (`id`), /* primary key index */ add unique key `uk_acu_donor_name` (`name`);
create table `the_table` ( `id` int(11) not null primary key,            /* <<== primary key index on creation */ `name_fa` varchar(255) not null, `name_pa` varchar(255) not null;
set foreign_key_checks=off;
alter table ... add constraint ... set foreign_key_checks=on;
constraint `fk_purchase_customer_id` foreign key (`customer_id`) references `customer` (`id`) on update cascade on delete cascade;
constraint `fk_purchase_customer_id` foreign key (`customer_id`) references `customer` (`id`) on update cascade on delete cascade;
table a has column id, type=bigint table b column referenced_id type varchar(this column gets the value from the id column of table a.) table a changeset: table b : referenced column type="varchar 50" table a : base column type ="varchar 255";
set @const = ( select top 1 'alter table' + your table name +' drop constraint '+name from sys.default_constraints a join sysconstraints b on a.parent_object_id = b.id where id = object_id('your table name') and col_name(id, colid)='column name' and objectproperty(constid,'isdefaultcnst')=1 ) exec (@const);
set @table_name = n'tablename' set @col_name = n'columnname' if exists (select       c.* from        sys.columns c where       t.name = @table_name and         c.name = @col_name) select @constraint=d.name from sys.tables t join sys.default_constraints d on d.parent_object_id = t.object_id join sys.columns c on c.object_id = t.object_id and c.column_id = d.parent_column_id where t.name = @table_name and c.name = @col_name if len(isnull(@constraint, '')) <> 0 set @sqlcmd = 'alter table ' + quotename(@table_name) + ' drop constraint' + exec (@sqlcmd);
alter table [table] drop constraint [constraint];
select @ery = (select bj.name from sys.tables as tb where tb.name = @tab and bj.type = 'pk');
default constraints or check constraints;
select t.name tablename, c.name columnname, d.name constraintname, d.definition constraintdefinition from sys.tables t join sys.check_constraints d  on d.parent_object_id = t.object_id join sys.columns c  on c.object_id = t.object_id and c.column_id = d.parent_column_id where t.name = n'roles2016.userscrm' and c.name = n'estado' select @cmd = 'alter table [' + @table_name +  '] drop constraint [' +  @constraint_name + ']' exec sp_executesql @cmd;
exec sp_helpconstraint 'mytable' --and look under constraint_name.;
create procedure [dbo].[removedefaultconstraints] @table_name nvarchar(256), @column_name nvarchar(256) as begin select @objectname = object_name([default_object_id]) from sys.columns where [object_id] = object_id(@table_name) and [name] = @column_name;
if @objectname is not null exec ('alter table '+@table_name+' drop constraint ' + @objectname) end end go exec [dbo].[removedefaultconstraints] n'[dbo].[user]', n'enabled' drop procedure [dbo].[removedefaultconstraints];
alter table  yourtablename drop constraint df__yourta__newco__47127295;
select 'alter table dbo.' + t.name + ' drop constraint '+ d.name from sys.tables t join sys.default_constraints d on d.parent_object_id = t.object_id join sys.columns c on c.object_id = t.object_id and c.column_id = d.parent_column_id where c.name in ('versioneffectivedate','versionenddate','versionreasondesc');
set @table_name = n'atablename' select @command = @command + 'alter table ' + @table_name + ' drop constraint ' + d.name + char(10)+ char(13) from sys.tables t join sys.default_constraints d on d.parent_object_id = t.object_id join sys.columns c on c.object_id = t.object_id and c.column_id = d.parent_column_id where t.name = @table_name and c.name in ('column1','column2','column3');
set @schema_name = n'schemaname' set @table_name = n'tablename' set @col_name = n'columnname' select @command = 'alter table [' + @schema_name + '].[' + @table_name + '] drop constraint ' + d.name from sys.tables t join sys.default_constraints d join sys.schemas s join    sys.columns c and c.column_id = d.parent_column_id where t.name = @table_name and s.name = @schema_name and c.name = @col_name;
select t.name tablename, c.name columnname from sys.columns c inner join if exists (select top(1) d.name from sys.tables t join sys.default_constraints d on d.parent_object_id = t.object_id join sys.columns c on c.object_id = t.object_id and c.column_id = d.parent_column_id where t.name = @table_name and c.name = @column_name) set @df_name = (select top(1) d.name from sys.tables t join sys.default_constraints d on d.parent_object_id = t.object_id join sys.columns c on c.object_id = t.object_id and c.column_id = d.parent_column_id where t.name = @table_name and c.name = @column_name) select @cmd = 'alter table [' + @table_name +  '] drop constraint [' +  @df_name + ']' exec sp_executesql @cmd;
select @objectname = object_name([default_object_id]) from sys.columns where [object_id] = object_id('[tableschema].[tablename]') and [name] = 'columnname';
set @table_name = n'department' set @col_name = n'modifieddate' select t.name, c.name, d.name, d.definition from sys.tables t join sys.default_constraints d on d.parent_object_id = t.object_id join sys.columns c on c.object_id = t.object_id and c.column_id = d.parent_column_id where t.name = @table_name and c.name = @col_name;
set @schema_name = n'myschema' set @table_name = n'department' set @col_name = n'modifieddate' select @command = 'alter table ' + @schema_name + '.[' + @table_name + '] drop constraint ' + d.name from sys.tables t join sys.default_constraints d on d.parent_object_id = t.object_id join sys.columns c on c.object_id = t.object_id and c.column_id = d.parent_column_id where t.name = @table_name and t.schema_id = schema_id(@schema_name) and c.name = @col_name;
select foo, bar, (event_id + 155) from table where event_id = "120";
create table temporary_table as select * from original_table where event_id="155";
update temporary_table set event_id="120";
update temporary_table set id=null drop table temporary_table;
create table temporary_table as select * from original_table where <conditions>;
update temporary_table set <fieldx>=<valuex>, <fieldy>=<valuey>, ...;
update temporary_table set <auto_inc_field>=null;
drop table temporary_table;
create temporary table temporary_table as select * from original_table where <conditions>;
update temporary_table set <auto_inc_field>=null, <fieldx>=<valuex>, <fieldy>=<valuey>, ...;
) select "155" from table where event_id = "120";
select foo, bar, "155" from table where event_id = "120";
select foo, bar, event_id+"155" from table where event_id = "120";
select * from table where event_id = "120" update #temp set column = "changed" select * from #temp;
alter table foobar_data modify column col varchar(255) not null default '{}';
alter table foobar_data change column col col varchar(255) not null default '{}';
alter table table_name alter column column_name set default 'literal';
alter table [table_name] drop constraint df_my_constraint;
alter table [table_name] add constraint df_my_constraint  default getdate() for column_name;
update foobar_data set col = '{}' where col is null;
alter table foobar_data modify column col varchar(255) not null default '{}';
alter table `table_name` change `column_name` `column_name` data_type  null default '';
alter table `drivers_meta` change `driving_license` `driving_license` varchar(30) null default '';
alter table tablename change column columnname2 columname2 datetime not null default current_timestamp;
alter table tablename alter column columnname1 drop default, alter column columnname2 dropt default;
alter table persons alter credit set default 0.0;
alter table `table name`;
alter table `your_table` change `property` `property`;
alter table table_name modify column_name varchar(40);
alter table "jobs"  alter column "job_title" set  data type varchar(30);
alter table table_name modify column column_name varchar (500);
alter table yourtable alter column yourcolumn <<new_datatype>> [null | not null];
alter table yourtable alter column yourcolumn varchar (500) not null;
alter table yourtable alter column yourcolumn varchar (500);
alter table ... alter column;
alter table yourtable alter column yourcolumn varchar (500) null;
alter table [progennet_dev].progen.le alter column ur_value_3 varchar(500);
alter table provider add primary key(person,place,thing);
alter table provider drop primary key, add primary key(person, place, thing);
alter table `mydatabase`.`provider` add constraint ck_per_place_thing_unique unique (person,place,thing);
alter table table_name add primary key (col_name1, col_name2);
alter ignore table table_name add uniques index idx_name(some_id, another_id, one_more_id);
alter table table_name drop primary key,add primary key (col_name1, col_name2);
alter table parent  drop column id;
and 2) alter table provider add primary key(person,thing,place);
select @sql += ' alter table ' + quotename(table_schema) + '.'+ quotename(table_name) +    ' nocheck constraint all; ' from   information_schema.tables where  table_type = 'base table' exec sp_executesql @sql;
select @sql += ' drop table ' + quotename(table_schema) + '.'+ quotename(table_name) + '; ' from   information_schema.tables where  table_type = 'base table' exec sp_executesql @sql;
select @sql += ' drop table ' + quotename(table_schema) + '.'+ quotename(table_name) from   information_schema.tables where  table_type = 'base table' exec sp_executesql @sql select @sql = @sql + 'drop view ' + quotename(schema_name(schema_id)) + '.' + from   sys.views v end close cur select @sql = @sql + n' drop function ' from sys.objects where type_desc like '%function%';
exec sp_executesql @sql;
drop database db_name create database db_name;
select @name = (select top 1 [name] from sysobjects where [type] = 'p' and category = 0 order by [name]) select @sql = 'drop procedure [dbo].[' + rtrim(@name) +']' exec (@sql) select @name = (select top 1 [name] from sysobjects where [type] = 'p' and category = 0 and [name] > @name order by [name]) end go select @name = (select top 1 [name] from sysobjects where [type] = 'v' and category = 0 order by [name]) select @sql = 'drop view [dbo].[' + rtrim(@name) +']' exec (@sql) select @name = (select top 1 [name] from sysobjects where [type] = 'v' and category = 0 and [name] > @name order by [name]) end go select @name = (select top 1 [name] from sysobjects where [type] in (n'fn', n'if', n'tf', n'fs', n'ft') and category = 0 order by [name]) select @sql = 'drop function [dbo].[' + rtrim(@name) +']' exec (@sql) select @name = (select top 1 [name] from sysobjects where [type] in (n'fn', n'if', n'tf', n'fs', n'ft') and category = 0 and [name] > @name order by [name]) end go select @name = (select top 1 table_name from information_schema.table_constraints where constraint_catalog=db_name() and constraint_type = 'foreign key' order by table_name) select @constraint = (select top 1 constraint_name from information_schema.table_constraints where constraint_catalog=db_name() and constraint_type = 'foreign key' and table_name = @name order by constraint_name) select @sql = 'alter table [dbo].[' + rtrim(@name) +'] drop constraint [' + rtrim(@constraint) +']' exec (@sql) select @constraint = (select top 1 constraint_name from information_schema.table_constraints where constraint_catalog=db_name() and constraint_type = 'foreign key' and constraint_name <> @constraint and table_name = @name order by constraint_name) end select @name = (select top 1 table_name from information_schema.table_constraints where constraint_catalog=db_name() and constraint_type = 'foreign key' order by table_name) end go select @name = (select top 1 table_name from information_schema.table_constraints where constraint_catalog=db_name() and constraint_type = 'primary key' order by table_name) select @constraint = (select top 1 constraint_name from information_schema.table_constraints where constraint_catalog=db_name() and constraint_type = 'primary key' and table_name = @name order by constraint_name) select @sql = 'alter table [dbo].[' + rtrim(@name) +'] drop constraint [' + rtrim(@constraint)+']' exec (@sql) select @constraint = (select top 1 constraint_name from information_schema.table_constraints where constraint_catalog=db_name() and constraint_type = 'primary key' and constraint_name <> @constraint and table_name = @name order by constraint_name) end select @name = (select top 1 table_name from information_schema.table_constraints where constraint_catalog=db_name() and constraint_type = 'primary key' order by table_name) end go select @name = (select top 1 [name] from sysobjects where [type] = 'u' and category = 0 order by [name]) select @sql = 'drop table [dbo].[' + rtrim(@name) +']' exec (@sql) select @name = (select top 1 [name] from sysobjects where [type] = 'u' and category = 0 and [name] > @name order by [name]) end go;
set @cnt = @cnt + 1;
exec sp_msforeachtable @command1 = "drop table ?" end;
select  'drop table [' + name + '];' from    sys.tables;
select @sql += ' drop table ' + quotename(table_schema) + '.'+ quotename(table_name) + '; ' from   information_schema.tables where  table_type = 'base table' exec sp_executesql @sql;
select @sql += ' drop table ' + quotename(s.name) + '.' + quotename(t.name) + '; ' from   sys.tables t join sys.schemas s where  t.type = 'u' exec sp_executesql @sql;
exec sp_msforeachtable "alter table ? nocheck constraint all";
select @sql += 'drop table ' + quotename([table_schema]) + '.' + quotename([table_name]) + ';' from [information_schema].[tables] where [table_type] = 'base table';
exec sp_executesql @sql;
select @sql += 'drop table ' + quotename([s].[name]) + '.' + quotename([t].[name]) + ';' from [sys].[tables] as [t] where [t].[type] = 'u' and [t].[is_ms_shipped] = 0;
exec sp_executesql @sql;
exec sp_msforeachtable 'alter table ? nocheck constraint all' select @sql = stuff((select '; ' + 'alter table ' + table_name  +'  drop constraint ' + constraint_name  from information_schema.constraint_table_usage order by constraint_name for xml path('')),1,1,'') exec sp_msforeachtable 'drop table ?';
exec sp_msforeachtable 'alter table ? nocheck constraint all' exec sp_msforeachtable 'delete from ?' set @cursor = cursor fast_forward for select distinct sql = 'alter table [' + tc2.table_name + '] drop [' + rc1.constraint_name + ']' from information_schema.referential_constraints rc1 exec sp_executesql @sql from @cursor into @sql end close @cursor deallocate @cursor exec sp_msforeachtable 'drop table ?' exec sp_msforeachtable 'alter table ? with check check constraint all';
exec sp_msforeachtable @command1 = "drop table ?";
exec sp_msforeachtable "alter table ? nocheck constraint all";
select concat('drop table ', table_name, ';') from information_schema.tables where table_schema = 'your_database_name';
create table #table(c1 int, c2 nvarchar(100) , c3 varchar(100) unique clustered (c1);
create nonclustered index ix1  on #table (c2,c3);
c1 int index ix1 clustered, /*single column indexes can be declared next to the column*/ index ix3 nonclustered(c1,c2) /*example composite index*/;
( c1 int null index ix unique where c1 is not null /*unique ignoring nulls*/ );
[id]   [int] not null primary key, [name] [nvarchar] (255) collate database_default null, unique nonclustered ([name], [id]) );
( a int null unique clustered, b int not null primary key nonclustered );
( a int null, b int null, c int null, uniqueifier int not null identity(1,1), unique clustered (a,uniqueifier) );
select a.*,b.* from aaaa a;
select x.a,x.b,x.c,(select orderqty from myns.getlastshipped(x.customerid)) as qty from xxxx   x;
create function myns.getlastshipped() ( saleorderid    int         not null, customerid      int         not null, orderdate       datetime    not null, orderqty        int         not null ) as begin select a.salesorderid, a.customerid, a.orderdate, b.orderqty from sales.salesorderheader a where a.orderdate = ( select max(sh1.orderdate) from sales.salesorderheader as sh1 where sh1.customerid = a.customerid ) end go;
select * from accounts;
select * from "accounts";
select * from accounts;
select * from "accounts";
set search_path to schema,public;
select * from "schemaname"."tablename";
select * from place.user_place;
set search_path to place;
select * from user_place;
select * from "table_name";
set search_path to <schema_name>;
create table "sf_bands" ( ... );
select * from sf_bands;  -- error!;
select * from "sf_bands";
set search_path to showfinder,public;
select * from my_schema.your_table;
then insert(employeeid, employeename) values(s.employeeid, s.employeename) then update set t.employeename = s.employeename then delete;
update po set po.purchaseorder_status = 'completed' from purchaseorder po where iod.purchaseorder_id is null;
select @resultcount = count(*) from itemsordered where purchaseorder_id = '@purchaseordered_id' and status = 'pending' if @resultcount > 0 update purchaseorder set purchaseorder_status = 'completed' where purchaseorder_id = '@purchaseorder_id';
if not exists(select top 1 fromfrom itemsordered where purchaseorder_id = '@purchaseordered_id' and status = 'pending' ) update purchaseorder set purchaseorder_status = 'completed' where purchaseorder_id = '@purchaseorder_id end;
if not exists(select top 1 fromfrom itemsordered where purchaseorder_id = '@purchaseordered_id' and status = 'pending' ) update purchaseorder set purchaseorder_status = 'completed' where purchaseorder_id = '@purchaseorder_id end;
select from t1 where s11 > any where not exists where row(5*t2.s1,77)=;
update purchaseorder set purchaseorder_status = 'completed' where purchaseorder_id = '@purchaseorder_id' and not exists (select * from itemsordered where purchaseorder_id = '@purchaseordered_id' and status = 'pending' );
update purchaseorder set purchaseorder_status = 'completed' where not exists (select 1 from itemsordered where itemsordered.purchaseorder_id = purchaseorder.purchaseordered_id and limit 1 );
update purchaseorder p left join itemsordered i and i.status = 'pending' set    p.purchaseorder_status = 'completed' where  p.purchaseorder_id = '@purchaseorder_id' and i.purchaseorder_id is null;
if exists(*your condition*) (*write your query*);
set @s = '' select @s = @s + city + ',' from locations select @s;
select [vehicleid] from [location] where (vehicleid = vehicle.vehicleid) from [vehicle];
select @employeelist = coalesce(@employeelist + ', ', '') + from salescallsemployees where salcal_uniqueid = 1;
if (value.isnull) return;
create function fnconcatvehiclecities(@vehicleid smallint) select @csvcities = coalesce(@csvcities + ', ', '') + coalesce(city,'') from vehicles where vehicleid = @vehicleid end  select vehicleid from vehicles;
select dbo.concatenate(column1 + '|') from table1;
(select ',' + column from table;
select stuff( (select n', ' + name from names for xml path(''),type);
select per.id, emails = json_value( replace( (select _ = em.email from email em where em.person = per.id for json path) ) from person per;
select vehicleid, city, row_number() over ( partition by vehicleid from locations -- concatenate locations using a recursive query -- for each vehicle, select the first location select vehicleid, convert(nvarchar(max), city) cities, rank from rankedlocations where rank = 1 union all  select c.vehicleid, (c.cities + ', ' + l.city) cities, l.rank from concatenations c -- this is a recursion! and l.rank = c.rank + 1 -- rank concatenation results by decrementing length select vehicleid, cities, row_number() over ( partition by vehicleid from concatenations ) select v.vehicleid, v.name, c.cities from vehicles v and c.rank = 1;
create function [dbo].[jointexts] ( @delimiter varchar(20) , @whereclause varchar(1) ) as begin select  @texts = coalesce(@texts + @delimiter, '') + t.texto from    sometable as t where   t.someothercolumn = @whereclause end go;
select dbo.jointexts(' , ', 'y');
select v.vehicleid, v.name, ll.locationlist from vehicles v (select distinct vehicleid, replace( replace( replace( ( select city as c from locations x where x.vehicleid = l.vehicleid for xml path('') '</c><c>',', ' '<c>','' '</c>', '' from locations l;
select table_name select ',' + column_name from information_schema.columns columns where tables.table_name = columns.table_name from information_schema.columns tables;
select [vehicleid] from [location] where (vehicleid = vehicle.vehicleid) from [vehicle];
alter table your_table drop constraint constraint_name;
alter table table_name add constraint constraint_name unique (column1, column2, ... column_n);
alter table tablename add constraint constraintname unique (columns);
create unique index constraint_name on table_name (columns);
select * from master.sys.sysprocesses where spid > 50 -- process spids < 50 are reserved by sql - we're not interested in these and dbid=db_id ('yourdbnamehere') alter database yourdbnamehere set read_only;
alter database appswiz set multi_user with rollback immediate;
alter database yourdbname set multi_user;
select @kill = @kill + 'kill ' + convert(varchar(10), spid) + '; ' from master..sysprocesses where spid > 50 and dbid = db_id('<your_db_name>') set deadlock_priority high alter database [<your_db_name>] set multi_user with no_wait alter database [<your_db_name>] set multi_user with rollback immediate;
alter database [<your_db_name>] set single_user;
alter database [tuncayoto] set multi_user with no_wait;
select @spid = min(spid) from master..sysprocesses where dbid = db_id('db_name') and spid != @@spid end;
select d.name, d.dbid, spid, login_time, nt_domain, nt_username, loginame from sysprocesses p where d.name = 'dbname' exec sp_dboption 'dbname', 'single user', 'false';
alter database bardabard set multi_user;
select d.name, d.dbid, spid, login_time, nt_domain, nt_username, loginame from sysprocesses p where d.name = 'dbname' exec sp_dboption 'dbname', 'single user', 'false';
select @kill = @kill + 'kill ' + convert(varchar(5), spid) + ';' from master..sysprocesses where dbid = db_id('<yourdbname>');
alter database [yourdatabasenamehere] set multi_user with no_wait;
create table demo ( iddemo    integer    not null primary key autoincrement create trigger trgdemoupd after update on demo begin update demo set where iddemo = new.iddemo;
create view if not exists vewdemo as select -- convert unix-times to datetimes so not every single query needs to do so from demo;
update demo set demovalue = demovalue || ' upd' where iddemo = 1; -- activate the update-trigger select * from    demo;                                            -- display raw audit values select * from vewdemo;                                            -- display automatic audit values;
create table test ( id integer primary key autoincrement, t real default (datetime('now', 'localtime'));
create table if not exists example ( id integer primary key autoincrement select id from example;
create table test ( id integer primary key autoincrement, t timestamp default current_timestamp;
create table whatever( .... ...;
select iif(exists(select * from thetable where thecolumn like 'thevalue%'), 1, 0);
select isnull((select top 1 1 from thetable where thecolumn like 'thevalue%'), 0);
select cast(count(*) as bit) from mytable where thecolumn like 'thevalue%';
select top 1 cast(numberkeycolumn as bit) from mytable where thecolumn like 'thevalue%';
select cast( case when exists(select * from thetable where thecolumn like 'thevalue%') then 1 else 0 end as bit);
select case when exists( select 1 from thetable where thecolumn like 'thevalue%' ) then 1 else 0 end;
create table table1 (col1   int null) select 'no items',convert(bit, (select count(*) from table1) )   -- returns 'no items', 0 select '1 item',convert(bit, (select count(*) from table1) )     --returns '1 item', 1 select '2 items',convert(bit, (select count(*) from table1) )    --returns '2 items', 1 drop table table1;
select distinct 1 from thetable where thecolumn like 'thevalue%';
select @b = isnull((select top 1 1 from @t where name = n'simon byorg'),0) select @b whentrue select @b = isnull((select top 1 1 from @t where name = n'anne droid'),0) select @b whenfalse;
select cast(iif(exists(select * from thetable where thecolumn like 'thevalue%'), 1, 0) as bit);
from 'c:\csvdata\schools.csv' ( format = 'csv', fieldquote = '"', firstrow = 2, fieldterminator = ',',  --csv field delimiter );
from 'c:\users\steve\downloads\yourfiletoimport.txt' firstrow = 2, (if skipping a header row) rowterminator   = '\n' );
update table set columnhavingdoublequotes = replace(columnhavingdoublequotes,'"','');
from 'c:\csvdata\schools.csv' ( firstrow = 2, fieldterminator = ',',  --csv field delimiter tablock );
update dbo.users set password = @password where userid = @userid;
if (bodyexpression.nodetype == expressiontype.convert && bodyexpression is unaryexpression) else {;
//which is good as we want to know about it;
if (!session.update(franchiseviewmodel.franchise, new[] "startdate";
where tentity: class if (bodyexpression.nodetype == expressiontype.convert else {;
if (entity== null) return notfound();
if (sp.getvalue(source) == null) return;
exec sp_executesql n'set nocount on;
update [user] set [someprop] = @p0 where [userid] = @p1;
select @@rowcount;
t2 idvalue, params updatewrapper<t>[] updatevalues) where t : class, new();
select * from `orders` where from_unixtime(order_ts) > date_sub(curdate(), interval 1 day);
select * from `your_table` where date(`your_datatime_field`)='2017-10-09';
select  * from    my_table where   date_column >= sysdate - 24/24;
select  * from    my_table where   date_column between (sysdate - 24/24) and sysdate;
select ... from ... where yourdatecolumn >= getdate()-1;
select  * from    mytable where   record_date >= now() - interval 1 day;
select  * from    mytable where   record_date >= dateadd(day, -1, getdate());
select  * from    mytable where   record_date >= sysdate - 1;
select  * from    mytable where   record_date >= now() - '1 day'::interval;
select  * from    mytable where   record_date >= getdate() - '1 day'::interval;
select  * from    mytable where   record_date >= datetime('now','-1 day');
select  * from    mytable where   record_date >= (now - 1);
select * from tablename where datecolumn >= dateadd(hour,-24,getdate());
select yourfields from yourtable where yourfieldwithdate > dateadd(dd,-1,getdate());
select * from table_name where table_name.the_date > date_sub(curdate(), interval 1 day);
select * from table_name where table_name.the_date > date_sub(now(), interval 24 hour);
select * from table_name where table_name.the_date > date_sub(now(), interval 10 minute);
select  * from    mytable where   order_date > dateadd(day, -1, getdate()) and order_date<=getdate();
select your rows.;
in ssms 2017 you need to ignore step 2 - the generate scripts options is at the top level of the context menu;
select * into sampleproducttracking_tabledump from sampleproducttracking;
exec dbo.dumpdatafromtable;
exec sp_configure 'ole automation procedures', 1; reconfigure with override;
select ... from;
if exists (select * from sys.objects where object_id = object_id(n'[dbo].[dumpdatafromtable]') and type in (n'p', n'pc')) drop procedure dbo.[dumpdatafromtable] set ansi_nulls on set quoted_identifier on create procedure [dbo].[dumpdatafromtable] ( @schemaname nvarchar(128) --= 'dbo' ) as begin set nocount on;
set @schemaname = replace(replace(@schemaname,'[',''),']','') set @tablename = replace(replace(@tablename,'[',''),']','') set @asfilename = nullif(@asfilename,'') set @asfilename = replace(@asfilename,'.','_') set @asfilename = coalesce(@pathout + @asfilename + '.sql', @pathout + @schemaname + isnull('_' + @tablename,n'') + '.sql') if @debugmode = 1 drop  procedure  prc_writereadfile exec  (@prc_writereadfile) set @prc_writereadfile = @filemode int -- recreate = 0 or append mode 1 ) as declare @oleresult int if @oleresult <> 0 begin end  if @filemode = 0 begin  -- create if @oleresult <> 0 begin end end else begin          -- append if @oleresult <> 0 begin end end  if @oleresult <> 0 begin end  if @oleresult <> 0 begin end  exec @hr = sp_oageterrorinfo null, @source out, @desc out select oleresult = @oleresult, hr = convert (binary(4), @hr), source = @source, description = @desc exec  (@prc_writereadfile) exec prc_writereadfile 0 /*create*/, '', @asfilename, '' select 1 as rn, c.ordinal_position from information_schema.columns c where 1 = 1 and c.table_schema = @schemaname and c.table_name = @tablename ) select @columnscast = ( select case when columntype in ('date','time','datetime2','datetimeoffset','smalldatetime','datetime','timestamp') then 'convert(nvarchar(1001), s.[' + columnname + ']' + ' , 121) as [' + columnname + '],' else 'cast(s.[' + columnname + ']' + ' as nvarchar(1001)) as [' + columnname + '],' end as 'data()' from stecolumns t2 where 1 =1 and t1.rn = t2.rn ) from stecolumns t2 where 1 =1 and t1.rn = t2.rn ) from stecolumns t1 if len(@columns) > 0 begin set @columns = substring(@columns, 1, len(@columns)-1);
set @columnscast = substring(@columnscast, 1, len(@columnscast)-1);
end  if @debugmode = 1 begin select @columnscast ,  @columns end  set @sql = ' select u.rn from (select ' ( columnvalue ' + char(13) + @columns ) and c.table_schema = '''+ @schemaname + ''' and c.table_name = ''' + @tablename +''' if @debugmode = 1 begin exec (@sql) end  if object_id('tempdb..#tmp') is not null drop table #tmp create table #tmp ( rn bigint ) set @sql = 'insert into  #tmp ' + char(13)  + @sql if @debugmode = 1 begin end  exec (@sql) select max(rn) +  1 from #tmp if @debugmode = 1 begin select * from #tmp end  select rn, columnposition, columntype, columnname, columnvalue from #tmp if @buildmethod = 1 set @sqlinsert = 'set nocount on;' + char(13);
exec prc_writereadfile 1 /*add*/, '', @asfilename, @sqlinsert set @sqlinsert = '' end else begin set @sqlinsert = 'set nocount on;' + char(13);
set @sqlinsert = @sqlinsert exec prc_writereadfile 1 /*add*/, '', @asfilename, @sqlinsert set @sqlinsert = null end  set @i = @rn if (@i <> @rn) -- is a new row if @buildmethod = 1 set @sqlinsert = 'insert into [' + @schemaname + '].[' + @tablename + '] (' end else begin if (@i <> @rn) -- is a new row set @sqlinsert = coalesce(@sqlinsert + ',','') +  '(' + @valuesinsert+ ')' exec prc_writereadfile 1 /*add*/, '', @asfilename, @sqlinsert set @sqlinsert = '' -- in method 2 we should clear script end end -- debug if @debugmode = 1 exec prc_writereadfile 1 /*add*/, '', @asfilename, @sqlinsert set @i = @rn set @columnsinsert = null set @valuesinsert = null end  if (@i = @rn) -- is same row set @columnsinsert = coalesce(@columnsinsert + ',','') + '[' + @columnname + ']' set @valuesinsert =  case then coalesce(@valuesinsert + ',','') + '' + isnull(rtrim(@columnvalue),'null') + '' else coalesce(@valuesinsert + ',','') + '''' + isnull(rtrim( -- escape single quote end end  if @debugmode = 1 end end close cur if @buildmethod = 1 end else begin set @sqlinsert = char(13) + ') as vtable ' exec prc_writereadfile 1 /*add*/, '', @asfilename, @sqlinsert set @sqlinsert = null end print 'done: ' + @asfilename end;
select * from b_db.dbo.b_table;
select * from a_db.dbo.a_table;
select `date`, concat('{',group_concat('{\"id\": \"',`product_id`,'\",\"name\": \"',`product_name`,'\"}'),'}') as `productsjson` from `buy` group by `date`;
select `date`,json_objectagg(concat('product-',`product_id`),json_object('id', `product_id`, 'name', `product_name`)) as `productsjson` from `buy` group by `date`;
select distinct(date) as date from buy order by date desc;
select * from buy group by date order by date desc;
select distinct( date ) as date from   buy;
select * from buy group by date,description;
select distinct `field1`, `field2`, `field3` from `some_table`  where `some_field` > 5000 order by `some_field`;
select * from `buy` group by date order by date desc;
select distinct date from buy order by date;
select distinct(date) as date from buy order by date desc;
select distinct(date) as date from buy order by date desc;
update [dbo].[jobtemplates] set [cycleid] = case [id] else 0 end where [id] in (1376,1385,1574,1576,1581,1585,1588,1589,1590,1591,1595);
select [id] else    0 end                as [cycleid] from [dbo].[productionqueueprocessautoclavenominals] where [queueid] = 3 [basedimensionid], [elastomertypeid], [id];
update [dbo].[productionqueueprocessautoclavenominals] set [cycleid] = x.[cycleid] from [dbo].[productionqueueprocessautoclavenominals] ( select min([id]) as [id],[queueid],[basedimensionid],[elastomertypeid],[cycleid] from ##ace1_pqpanominals_1 [queueid],[basedimensionid],[elastomertypeid],[cycleid];
update dbo.teststudents set     lastname =  case else lastname end where   lastname in ('aaa', 'ccc', 'eee');
('ccc','ddd'), ('eee','fff') update ts set lastname = toname from dbo.teststudents ts @todo t;
alter schema `<database name>`  default character set utf8mb4  default collate utf8mb4_unicode_ci (as rich said - utf8mb4);
alter table <some_table> convert to character set utf8mb4 collate utf8mb4_unicode_ci;
select count(*) from table ) select grade, count(*) / total * 100 from table;
select grade, countofgrade / sum(countofgrade) *100 from ( select grade, count(*) as countofgrade from grades;
select @countofall = count(*) from grades select grade,  count(*) / @countofall * 100 from grades;
select grade, count(*) / totalrows from (select grade, count(*) as totalrows from mytable) grades;
select grade, sum(partialcount) from (select grade, 1/count(*) as partialcount from mytable) grades;
select grade, gradecount / sum(gradecount) from (select grade, count(*) as gradecount from mytable;
select count(*) from mytable from mytable end;
select grade, count(id) * 100.0 / ((select count(id) from mytable) * 1.0) from mytable;
select grade, round(100.0 * grade_sum / (select count(*) from grades), 2) as pct_of_grades from (select grade, count(*) as grade_sum from grades );
create table grades ( id varchar(10) not null, grade char(1) not null check (grade matches '[abcdef]');
select grade, (count(grade)* 100 / (select count(*) from mytable)) as score from mytable;
select grade, 100. * count(*) / sum(count(*)) over () from table;
select grade, count(*) * 100.0 / sum(count(*)) over() from mytable;
select grade, count(*) * 100.0 / (select count(*) from mytable) from mytable;
as ( select grade, count(*) from mytable ) select grade, gradecount * 100.0/(select sum(gradecount) from t) from t;
select grade, gradecount / sum(gradecount) from (select grade, count(*) as gradecount from mytable;
select field1, cast(try_convert(float,(count(field2)* 100) / from table1;
select t1.ks, t1.[# tasks], coalesce(t2.[# late], 0) as [# late] from (select ks, count(*) as '# tasks' from table group by ks) t1 (select ks, count(*) as '# late' from table where age > palt group by ks) t2;
select * from (select ks, count(*) as '# tasks' from table group by ks) t1 (select ks, count(*) as '# late' from table where age > palt group by ks) t2;
select ks, count(*) as '# tasks' from table group by ks union select ks, count(*) as '# late' from table where age > palt group by ks;
select ks, count(*) as '# tasks' from table group by ks union all select ks, count(*) as '# late' from table where age > palt group by ks;
select ks, count(*) tasks, sum(case when age > palt then 1 end) late from table;
uploader_id,is_deleted,last_updated) select '4827499',pre_image_status,file_extension,reviewer_id, uploader_id,'0',last_updated from preliminary_image where style_id=4827488;
select `campaign_id`, `from_number`, 'example@domain.xyz', `received_msg`, `date_received`, 1502309889 from `received_txts` where `campaign_id` = '8';
select campaign_id, from_number, received_msg, date_received from `received_txts` where `campaign_id` = '8';
alter user <username> createdb;
alter user docker with createdb;
create user docker;
alter user docker with createdb;
create database djangodb;
from postgres:10.1-alpine;
if 'rds_db_name' in os.environ: 'name': os.environ['rds_db_name'], 'user': os.environ['rds_username'], 'password': os.environ['rds_password'], 'host': os.environ['rds_hostname'], 'port': os.environ['rds_port'], };
alter django with superuser;
'name': 'finance', 'user': 'django', 'test': { }, 'password': 'mydb123', 'host': '127.0.0.1', 'port': '', };
'name': 'myproject', 'user': 'chandan', 'password': 'root', 'host': 'localhost', 'port': '3306', 'test': { }, };
alter role miriam createdb;
alter role username createdb;
alter role username createdb;
'name': 'database_name', 'user': 'username', 'password': 'password', 'host': 'db', 'port': '3306', };
'engine': 'mysql.connector.django',   # 'django.db.backends.mysql' 'password': '<pass>', 'host': 'localhost', 'port': 3306, 'options': { }, 'test': { 'name': os.path.join(base_dir, 'db.sqlite3'), }, };
select * from tablename where results not in  ('null','{}');
select * from tablename where results is not null;
where length(stringexpression) > 0;
select ''::char(5) = ''::char(5)     as eq1;
select stringexpression from  ( values ('foo'::char(5));
select stringexpression from  ( values ('foo'::text);
where columnname is null;
where not exists();
where (case when columnname is null then true end);
union all select 0,0,1 union all select 0,1,0 union all select 0,1,1 union all select 1,0,0 union all select 1,0,1 union all select 1,1,0 union all select 1,1,1 ) select ctedata.*, case when then 'true' else 'false' end as result from ctedata;
where a1 or a2 and b,;
where a1 or (a2 and b);
where (a1 or a2) and b;
select case when @x=1 or @y=1 and @z=1 then 't' else 'f' end -- outputs t select case when (@x=1 or @y=1) and @z=1 then 't' else 'f' end -- outputs f;
where some_col in (1,2,3,4,5) and some_other_expr where ( some_col = 1 or ) and some_other_expr;
select date from blog;
select sum(no), hour(dateofissue) from tablename where dateofissue>='2011-07-30';
select sum(foo), date(mydate) from a_table group by date(a_table.mydate);
select sum(foo), date(mydate) dateonly from a_table group by dateonly;
select sum(foo), date(mydate) mydate from a_table group by mydate;
select category, count(*) as `num` from posts category;
create table if not exists app_user ( username varchar(45) not null, password varchar(450) not null, enabled integer not null default '1', primary key (username) );
create or replace function prc_create_sch_foo_table() returns void as $$ id serial not null, demo_column varchar not null, demo_column2 varchar not null, constraint pk_sch_foo primary key (id));
create index /* if not exists add for postgresql 9.5+ */ idx_sch_foo_demo_column on sch.foo(demo_column);
create index /* if not exists add for postgresql 9.5+ */ idx_sch_foo_demo_column2 on sch.foo(demo_column2);' where not exists(select * from information_schema.tables where table_schema = 'sch' and table_name = 'foo');
create or replace function execute(text) returns void as $$ select execute($$ create table sch.foo ( i integer ) where not exists ( select * from information_schema.tables where table_name = 'foo' and table_schema = 'sch';
create table if not exists myschema.mytable (i integer);
create or replace function create_mytable() if exists (select from pg_catalog.pg_tables where  schemaname = 'myschema' and    tablename  = 'mytable') then else create table myschema.mytable (i integer);
select create_mytable();        -- call as many times as you want.;
create or replace function create_if_not_exists (table_name text, create_stmt text) if exists ( select * from   pg_catalog.pg_tables where    tablename  = table_name else execute create_stmt;
select create_if_not_exists('my_table', 'create table my_table (id integer not null);');
create language plpgsql;
create or replace function create_table () returns text as $$ create table table_name ( i int select 'extended_recycle_bin created'::text;
select case when (select true::boolean from   pg_catalog.pg_tables where  schemaname = 'public' and    tablename  = 'table_name' else (select create_table()) drop function create_table();
select  * from    ( values (1, 2), (3, 4);
select  1 as col1, 2 as col2 union all select  3 as col1, 3 as col2;
select  level from    dual;
( select  1 union all select  l + 1 from    q where   l < @n ) select  l from    q;
select  l from    generate_series(1, $n) l;
select 1, 2, 3 union all select 4, 5, 6 union all select 7, 8, 9;
create table prop name varchar2(10), val varchar2(10), created timestamp, constraint pk_prop primary key(id) select extractvalue(value(r), '/r/id') id, extractvalue(value(r), '/r/name') name, extractvalue(value(r), '/r/val') val from (select xmltype(' table(xmlsequence(input.xml.extract('/rowset/r'))) r values ( p_new.id, p_new.name, p_new.val, systimestamp );
select * from dual;
select level,level+1,level+2 from dual connect by level <=3;
values (1,2,3), (4,5,6), (7,8,9);
select case when level = 1 then 'hi' then 'bye' end test from dual;
select * from xmltable ('$doc/rowset/row' passing xmlparse ( document ' "b" int path 'b/@val', "c" int path 'c/@val' ) as x;
select   top 3 2 as second, 3 as third from     any_table_in_your_database;
select 101 as c1, 102 as c2 from sysibm.sysdummy1 union all select 201 as c1, 202 as c2 from sysibm.sysdummy1 union all select 301 as c1, 302 as c2 from sysibm.sysdummy1;
select column_value as prods_code from table( sys.odcivarchar2list( 'prod1', 'prod2' ) ) ) select * from prods;
values (1,2), (3, 4);
select constants from (values ('foo@gmail.com'), ('bar@gmail.com'), ('baz@gmail.com')) as mytable(constants);
select (level - 1) * row_dif + 1 as a, (level - 1) * row_dif + 2 as b, (level - 1) * row_dif + 3 as c from dual;
select (level - 1) * 3 + 1 as a, (level - 1) * 3 + 2 as b, (level - 1) * 3 + 3 as c from dual;
select all * from ( values row (1, 2, 3), row (4, 5, 6), row (7, 8, 9);
from dbo.employees;
alter schema exe transfer dbo.employees;
create schema exe;
alter schema exe transfer dbo.employees;
create schema exe authorization [dbo] alter schema exe;
alter schema newschema transfer [oldschema].[tablename];
exec sp_rename 'nameofobject', 'renameofobject';
set @oldschema = 'dbo' set @newschema = 'exe' select @table = name from sys.tables where object_id in(select min(object_id) from sys.tables where  schema_name(schema_id)  = @oldschema) set @sql = 'alter schema ' + @newschema + ' transfer ' + @oldschema + '.' + @table end;
if (not exists (select * from sys.schemas where name = 'exe')) exec ('create schema [exe] authorization [dbo]') end;
alter schema exe;
( select * from mytable y as ( select * from x ) select * from y;
as ( select x, y, z from mytable where [base_condition] union all  select x, y, z from mytable m ) select * from y;
as ( select * from mytable where [base_condition] x as ( select * from y where [something_else] ) select * from x;
... b as( ... ) select * from a union all select * from b;
select employeeid, convert(varchar(900), concat('.', employeeid, '.')) as fullpath from employeehierarchywide where managerid is null union all  select ehw.employeeid, convert(varchar(900), concat(p.fullpath, ehw.employeeid, '.')) as fullpath from paths as p join employeehierarchywide as ehw on ehw.managerid = p.employeeid ) select * from paths order by fullpath;
( select * from [humanresources].[department] ( select * from [humanresources].[department] ) select * from cte_data,cte_data1;
--with b as ( select count(1) as _ct from c ) select case _ct when 1 then 1 else 0 end from b --doesn't work select case when count = 1 then 1 else 0 end as ct from (select count(1) as count from dual) union all select 100 as ct from dual ) select ct from a;
as ( select ps.process as processevent from dbo.tbl_some_table ps from dbo.tbl_some_table where process = 'some_extract_tbl' and convert(varchar(10), processstartdate, 112) < '29991231' cte_rls as ( select 'sample' as processevent, x.processstartdate, y.processenddate  from ( select 1 as id, ps.process as processevent from dbo.tbl_some_table ps from dbo.tbl_some_table where process = 'xx prcss' and convert(varchar(10), processstartdate, 112) < '29991231' select 1 as id, ps.process as processevent from dbo.tbl_some_table ps from dbo.tbl_some_table where process = 'yy prcss cmpltd' and convert(varchar(10), processenddate, 112) < '29991231';
create table [misc_info] ( [id] integer primary key identity not null, [key] nvarchar(450) unique not null, [value] nvarchar(max) not null );
create function [dbo].[checkkey] ( @key nvarchar(max) ) as begin if exists(select * from key_value where [key] = @key) set @res = 0 else set @res = 1 end;
create or replace;
select <values to be inserted> from dual where not exists (select from my_table where <identify data that you are trying to insert>);
table dropped. drop table foo;
table dropped. drop table foo;
create procedure;
select exists(select 1 from contact where id=12);
select 1 from user_right where userid = ? limit 1;
select true from tablename where condition limit 1;
select 1 from tbl where userid = 123 limit 1;
select userid, rightid, count from batch where not exists ( select * from target t2, batch b2 where t2.userid = b2.userid );
select userid, rightid, count from batch;
if found then else raise notice ' not found record id=%', i;
select exists(select 1 from contact where id=12);
create index index_contact on contact(id);
create table temp_test ( id serial primary key, sometext text, userid int, somethingtomakeitfail int unique ) ('bar', 2, 2), ('baz', 3, 3) select * from temp_test ('bar', 2, 5), ('baz', 3, 3)  -- <<--(deliberately simulate a failure) select * from temp_test;
select col1, col2, col3, case when condition then case when condition1 then case when condition2 then calculation1 else calculation2 end else case when condition2 then calculation3 else calculation4 end end else case when condition1 then case when condition2 then calculation5 else calculation6 end else case when condition2 then calculation7 else calculation8 end end as 'calculatedcol1', col4, col5 -- etc from table;
select  datediff(dd,invdate,'2009/01/31')+1 as daysold, case when datediff(dd,invdate,'2009/01/31')+1 >150 then 6 else case when datediff(dd,invdate,'2009/01/31')+1 >120 then 5 else case when datediff(dd,invdate,'2009/01/31')+1 >90 then 4 else case when datediff(dd,invdate,'2009/01/31')+1 >60 then 3 else case when datediff(dd,invdate,'2009/01/31')+1 >30 then 2 else case when datediff(dd,invdate,'2009/01/31')+1 >30 then 1 end end end end end end as bucket from rm20090131atb;
case when condition1 = true and condition2 = true then calculation1 else 'what so ever' end,;
case when a = 1 and b = 1 and c = 1 then '1' else '0' end,;
select col1, col2, col3, case when condition1 then calculation1 else null end as 'calculatedcol1', col4, col5 -- etc from table;
select col1, col2, col3, case when condition1 then calculation1 end as 'calculatedcol1', col4, col5 -- etc from table;
select distinct t_outer.section_id, t_top.id, t_top.name from t t_outer join lateral ( select * from t t_inner where t_inner.section_id = t_outer.section_id limit 2;
select  x.* from    ( select  section_id, coalesce ( ( select  xi from    xxx xi where   xi.section_id = xo.section_id name, id ( select  xi from    xxx xi where   xi.section_id = xo.section_id name desc, id desc limit 1 ) from    ( select  distinct section_id from    xxx join    xxx x and (x.name, x.id) <= ((mlast).name, (mlast).id);
select x1.id from xxx x1 ) select this.* from xxx this join rnk on rnk.id = this.id where rnk.rnk <=2 select this.* from xxx this join ( select x1.id from xxx x1 where rnk.rnk <=2;
select * from ( select row_number() over (partition by section_id order by name) as r, t.* from xxx t) x where x.r <= 2;
select * from xxx a where ( select count(*) from xxx where section_id = a.section_id and name <= a.name;
select phone, case when phone2 = '' then 'na' end as phone2 else isnull(phone2,0) from jewishyellow.users  where phone like '813%';
select phone, phone2 from jewishyellow.users where phone like '813%' and phone2<>'';
select phone, phone2 from jewishyellow.users where phone like '813%' and phone2 is not null;
select phone, phone2 from jewishyellow.users where phone like '813%' and (phone2 <> "");
select phone, phone2 from jewishyellow.users where phone like '813%' and trim(ifnull(phone2,'')) <> '';
select t.phone, t.phone2 from jewishyellow.users t where t.phone like '813%' and t.phone2 is not null;
select phone from users where phone like '813%' and trim(coalesce(phone2, '')) <>'';
select * from `db_name` where `column_name` like '%*%';
select phone, phone2 from users where phone like '813%' and char_length(phone2) > 0;
where ord(field_to_check) > 0;
select t.phone, t.phone2 from jewishyellow.users t where t.phone like '813%' and t.phone2 > '';
select if(null > '','true','false');-- false select if('' > '','true','false');-- false select if(' ' > '','true','false');-- false select if('\n' > '','true','false');-- false select if('\t' > '','true','false');-- false select if('yeet' > '','true','false');-- true;
select t.phone, t.phone2 from jewishyellow.users t where t.phone like '813%' and t.phone2 like '[0-9]';
select datepart(hour, getdate());
select * from table001 where datepart(hh,datetime) like 23;
select {fn hour(getdate())} as hour;
select run_time_hour = case datepart(hour, r.date_schedule) else convert(varchar, datepart(hour, r.date_schedule)-12) + 'pm' end from dbo.archive_run_schedule r;
select case when [am or _pm] ='pm' and datepart(hour,time_received)<>12 then dateadd(hour,12,time_received) else time_received end from table;
select convert(char(8),getdate(),108);
select convert(time,getdate());
select itemid, count(*) as ordercount, row_number over (partition by itemid order by rank desc) as rank from orders;
select @r := @r+1 , z.* (select @r:=0)y;
select @r := @r+1 , z.* select itemid, count(*) as ordercount from orders (select @r:=0)y;
select @rank:=@rank+1 as rank, itemid, count(*) as ordercount from orders select @rank;
select 0 into @x;
select itemid, count(*) as ordercount, (@x:=@x+1) as rownumber from orders;
select @rn:=@rn+1 as rank, itemid, ordercount from ( select itemid, count(*) as ordercount from orders;
select table_name, column_name, data_type, data_length from user_tab_columns where table_name = 'mytable';
select column_name as column_name, nullable || '       ' as be_null, substr(data_type || '(' || data_length || ')', 0, 10) as type from all_tab_columns where table_name = 'tablename';
select [name] as [column name] from syscolumns where id = (select id from sysobjects where type = 'v' and [name] = 'your table name');
select top 0 from posts;
select a.column_name, a.* from all_tab_columns a where table_name = 'your table name' and a.column_name = 'column name' and a.owner = 'schema';
select * from   information_schema.columns where  table_name = 'table_name';
select column_name,* from information_schema.columns where table_name = 'yourtablename';
select column_name from information_schema.columns where table_schema = 'schema' and table_name = 'table_name';
select column_name from user_tab_cols where table_name=upper('tablename');
select [name] as [column name] from syscolumns where id = object_id('table_name');
select * from product where 1 != 1;
select * from <table name> where rownum = 1;
select column_name 'all_columns' from information_schema.columns where table_name='user';
select columnname from dbc.columns where databasename='dbase_name' and tablename='table_name';
select * from sys.all_columns c join sys.objects o on c.object_id=o.object_id where o.name = 'tablename' and c.name like '%column name%';
select t.name as table_name, schema_name(schema_id) as schema_name, c.name as column_name from sys.tables as t where c.name like '%%' --if you want to find specific column write here;
select column_name from yourdatabase.information_schema.columns where table_name = 'yourtablename';
if (!$result) { if (mysql_num_rows($result) > 0) {;
select coalesce(mycolumn, 0 ) from mytable;
update tablename set columnname= isnull(columnname, 0 ) where id = 10;
select isnull(mycolumn, 0 ) from mytable;
sum(case when c.runstatus = 'failed' then 1 else 0 end) as failed, sum(case when c.runstatus = 'cancelled' then 1 else 0 end) as cancelled,;
select coalesce(sum(case when c.runstatus = 'succeeded' then 1 end), 0) as succeeded;
select c.rundate, sum(case when c.runstatus = 'succeeded' then 1 else 0 end) as succeeded, sum(case when c.runstatus = 'failed' then 1 else 0 end) as failed, sum(case when c.runstatus = 'cancelled' then 1 else 0 end) as cancelled, count(*) as totalrun from ---cast(run_date as datetime) from msdb.dbo.sysjobs as a(nolock) inner join msdb.dbo.sysjobhistory as b(nolock) where a.name='ai' and b.step_id=0) as c c.rundate;
select isnull(col1, 0 ) from table1 select coalesce(col1, 0 ) from table1;
create table #demo ( col1 integer null, col2 as coalesce(col1, 0) primary key, col3 as isnull(col1, 0);
create table #demo ( col1 integer null, col2 as coalesce(col1, 0), col3 as isnull(col1, 0) primary key;
update tbl_name set fild_name = value where fild_name is null;
sum(case when c.runstatus = 'failed' then 1 else 0 end) as failed, sum(case when c.runstatus = 'cancelled' then 1 else 0 end) as cancelled,;
create table my_table ( column_a integer not null, column_b integer not null, column_c varchar(50), primary key (column_a, column_b);
create table usergroup ( [user_id] int not null, [group_id] int not null constraint pk_usergroup primary key nonclustered ([user_id], [group_id]) );
alter table table_name add constraint [name of your pk, e.g. pk_tablename] primary key clustered (column1, column2, etc.);
alter table [tablename] add unique ([column1], [column2], [column3]);
create table usergroup ( [user_id] int foreign key, [group_id] int foreign key,  );
create table usrgroup( usr_id int foreign key references users(id), grp_id int foreign key references groups(id),  );
create table usrgroup( usr_id int, grp_id int,  constraint fk_usrgroup_usrid foreign key (usr_id) references users(id), constraint fk_usrgroup_groupid foreign key (grp_id) references groups(id),  constraint pk_usrgroup primary key (usr_id,grp_id) );
set @today=getdate() --date will equal today select * from table_name where created <= @today;
select * from users where date(date_time) > '2010-10-10';
select * from users where created > concat(curdate(), ' 23:59:59');
select * from users where created >= concat(curdate(), ' 00:00:00') and;
select * from users where created between;
select * from users where created < date_add(curdate(), interval 1 day);
select * from table_name where concat( substring(json_date, 11, 4 ) ,  '-', substring( json_date, 7, 2 ) ,  '-', substring(json_date, 3, 2 ) ) >= now();
select * from users where created >= now();
select * from users where created >= curdate();
select * from users where created >= now();
select * from mytable where  date(mydate) = date(now());
select * from users where created >= current_timestamp;
select 'insert into ' || tablename || ' values( ' ||;
select * from mytable;
select * from mytable;
from os import path table = table[0];
if 'id' in column_names:;
alter table user_customer_permission modify id int not null;
alter table user_customer_permission drop primary key;
alter table user_customer_permission modify id int not null primary key auto_increment;
alter table `user_customer_permission` modify `id` int;
alter table `user_customer_permission` drop primary key;
alter table  `user_customer_permission` drop primary key , add primary key (  `id` );
drop primary key , add primary key (;
alter table table_name drop primary key,add primary key (col_name1, col_name2);
alter table `table_name` add primary key( `column_name`);
alter table table_name add primary key (column_name);
alter table table_name drop primary key;
select user_id , count(*) count from payment account, user_id , date having count(*) > 1;
select user_id, account_no , date, count(*) from (select distinct account_no , zip, date from payment )  account_no ,  having count(*) > 1;
as ( select user_id, zip, count(*) as tally from payment ) select distinct * from payment as p where exists ( select * from payment_tallies as pt where p.user_id = pt.user_id and pt.tally > 1;
create table payment( user_id int(11), account int(11) not null, zip int(11) not null, dt date not null (1,123,66666,'2009-12-12'), (1,123,77777,'2009-12-13'), (2,456,77777,'2009-12-14'), (2,456,77777,'2009-12-14'), (2,789,77777,'2009-12-14'), (2,789,77777,'2009-12-14');
select foo.user_id, foo.cnt from where foo.cnt > 1;
select column_name from table_name having count(column_name) = 1;
select * from @d;
exec uspwhatever @param=@p1;
exec sp_select 'tempdb..#mytemptable';
select count(*) from mytable;
select row_number() over (order by id) as rownumber, field1, field2, field3 from user;
select us.id from (select row_number() over (order by id) as row, id from user ) us where row = currentrow - 5;
select num, username from from users) as numbered where username='joe';
select count(*);
select count(*);
select rows from sysindexes where id = object_id('table_name') and indid < 2;
select row_number() over (order by id) as rownum from table_name ) select max(rownum) from temp;
select name, row_number() over (order by id) as rownum from table_name ) select rownum from temp where name like 'matt';
select top 1 row_number() over (order by id) from users;
select * from ( select row_number() over (order by createtime desc) as rowindex,* from tablename ) tb where tb.rowindex between 0 and 10;
select *, row_number() over (order by (select 100)) as any_id from #any_table;
select row_number() over(order by userid) from users where username='joe';
select top(1) * , row_number() over(order by userid) as rownum from     users where    username = 'joe';
select salesordernumber, customerid, subtotal, row_number() over (partition by customerid order by subtotal desc) rn from sales.salesorderheader;
select salesordernumber, customerid, count(*) over (partition by customerid) customerordercount from sales.salesorderheader;
select * from table where username='joe';
select ml.hid, ml.blockid, row_number() over (partition by ml.blockid order by ml.hid desc) as rownumber, h.hname from mit_leadbechmarkhamletwise ml join [mt.hamle] h on ml.hid=h.hid;
if not exists (select * from sysobjects where name='cars' and xtype='u') create table cars ( name varchar(64) not null );
alter table the_table add constraint constraint_name unique (column1, column2);
alter table foo add unique (thecolumn);
alter table the_table add constraint constraint_name unique (thecolumn);
select * from table1 where table1.principal not in (select principal from table2);
select table1.* from table1 left join table2 on table2.principal=table1.principal where table2.principal is null;
select table1.* from table1 where table2.name is null and table3.name is null;
select c from t1 left join t2 using (c) where t2.c is null;
select c from t1 where c not in (select c from t2);
select c from t1 where c <> any (select c from t2);
create trigger before_jobs_delete delete from advertisers where advertiser_id=old.advertiser_id;
set foreign_key_checks=0; -- to disable them delete from `jobs` where `job_id` = 1 limit 1 set foreign_key_checks=1; -- to re-enable them;
set foreign_key_checks=off; //disabling foreign key set foreign_key_checks=on; // enabling foreign key;
alter table `advertisers` drop foreign key `advertisers_ibfk_1`;
alter table `advertisers` add constraint `advertisers_ibfk_1` foreign key (`advertiser_id`) references `jobs` (`advertiser_id`);
alter table `advertisers` add constraint `advertisers_ibfk_1`;
alter table `jobs` add foreign key (`advertiser_id`) references `advertisers` (`advertiser_id`);
alter table `jobs` add constraint `advertisers_ibfk_1`;
alter table `advertisers` add constraint `advertisers_ibfk_1`;
alter table `advertisers` add constraint `advertisers_ibfk_1` foreign key (`advertiser_id`);
alter table `jobs` add constraint `advertisers_ibfk_1` foreign key (`advertiser_id`);
alter table 'jobs' add constraint `advertisers_ibfk_1` foreign key (`advertiser_id`) references `advertisers` (`advertiser_id`);
set foreign_key_checks=0; -- to disable them set foreign_key_checks=1; -- to re-enable them;
set @old_foreign_key_checks=@@foreign_key_checks, foreign_key_checks=1;
set @old_foreign_key_checks=@@foreign_key_checks, foreign_key_checks=1;
delete from `jobs` where `job_id` =1 limit 1;
create table table1(mostselective char(800), secondmost tinyint, least  char(1), filler char(4000) null);
create table table2(mostselective char(800), secondmost tinyint, least  char(1), filler char(4000) null);
create nonclustered index myindx on table1(mostselective,secondmost,least);
create nonclustered index myindx2 on table2(least,secondmost,mostselective);
select top 26 replicate(char(number + 65),800), number/5, '~' from master..spt_values where type = 'p' and number >= 0;
select * from   table1 where  mostselective = replicate('p', 800) and secondmost = 3 and least = '~';
select * from   table2 where  mostselective = replicate('p', 800) and secondmost = 3 and least = '~';
select * ... where  mostselective = 'p' select * ...where least = '~';
select mostselective, secondmost, least from   table2 where  least = '~' mostselective;
where deleted = 0  and  the_datetime > now() - interval 7 day;
create table scores ( user_id int, score int ) select t.range as [score range], count(*) as [number of occurences] from ( select user_id, case when score >= 0 and score < 10 then '0-9' case when score >= 10 and score < 20 then '10-19' else '90-99' as range from scores) t;
select cast(score/10 as varchar) + '-' + cast(score/10+9 as varchar), count(*) from scores;
select (score/10)*10 || '-' || (score/10)*10+9 as scorerange, count(*) from scores;
set @rangewidth = 10 select floor(score/@rangewidth) as lowerbound, floor(score/@rangewidth)+@rangewidth as upperbound, count(*) from scoretable floor(score/@rangewidth);
select t.range as [score range], count(*) as [number of occurences] from ( select case else '90-99' end as range from scores) t;
select [score range] = cast((score/10)*10 as varchar) + ' - ' + cast((score/10)*10+9 as varchar), [number of occurrences] = count(*) from #scores;
select t.range as [score range], count(*) as [number of occurences] from ( select case else '20-99' end as range from scores) t;
select t.range as [score range], count(*) as [number of occurrences] from ( select user_id, case when score >= 0 and score< 10 then '0-9' else '20-99' end as range from scores) t;
select range as [score range], count(*) as [number of occurences] from ranges r inner join scores s on s.score between r.lowerlimit and r.upperlimit;
select t.blah as [score range], count(*) as [number of occurences] from ( select case else '90-99' end as blah from scores) t;
select t.range as scorerange, count(*) as numberofoccurrences from (select case else '20-99' end as range from scores) t;
select t.range as scorerange, count(*) as numberofoccurrences from (select case else '100-999' end as range from scores) t;
select t.range as [score range], count(*) as [number of occurences] from ( select floor(score/10) as range from scores) t;
select concat(range,'-',range+9), count(range) from ( select score - (score % 10) as range from scores );
select (str(range) + "-" + str(range + 9) ) as [score range], count(score) as [number of occurances] from (select  score,  int(score / 10 ) * 10  as range  from scoredata );
select t.range as score, count(*) as count from ( select userid, case when isnull(score ,0) >= 0 and isnull(score ,0)< 5 then '0-5' else ' 20+' end as range else 5  end as pd from score table;
select --min(score), max(score), [score range] = cast(round(score-5,-1)as varchar) + ' - ' + cast((round(score-5,-1)+10)as varchar), [number of occurrences] = count(*) from order;
select fielda...fieldn from mytable;
select ... into;
as (select /*... rest of cte definition removed for clarity*/) select eventid, eventstartdate, eventenddate, planneddate                   as [eventdates], cast(planneddate as datetime) as dt, cast(eventstarttime as time)  as st, cast(eventendtime as time)    as et, eventtitle, eventtype from   calendar where  ( planneddate >= getdate() ) and ',' + eventenumdays + ',' like '%,' + cast(datepart(dw, planneddate) as char(1)) + ',%' or eventenumdays is null planneddate;
create table #temp ( eventid int, eventtitle varchar(50), eventstartdate datetime, eventenddate datetime, eventenumdays int, eventstarttime datetime, eventendtime datetime, eventrecurring bit, eventtype int );
as (select /*...*/) select eventid, eventstartdate, eventenddate, planneddate as [eventdates], cast(planneddate as datetime) as dt, cast(eventstarttime as time) as st,cast(eventendtime as time) as et, eventtitle where (planneddate >= getdate()) and ',' + eventenumdays + ',' like '%,' + cast(datepart(dw, planneddate) as char(1)) + ',%' or eventenumdays is null;
drop table #temp end;
select      eventname, count(eventname) as 'counts' from        tblevent where       eventname like 'a%';
create table #mytemptable ( employeeid int;
select employeeid from [employeemaster] where employeeid between 1 and 100;
select employeeid from #mytemptable;
drop table #mytemptable;
select * into #temp from ( select optionno, optionname from options where optionactive = 1;
select table1.id, table2.id from table1 left outer join table2 on table1.id=table2.id;
select suspreason, siteid from( select susp.susp_visits.suspreason, susp.susp_visits.siteid, row_number() from susp.susp_visits where rn=1;
select susp.susp_visits.suspreason, susp.susp_visits.siteid from susp.susp_visits where exists( select data.dim_member where susp.susp_visits.memid = data.dim_member.membershipnum );
select * from `table` where str_to_date(mydate, '%d/%m/%y') < curdate() - interval 30 day and str_to_date(date, '%d/%m/%y') > curdate() - interval 60 day select * from `table` where str_to_date(mydate, '%d/%m/%y') < curdate() - interval 7 day and str_to_date(date, '%d/%m/%y') > curdate() - interval 14 day;
select datediff('2010-10-08 18:23:13', '2010-09-21 21:40:36') as days;
select (end_time - start_time) from t; -- return in millisecond select (end_time - start_time)/1000 from t; -- return in second;
--else it could produce wrong results set @startdate = '2013-12-30' --birthdate set @enddate  = getdate()            --current datetime select @years = datediff(year,@startdate,@enddate) select @monthoverflow = case when datediff(month,@startdate,@enddate) - select @years = case when @monthoverflow < 0 then @years-1 else @years end select @months =  datediff(month,@startdate,@enddate) - (@years * 12) select @lastdayofmonth =  datepart(d,dateadd select @days = case when @monthoverflow<0 and then @lastdayofmonth + else datepart(d,@enddate) - datepart(d,@startdate) end select @months=case when @days < 0 or day(@startdate)> day(@enddate) then @months-1 else @months end set @lastdayasondate = datepart(d,dateadd(s,-1,dateadd(mm, datediff(m,0,@enddate),0)));
set @lastdaybirthdate =  datepart(d,dateadd(s,-1,dateadd(mm, datediff(m,0,@startdate)+1,0)));
if (@days < 0) ( select @days = case when( @lastdaybirthdate > @lastdayasondate) then else @lastdayasondate + @days end );
select timestampdiff(hour,now(),'2013-05-15 10:23:23') select datediff('2012-2-2','2012-2-1') select to_days ('2012-2-2')-to_days('2012-2-1');
select timediff('2007-12-31 10:02:00','2007-12-30 12:01:01');
select timestampdiff(second,'2007-12-30 12:01:01','2007-12-31 10:02:00');
select unix_timestamp('2007-12-30 00:00:00') -;
select to_char(trunc(sysdate)+(to_date( '31-may-2012 12:25', 'dd-mon-yyyy hh24:mi') 'hh24:mi:ss') from dual;
select datedifference(date1, date2) from .... create function datedifference(date1 date, date2 date) returns date if datediff(date1, date(concat(year(date1),'-', month(date1), '-', day(date2)))) < 0    then set dif=date_format( concat( period_diff(date_format(date1, '%y%m'),date_format(date2, '%y%m'))div 12 , '-', period_diff(date_format(date1, '%y%m'),date_format(date2, '%y%m'))% 12 , '-', datediff(date1, date(concat(year(date1),'-', month(date_sub(date1, interval 1 month)), '-', day(date2))))), '%y-%m-%d');
set dif=date_format( concat( period_diff(date_format(date1, '%y%m'),date_format(date2, '%y%m'))div 12 , '-', period_diff(date_format(date1, '%y%m'),date_format(date2, '%y%m'))% 12 , '-', datediff(date1, date(concat(year(date1),'-', month(date1), '-', day(date2))))), '%y-%m-%d');
else set dif=date_format( concat( period_diff(date_format(date1, '%y%m'),date_format(date2, '%y%m'))div 12 , '-', period_diff(date_format(date1, '%y%m'),date_format(date2, '%y%m'))% 12 , '-', datediff(date1, date(concat(year(date1),'-', month(date1), '-', day(date2))))), '%y-%m-%d');
select timestampdiff(second,'2018-01-19 14:17:15','2018-01-20 14:17:15');
select ( datediff('1993-02-20','1993-02-19')*( 24*60*60) )as 'seccond';
select , ( 3959 acos( cos( radians('28.5850154') ) cos( radians(lat) ) cos( radians( lng ) - radians('77.07207489999999') ) + sin( radians('28.5850154') ) * sin( radians( lat ) ) ) ) as distance from `wo_products` where `active` = '1' having distance < 5;
set @slat = 38.150785 set @slon = 27.360249 select top 10 [latitude], [longitude], sqrt( power(69.1 * ([latitude] - @slat), 2) + from [table] order by 3;
select *, st_distance_sphere( point ('input_longitude', 'input_latitude'), point(longitude, latitude)) * .000621371192 as `distance_in_miles` from `tablename` having `distance_in_miles` <= 'input_max_distance';
select (atan( sqrt( pow(cos(radians(users.location_lat)) * sin(radians(users.location_long) - radians(-99.165660)), 2) + ) sin(radians(19.391124)) * users.id from users;
create table `markers` ( `id` int not null auto_increment primary key , `name` varchar( 60 ) not null , `address` varchar( 80 ) not null , `lat` float( 10, 6 ) not null , `lng` float( 10, 6 ) not null;
select id, ( 3959 * from markers having distance < 28;
select id, ( 3959 * from markers having distance < 29 and distance > 28;
select m.name, m.lat, m.lon, p.distance_unit from <table_name> as m join ( select <userlat> as latpoint, <userlon> as longpoint, 50.0 as radius, 111.045 as distance_unit where m.lat between p.latpoint  - (p.radius / p.distance_unit) and p.latpoint  + (p.radius / p.distance_unit) and m.lon between p.longpoint - (p.radius / (p.distance_unit * cos(radians(p.latpoint)))) and p.longpoint + (p.radius / (p.distance_unit * cos(radians(p.latpoint))));
set @my_lat=34.6087674878572;
set @my_lng=58.3783670308302;
set @dist=10; #10 miles radius select dest.id, dest.lat, dest.lng,  3956 * 2 * asin(sqrt(power(sin((@my_lat -abs(dest.lat)) * pi()/180 / 2),2) + cos(@my_lat * pi()/180 ) * cos(abs(dest.lat) *  pi()/180) * power(sin((@my_lng - abs(dest.lng)) *  pi()/180 / 2), 2)) from hotel as dest having distance < @dist;
as distance from $tablename where and ($origlon+$dist/cos(radians($origlat))*69) and latitude between ($origlat-($dist/69)) and ($origlat+($dist/69)) having distance < $dist order by distance limit 100";
'host'      => "localhost", 'user'      => "root", 'pass'      => "password";
select * from location;
select latitude, longitude, sqrt( pow(69.1 * (latitude - [startlat]), 2) + from tablename having distance < 25 order by distance;
set @orig_lat=37.46;
set @orig_long=-122.25;
set @bounding_distance=1;
select * from `cities` where ( `lat` between (@orig_lat - @bounding_distance) and (@orig_lat + @bounding_distance) and `long` between (@orig_long - @bounding_distance) and (@orig_long + @bounding_distance) ) limit 25;
select * from `waypoints` w order by;
select case colour_txt else 0 end as pass_flag;
select id,stud_name, case when marks <= 40 then 'bad' else 'best' end as grade from result;
select itemsreq.item as item, itemsreq.cantidad as cantidad, (case  when itemsreq.itemaprobado=1 then 'aprobado' (case then case when requisiciones.recibida is null  then 'item no aprobado para entrega' end then case when requisiciones.recibida is null then 'item aun no recibido' end end) as recibida from itemsreq;
case when 1=1       //if then when 1=1              //else if then else                      //else end;
select   url='', p.artno, p.[description], p.specification, case when 1 = 1 or 1 = 1 then 1 then 2 then 3 else 0 end as qty, p.netprice, [status] = 0 from  product p (nolock);
case when first_condition then first_condition_result_true else case when second_condition then second_condition_result_true else second_condition_result_false end end end as qty;
case  when col1 = 1 or col3 = 1  then 1 else 0 end as qty;
case col1 when 1 then 11 when 2 then 21 else 13 end;
case  when col1 < 2 then case col2 when 'x' then 10 else 11 end else 0 end as qty;
select  a.* from tbl_company a where  a.company_id not in (1,2) and ( (0 = case when (@fromdate = '' or @todate='') then 0 else 1 end )      -- if 0=0 true , if 0=1 fails (filter only when the fromdate and todate is present) or (a.created_date between @fromdate and @todate ) );
case when a.reasonid in ('02','03','04','05','06') then case b.calsoc else 'no' end else 'no' end;
set @yr=(select case when month(getdate())=1 then year(getdate())-1 else year(getdate())end) set @mth=(select case when month(getdate())=1 then month(getdate())+11 else month(getdate())end);
create function count_str( haystack text,  needle varchar(32));
select title,description,count = (len(description) - len(replace(description, 'value', '')))/len('value') from @t;
select title,description, (length(description) - length(replace(description, 'value', '')))/length('value') as count from <yourtable>;
select title, description, round ( ( length(description) from <table>;
select title, (length(description )-length(replace(description ,'value','')))/5 as count from <table>;
select id, jsondata, round ( ( length(jsondata) ) ( length(jsondata) ) as count1    from test order by count1 desc limit 0, 2;
select title, description, char_length(description) - char_length( replace ( description, 'value', '1234') ) as `count` from <table>;
set @needle = 'value';
select description, char_length(description) - char_length(replace(description, @needle, space(length(@needle)-1))) as `count` from <table>;
create function count_str(haystack text, needle varchar(32));
select from_unixtime( 600 * ( unix_timestamp( [date] ) % 600 ) ) as rect, avg(value) from [friib].[dbo].[archiveanalog];
set @interval = 30 select dateadd(minute,(datediff(minute,0,[dateinsert])/@interval)*@interval,0), sum(value_transaction) from transactions;
select dateadd(minute, datediff(minute, 0, date), 0), sum(snapshotvalue) from [friib].[dbo].[archiveanalog];
select concat( format(endtime,'yyyy-mm-dd_hh:'), left(format(endtime,'mm'),1), '0';
select [date] from [friib].[dbo].[archiveanalog];
select timeslot, count(*) from ( select datepart('hh', date) timeslot from [friib].[dbo].[archiveanalog] );
select timeslot, count(*) from ( select to_char(l_time, 'yyyy-mm-dd hh24') timeslot from ( select l_time from mytab );
datepart(year, dt.[date]), datepart(month, dt.[date]), datepart(day, dt.[date]), datepart(hour, dt.[date]), (datepart(minute, dt.[date]) / 10);
create function [dbo].[fn_minuteintervals] ( @startdate smalldatetime , @enddate smalldatetime , @interval int = 1 ) ( [date] smalldatetime primary key not null ) as begin set @counter = @startdate set @counter = dateadd(n, @interval, @counter) end return end;
select   dateadd(minute, datediff(minute, '2000', aa.[date]) / 10 * 10, '2000') as [date_truncated], count(*) as [records_in_interval], avg(aa.[value]) as [average_value] from     [friib].[dbo].[archive_analog] as aa;
date(`your_date_field`), hour(`your_date_field`), floor( minute(`your_date_field`) / 10);
select update_time from   information_schema.tables where  table_schema = 'dbname' and table_name = 'tabname';
select update_time, table_schema, table_name from information_schema.tables;
"c:\programdata\mysql\mysql server 5.5\data\mydb\person.frm");
id int primary key updated_at timestamp default current_timestamp key (updated_at);
create procedure `timestamp_update` () update `schema_name`.`timestamps_table_name` set `timestamp_column`=date_format(now(), '%y-%m-%d %t') where `table_name_column`='table_name';
select * from information_schema.tables where table_schema='db_name' order by update_time desc;
select * from information_schema.tables where table_schema='db_name' and table_name='table_name' order by update_time desc';
select last_update from mysql.innodb_table_stats where table_name = 'yourtblname';
select l.ip, tbl2.ip as ip2, tbl2.hostname from   login_log l from ip_location where ip_location.ip is null)tbl2;
select ip from login_log where ip not in ( select ip from ip_location );
select ip from   login_log l where  not exists ( select  -- select list mostly irrelevant; can just be empty in postgres from   ip_location where  ip = l.ip;
select l.ip from   login_log l where  i.ip is null;
select ip from   login_log select ip from   ip_location;
select ip from   login_log where  ip not in ( select distinct ip  -- distinct is optional from   ip_location;
select * from   testcases1 t where  not exists ( select 1<br> from   executions1 i where  t.tc_id = i.tc_id and t.pro_id=i.pro_id and pro_id=7 and version_id=5;
create table employee(name varchar, paymenttype varchar, amount bigint);
select paymenttype, amount from employee where name = 'bob' and paymenttype='salary' select paymenttype, amount from employee where name = 'bob' and paymenttype='salary' or 'a'!='b';
select paymenttype, amount from employee where name = 'bob' and paymenttype=? select paymenttype, amount from employee where name = 'bob' and paymenttype=?;
select * from users where id=1;
select * from users where id=1; drop table users;
select * from table where username='a' or 1=1 -- and password=asda;
select * from table1 where date in (select * from dates) -- wrong select * from table1 where date in (select column1,column2 from dates) -- wrong select * from table1 where date in (select column1 from dates) -- ok;
where a_id in (subquery);
select * from thistable where thiscolumn in (select thatcolumn from thattable);
select count(distinct dnum) from mydb.dbo.aq where a_id in from mydb.dbo.aq where m > 1 and b = 0;
set @jsonout = (select id, sumlev, census_geoid, areaname, worksite from cs_geo g (nolock) join @allids a on g.id = a.[value] where g.worksite = @worksite);
set @jsonout = (select id, sumlev, census_geoid, areaname, worksite from cs_geo g (nolock) join @allids a on g.id = a.[value] where g.worksite = @worksite for json path);
select count(distinct dnum) from mydb.dbo.aq where a_id in ( select a_id from (select distinct top (0.1) percent a_id, count(distinct dnum) as ud from         mydb.dbo.aq where     m > 1 and b = 0 );
if object_id('dbo.fktest2', 'u') is not null drop table fktest2 if object_id('dbo.fktest1', 'u') is not null drop table fktest1 if exists (select name from sysobjects where name = 'fktest1trigger' and type = 'tr') drop trigger dbo.fktest1trigger create table fktest1 (id int primary key, anqid int identity) create table fktest2 (id1 int, id2 int, anqid int identity, foreign key (id1) references fktest1 (id) foreign key (id2) references fktest1 (id) this causes compile error so we have to use triggers ) create trigger fktest1trigger as if @@rowcount = 0 set nocount on -- or modify other foreign key constraints. if ((update (id) and exists(select 1 from fktest1 a join deleted b on b.anqid = a.anqid where b.id <> a.id))) update fktest2 set id2 = i.id from deleted d join fktest2 on d.id = fktest2.id2 join inserted i on i.anqid = d.anqid end if exists (select 1 from deleted) delete one from fktest2 one left join fktest1 two on two.id = one.id2 where two.id is null -- drop all from dest table which are not in source table select * from fktest1 select * from fktest2 update fktest1 set id=11 where id=1 update fktest1 set id=22 where id=2 update fktest1 set id=33 where id=3 delete from fktest1 where id > 22 select * from fktest1 select * from fktest2;
select 1 from table201608 limit 1;
select count(*) from information_schema.tables where (table_schema = 'mydb') and (table_name = 'table201608');
select if( exists where table_schema = '$database' and table_name = '$table' limit 1), 1, 0) as if_exists;
if (connection.state == connectionstate.closed) if (reader.hasrows) else {;
select 1 from `tablename`; //avoids a function call select * from information_schema.tables where schema = 'db' and table = 'table' // slow. field names not accurate;
create procedure `insert_in_my_table`(in my_var int) create table my_table(n int);
select count(*) as cnt from information_schema.tables where concat(table_schema,".",table_name)="db_name.table_name";
select * from information_schema.tables where table_schema = 'yourdb' and table_name = 'testtable' limit 1;
select count(*) from information_schema.tables where (table_schema = 'your_db_name') and (table_name = 'name_of_table');
select table_name from information_schema.tables where table_schema = 'databasename' and table_name = 'testtable';
select 1 from test_table limit 1;
set @table_exists = 0;
set @table_exists = (select 1 from test_table limit 1);
set @test_table = 'test_table';
set @test_db = null;
set @does_table_exist = null;
select @does_table_exist;
if null is given for p_database_name, then it defaults to the currently selected database select null from `p_database_name`.`p_table_name` limit 0;
if [sqlstate '42s02'] is raised, then set p_does_table_exist = 0 else set p_does_table_exist = 1 drop procedure if exists doestableexist create procedure         doestableexist ( in p_table_name varchar(64), in p_database_name varchar(64), out p_does_table_exist tinyint(1) unsigned ) set p_does_table_exist = 0 end ;
if p_table_name is null then end if;
set @test_select_sql_793441 = concat( "set @dummy_var_793441 = (" if( p_database_name is null, "", concat( "`", replace(p_database_name, "`", "``"), "`." ) "`", replace(p_table_name, "`", "``"), "`" ) set @test_select_sql_793441 = null set p_does_table_exist = 1 end $$;
create function fn_table_exists(dbname varchar(255), tablename varchar(255)) select count(*) from information_schema.tables where (table_schema collate utf8_general_ci = dbname collate utf8_general_ci) and (table_name collate utf8_general_ci = tablename collate utf8_general_ci) totaltablescount > 0, true, false end ;
select fn_table_exists('development', 'user');
select exists( select * from information_schema.tables where table_schema = 'db' and table_name = 'table';
select count(*) from information_schema.tables where table_name = 'yourtable' and table_schema in (select database());
drop procedure if exists `prcdoestableexist`;
create procedure `prcdoestableexist`(in pin_table varchar(100), out pout_tableexists bool) set @s = concat('select null from `', pin_table, '` limit 0 into @resultnm');
set pout_tableexists = `booltableexists`; -- set output variable if @debug then select if(`booltableexists` end if;
set @debug = true;
select @tblexists as '@tblexists';
select 1 into @ret from information_schema.tables where table_schema = database() and table_name = 'my_table';
create function existtable (_tablename varchar(255)) set _ret = 0;
select 1 into _ret from information_schema.tables where table_schema = database() and table_name = _tablename limit 1;
select existtable('my_table');
create table sample ( sample_pk             int not null auto_increment, sample_id             varchar(100) not null, ...;
select s.id, s.age, c.cnt from students s;
select age, count(age) from students;
select s.id, s.age, c.cnt from students  s from students;
select s.id, s.age, c.count from students s select age, count(*) as count from students;
select a.id, a.age, b.count from students a, (select age, count(*) as count from students group by age) b where a.age=b.age;
select id, age, count(*) over (partition by age) from students;
select a.id, a.age, b.age_count from students a join (select age, count(*) as age_count from students;
select age, count(*) from students;
[id]      int identity(1,1) primary key not null, [command] char(1) not null set @codepos  = @codepos + 1;
set @codechar = substring(@code, @codepos, 1);
if @codechar in ('+', '-', '>', '<', ',', '.', '[', ']') end  [id]   int identity(1,1) primary key not null, [char] char(1) not null set @inputpos = @inputpos + 1;
values (substring(@input, @inputpos, 1)) end  [id]   int identity(1,1) primary key not null, [char] char(1) not null [id]     int identity(1,1) primary key not null, [memory] int default 0  not null values (0);
set @codeindex = @codeindex + 1;
set @command = (select [command] from @codetable where [id] = @codeindex);
if @command = '>' set @pointer = @pointer + 1;
if (select [id] from @buffertable where [id] = @pointer) is null end  else if @command = '<' set @pointer = @pointer - 1;
else if @command = '+' update @buffertable set [memory] = [memory] + 1 where [id] = @pointer;
else if @command = '-' update @buffertable set [memory] = [memory] - 1 where [id] = @pointer;
else if @command = '.' else if @command = ',' set @inputindex = @inputindex + 1;
update @buffertable set [memory] = coalesce((select ascii([char]) from @inputtable where [id] = @inputindex), 0) where [id] = @pointer;
end  else if @command = '[' and coalesce((select [memory] from @buffertable where [id] = @pointer), 0) = 0 set @depth = 1;
set @codeindex = @codeindex + 1;
set @command = (select [command] from @codetable where [id] = @codeindex);
if @command = '[' set @depth = @depth + 1;
else if @command = ']' set @depth = @depth - 1;
end end  else if @command = ']' and coalesce((select [memory] from @buffertable where [id] = @pointer), 0) != 0 set @depth = 1;
set @codeindex = @codeindex - 1;
set @command = (select [command] from @codetable where [id] = @codeindex);
if @command = ']' set @depth = @depth + 1;
else if @command = '[' set @depth = @depth - 1;
select @output = coalesce(@output, '') + [char] from @outputtable;
select b.id, a.* from mytable a join (values (250000), (2500001), (2600000)) as b(id);
select position_id , position_name from position where position_id in (6 ,7 ,8);
select * from table where id in (id1, id2, ..., idn);
select * from table where id in (id1,id2.........long list);
id  int ) select * from dbo.fnsplitter('#idlist#');
select * from table inner join temp on temp.id = table.id;
in (val1, val2, );
select * from canada where id ...;
"original_condition": "((`canada`.`id` = 296172) or (`canada`.`id` = 295093) or (`canada`.`id` = 293626))", "steps": [ "resulting_condition": "(multiple equal(296172, `canada`.`id`) or multiple equal(295093, `canada`.`id`) or multiple equal(293626, `canada`.`id`))";
"ranges": [ "295093 <= id <= 295093", "296172 <= id <= 296172" "index_dives_for_eq_ranges": true, "chosen": true;
"pushed_index_condition": "((`canada`.`id` = 296172) or (`canada`.`id` = 295093) or (`canada`.`id` = 293626))", "table_condition_attached": null, "access_type": "range";
"original_condition": "(`canada`.`id` in (296172,295093,293626,295573,297148,296127,295588,295810))", "steps": [ "resulting_condition": "(`canada`.`id` in (296172,295093,293626,295573,297148,296127,295588,295810))";
"ranges": [ "295093 <= id <= 295093", "295573 <= id <= 295573", "295588 <= id <= 295588", "295810 <= id <= 295810", "296127 <= id <= 296127", "296172 <= id <= 296172", "297148 <= id <= 297148" "index_dives_for_eq_ranges": true, "chosen": true;
"pushed_index_condition": "(`canada`.`id` in (296172,295093,293626,295573,297148,296127,295588,295810))", "table_condition_attached": null, "access_type": "range";
"original_condition": "(`canada`.`id` in (293831,292259,292881,293440,292558,295792,292293,292593,294337,295430,295034,297060,293811,295587,294651,295559,293213,295742,292605,296018,294529,296711,293919,294732,294689,295540,293000,296916,294433,297112,293815,292522,296816,293320,293232,295369,291894,293700,291839,293049,292738,294895,294473,294023,294173,293019,291976,294923,294797,296958,294075,293450,296952,297185,295351,295736,296312,294330,292717,294638,294713,297176,295896,295137,296573,292236,294966,296642,296073,295903,293057,294628,292639,293803,294470,295353,297196,291752,296118,296964,296185,295338,295956,296064,295039,297201,297136,295206,295986,292172,294803,294480,294706,296975,296604,294493,293181,292526,293354,292374,292344,293744,294165,295082,296203,291918,295211,294289,294877,293120,295387))", "steps": [ "resulting_condition": "(`canada`.`id` in (293831,292259,292881,293440,292558,295792,292293,292593,294337,295430,295034,297060,293811,295587,294651,295559,293213,295742,292605,296018,294529,296711,293919,294732,294689,295540,293000,296916,294433,297112,293815,292522,296816,293320,293232,295369,291894,293700,291839,293049,292738,294895,294473,294023,294173,293019,291976,294923,294797,296958,294075,293450,296952,297185,295351,295736,296312,294330,292717,294638,294713,297176,295896,295137,296573,292236,294966,296642,296073,295903,293057,294628,292639,293803,294470,295353,297196,291752,296118,296964,296185,295338,295956,296064,295039,297201,297136,295206,295986,292172,294803,294480,294706,296975,296604,294493,293181,292526,293354,292374,292344,293744,294165,295082,296203,291918,295211,294289,294877,293120,295387))";
"ranges": [ "291839 <= id <= 291839", ... "297201 <= id <= 297201" "index_dives_for_eq_ranges": false, "rows": 111, "chosen": true;
"pushed_index_condition": "(`canada`.`id` in (293831,292259,292881,293440,292558,295792,292293,292593,294337,295430,295034,297060,293811,295587,294651,295559,293213,295742,292605,296018,294529,296711,293919,294732,294689,295540,293000,296916,294433,297112,293815,292522,296816,293320,293232,295369,291894,293700,291839,293049,292738,294895,294473,294023,294173,293019,291976,294923,294797,296958,294075,293450,296952,297185,295351,295736,296312,294330,292717,294638,294713,297176,295896,295137,296573,292236,294966,296642,296073,295903,293057,294628,292639,293803,294470,295353,297196,291752,296118,296964,296185,295338,295956,296064,295039,297201,297136,295206,295986,292172,294803,294480,294706,296975,296604,294493,293181,292526,293354,292374,292344,293744,294165,295082,296203,291918,295211,294289,294877,293120,295387))", "table_condition_attached": null, "access_type": "range";
create table `mytable` ( `id` mediumint(8) unsigned not null auto_increment, `aname` varchar(255) default null, `adate` datetime, `anum`  mediumint(8), primary key (`id`) alter table `mytable` add index `aname_idx` (`aname`);
alter table `mytable` add index `adate_idx` (`adate`);
alter table `mytable` add index `anum_idx` (`anum`);
values ("daniel","2017-09-19 01:22:31");
update mytable set anum = id;
select 'anum by or' q, mytable.* from mytable where anum = 12 or anum = 22 or anum = 27 or anum = 32 or anum = 42 or anum = 52 or anum = 62 or anum = 65 or anum = 72 or anum = 82;
select 'anum by in' q, mytable.* from mytable where anum in ( 12 );
select 'adate by or' q, mytable.* from mytable where adate= str_to_date("2017-02-15 02:45:29",'%y-%m-%d %h:%i:%s') or adate = str_to_date("2018-03-10 18:37:26",'%y-%m-%d %h:%i:%s') or adate = str_to_date("2017-05-20 16:25:10",'%y-%m-%d %h:%i:%s') or adate = str_to_date("2018-07-10 06:29:39",'%y-%m-%d %h:%i:%s') or adate = str_to_date("2017-07-14 00:04:00",'%y-%m-%d %h:%i:%s') or adate = str_to_date("2018-08-18 08:54:08",'%y-%m-%d %h:%i:%s') or adate = str_to_date("2018-10-02 06:55:56",'%y-%m-%d %h:%i:%s') or adate = str_to_date("2017-04-20 07:03:05",'%y-%m-%d %h:%i:%s') or adate = str_to_date("2018-03-02 15:04:32",'%y-%m-%d %h:%i:%s') or adate = str_to_date("2017-09-19 04:07:54",'%y-%m-%d %h:%i:%s') or adate = str_to_date("2016-12-13 04:24:08",'%y-%m-%d %h:%i:%s');
select 'adate by in' q, mytable.* from mytable where adate in ( str_to_date("2017-02-15 02:45:29",'%y-%m-%d %h:%i:%s') );
select 'name by  or' q, mytable.* from mytable where aname = 'alan' or aname = 'brian' or aname = 'chandler' or aname = 'darius' or aname = 'evan' or aname = 'ferris' or aname = 'giacomo' or aname = 'hall' or aname = 'james' or aname = 'jarrod';
select 'name by in' q, mytable.* from mytable where aname in ( 'alan' );
select * from item where id = 1 or id = 2 ... id = 10000;
select * from item where id in (1,2,3,...10000);
select ... from ...;
exec sp_updatestats;
if exists(select * from sys.indexes where name like '<index_name>') alter table dbo.<target_table_name> drop constraint <index_name> alter table dbo.<target_table_name> add constraint <index_name> unique nonclustered (<col_1>, <col_2>, ..., <col_n>);
create unique nonclustered index idx_col1 where col1 is not null;
alter table tablename add unique (columnname1,columnname2, columnname3, ...);
alter table tablename add constraint un_constaint_name unique (columnname1,columnname2, columnname3, ...);
alter table dbo.<tablename> add constraint ( <columnname>;
alter table dbo.doc_exz add constraint col_b_def unique column_b;
alter table [tablename] add constraint  [constraintname] unique ([columns]);
alter table <tablename> add constraint ( <columnname> );
( select col1, col2, ..., row_number() over (order by sortcol1, sortcol2, ...) as rownum from table where <whatever> ) select * from results_cte where rownum >= @offset and rownum < @offset + @limit;
( select col1, col2, row_number() over(order by col1) as row_number from my_table where <<<whatever>>> ) select col1, col2 from my_cte where row_number between @start_row and @end_row;
select email from emailtable where user_id=3;
set @offset = 2;
set @limit = 20;
select @idxfim = @offset * @limit select @idxini = @idxfim - (@limit-1);
( select row_number() over (order by object_id) as rowid, * from sys.objects ) select * from (select count(1) as rowqtd from paging) qtd, paging where rowid between @idxini and @idxfim rowid;
select * from( select *, row_number() over (order by id ) as ct from [db].[dbo].[table] ) sub where ct > fromnumber  and ct <= tonumber;
select * from [db].[dbo].[table] limit 0, 10;
( select col1, row_number() over(order by col1) as row_number from my_table where <<<whatever>>> ) select * from my_cte where rownum between (@pagenum - 1) * (@pagesize + 1) and @pagenum * @pagesize end;
select top {limit here} * from ( select *, row_number() over (order by {order field}) as r_n_n from {your tables} where {other optional filters};
set rowcount 10 select customerid, companyname from customers;
set rowcount 0 select customerid, companyname from customers;
row_number() over (order by companyname) as rownumber from customers ) select * from cust where rownumber between 0 and 10;
select customerid, companyname from customers;
select top {limit} * from ( select top {limit} + {offset} row_number() over (order by (select null)) as row_no,* from  {table_name};
select top 20 * from (select columname1, columname2 from tablename where <conditions...> order by columname1 offset 100 rows) aliasname;
select top 20 columname1, columname2 from tablename where <conditions...> order by columname1 offset 100 rows;
select top 20 from (select distinct columname1, columname2 where <conditions...> order by columname1 offset 100 rows) aliasname;
select * from memberemployeedata;
select top (@takecount) * --fetch next select  row_number() over (order by startdate) as rowid,* from yourtable where rowid>@skipcount --offset;
set @nombre_row=5;
select  * from    ( select    row_number() over ( order by etudiant_id ) as rownum, * from      etudiant where   rownum >= ((@page-1)*@nombre_row)+1 and rownum < ((@page)*@nombre_row)+1;
select top @limit f1, f2, f3... from t1 where c1 = v1, c2 > v2... and t1.id not in from t1 where c1 = v1, c2 > v2...;
alter table yourtable drop constraint constraint_name     -- df_movies_rating__48cfd27e;
alter table tablename drop constraint dependent_constraint;
alter table employees drop constraint df__employees__colf__1273c1cd;
alter table tablename drop column columnname;
select @var0 = name from sys.default_constraints where parent_object_id = object_id(n'dbo.mytable') and col_name(parent_object_id, parent_column_id) = 'rating';
if @var0 is not null;
create table movie ( ... );
create table movie ( name varchar(255) not null, rating int not null constraint rating_default default 100;
alter table movie drop constraint rating_default;
alter table movie alter column rating decimal(2) not null;
alter table movie add constraint rating_default default ((1.0)) for rating;
select @sql += 'alter table ' + quotename(tbl.name) + '  drop constraint ' + quotename(cons.name) + ';' from sys.default_constraints cons join   sys.columns col on col.default_object_id = cons.object_id join   sys.tables tbl on tbl.object_id = col.object_id where  col.[name] in ('column1','column2') exec sp_executesql @sql;
select @sql += 'alter table ' + quotename(table_catalog)+ '.' + quotename(table_schema) + '.'+ quotename(table_name) from   information_schema.columns where column_name in ('column1','column2') exec sp_executesql @sql;
select @constraintname = name from sys.default_constraints where parent_object_id = object_id('__tablename__') and parent_column_id = (select column_id from sys.columns where name = n'__columnname__' and object_id = object_id(n'__tablename__')) if @constraintname is not null if exists (select * from syscolumns where id=object_id('__tablename__') and name='__columnname__');
if exists(select 1 from information_schema.constraint_column_usage where table_name = '__tablename__' and column_name = '__columnname__') select @constraintname = constraint_name from information_schema.constraint_column_usage where table_name = '__tablename__' and column_name = '__columnname__' end;
select pid from pg_stat_activity where state = 'active';
select * from pg_stat_activity where datname = 'dbname' and state = 'active';
select * from pg_stat_activity;
select cast(myvarcharcol as int) from table select convert(int, myvarcharcol) from table;
select cast(cast (myvarcharcol as numeric(19,4)) as int);
select cast(myvarcharcol as numeric(19,4)) as [myintcol] from tablea;
select try_parse(myvarcharcol as int) select try_convert(int, myvarcharcol);
select logcount, loguserid, maxlogtm from statslogsummary having daysdiff > 120;
select * from (select logcount, loguserid, maxlogtm from statslogsummary) as 'your_alias' where daysdiff > 120;
select s.logcount, s.loguserid, s.maxlogtm, c.daysdiff from statslogsummary s where c.daysdiff > 120;
where (case when column1=column2 then '1' else '0' end) = 0;
select logcount, loguserid, maxlogtm from statslogsummary where (datediff(day, maxlogtm, getdate())) > 120;
select length(name) as name_length, id, name from any_table ) select id, name, name_length form q1 where name_length > 0;
select logcount, loguserid, maxlogtm, datediff(day, maxlogtm, getdate()) as daysdiff from statslogsummary where ( datediff(day, maxlogtm, getdate() > 120);
select * from ( select logcount, loguserid, maxlogtm, datediff(day, maxlogtm, getdate()) as daysdiff from statslogsummary where daysdiff > 120;
( select logcount, loguserid, maxlogtm from statslogsummary ) select logcount, loguserid, maxlogtm, daysdiff from logdatediff where daysdiff > 120;
select s.logcount, s.loguserid, s.maxlogtm, a.daysdiff from statslogsummary as s where a.daysdiff > 120;
select * from member where member_no=285;
select * from member where member_no=@mno;
alter database <database_name> character set utf8mb4 collate utf8mb4_0900_ai_ci;
alter table <table_name> convert to character set utf8mb4 collate utf8mb4_0900_ai_ci;
alter table <table_name> modify <column_name> varchar(255) character set utf8mb4 collate utf8mb4_0900_ai_ci;
select distinct concat('alter database `', table_schema, '` character set utf8 collate utf8_unicode_ci;') from information_schema.tables where table_schema like  'database_name';
select concat('alter table `', table_schema, '`.`', table_name, '` character set utf8 collate utf8_unicode_ci;') from information_schema.tables where table_schema like 'database_name';
select concat('alter table `', t1.table_schema, '`.`', t1.table_name, '` modify `', t1.column_name, '` ', t1.data_type , '(' , t1.character_maximum_length , ')' , ' character set utf8 collate utf8_unicode_ci;') from information_schema.columns t1 where t1.table_schema like 'database_name' and t1.collation_name = 'old_charset_name';
select a.table_name, concat('alter table ', a.table_schema, '.', a.table_name, ' default character set utf8mb4 default collate utf8mb4_unicode_ci, ', group_concat(distinct(concat(' modify ',  column_name, ' ', column_type, ' character set utf8mb4 collate utf8mb4_unicode_ci ', if (is_nullable = 'no', ' not', ''), ' null ', if (column_default is not null, concat(' default \'', column_default, '\''), ''), if (extra != '', concat(' ', extra), '')))), ';') as alter_statement from information_schema.columns a and a.table_schema = b.table_schema and a.table_name = b.table_name and b.table_type != 'view' where a.table_schema = ? and (collation_name = 'latin1_swedish_ci' or collation_name = 'utf8mb4_general_ci');
select * from user where login like 'test%';
select count(*) from master..sysobjects as a join tempdb..sysobjects as b select count(*) from master..sysobjects as a join tempdb..sysobjects as b;
select * from people where name ilike 'john';
select * from people where name ~ 'john.*';
getrowmapper());
parameters, getrowmapper());
set xact_abort on;
set xact_abort on;
create procedure [usp_my_procedure_name] as begin set nocount on;
set @trancount = @@trancount;
if @trancount = 0 else save transaction usp_my_procedure_name;
if @trancount = 0 end try select @error = error_number(), @message = error_message(), @xstate = xact_state();
if @xstate = -1 if @xstate = 1 and @trancount = 0 if @xstate = 1 and @trancount > 0 end catch end go;
select 'everything is fine';
select right(mycolumn, len(mycolumn) - 4) as mytrimmedcolumn;
update mytable set mycolumn = right(mycolumn, len(mycolumn) - 4);
update table yourtable set yourfield = substring(yourfield, 5, len(yourfield)-3);
create table codes ( code1 varchar(10), code2 varchar(10) ) update codes set code2 = substring(code1, 5, len(code1) -4);
select trim(both 'ag' from 'asdfg');
update tblinvalidid set [columnname] =stuff(columnname, 1, charindex('#', columnname), ' ');
set @v='#temp' select stuff(@v, 1, 1, '') where left(@v,1)='#';
select case when len(foo) >= 4 then right(foo, len(foo) - 4) else '' end as myfoo from mytable;
create temp table foo (foo) as values ('123456789'),('12345678'),('1234567'),('123456'),('12345'),('1234'),('123'),('12'),('1'), ('');
select foo, right(foo, length(foo) - 5), right(foo, -5) from foo;
update table_name set right(column_name, len(column_name) - 1);
select docgrp_id,docgrp_subid,docgrp_groupname,docgrp_pm,docgrp_doctype from opendatasource( 'sqloledb','data source=10.132.20.19;userid=sa;password=gchaturthi').dbipfmci.dbo.doctypegroup;
select longintcolumn1, avg(currencycolumn) as currencycolumn1 from table1 group by longintcolumn1;
select longintcolumn1, avg(currencycolumn) from table1 group by longintcolumn1;
create table table1 ( id int identity(1, 1) not null, longintcolumn1 int, currencycolumn money ) create table table2 ( id int identity(1, 1) not null, longintcolumn2 int, currencycolumn2 money ) select longintcolumn1, avg(currencycolumn) as currencycolumn1 from table1 group by longintcolumn1;
create table table1 ( id int identity(1, 1) not null, longintcolumn1 int, currencycolumn money ) select longintcolumn1, avg(currencycolumn) as currencycolumn1 from table1;
select [source.]field1[, field2[, ] from tableexpression;
values (value1[, value2[, ]);
select longintcolumn1, avg(currencycolumn) as currencycolumn1 into t1 from table1;
select longintcolumn, avg(currencycolumn) as currencycolumn1 from table1;
select longintcolumn, avg(currencycolumn) from table1;
set ansi_nulls on set quoted_identifier on create proc [dbo].[spcountnewlastidanytablerows] ( @passedtablename as nvarchar(255), @passedcolumnname as nvarchar(225) ) as begin select @actualtablename = quotename( table_name ) from information_schema.tables where table_name = @passedtablename select @actualcolumnname = quotename( column_name ) from information_schema.columns where column_name = @passedcolumnname select @sql = 'select max('+ @actualcolumnname + ') + 1  as lastid' + ' from ' + @actualtablename end;
if (! acceptduplicates)  // check if "acceptduplicates" flag is set if (existentsymbols.count > 0) return existentsymbols; //(1) return existent records because creation of duplicates is not allowed if (myreader.getint32(0) > -1) if (symbolid[0] != 0 || symbolid[1] != 0) // if last inserted id succeded if (sqltrace) sqlview.log(mysqlcommand.commandtext); // log the text of the command if (lastinsertedid > 0) // if insertion of the new row in the table was successful if (myresultstrace) sqlview.logresult(lastinsertedid); // log the action;
if (reader.hasrows);
create procedure [dbo].[insertnewcompanyandstaffdetails]   ;
as begin set nocount on;
values (@comp_name, @comp_regno, @comp_email) set @recid = (select tempid from @tablevar);
values (@recid) end;
select scope_identity();
set @sqlcommand = 'select * from yourtable' exec (@sqlcommand);
select * from [db_one].[dbo].[acty] select * from [db_two].[dbo].[acty];
set @schema = 'dbo' set @table = 'acty' set @query = 'select * from [db_one].[' + @schema + '].[' + @table + '] except select * from [db_two].[' + @schema + '].[' + @table + ']' exec sp_executesql @query;
set @tablename = 'test' set @sql = 'select * from ' + @tablename exec (@sql);
set @table_name = if exists(select name from sysobjects where name = @table_name and xtype = 'u') end ;
create procedure [dbo].[getbyname] as begin set nocount on;
select @ssql = n'select * from' + quotename(@tablename);
exec sp_executesql @ssql end;
set @c_tables = cursor for select name from sysobjects where objectproperty(id, n'isusertable') = 1 and name like 'tr_%' select @fs_e = sdec.fetch_status from sys.dm_exec_cursors(0) as sdec where sdec.name = '@c_tables' select @fs_e = sdec.fetch_status from sys.dm_exec_cursors(0) as sdec where sdec.name = '@c_tables' end;
set @tablename = 'your table name';
@sql       nvarchar(max);
set @table = n'tablename';
set @sql = n'select * from ' + @table;
exec sp_executesql @sql;
set @tablename = (select tablename from table);
set @seqid = 'select next value for ' + @tablename + '_data' exec (@seqid);
@sql    nvarchar(4000), @params nvarchar(4000), @count  int select object_name(id) from syscolumns where name = 'lastupdated' if @@fetch_status <> 0 select @sql = select @params = n'@fromdate datetime, ' + exec sp_executesql @sql, @params, '20060101', @cnt = @count output end ;
select   uc.constraint_name||chr(10) from user_constraints uc , user_cons_columns ucc1 , user_cons_columns ucc2 where uc.constraint_name = ucc1.constraint_name and uc.r_constraint_name = ucc2.constraint_name and ucc1.position        = ucc2.position -- correction for multiple column primary keys. and uc.constraint_type   = 'r' and uc.constraint_name   = 'sys_c00381400' uc.constraint_name;
select constraint_name, constraint_type, column_name from user_constraints natural join user_cons_columns where table_name = "my_table_name";
select * from all_constraints where owner = '<name>' and constraint_name = 'sys_c00381400';
values ($1, $2, $3), ($2, $1, null);
values (text 'foo1', text 'bar1', text 'bob1')  -- type casts in first row ) insert into chats (usr, contact, name) select * from input_rows ) select 'i' as source                           -- 'i' for 'inserted' from   ins union  all select 's' as source                           -- 's' for 'selected' from   input_rows join   chats c using (usr, contact);           -- columns of unique index;
insert into chats as c (usr, contact, name) select * from input_rows ) select 'i'::"char" as source                 -- 'i' for 'inserted' from   ins union  all select 's'::"char" as source                 -- 's' for 'selected' from   input_rows join   chats c using (usr, contact) ) select i.* from   input_rows i where  s.usr is null                         -- missing! set    name = c.name                         -- ... this time we overwrite with old value ) select source, id from sel union  all table  ups;
set name = name where false  -- never executed, but still locks the row;
(select usr, contact, name from chats limit 0)  -- only copies column names and types union all values ('foo1', 'bar1', 'bob1')  -- no type casts here );
select * from ( values ((null::chats).*)         -- copies whole row definition );
insert into chats ("user", "contact", "name") values ($1, $2, $3) (select id from new_chats), (select id from chats where user = $1 and contact = $2);
values (text 'foo1', text 'bar1', text 'bob1')  -- type casts in first row ) select c.usr from input_rows as r ) select usr, contact, name from new_rows where not row_exists;
insert into chats ("user", "contact", "name") values ($1, $2, $3), ($2, $1, null) ) select * from e union select id from chats where user=$1, contact=$2;
select  a.* from    a join    b;
select  a.* from    a where   col in ( select  col from    b );
select  a.* from    a join    ( select  distinct col from    b );
select  a.* from    a where   exists ( select  * from    b where   b.col = a.col );
select * from flights and (airports.code = flights.tairport));
select f.* from flights f;
select flights.*,fromairports.*,toairports.* from flights airports fromairports on flights.fairport = fromairports.code airports toairports on flights.tairport = toairports.code where ...;
select airline, flt_no, fairport, tairport, depart, arrive, fare from flights airports from_port on (from_port.code = flights.fairport) airports to_port on (to_port.code = flights.tairport) where from_port.code = '?' or to_port.code = '?' or airports.city='?';
select flights.*, fromairports.city as fromcity, toairports.city as tocity from flights where flights.fairport = '?' or fromairports.city = '?';
alter database [olddatabasename] set single_user with rollback immediate;
exec sp_renamedb n'olddatabasename', n'newdatabasename';
alter database [newdatabasename] set multi_user;
alter database bosevikram set single_user with rollback immediate exec sp_renamedb 'bosevikram','bosevikram_deleted' alter database bosevikram_deleted set multi_user;
alter database bosevikram set single_user with rollback immediate alter database bosevikram modify name = [bosevikram_deleted] alter database bosevikram_deleted set multi_user;
alter database bosevikram set single_user with rollback immediate alter database bosevikram modify name = [bosevikram_deleted] alter database bosevikram_deleted set multi_user;
select * from master.sys.sysprocesses where spid>50 -- don't want system sessions and dbid = db_id('bosevikram');
alter database dbname set single_user with rollback immediate;
alter database dbname modify name = newname;
alter database newname set multi_user with rollback immediate;
alter sequence serial increment by -400;
select serial.nextval from dual;
alter sequence serial increment by 1;
create or replace procedure reset_sequence( p_seq_name in varchar2, p_val in number default 0) select min_value from user_sequences where sequence_name = p_seq_name;
if p_val < l_minvalue then else l_difference := p_val - l_current;
if l_difference = 0 then end if;
end reset_sequence;
create or replace procedure reset_sequence_to_data( p_tablename varchar2, p_fieldname varchar2 ) end reset_sequence_to_data;
create or replace procedure reset_all_sequences end reset_all_sequences;
create sequence s start with 1 increment by 1;
select s.nextval from dual create or replace procedure reset_sequence ( i_buffer in pls_integer default 0) as maxval pls_integer;
exec reset_sequence;
select s.nextval from dual;
alter sequence serial restart start with 1;
create sequence test_seq;
create or replace procedure reset_sequence;
drop sequence blah;
create sequence blah;
create sequence testseq;
select testseq.nextval from dual select testseq.nextval from dual select testseq.nextval from dual select testseq.nextval from dual;
alter sequence testseq increment by -3;
select testseq.nextval from dual;
alter sequence testseq increment by 1;
select testseq.nextval from dual;
drop sequence my_seq;
create sequence my_seq;
select max (proj_key) into proj_key_max from pcs_proj;
select pcs_proj_key_seq.nextval into proj_key_currval from dual;
create or replace procedure alter_sequence( seq_name      user_sequences.sequence_name%type as l_seq user_sequences%rowtype;
select * into l_seq from user_sequences where sequence_name = seq_name;
if next_value is not null then if l_next <> 0 then end if;
if coalesce( cycle_flag then execute immediate else ' cache '||l_seq.cache_size end end if;
select max(id) into max_db_value from persons;
select last_number into cur_seq_value from user_sequences where  sequence_name = 'seq_persons';
select seq_persons.nextval into dummy_number from dual;
select [nome_da_sequence].nextval into actual_sequence_number from dual;
select max([nome_da_coluna]) into max_number_from_table from [nome_da_tabela];
select (max_number_from_table-actual_sequence_number) into difference from dual;
if difference > 0 then select [nome_da_sequence].nextval into actual_sequence_number from dual;
else dbms_output.put_line ('a sequence [nome_da_sequence] no foi atualizada, j estava ok!');
create or replace procedure reset_sequence( p_seq_name in varchar2, p_val      in number default 0) select min_value from user_sequences where sequence_name = p_seq_name;
if p_val        < l_minvalue then else l_difference := p_val - l_current;
if l_difference = 0 then end if;
end reset_sequence;
create or replace procedure reset_user_sequences_to_data select 'select ''begin'' || chr(10) || x || chr(10) || ''end;'' from (select listagg(x, chr(10)) within group (order by null) x from (' from (select listagg(x, ' union ') within group ( order by null) x from (select chr(10) from (select table_name, regexp_substr(wtext, 'new\.(\s*) is null',1,1,'i',1) col_name, regexp_substr(btext, '(\.|\s)([a-z_]*)\.nextval',1,1,'i',2) seq_name from user_triggers (select name bname, text btext from user_source where type = 'trigger' and upper(text) like '%nextval%' ) (select name wname, text wtext from user_source where type = 'trigger' and upper(text) like '%is null%' ) where trigger_type   = 'before each row' and triggering_event = 'insert' ) ) end reset_user_sequences_to_data;
create or replace procedure reset_sequence( p_seq_name in varchar2, tablename in varchar2 );
create or replace procedure reset_seq( p_seq_name in varchar2 );
create or replace function in_sort(anyarray, out id anyelement, out ordinal int) select $1[i], i from generate_series(array_lower($1,1),array_upper($1,1)) i;
select * from comments c;
select * from "comments" where ("comments"."id" in (1,3,2,4)) end;
select * from "comments" join ( select 1 as "id",1 as "order" union all select 3,2 union all select 2,3 union all select 4,4;
select * from "comments" where ("comments"."id" in (1,3,2,4));
create sequence serial start 1;
select * from comments c join (select unnest(array[1,3,2,4]) as id, nextval('serial') as id_sorter) x drop sequence serial;
create function unnest(anyarray) returns setof anyelement select $1[i] from generate_series(array_lower($1,1),array_upper($1,1)) i;
select unnest(array['john','paul','george','ringo']) as beatle select unnest(array[1,3,2,4]) as id;
select * from comments as c, (values (1,1),(3,2),(2,3),(4,4) ) as t (ord_id,ord) where (c.id in (1,3,2,4)) and (c.id = t.ord_id);
select * from comments c join ( select id, row_number() over() as id_sorter from (select unnest(array[1,3,2,4]) as id) as y;
select c.* from comments c join ( values (1,1), (3,2), (2,3), (4,4);
select * from `comments` where `comments`.`id` in ('12','5','3','17');
select * from "comments" where ("comments"."id" in (1,3,2,4));
select * from comments;
select c.* from comments c join ( select * from unnest(array[43,47,42]) with ordinality;
select c.* from comments c join unnest(array[43,47,42]) with ordinality as x (id, ordering);
values (array[42,48,43]) ) select c.* from comments c, x where id = any (x.id_list);
select c.* from comments c where id in (42,48,43);
select * from comments where id in (1,3,2,4);
select c.* from   comments c join   unnest('{1,3,2,4}'::int[]) with ordinality t(id, ord) using (id);
select * from comments where comments.id in;
select a.id,a.status,a.description from minicloud_tasks as a order by random();
select a.id,a.status,a.description from minicloud_tasks as a join ( values ('processing', 1), ('pending', 2), ('completed', 3), ('deleted', 4);
alter table users alter column priv_user set default false;
alter table users add "priv_user" boolean default false;
alter table users add column "priv_user" boolean default false;
alter table users add column "priv_user" boolean not null default false;
alter table users add column priv_user boolean;
update users set priv_user = 'f';
alter table users alter column priv_user set not null;
alter table users alter column priv_user set default false;
alter table users add column priv_user boolean default false ;
update my_table set a = 5;
update my_table set a = 5;
update "my_table" set "a" = 5;
select * from persons where "first_name" = 'xyz';
if exists (select * from   [sys].[table_types] where  user_type_id = type_id(n'[dbo].[udtabletype]')) end;
if type_id(n'idtype') is null create type [dbo].[idtype] from bigint not null if not exists (select * from sys.types where is_user_defined = 1 and name = 'idtype') create type [dbo].[idtype] from bigint not null;
if type_id(n'mytype') is null ...;
if exists (select * from sys.types where is_table_type = 1 and name = 'mytype');
if exists(select 1 from sys.types where name = 'person' and is_table_type = 1 and schema_id('vab') = schema_id) drop type vab.person;
create type vab.person as table;
select prkey,whatsthat,cash,sum(cash) over (order by whatsthat) from public.iuk order by whatsthat,prkey;
[ <partition by clause> ] );
select *,sum(salary) over(order by salary range between unbounded preceding and current row) as sum_sal from employees;
select *,sum(salary) over(order by salary rows between unbounded preceding and current row) as sum_sal from employees;
select *,sum(salary) over(order by salary) as sum_sal from employees;
select *, sum(salary) over(order by salary range between unbounded preceding and current row) as sum_sal from employees;
select *,sum(salary) over(order by salary rows between unbounded preceding and unbounded following) as sum_sal from employees;
select *,sum(salary) over() as sum_sal from employees;
select salesorderid, productid, orderqty from sales.salesorderdetail where salesorderid in(43659,43664) salesorderid, productid, orderqty;
select salesorderid, productid, orderqty ,count(*) over () as 'countallagain' from sales.salesorderdetail where salesorderid in(43659,43664);
select ..., from (your query) inlineview where total < 200;
select o.order_id, o.order_date, row_number() over(partition by o.order_id) as line_item_no, ol.product_id from orders o;
select orig.[partition], orig.value, orig.value * 100.0 / agg.totalvalue as valuepercent from originalrowset orig select [partition], sum(value) as totalvalue from originalrowset;
select [partition], value, value * 100.0 / sum(value) over (partition by [partition]) as valuepercent from originalrowset orig;
select vin, make, model, year, color , count(*) over (partition by year) as count2 from dim_equipment;
) select vin, make, model, year, color, count2 from dim_equipment, eq where eq.year2=dim_equipment.year;
alter procedure getemployees as begin delete @eelist where employeeid in (select employeeid from @ee20) delete @ee20;
select @customerid = customerid, @id = id from @tmp where id = @id + 1 if @@rowcount = 0 break;
exec dbo.yoursproc @customerid;
select top 1 @currentrownum = extendeddata.rownum from    ( select data.* from [datatable] data where extendeddata.rownum > @currentrownum if @@rowcount = 0 break;
drop type if exists cprootmaptype create type cprootmaptype as table( rootid1 int ) drop procedure if exists spmaproot2toroot1 create procedure spmaproot2toroot1 ( @map cprootmaptype readonly ) as  update linktable set root = root1 from linktable  lt join @map m on lt.root = root2 update comments set root = root1 from comments c join @map m on c.root = root2;
exec spmaproot2toroot1 @map;
set @lastcustomerid = 0 select top 1 @customeridtohandle = customerid from sales.customer where customerid > @lastcustomerid set @lastcustomerid = @customeridtohandle set @customeridtohandle = null select top 1 @customeridtohandle = customerid from sales.customer where customerid > @lastcustomerid end;
select customerid, customersum.total from customers;
create function computecustomertotal ( @customerid int ) as return ( select sum(customerorder.amount) as total from customerorder where customerid = @customerid );
set @lastcustomerid = 0 set @customeridtohandle = 1 set @lastcustomerid = @customeridtohandle select top 1 @customeridtohandle = customerid from sales.customer where customerid > @lastcustomerid if @customeridtohandle <> @lastcustomerid end  end;
select top 1 @customerid = customerid from sales.customer where customerid > @customerid if @@rowcount = 0 break;
exec dbo.yoursproc @customerid end;
create procedure setfakeusers (out output varchar(100)) set @lastgameid = 0;
set @userid = 0;
select @currentgameid = id from online_games where id > lastgameid set @lastgameid = @currentgameid;
set @currentgameid = null;
select @userid = userid from users where find_in_set('bot',baseinfo) update online_games set userid = @userid where id = @currentgameid;
select @currentgameid = id from online_games where id > lastgameid end while;
set output = "done";
select @data1 = data1, @data2 = data2 from sales.customer where [id] = @customerid ;
exec dbo.yoursproc @data1, @data2 select @customerid = min(customerid) from sales.customer where customerid > @customerid end;
select @sql = @sql + 'exec myproc ' + convert(varchar(10),fld1) + ',' from mytable exec (@sql);
id int identity(1,1) , isiterated bit default 0 , someint int , somebool bit , otherstuff varchar(200) ) someint , somebool , otherstuff ) select 1 , -- someint - int union all select 42 , -- someint - int set     @tablecount = (select count(1) from [@holdstuff]) set     @loopcount = 1 set @loopcount = @loopcount + 1 select  top 1 @someint = someint , @somebool = somebool , @otherstuff = otherstuff from    @holdstuff where   isiterated = 0 update  @holdaccounts set     isiterated = 1 where   id = @id exec somerandomsp @someint, @somebool, @otherstuff end;
id int ) set @rowcnt = @rowcnt + 1 select @code=code, @name=longname from mytable inner join @tblloop tl on mytable.id=tl.id where tl.rownum=@rowcnt end;
set serverout on size 6000;
select xmlagg(xmlelement(e,suplr_suplr_id||',')).extract('//text()') "supplier" from suppliers;
select xmlagg(xmlelement(e,ename||',')).extract('//text()') "result" from employee_names;
select pid, listagg(desc, ' ') within group (order by seq) as description from b group by pid;
select pid, dbo.myconcat(pid) from tablea;
as begin select @x = isnull(@x +',', @x, @x +',') + desc from tableb where pid = @pid;
select xmlagg(xmlelement(e,fieldname||',')).extract('//text()') "fieldnames" from field_master where field_id > 10 and field_area != 'nebraska';
select pid, listagg(desc, ' ') within group (order by seq) as description from b group by pid;
select pid, to_string(cast(collect(desc) as varchar2_ntt)) as vals from b group by pid;
select pid, to_string(cast(collect(desc order by desc) as varchar2_ntt)) as vals from b group by pid;
select pid, substr (max (sys_connect_by_path (description, ', ')), 3) all_descriptions from ( select row_number () over (partition by pid order by pid, seq) rnum, pid, description from ( select a.pid, seq, description from table_a a, table_b b where a.pid = b.pid(+) ) );
select pid, substr (max (sys_connect_by_path (description, ', ')), 3) all_descriptions from ( select row_number () over (partition by pid order by pid, seq) rnum, pid, description from ( select pid, seq, description from table_b ) );
select substr (max (sys_connect_by_path (description, ', ')), 3) all_descriptions from ( select row_number () over (partition by unique_id order by pid, seq) rnum, description from ( select '1' unique_id, b.pid, b.seq, b.description from table_b b ) );
select pid, listagg(desc, ' ' on overflow truncate) within group (order by seq) as desc from b group by pid;
select * from items where id in;
select * from items where exists (select 1 from item_tag where id = item_id and tag_id = tag1) and exists (select 1 from item_tag where id = item_id and tag_id = tag2) and ...;
select distinct target from tags where tag in ([your list of tags to search for here]) and target_type = [the table you're searching];
select target from ( select target, count(*) cnt from tags where tag in ([your list of tags to search for here]) and target_type = [the table you're searching] ) where cnt = [number of tags being searched];
select tags.tagid,tags.tagname from tags,tagxref where tagxref.tagid = tags.tagid and tagxref.itemid = @itemid;
select * from items, tagxref where tagxref.tagid in where tags.tagname = @tagname; ) and items.itemid = tagxref.itemid;
select field1, field2 from sometable where --(constraints);
select distinct value from table order by value desc limit 2;
select min(value) from (select distinct value from table order by value desc limit 2) as t;
select * from table order by numericalcolumn desc limit 1 offset 1;
select * from table order by numericalcolumn desc limit (1, 1);
select max( col ) from table where col < ( select max( col ) from table );
select top 1 myintcolumn from mytable where myintcolumn <> (select top 1 myintcolumn from mytable order by myintcolumn desc);
select max([column_name]) from [table_name] where [column_name] <;
select top 1 x from ( select top 2 distinct x from y;
select max( col ) from [table] where col < ( select max( col ) from [table] ) select top 1 col from ( select top 2 col from [table];
select col from ( select row_number() over (order by col asc) as 'rownum', col from [table] ) withrownum where rownum = 2;
select top 1 start at 2 value from table order by value;
select min([column]) as [column] from ( select top 2 [column] from [table];
select `column` from `table` limit 1,1;
select top 2 [column] from [table];
select * from emp e where 3>=(select count(distinct salary) from emp where s.salary<=salary);
select * from x x1 where 1 = (select count(*) from x where x1.a < a);
select max([column_name]) from [table_name];
select max([column_name]) from [table_name] where [column_name] **in**;
select max(col_name) from table_name where col_name in;
select min(sal) from emp where sal in;
select max(col) from table where col not in (select max(col) from table);
select col_name from ( select dense_rank() over (order by col_name desc) as 'rank', col_name from table_name ) withrank where rank = 2;
select * from (select row_number() over (order by col_x desc) as row, col_1 from table_1)as table_new tn inner join table_1 t1 where row = 2;
select * from table where column < (select max(columnq) from table) column desc limit 1;
select `column` from `table` order by `column` desc limit 1,1;
select * from tablename a where 2 = (select count(distinct(b.columnname)) from tablename b where;
select top 1 (salary) from xyz where salary not in (select distinct top 1(salary) from xyz order by salary desc);
select  top 1 col_name from table_name where col_name < (select top 1 col_name from table_name order by col_name desc);
select * from emp where salary= where salary != (select max(salary) from emp);
select top 1 age from student where age in(select distinct top 2 age  from student order by age desc) order by age asc;
select column name from table name column name desc limit 1,1;
select a.* ,b.* from (select * from (select row_number() over(order by fc_amount asc) srno2, fc_amount as amount2  from entry group by fc_amount) tbl where tbl.srno2 =2) b;
select * from [table] where (column)=(select max(column)from [table] where column < (select max(column)from [table]));
select max( colname ) from tablename where colname < ( select max( colname ) from tablename);
select max(salary) as secondmax from test where salary !=(select max(salary) from test);
select age from student group by id having age<(select max(age) from student)order by age limit 1;
select max(salary) from employee where salary not in (select max(salary) from employee );
select sal from salary order by sal desc limit 1 offset 1;
select score from table where score = (select max(score)-1 from table);
select top 1 q.* from (select top 2 column_name from table_name order by column_name desc) as q;
select top 1 q.* from (select top 5 column_name from table_name order by column_name desc) as q;
select top 1 lead(max (column)) over (order by column desc) from table;
select extension from [dbo].[employees] order by extension desc offset  2  rows fetch next  1 rows only;
select  amount from  salary limit 1 , 1;
select distinct amount from  salary limit 1 , 1;
select max(sal) from emp where sal not in (select top 3 sal from emp order by sal desc );
select distinct supplierid from [products] order by supplierid desc limit 1 offset 1;
select * from `tablename` order by `columnname` desc limit 1,1;
select salary from test order by salary desc offset 1 rows fetch next 1 rows only;
select  * from [users];
select  * from users;
select  * from `employee` where  employee_salary = (select employee_salary;
select max(column_name) from table_name where column_name not in (select max(column_name) from table_name);
select top 1 unitprice from (select distinct top n unitprice from;
select max(salary) from (select * from emp where salary<> (select max(salary) from emp)) temp;
select concat(coalesce(`affiliate_name`,''),'-',coalesce(`model`,''),'-',coalesce(`ip`,''),'-',coalesce(`os_type`,''),'-',coalesce(`os_version`,'')) as device_name from devices;
select concat_ws('-',`affiliate_name`,`model`,`ip`,`os_type`,`os_version`) as device_name from devices;
select concat(isnull(`affiliate_name`,''),'-',isnull(`model`,''),'-',isnull(`ip`,''),'-',isnull(`os_type`,''),'-',isnull(`os_version`,'')) as device_name from devices;
select concat(if(affiliate_name is null ,'',affiliate_name),'- ',if(model is null ,'',affiliate_name)) as model from devices;
select concat_ws("",affiliate_name,':',model,'-',ip,... etc);
select  a.*, b.score from    @table1 a where 1=1 and a.name = 'flow';
select setting_id, value from character_settings where character_id = 1 ) select settings.*, settings_for_char.value from settings;
select  `settings`.*, `character_settings`.`value` from    `settings` `character_settings` and `character_settings`.`character_id` = '1';
select `settings`.*, `character_settings`.`value` from (`settings`) where `character_settings`.`character_id` = '1' or;
select  s.*, cs.`value` from settings s and cs.character_id = 1;
select `settings`.*, ( select `value` from `character_settings` where `character_settings`.`setting_id` = `settings`.`id` and `character_settings`.`character_id` = '1') as cv_value from `settings`;
select s.*, c.value from settings s;
create fulltext;
if (dr.haserrors);
and c.crsnum = e.crsnum and c.batch_no = e.batch_no and d.lect_code= e.lect_code;
select 'mr ' || ename from emp;
select concat('a','b') from dual;
select concat(a,b) from dual;
select 'a'||'b'||'c'||'d' from dual;
create table master ( con_id integer unique, ind_id integer create unique index master_unique_idx on master (ind_id);
table "public.master" column |  type   | modifiers;
create table detail ( con_id integer, ind_id integer, constraint detail_fk1 foreign key (con_id) references master(con_id), constraint detail_fk2 foreign key (ind_id) references master(ind_id) table "public.detail" column |  type   | modifiers;
alter table master add constraint master_ind_id_key unique using index master_unique_idx;
table "public.master" column |  type   | modifiers table "detail" constraint "detail_fk1" foreign key (con_id) references master(con_id) table "detail" constraint "detail_fk2" foreign key (ind_id) references master(ind_id);
create table ...;
alter table master add column part_id integer;
create unique index master_partial_idx on master (part_id) where part_id is not null;
alter table master add constraint master_part_id_key unique using index master_partial_idx;
unique constraint;
create table t (a int primary key, b int, c int);
create unique index u on t(b);
values (1, 2, 3);
alter table t add constraint u unique (b);
create table users ( name text, unique (lower(name));
create table users ( name text create unique index uq_name on users (lower(name));
create function dbo.fn_workdays(@startdate datetime, @enddate datetime= null ) as begin set @days = 0 if @enddate = null set @enddate = eomonth(@startdate) --last date of the month if datename(dw, @startdate) <> 'saturday' and datename(dw, @startdate) <> 'sunday' and not ((day(@startdate) = 1 and month(@startdate) = 1)) --new year's day. and not ((day(@startdate) = 4 and month(@startdate) = 7)) --independence day. set @days = @days + 1 end  set @startdate = dateadd(dd,1,@startdate) end  end;
select dbo.fn_workdays('1/1/2016', '9/25/2016');
select dbo.fn_workdays(startdate, enddate) from table1;
@enddate date = '2014-01-31';
select count(*) as numberofweekdays from dbo.calendar where calendardate between @startdate and @enddate and isworkday = 1;
@enddate datetime = '2014-01-31';
select sum(case when datepart(dw, dateadd(dd, number-1, @startdate)) between 2 and 6 then 1 else 0 end) as numberofweekdays from dbo.numbers where number <= datediff(dd, @startdate, @enddate) + 1 -- number table starts at 1, we want a 0 base;
create function [dbo].[fngetcountworkingbusinessdays] ( @startdate as datetime, @enddate as datetime ) as begin set @startdate = case else @startdate end set @enddate = case else @enddate end set @res = set @res = case when @res < 0 then 0 else @res end end ;
create function x ( @startdate datetime, @enddate datetime ) as begin set @startdate = dateadd(dd,1,@startdate) set @teller = 0 if datediff(dd,@startdate,@enddate) <= 0 set @teller = 0 end else begin if datepart(dw,@startdate) < 6 set @teller = @teller + 1 end set @startdate = dateadd(dd,1,@startdate) end end return @teller end;
select @result = (..cms's answer..) if  (@result < 0) select @result = 0;
create table [dbo].[holiday]( [id] [int] identity(1,1) not null, [name] [nvarchar](50) null, [date] [datetime] not null);
create table [dbo].[plan_phase]( [id] [int] identity(1,1) not null, [id_plan] [int] not null, [id_phase] [int] not null, [start_date] [datetime] null, [end_date] [datetime] null, [work_days] [int] null);
select start_date, end_date, (datediff(dd, start_date, end_date) + 1) from plan_phase;
create function [dbo].[fngetbusinessdays] ( @promisedate date, @receiveddate date ) as begin select @days = case when @promisedate > @receiveddate then case when datename(dw, @promisedate) <> 'saturday' and datename(dw, @receiveddate) = 'saturday' then 1 else 0 end + where holidaydate between @receiveddate and @promisedate and datename(dw, holidaydate) <> 'saturday' and datename(dw, holidaydate) <> 'sunday') else datediff(d,@promisedate,@receiveddate)  - case when datename(dw, @promisedate) <> 'saturday' and datename(dw, @receiveddate) = 'saturday' then 1 else 0 end - where holidaydate between @promisedate and @receiveddate and datename(dw, holidaydate) <> 'saturday' and datename(dw, holidaydate) <> 'sunday') end  end;
select @rawdays =  datediff(day, @startdate, @enddate )--+1 select  @rawdays - count(*) from holiday numberofbusinessdays where [holiday_date] between @startdate+1 and @enddate;
if exists ( select * from dbo.sysobjects where id = object_id(n'[dbo].[fn_workdays]') and xtype in (n'fn', n'if', n'tf') ) drop function [dbo].[fn_workdays] create function dbo.fn_workdays ( @startdate datetime, @enddate   datetime = null --@enddate replaced by @startdate when defaulted ) as --calculate the return of the function. if @startdate is null if @enddate is null select @enddate = @startdate select @startdate = dateadd(dd,datediff(dd,0,@startdate), 0), @enddate   = dateadd(dd,datediff(dd,0,@enddate)  , 0) if @startdate > @enddate select @swap      = @enddate, @enddate   = @startdate, @startdate = @swap select --start with total number of days including weekends then 1 else 0 then 1 else 0 where  [holdate] between @startdate and @enddate ) ) end go select  [master].[dbo].[fn_workdays] (getdate(), @enddate);
create table calendar ( dt smalldatetime primary key, isworkday bit create function addworkingdays (@initialdate smalldatetime, @numberofdays int) set @result = ( select t.dt from ( select dt, row_number() over (order by dt) as daysahead from calendar where dt > @initialdate and isworkday = 1 where t.daysahead = @numberofdays ) end;
create function [dbo].[shiftholidaytoworkday](@date date) as begin if datename( dw, @date ) = 'saturday' set @date = dateadd(day, - 1, @date) else if datename( dw, @date ) = 'sunday' set @date = dateadd(day, 1, @date) end go create function [dbo].[getholiday](@date date) as begin select @s = case else null end from ( select [year] = year(@date), [month] = month(@date), [dayofmonth] = day(@date), [dayname]   = datename(weekday,@date) end go create function [dbo].getholidays(@year int) as return ( select dt, dbo.getholiday(dt) as holiday from ( select dateadd(day, number, convert(varchar,@year) + '-01-01') dt from master..spt_values where type='p' where year(dt) = @year and dbo.getholiday(dt) is not null ) create proc updateholidaystable as  if not exists(select table_name from information_schema.tables where table_name = 'holidays') create table holidays(dt date primary key clustered, holiday varchar(50)) set @year = 1990 select a.dt, a.holiday from dbo.getholidays(@year) a where b.dt is null set @year = @year + 1 end  create function [dbo].[getworkdays](@startdate date = null, @enddate date = null) as begin if @startdate is null or @enddate is null if @startdate >= @enddate set @days = 0 if year(@startdate) * 100 + datepart(week, @startdate) = year(@enddate) * 100 + datepart(week, @enddate) select @days = (datediff(dd, @startdate, @enddate)) else --diff weeks select @days = (datediff(dd, @startdate, @enddate) + 1) end;
create function dbo.ufn_calculatebusinessdays( @startdate date, @enddate date = null) as  if @enddate is null select @totalbusinessdays += ( select case else 1 end as result);
set @testdate = dateadd(dd, 1, @testdate);
set @startdate = '2018/01/01' set @enddate = '2019/01/01' select datediff(day, @startdate, @enddate) -- total days;
select datediff(day, @startdate, @enddate) /* all midnights passed */;
create function dbo.datediff_weekdays ( @startdate  datetime, @enddate    datetime ) as  if datename(dw, @startdate) not in ('saturday','sunday') set @result = @result +1 end set @startdate = dateadd(day, +1, @startdate) end ;
create function [dbo].[fn_gettotalworkingdaysusingloop] @dateto date ) as begin if datename(weekday, @datefrom) in('monday', 'tuesday', 'wednesday', 'thursday', 'friday') set @totworkingdays = @totworkingdays + 1;
set @datefrom = dateadd(day, 1, @datefrom);
set datefirst 1 select ,(datediff(dd,  [startdate], [enddate])) from /*your table*/;
select  sum(case when datename(dw,currentdate) not in ('saturday', 'sunday') then 1 else 0 end) as noofworkdays from dbo.getnums(0,datediff(day,@date1, @date2)-1) as num;
if exists ( select * from dbo.sysobjects where id = object_id(n'[dbo].[fn_workdays]') and xtype in (n'fn', n'if', n'tf') ) drop function [dbo].[fn_workdays] create function dbo.fn_workdays ( @startdate datetime, @enddate   datetime = null --@enddate replaced by @startdate when defaulted ) as --calculate the return of the function. if @startdate is null if @enddate is null select @enddate = @startdate select @startdate = dateadd(dd,datediff(dd,0,@startdate), 0), @enddate   = dateadd(dd,datediff(dd,0,@enddate)  , 0) if @startdate > @enddate select @swap      = @enddate, @enddate   = @startdate, @startdate = @swap select --start with total number of days including weekends then 1 else 0 then 1 else 0 ) end go;
set @startdate = '2008/10/01' set @enddate = '2008/10/31' select (datediff(dd, @startdate, @enddate) + 1);
set ansi_nulls on set quoted_identifier on create function bdatediff ( @startdate as datetime, @enddate as datetime ) as begin set @res = (datediff(dd, @startdate, @enddate) + 1) end go;
set @totaldays= datediff(day, @startdate, @enddate) +1 select @reduceddayswithenddate = case datename(weekday, @enddate) else 0 end set @totaldays=@totaldays-@reduceddayswithenddate set @weekpart=@totaldays/7;
set @datepart=@totaldays%7;
set @workdays=(@weekpart*5)+@datepart;
select @startdate='3/2/2010', @enddate='3/7/2010' set @totaldays= datediff(day, @startdate, @enddate) +1 select @reduceddayswithenddate = case datename(weekday, @enddate) else 0 end set @totaldays=@totaldays-@reduceddayswithenddate set @weekpart=@totaldays/7;
set @datepart=@totaldays%7;
set @workdays=(@weekpart*5)+@datepart select @workdays;
select `train`, `dest`, substring_index(group_concat(`time` order by `time` desc), ",", 1) as `time` from traintable;
select * from traintable where (train, time) in (select train, max(time) from traintable group by train);
select t1.* from traintable t1 left join traintable t2 where t2.time is null;
select train, dest, time from ( select train, dest, time, rank() over (partition by train order by time desc) dest_rank from traintable;
select t.train, t.dest, r.maxtime from ( select train, max(time) as maxtime from traintable;
select train, max(time), max(dest) keep (dense_rank last order by time) max_keep from traintable;
select * from table where lower(value) similar to '%(foo|bar|baz)%';
select * from table where value ~* 'foo|bar|baz';
select * from table where value  like any (array['%foo%', '%bar%', '%baz%']);
select * from table where value ilike any (array['%foo%', '%bar%', '%baz%']);
select * from table where lower(value) ~~ any('{%foo%,%bar%,%baz%}');
select uo.order_id, uo.order_total, uo.order_status, (select ifnull(sum(uop.price * uop.qty),0) from uc_order_products uop where uo.order_id = uop.order_id (select ifnull(sum(upr.amount),0) from uc_payment_receipts upr where uo.order_id = upr.order_id (select ifnull(sum(uoli.amount),0) from uc_order_line_items uoli where uo.order_id = uoli.order_id from uc_orders uo where uo.order_status not in ("future", "canceled") and uo.uid = 4172;
select ifnull(`field`,0) as field, `otherfield` from `mytable`;
[string] $datasource = ".\sqlexpress", [string] $database = "masterdata", [string] $sqlcommand = $(throw "please specify a query.") );
if ($cmd.executenonquery() -ne -1);
if ($pars -and $pars.keys) {;
update table_name set column1=value1,column2=value2,... where some_column=some_value;
update table-name set column-name = value, column-name = value, ... where condition;
update school set course = 'mysqli', teacher = 'tanzania', student = 'you' where id = 6;
update emp set id = 123, name = 'peter' from table_name;
colname varchar(255), val varchar(255) ) select colname, val from tblb ( val where id = @id select @tsql = coalesce(@tsql + ''' from @tblpivot set @tsql = n'update tbla set ' + @tsql + ''' where id = ' + @id;
where credit_id='" & lbcreditid.text & "'".;
update table1 set a = t2.a, b = t2.b, ....... from table2 t2 where table1.id = t2.id;
update  table1 set     field1 = table2.field1, field2 = table2.field2, other columns... from    table2 where   table1.id = table2.id;
update table1 set (a,b,c) = (select x,y,x);
update t1 set t1.a = t2.a, t1.b = t2.b, . from table1 t1;
update  `table_1` `table_2` set  col1= value, col2= val,col3= val,col4= val;
update t1 set t1.cost2=t1.tot_cost+2.000, t1.cost3=t1.tot_cost+2.000, t1.cost4=t1.tot_cost+2.000, t1.cost5=t1.tot_cost+2.000, t1.cost6=t1.tot_cost+2.000, t1.cost7=t1.tot_cost+2.000, t1.cost8=t1.tot_cost+2.000, t1.cost9=t1.tot_cost+2.000, t1.cost10=t1.tot_cost+2.000, t1.cost11=t1.tot_cost+2.000, t1.cost12=t1.tot_cost+2.000, t1.cost13=t1.tot_cost+2.000 from dbrmast t1;
update mytable set col = concat( col , "string" );
update mytable set col = concat( mytable.col , "string" );
update mytable set spares = concat(spares, ',', '818') where id = 1;
update mytable set spares = (select case when spares is null then '' else spares end as spares where id = 1) + 'some text' where id = 1;
create function isnumber(inputvalue varchar(50)) if (inputvalue regexp ('^[0-9]+$')) then return 1;
select isnumber('383xxxx');
select isnumber('38333434');
select * from tablex where isnumber(columnx) = isnumber('unkownuserinput');
select * from tbl where col1 = concat(cast(col1 as decimal), "");
select * from mytable where col1 regexp '^[+-]?[0-9]*([0-9]\\.|[0-9]|\\.[0-9])[0-9]*(e[+-]?[0-9]+)?$';
drop table if exists mytable;
create table mytable (col1 varchar(50));
values ('00.00'),('+1'),('.123'),('-.23e4'),('12.e-5'),('3.5e+6'),('a'),('e6'),('+e0');
select col1, col1 + 0 as casted, col1 regexp '^[+-]?[0-9]*([0-9]\\.|[0-9]|\\.[0-9])[0-9]*(e[+-]?[0-9]+)?$' as isnumeric from mytable;
select if(value/1>0 or value=0,'its a number', 'its not a number') from table;
select * from mytable where col1 > 0;
select * from mytable where !col1 > 0;
select * from mytable where mytextfield regexp "^([,|.]?[0-9])+$";
select * from mytable where `col1` + 0 = `col1`;
select *, case when `col1` + 0 = `col1` then 1 else 0 end as `is_numeric` from `mytable` having `is_numeric` = 1;
select * from mytable where sign (col1)!=0;
select * from mytable where sign (col1)!=0 or col1=0;
select * from table where col1 regexp '^[[:digit:]]+$';
select * from mytable where col1*0 != col1;
select * from mytable where concat('',col1 * 1) = col1;
select * from mytable where col1 regexp '^[0-9]+$';
select * from mytable where col1 regexp '^[0-9]+$';
select * from mytable where col1 regexp '^[0-9]+\\.?[0-9]*$'; - for 123.12;
select * from mytable where col1 regexp '[0-9]+';
column 'year_month' does not exist;
select date_trunc('month', created_at), 'mm/yyyy' as month from "orders" date_trunc('month', created_at);
select "id", "product", "sale", date_trunc('month', case when then t."date" at time zone '+03' -- romania timezone offset + dst else t."date" at time zone '+02' -- romania timezone offset from public."table" as t where 1=1 and t."date" >= '01/07/2015 00:00:00'::timestamp without time zone and t."date" < '01/07/2017 00:00:00'::timestamp without time zone case when then t."date" at time zone '+03' -- romania timezone offset + dst else t."date" at time zone '+02' -- romania timezone offset;
select date_part('month', txn_date) as txn_month, date_part('year', txn_date) as txn_year, sum(amount) as monthly_sum from yourtable;
select to_char(date,'mon') as mon, extract(year from date) as yyyy, sum("sales") as "sales" from yourtable;
select date_trunc('month', txn_date) as txn_month, sum(amount) as monthly_sum from yourtable;
"select to_char(created_at, 'mon') as month, extract(year from created_at) as year, sum(desired_value) as desired_value from desired_table );
select to_char(date('2014-05-10'),'mon-yy') as year_month; --'may-14' select to_char(date('2014-05-10'),'yyyy-mm') as year_month; --'2014-05';
select to_char(date,'yy-mon') as year_month from some_table;
select * from table where yourcolumn is not null;
select * from table where not (yourcolumn <=> null);
select null <=> null -- 1 select true <=> true -- 1 select col1 <=> col2 from mytable;
select null != null,         //--result is null not null <=> null,        //--result is 0;
where p.name is null;
case when (a = b) or (a is null and b is null) then 1 else 0 end = 1;
case when a is null and b is null then 1 -- both operands null then 1 else a = b                          -- else behave like normal = operator end;
where p.name <=> null;
where p.name is null;
select 1 <=> 1, null <=> null, 1 <=> null;
select 1 = 1, null = null, 1 = null;
select top 25   amount, (select sum(amount) from time_detail b where b.time_detail_id <= a.time_detail_id) as total from time_detail a;
select testtable.*, sum(somevalue) over(order by somedate) from testtable;
select somedate, somevalue, sum(somevalue) over(order by somedate as runningtotal from table;
drop table #t create table #t ( ord int primary key, total int, running_total int) set @total = 0 update #t set running_total = @total, @total = @total + total select * from #t;
create table #t ( ord int primary key, total int, running_total int) set nocount on set @i = 0 set @i = @i +1 end commit;
select ord,total, (select sum(total) from #t b where b.ord <= a.ord) as b from #t a;
select a.ord, a.total, sum(b.total) as runningtotal from #t a cross join #t b where (b.ord <= a.ord);
select ord, total from #t @ord int, @total int set @running_total = 0 set @running_total = @running_total + @total end  select * from @totaltable;
set @total = 0 update #t set running_total = @total, @total = @total + total select * from #t;
select a.somedate, a.somevalue, sum(b.somevalue) as runningtotal from testtable a where (b.somedate <= a.somedate);
select t.id , t.somedate , t.somevalue , rt.runningtotal from testtable t from testtable where somedate <= t.somedate;
select row_number() over (order by somedate) as orderid from ( select 45 as id, cast('01-01-2009' as datetime) as somedate, 3 as somevalue union all select 23, cast('01-08-2009' as datetime), 5 union all select 12, cast('02-02-2009' as datetime), 0 union all select 77, cast('02-14-2009' as datetime), 7 union all select 39, cast('02-20-2009' as datetime), 34 union all select 33, cast('03-02-2009' as datetime), 6 select t1.id from #tmp t1 join #tmp t2 t1.orderid t1.orderid drop table #tmp;
select id, somedate, somevalue, sum(somevalue) over(order by somedate rows unbounded preceding) as runningtotal from testtable;
as ( select t.ord, t.total, t.total as running_total from #t as t where t.ord = 0 union all select t.ord, t.total, t.total + c.running_total as running_total from cte_runningtotal as c ) select c.ord, c.total, c.running_total from cte_runningtotal as c;
select @total = 0, @ord = -1 update #t set @ord = case when ord <> @ord + 1 then 1/0 else ord end, ------------------------ select * from #t;
select somedate, (select sum(somevalue) from testtable t2 where t2.somedate<=t1.somedate) as running_total from testtable t1;
select id, somedate, somevalue, (select sum(somevalue) from testtable t2 where t2.somedate<=t1.somedate) as running_total from testtable t1;
create table #table (_id int identity(1,1) ,id int ,    somedate varchar(100) , somevalue int) select 45 , '01/jan/09', 3 union all select 23 , '08/jan/09', 5 union all select 12 , '02/feb/09', 0 union all select 77 , '14/feb/09', 7 union all select 39 , '20/feb/09', 34 union all select 33 , '02/mar/09', 6 (  select _id , id  ,    somedate  , somevalue ,somevalue from #table where _id = 1 union all select #table._id , #table.id  , somedate  , somevalue , somevalue + _totvalue from #table,cte where #table._id > 1 and cte._id = ( #table._id-1 ) ) select * from cte;
select id, someday, somevalue, (select sum(somevalue) from testtable as t2 where t2.id = t1.id and t2.someday <= t1.someday) as runningtotal from testtable as t1;
select id lag(runningtotal) over (order by somedate) + somevalue as runningtotal from testtable;
select a.id, a.value, sum(b.value)from   runtotaltestdata a, runtotaltestdata b where b.id <= a.id;
select     id from       testtable;
select     t.id from       testtable t select   runningtotal = sum(ti.somevalue) from     testtable ti where    ti.somedate <= s.somedate;
alter table table_name drop constraint some_constraint;
alter table table_name add constraint some_constraint primary key(column_name1,column_name2);
select t1.field1 from table1 t1 join table2 t2 where t1.field2 = 'test';
set @businesscursor = cursor for select customerid from customer where customerid in ('3908745','3911122','3911128','3911421') set @msg = '{ "customer": { "firstname": "firstname-'+convert(varchar(10), @customerid)+'", } end;
select cateid into [#temptable] from category where groupid = 'stocklist' select top 1 @cateid = cateid from #temptable delete #temptable where cateid = @cateid end  drop table #temptable;
select  top 1000 a.*, row_number() over(order by a.id desc) as row from dbo.table as a where statusid = 7;
select @row = row from #temptable where row = @counter set @counter = @row -1 end  drop table #temptable;
create  table #temp (jobid int) select @_minjid = min(jobid),@_maxjid = max(jobid)  from #temp ( jobid, ) values ( @_minjobid, ) set @_minjid = @_minjid + 1;
end  drop table #temp;
select top 1000 tableid from dbo.table where statusid = 7 select @tableid = (select top 1 tableid from #controltable delete #controltable where tableid = @tableid end  drop table #controltable;
set @mycursor = cursor for select top 1000 yourfield from dbo.table where statusid = 7;
select top 1000 tableid from dbo.table where statusid = 7 select top 1 @tableid = tableid from #controltable delete #controltable where tableid = @tableid end  drop table #controltable;
create table #temptable ( rowid int identity(1,1) primary key, hierarchy_id_to_update int, ) set @counter = 1 select @maxid = count(*) from #temptable select @hierarchy_id_to_update = pt.hierarchy_id_to_update from #temptable as pt where rowid = @counter set @counter = @counter + 1 end  if (object_id('tempdb..#temptable') is not null) drop table #temptable end;
delete from blob where not exists ( select * from files where id=blob.id );
delete from blob where fileid not in from files where id is not null/*this line is unlikely to be needed );
delete b from blob b where f.id is null;
delete from blob where not exists(select null from files f where f.id = fileid);
delete from blob where fileid not in (select f.id from files f);
select * from v$version;
select * from v$version;
set serveroutput on exec dbms_output.put_line( dbms_db_version.version );
select * from v$version;
select * from product_component_version;
create function fn_which_edition select banner from v$version where upper(banner) like upper('oracle database%');
if instr( upper(vrec_banner.banner), 'express') > 0 then v_database := 'express';
then v_database := 'standard';
then v_database := 'personal';
then v_database := 'enterprise';
else v_database := 'unknown';
then return 'error:' || sqlerrm(sqlcode);
end fn_which_edition; -- function fn_which_edition;
select * from v$version;
select @@version as version;
select edition,version from v$instance;
set serveroutput on;
select version from    v$instance;
select charindex('@', 'someone@somewhere.com');
select charindex('c', 'abcde');
select len(emailfield) - charindex('@', reverse(emailfield)) + 1;
delete f from dbo.foods as f where f.name in (...);
delete f from foods f where (f.name in ('chickens', 'rabbits'));
alter table tblname add columnnamea text default '';
alter table tblname add columnnameb text default '';
alter table tblname add columnnamec text default '';
values ('2020-01-27 14:54:11.000';
select convert(date, yourdate ,104);
( 'email_header', '<h2>111 any st.<br />anywhere, st 11111</h2><br />' + );
select (convert(date, '2018-04-01'));
select cast('02-21-2012 6:10:00 pm' as datetime2),     -- works just fine;
select convert(datetime,'21-02-12 6:10:00 pm',5);
select convert(datetime,'21-02-12 6:10:00 pm',105);
select convert(datetime,'21-02-2012 6:10:00 pm',5);
select convert(datetime,'21-02-2012 6:10:00 pm',105);
create table mytable (mydate);
select sum(case when mycolumn=1 then 1 else 0 end) from ad_currentview;
select sum(case when isnull(mycolumn,0)=1 then 1 else 0 end) from ad_currentview;
select count(nullif(0, mycolumn)) from ad_currentview;
select count(case when mycolumn = 1 then 1 else null end) from   ad_currentview;
select count() filter where <condition-1>, count() filter where <condition-2>, ... from ...;
select count(1) from ad_currentview where mycolumn=1;
select count(case when mycolumn=1 then ad_currentview.primarykeycolumn else null end) from ad_currentview;
select sum(case when mycolumn=1 then ad_currentview.numbercolumn else 0 end) from ad_currentview;
select id, count(if status=42 then 1 endif) as cnt from table;
select col1, col2, ... etc from (select vm2.visit_id, count(*) as vcount from dbo.visitmanifests as vm2 where vm2.inactive = 0 and vm2.visit_id = vm.visit_id col xyz from etc etc;
select coalesce(if(mycolumn = 1,count(distinct numbercolumn),null),0) column1, coalesce(case when mycolumn = 1 then count(distinct numbercolumn) else null end,0) as column2 from ad_currentview;
select tl.resource_type as restype from sys.dm_tran_locks as tl and tl.request_owner_type = 'transaction' and tl.resource_type = 'object' and tl.resource_type in ('page', 'key', 'rid', 'hobt') and par.index_id = paridx.index_id where tl.resource_database_id  = db_id() and es.session_id <> @@spid -- exclude "my" session and tl.request_mode <> 's' -- exclude simple shared locks select db_name(rsc_dbid) as 'database_name', case rsc_type when 1 then 'null'  case req_ownertype when 1 then 'transaction'  process.hostname , process.program_name , process.nt_domain , process.nt_username , process.program_name , sqltext.text from sys.syslockinfo lock join where 1=1 and db_name(rsc_dbid) = db_name() select * from sys.dm_tran_locks where resource_database_id = db_id() and resource_associated_entity_id = object_id('specific table');
select t1.resource_type , db_name( resource_database_id) as dat_name , t1.resource_associated_entity_id, t1.request_mode, t1.request_session_id, t2.wait_duration_ms, ( select text from sys.dm_exec_requests r cross apply sys.dm_exec_sql_text ( r.sql_handle ) where r.session_id = t1.request_session_id ) as wait_sql, t2.blocking_session_id, ( select text from sys.sysprocesses p cross apply sys.dm_exec_sql_text ( p.sql_handle ) where p.spid = t2.blocking_session_id ) as blocking_sql from sys.dm_tran_locks t1, sys.dm_os_waiting_tasks t2 where t1.lock_owner_address = t2.resource_address;
select * from sys.dm_tran_locks where resource_database_id = db_id() and resource_associated_entity_id = object_id(n'dbo.yourtablename');
select tl.resource_type, tl.resource_database_id, tl.resource_associated_entity_id, tl.request_mode, tl.request_session_id, wt.blocking_session_id, o.name as [object name], o.type_desc as [object descr], p.partition_id as [partition id], p.rows as [partition/page rows], au.type_desc as [index descr], au.container_id as [index/page container_id] from sys.dm_tran_locks as tl;
select cmd,* from sys.sysprocesses where blocked > 0;
update pg_attribute set atttypmod = 35+4 where attrelid = 'table1'::regclass and attname = 'col1';
alter table "my_table" alter column "mycolumn" type varchar(8);
create table address ( .....  );
create table foog(a varchar(10));
alter table foog alter column a type varchar(30);
table "public.foog" column |         type          | modifiers;
alter table users add column name_new varchar(512) default null;
update users set name_new = name;
alter table users drop name;
alter table users rename name_new to name;
alter table public.users alter column "password" type varchar(300);
alter table "public"."mytable" alter column "mycolumn" type varchar(40);
if (arguments != null && arguments.length <= 0) {;
parameters=[[value], [value], [value]]];
"insert into oc_manufacturer" +;
select id, email, productname, productmodel from products group by email;
select max(p.cliente) as id_cliente from rep_pre_ene_muestra as x where x.mail=p.mail and x.cliente=(select max(l.cliente) from rep_pre_ene_muestra as l where x.mail=l.mail)) as nombre, p.mail from rep_pre_ene_muestra as p;
select * from ( select  id, email, productname, productmodel, row_number() over(partition by email order by id desc) rn from products where rn = 1;
select * from ( select  id, email, productname, productmodel, row_number() over(partition by email order by id desc) rn from products where productmodel = 2 and productname like 'cyber%' where rn = 1;
( select id, email, productname, productmodel, row_number() over (partition by email order by id desc) as rownumber from   products ) select id, email, productname, productmodel from cte where rownumber = 1;
select distinct id, email, productname, productmodel from products;
select distinct top 1 id, email, productname, productmodel from products;
select email,row_number() over(order by email asc) as  id from tab;
select id, email, productname, productmodel from products where id in (select max(id) from products group by email);
select  cast(cast('000000000' as integer) as varchar);
case when substring(str_col, patindex('%[^0]%', str_col+'.'), len(str_col)) = '' then '0' else substring(str_col, patindex('%[^0]%', str_col+'.'), len(str_col)) end as str_col;
--  then you may skip the case-statement entirely and just use cn.cleannumber . select wn.wackadoonumber, cn.cleannumber, (case when wn.wackadoonumber like '%0%' and cn.cleannumber = '' then '0' else cn.cleannumber end)[allowzero] from (select @wackadoonumber[wackadoonumber]) as wn;
select o.type, o.value, parsed.value[wrongvalue], (case when charindex('0', t.value)  > 0--if there's at least one zero. and len(parsed.value) = 0--and the trimmed length is zero. then '0' else parsed.value end)[finalvalue], (case when charindex('0', t.value)  > 0--if there's at least one zero. and len(parsed.trimmedvalue) = 0--and the trimmed length is zero. then '0' else ltrim(rtrim(parsed.trimmedvalue)) end)[finaltrimmedvalue] from ( values ('null', null), ('emptystring', ''), ('zero', '0'), ('zero', '0000'), ('zero', '000.000'), ('spaces', '    0   a b c '), ('number', '000123'), ('alphanum', '000abc123'), ('nozero', 'nozeroshere') select ltrim(rtrim(o.value))[value] select substring(o.value, patindex('%[^0]%', o.value + '.'), len(o.value))[value], substring(t.value, patindex('%[^0]%', t.value + '.'), len(t.value))[trimmedvalue];
select right('0000000000' + ltrim(rtrim(nullif(' 0a10  ', ''))), 10)--0000000a10 select right('0000000000' + ltrim(rtrim(nullif('', ''))), 10)--null --when blank.;
case when patindex('%[^0]%', str_col + '.') > len(str_col) then right(str_col, 1) else substring(str_col, patindex('%[^0]%', str_col + '.'), len(str_col)) end;
select cast(cast('000000000' as integer) as varchar);
drop function [dbo].[fn_stripleading] create function [dbo].[fn_stripleading] (@string varchar(128), @stripchar varchar(1)) as begin @pattern varchar(10) select @pattern = '%[^'+@stripchar+']%' select @retval = case when substring(@string, patindex(@pattern, @string+'.'), len(@string)) = '' then @stripchar else substring(@string, patindex(@pattern, @string+'.'), len(@string)) end end go;
set option                  value;
select case then 'read uncommitted' and is_read_committed_snapshot_on = 1 then 'read committed snapshot' and is_read_committed_snapshot_on = 0 then 'read committed' then 'repeatable read' then 'serializable' then 'snapshot' else null end as transaction_isolation_level from   sys.dm_exec_sessions as s where  session_id = @@spid and  d.database_id = db_id();
select case transaction_isolation_level from sys.dm_exec_sessions where session_id = @@spid;
select    @isolationlevel = value from      @useroptions where     setoption = 'isolation level';
select emailaddress, customername from customers as a;
select customername,count(1) from customers group by customername having count(1) > 1;
select emailaddress, customername from customers a where exists ( select emailaddress from customers c where a.customername != c.customername and a.emailaddress = c.emailaddress);
select customername, emailaddress, count(*) over (partition by emailaddress) as num from customers ) select customername, emailaddress from counts where num > 1;
select emailaddress,customername from customers where emailaddress in;
select [emailaddress], [customername] from [customers] where [emailaddress] in;
drop table if exists dbo.table;
if object_id('dbo.table', 'u') is not null drop table dbo.table;
if object_id('tempdb.dbo.#t', 'u') is not null drop table #t;
drop table [table_name];
drop table if exists [table_name];
drop table if exists [table_name];
drop table [table_name];
drop table table_name;
drop table if exists table_name;
drop table table_name cascade;
drop table if exists table_name cascade;
select top 10 * from table where idcolumn not in (select top 10 idcolumn from table);
select top (returncount) * from ( select top (skipcount + returncount) * from sourcetable;
( select col1, col2, ..., row_number() over (order by sortcol1, sortcol2, ...) as rownum from table where <whatever> ) select * from results_cte where rownum >= @offset and rownum < @offset + @limit;
select * from users where id between 15 and 25;
( select salesorderid, orderdate, row_number() over (order by orderdate) as rownumber from sales.salesorderheader ) select salesorderid, orderdate, rownumber from orderedorders where rownumber between 50 and 60;
create proc pagination (@startfrom int ,@endto int) as select * from ( select *, row_number() over (order by name desc) as row from sys.databases;
select  * from     sys.databases;
select * from (select id,name,row_number() over (order by id  asc) as row from tablename1) tbl1 where tbl1.row>=10 and tbl1.row<=15;
select top {desired amount of rows} * from (select *, row_number() over (order by {order columns} asc)__row__ from {table})tmp where __row__ > {offset row count};
( select row_number() over (order by [dbo].[somecolumn]) [row] from [dbo].[sometable] ) select top 10 from rows where row > 10;
select * from sometable limit 10 offset 10 order by somecolumn;
select * from ( select *, row_number() over (order by name) as row from sys.databases;
set rowcount 10 select top 20 * from sys.databases;
create table my_table ( id_part1 int not null, id_part2 int not null, primary key (id_part1, id_part2) );
create table mytable ( column1 int not null, column2 int not null ) alter table mytable add constraint pk_myconstraint primary key (column1,column2);
create table mytable ( column1 int not null, column2 int not null ) alter table mytable add  primary key (column1,column2);
select db_name (database_id) as [database name], name as [database file name], [type] = case when type_desc = 'rows' then 'data file(s)' else type_desc end, size*8/1024 as 'size (mb)', physical_name as [database_file_location] from sys.master_files;
database name               database file name              type                size (mb)   database_file_location;
select sum((convert(dec (19, 2), convert(bigint,size))) * 8192 / 1048576.0) db_size_mb from dbo.sysfiles;
select db_name() as [database_name], concat(cast(sum( cast( (size * 8.0/1024) as decimal(15,2) ) from sys.database_files;
exec sp_spaceused ;
exec sp_spaceused @oneresultset = 1;
select      sys.databases.name as [database name], convert(varchar,sum(size)*8/1024)+' mb' as [size] from        sys.databases join        sys.master_files;
if object_id('tempdb..#spacetable') is not null drop table tempdb..#spacetable create table #spacetable ( database_name varchar(50) , total_size_data int, space_util_data int, space_data_left int, percent_fill_data float, total_size_data_log int, space_util_log int, space_log_left int, percent_fill_log char(50), [total db size] int, [total size used] int, [total size left] int ) select x.[database name],x.[total size data],x.[space util],x.[total size data]-x.[space util] [space left data], x.[percent fill],y.[total size log],y.[space util], y.[total size log]-y.[space util] [space left log],y.[percent fill], y.[total size log]+x.[total size data] ''total db size'' (y.[total size log]+x.[total size data])-(y.[space util]+x.[space util]) ''total size left'' from (select db_name() ''database name'', sum(size*8/1024) ''total size data'',sum(fileproperty(name,''spaceused'')*8/1024) ''space util'' from sys.master_files where database_id=db_id(db_name())  and  type=0 (select from sys.master_files where database_id=db_id(db_name())  and  type=1 select * from #spacetable drop table #spacetable;
exec sp_spaceused;
select database_name = db_name(database_id) from sys.master_files with(nowait) where database_id = db_id() -- for current db;
alter function [dbo].[getdbsize] ( @db_name nvarchar(100) ) as return select database_name = db_name(database_id) from sys.master_files with(nowait) where database_id = db_id(@db_name) or @db_name is null;
if object_id('tempdb.dbo.#space') is not null drop table #space create table #space ( database_id int primary key ) select @sql = stuff(( select ' select db_id() from ( select s.[type], space_used = sum(fileproperty(s.name, ''spaceused'') * 8. / 1024) from sys.database_files s from sys.databases d where d.[state] = 0 exec sys.sp_executesql @sql select d.database_id from ( select database_id from sys.master_files join sys.databases d on d.database_id = t.database_id select database_name from ( select s.database_name then s.backup_size else s.compressed_backup_size end / 1048576.0 as decimal(18,2)) from msdb.dbo.backupset s where s.[type] in ('d', 'l') where f.rownum = 1;
exec sp_helpdb @dbname= 'msdb';
select table_name from user_tables;
select table_name from  information_schema.tables where table_schema =? and table_type = 'base table';
select table_name  from all_tables where owner = 'yourschema';
select table_name from user_tables;
select any dictionary;
select distinct owner, object_name from dba_objects where object_type = 'table' and owner = '[some other schema]';
select distinct owner, object_name from all_objects where object_type = 'table' and owner = '[some other schema]';
select distinct object_name from user_objects where object_type = 'table';
select * from tab;
select * from cat;
select table_name, num_rows counter from dba_tables where owner = 'owner';
select distinct(owner) from sys.all_tables;
select table_name, owner from all_tables where owner like ('%xyz%');
select segment_name, partition_name, bytes from user_segments where segment_type='table' order by 1;
select * from user_tables;
select table_name from user_tables;
create table  with oids;
select str(12345.6789, 12, 3);
select convert(decimal(10,2),yourcolumn);
select 10.008 into vtest from dual;
select cast(12 as decimal(16,2));
select cast('12' as decimal(16,2));
set @myfloatval=(select convert(decimal(10, 2), 10.254000)) select  @myfloatval;
select format(@test, '##.##');
constraint ordrelinje_fk foreign key(ordre) references ordre(ordreid);
set foreign_key_checks=0;
set global foreign_key_checks=0;
select child_table.* from child_table where parent_table.referenced_column is null;
select * from information_schema.table_constraints where constraint_schema = 'my_db_name';
alter table my_table drop foreign key wrong_fk_constraint;
alter table orders add constraint order_to_user_cons  foreign key (orderuserid) references users(userid) on delete set null on update cascade;
select last_number from all_sequences where sequence_owner = '<sequence owner>' and sequence_name = '<sequence_name>';
select last_number from user_sequences where sequence_name = '<sequence_name>';
select * from user_sequences where sequence_name = '<sequence_name>';
select increment_by i from user_sequences where sequence_name = 'seq';
select seq.nextval s from dual;
alter sequence seq select seq.nextval s from dual;
alter sequence seq;
select my_seq_name.currval from dual;
select my_seq_name.nextval from dual;
select mysequence.currval into v_myvariable from dual;
select max(pk) from thetable;
select count(*) from thetable;
select my_seq_name.currval from dual;
select field_sq.nextval from dual;
select field_sq.currval from dual;
alter sequence field_sq increment by 1 minvalue 0;
select seq_my_name.currval from dual;
select ... from a;
select * from emp, dept where emp.dept_id=dept.dept_id(+);
select a.id, b.id, a.col_2, b.col_2, ... from a,b where a.id=b.id(+);
select  a.id, b.id, a.col_2, b.col_2, ... from a;
select  a.id, b.id, a.col_2, b.col_2, ... from a;
select  a.id, b.id, a.col_2, b.col_2, ... from a,b where a.id=b.id;
select  a.id, b.id, a.col_2, b.col_2, ... from a;
select  a.id, b.id, a.col_2, b.col_2, ... from a join b on a.id=b.id;
select  a.id, b.id, a.col_2, b.col_2, ... from a,b where a.id(+)=b.id;
select  a.id, b.id, a.col_2, b.col_2, ... from a;
select 1 from dbo.customers where   custid = @custid collate sql_latin1_general_cp1_cs_as and custpassword = @custpassword collate sql_latin1_general_cp1_cs_as;
select * from users where username = @username collate sql_latin1_general_cp1_cs_as and password = @password collate sql_latin1_general_cp1_cs_as and username = @username and password = @password;
select * from users where cast(username as varbinary(100)) = cast(@username as varbinary)) and cast(password as varbinary(100)) = cast(@password as varbinary(100)) and username = @username and password = @password;
select * from your_table where convert(varbinary, your_column) = convert(varbinary, 'abcd');
select from users where binary_checksum(username) = binary_checksum(@username) and binary_checksum(password) = binary_checksum(@password);
select * from table_name where binary username=@search_parameter and binary password=@search_parameter;
if hashbytes('sha1',@first_value) = hashbytes('sha1',@second_value) begin end else begin end ;
values  ('a', 'a'), ('a', 'a'), ('a', 'b') select  valuea + ' = ' + valueb from    @example where   hashbytes('sha1', valuea) = hashbytes('sha1', valueb) select  valuea + ' <> ' + valueb from    @example where   hashbytes('sha1', valuea) <> hashbytes('sha1', valueb);
select  valueb + ' = ' + @value_b from    @example where   hashbytes('sha1', valueb) = hasbytes('sha1', @value_b);
alter table `userauthentication` change `password` `password` varchar(255) character set latin1 collate latin1_general_cs not null;
select * from incidentsnew1 where binary_checksum(closeby) = binary_checksum(upper(closeby));
alter table dbo.yourtablename add constraint uq_yourtablename unique(column1, column2);
create unique index uq_yourtablename;
create trigger dbo.blockduplicatesyourtable as begin set nocount on;
if not exists (select 1 from inserted as i and i.column2 = t.column2 ) select column1, column2, ... from inserted;
end else begin end end go;
create table dbo.person ( id int identity(1,1) primary key, name nvarchar(32), active bit, personnumber int alter table dbo.person add constraint uq_person unique(personnumber, active);
create unique nonclustered index sk01 on dbo.person(id,name,active,personnumber);
create unique nonclustered index uq_usr_und_uul_usr_idf_uul_atual where uul_atual = 1;
select * from user_und where uul_usr_idf = 137 delete from user_und where uul_usr_id = 137;
create table performance_test as ( select * from dba_objects );
select * from performance_test where object_name in ('dbms_standard', 'dbms_registry', 'dbms_lob' );
where foo in ('a', 'b', 'c') where foo = 'a' or foo = 'b' or foo = 'c';
select count(*) from t_inner where val in (1000, 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000);
select count(*) from t_inner where val = 1000 or val = 2000 or val = 3000 or val = 4000 or val = 5000 or val = 6000 or val = 7000 or val = 8000 or val = 9000;
select t.relname as related_table, a.attname as related_column, s.relname as sequence_name from pg_class s join pg_depend d on d.objid = s.oid join pg_class t on d.objid = s.oid and d.refobjid = t.oid join pg_attribute a on (d.refobjid, d.refobjsubid) = (a.attrelid, a.attnum) join pg_namespace n on n.oid = s.relnamespace where s.relkind     = 's' and n.nspname     = 'public';
select nspname,relname from pg_class c join pg_namespace n on c.relnamespace=n.oid where relkind = 's' order by nspname;
c.relkind, c.relname as relation from pg_class c join pg_namespace n on n.oid = c.relnamespace ),  tables    as (select oid, fqname from fq_objects where relkind = 'r' ) select s.fqname as sequence, '->' as depends, t.fqname as table, a.attname as column from pg_depend d join sequences s on s.oid = d.objid join tables t on t.oid = d.refobjid join pg_attribute a on a.attrelid = d.refobjid and a.attnum = d.refobjsubid where d.deptype = 'a' ;
create or replace function public.reset_sequence(tablename text, columnname text) as $function$;
select * from information_schema.sequences;
create or replace function reset_sequence() returns void as sequences as (select oid,fqname from fq_objects where relkind = 's'), tables    as (select oid, fqname from fq_objects where relkind = 'r' ) select s.fqname as sequence, t.fqname as table, a.attname as column from pg_depend d join sequences s on s.oid = d.objid join tables t on t.oid = d.refobjid join pg_attribute a on a.attrelid = d.refobjid and a.attnum = d.refobjsubid where d.deptype = 'a' end loop;
select * from reset_sequence();
select * from information_schema.sequences;
select * from <sequence_name>;
drop function if exists public.show_sequence_stats();
create or replace function public.show_sequence_stats() as $body$ end loop;
select * from show_sequence_stats();
select seq_sch.nspname  as sequence_schema from pg_class seq select sch.nspname as "schema" trim(leading 'nextval(''' from ) ) from pg_class tbl --the table where tbl.relkind = 'r' --regular relations (tables) only and col.attnum > 0 --regular columns only and def.adsrc like 'nextval(%)' --sequences only where seq.relkind = 's' --sequences only;
select sequence_name, (xpath('/row/last_value/text()', xml_count))[1]::text::int as last_value from ( select sequence_schema, sequence_name, query_to_xml(format('select last_value from %i.%i', sequence_schema, sequence_name), false, true, '') as xml_count from information_schema.sequences where sequence_schema = 'public';
select * from pg_sequences;
select s.sequence_schema, s.sequence_name, (select * from exec('select last_value from ' || s.sequence_schema || '.' || s.sequence_name) as e(lv bigint)) last_value from information_schema.sequences s;
select string_agg('select sequence_name, last_value from ' || relname, chr(13) || 'union' || chr(13) order by relname) from pg_class where relkind ='s';
c.relkind, c.relname as relation from pg_class c join pg_namespace n on n.oid = c.relnamespace ),  tables    as (select oid, fqname from fq_objects where relkind = 'r' ) select s.fqname as sequence, '->' as depends, t.fqname as table from pg_depend d join sequences s on s.oid = d.objid join tables t on t.oid = d.refobjid where d.deptype = 'a' ;
select * from pg_tables where schemaname = '<schema_name>';
select * from information_schema.columns where table_name = '<table_name>';
select pg_get_serial_sequence('<table_name>', '<column_name>');
select * from <sequence_name>;
select * from (select n.nspname,c.relname, (select substring(pg_catalog.pg_get_expr(d.adbin, d.adrelid) for 128) from pg_catalog.pg_attrdef d where d.adrelid=a.attrelid and d.adnum=a.attnum and a.atthasdef) as def from pg_class c, pg_attribute a, pg_namespace n where c.relkind='r' and c.oid=a.attrelid and n.oid=c.relnamespace and a.atthasdef and a.atttypid=20) x where x.def ~ '^nextval';
select c.relname from pg_class c where c.relkind = 's';
select last_value from test_id_seq;
from customers c;
and movie m.movie is rented by customer m.customerid and ... from customers c cross join movies m;
and movie m.movie is rented by customer m.customerid and ... and c.customerid = m.customerid and c.age >= m.[minimum age] and c.age = 18 from customers c inner join movies m and c.age >= m.[minimum age] where c.age = 18;
select a.f, b.g, c.h from table_a a, table_b b, table_c c where a.x = b.x and b.y = c.y;
select t.tchrid,t.teachername,s.studentname from #teacher t;
select t.tchrid,t.teachername,s.studentname from #teacher t;
select * from table1 cross join table2 where table1.id = table2.fk_id;
select * from table1 join table2 on table1.id = table2.fk_id;
select t1.column_name,t2.column_name from table_name1 t1;
select * from table_name1;
select * from table_name1,table_name2;
select * from userdetails;
select * from userdetails, orderdetails;
select r.symbol as card_rank, s.symbol as card_suit from ranks r;
select p.id as post_id, p.title as post_title, pc.review  as review from post p;
select column1, column2, column3 from table2;
select col1, col2, col3 from mytable2;
select * from oldtable;
select column1, column2, column3 from oldtable;
select * from sourcetable;
select * from table1;
select suppliername, country from sourcetable;
select * into newtable from oldtable;
select * from from_table where condition;
create table `table2` like `table1`;
select top(100) * from customers union select top(100) * from customereurope union select top(100) * from customerasia union select top(100) * from customeramericas );
select top(100)* into #tmpferdeen from customers select top(100)* from customereurope select top(100)* from customerasia select top(100)* from customeramericas;
select top(100)* from customers union select top(100)* from customereurope union select top(100)* from customerasia union select top(100)* from customeramericas;
select top(100)* into #tmpferdeen from customers select top(100)* from customereurope select top(100)* from customerasia select top(100)* from customeramericas;
select * into tmpferdeen from( select top(100) * from customers union all select top(100) * from customereurope union all select top(100) * from customerasia union all select top(100) * from customeramericas );
select top(100) * from customers union all select top(100) * from customereurope union all select top(100) * from customerasia union all select top(100) * from customeramericas;
select * into tmpferdeen from from customers union all select top(100)* from customereurope union all select top(100)* from customerasia union all select top(100)* from customeramericas) as blablabal;
select top(100)* from customers union all select top(100)* from customereurope union all select top(100)* from customerasia union all select top(100)* from customeramericas;
select top(100)* from customers union all select top(100)* from customereurope union all select top(100)* from customerasia union all select top(100)* from customeramericas );
select * into tmpferdeen ( select top(100)* from customers union all select top(100)* from customereurope union all select top(100)* from customerasia union all select top(100)* from customeramericas);
select * into tmpferdeen from ( select top 100 * from customers union all select top 100 * from customereurope union all select top 100 * from customerasia union all select top 100 * from customeramericas;
set foreign_key_checks = 0;
set foreign_key_checks = 1;
set foreign_key_checks = 0;
alter table `ajout_norme`;
set foreign_key_checks=0;
create table `data` ( `id` int(10) unsigned not null, `name` varchar(100) not null, `value` varchar(15) not null, unique key `id` (`id`,`name`), constraint `data_ibfk_1`, foreign key (`id`) references `keywords` (`id`) on delete cascade on update cascade;
create table users ( ------------ create table emp ( ---------;
set foreign_key_checks = 0;
set foreign_key_checks = 1;
select count(id) + 1 as rank, count(distinct age) + 1 as dense_rank from testdata where gender = (select gender from testdata where id = 6) and age < (select age from testdata where id = 6);
select testdata.id, count(lesser.id) + 1 as rank, count(distinct lesser.age) + 1 as dense_rank from testdata;
select rank() over (partition by gender order by age) as `partition by gender`, firstname, age, gender from person;
select customerid, mydate  from mycustomers, (select @_currank:=0, @_sequence:=0, @_lastrank:=0, @_nxtrank:=0, @_overpart:=0 ) r;
select id,first_name,gender,age, rank() over(partition by gender order by age) rank_g from person create table person (id int, first_name varchar(20), age int, gender char(1));
select    first_name, age, gender, @currank := @currank + 1 as rank from      person p, (select @currank := 0) r;
create table person (id int, first_name varchar(20), age int, gender char(1));
select count(age) + 1 from person;
select age as age_var, ( select count(age) + 1 from person where (age < age_var) from person;
select    first_name, age, gender, if(age=@_last_age,@currank:=@currank,@currank:=@_sequence) as rank, @_sequence:=@_sequence+1,@_last_age:=age from      person p, (select @currank := 1, @_sequence:=1, @_last_age:=0) r;
create table person (id int, first_name varchar(20), age int, gender char(1));
select    a.first_name, a.age, a.gender, count(b.age)+1 as rank from  person a left join person b on a.age>b.age and a.gender=b.gender a.age, a.gender;
create table person (id int, first_name varchar(20), age int, gender char(1));
create table person ( id int not null primary key, firstname varchar(10), gender varchar(1), age int (2,  'matt',   'm', 31), (3,  'grace',  'f', 25), (4,  'harry',  'm', 20), (5,  'scott',  'm', 30), (6,  'sarah',  'f', 30), (7,  'tony',   'm', 30), (8,  'lucy',   'f', 27), (9,  'zoe',    'f', 30), (10, 'megan',  'f', 26), (11, 'emily',  'f', 20), (12, 'peter',  'm', 20), (13, 'john',   'm', 21), (14, 'kate',   'f', 35), (15, 'james',  'm', 32), (16, 'cole',   'm', 25), (17, 'dennis', 'm', 27), (18, 'smith',  'm', 35), (19, 'zack',   'm', 35), (20, 'jill',   'f', 25);
select person.*, @rank := case end as rnk from person, (select @rank := null, @partval := null, @rankval := null) as x;
set @totalstudents = 0;
select count(*) into @totalstudents from marksheets;
select id, score, @currank := if(@prevval=score, @currank, @studentnumber) as rank, @percentile := if(@prevval=score, @percentile, (@totalstudents - @studentnumber + 1)/(@totalstudents)*100), @studentnumber := @studentnumber + 1 as studentnumber, @prevval:=score from marksheets, ( select @currank :=0, @prevval:=null, @studentnumber:=1, @percentile:=100;
delete from emp where rowid in ( select rid from ( select rowid rid, row_number() over(partition by empno order by empno) rn from emp ) where rn > 1;
create table test(id int,sal int);
select * from test;
delete from where rowid in row_number() from test) where dup > 1);
select * from test;
delete from where rowid in as (select row_number() partition by first_name, last_name, birth_date) as rn partition by first_name, last_name, birth_date and unbounded following) as cnt from yourtable where load_date is null) select rid from duplicates where rn > 1);
create table abcd(id number(10),name varchar2(20)) select * from abcd delete duplicate record but keep distinct record in table delete from abcd a where rowid > (select min(rowid) from abcd b where b.id=a.id select * from abcd;
delete from table_name where rowid not in (select min(rowid) from table_name group by column_name);
delete from table_name a where rowid > (select min(rowid) from table_name b where a.column=b.column);
delete from your_table where rowid in select min(rowid) as rowid, column1,column2, column3 from your_table where co1.rowid is null;
delete from emp where rowid not in;
delete from emp e1 where rowid not in where e1.empno = e2.empno );
delete from emp where rowid not in;
delete from emp where rowid in ( select rid from ( select rowid rid, row_number() over(partition by empno order by empno) rn from emp ) where rn > 1;
delete from emp e1 where rowid not in where e1.empno = e2.empno );
delete from emp where rowid in ( select rid from ( select rowid rid, dense_rank() over(partition by empno order by rowid from emp ) where rn > 1;
delete from emp where rowid not in;
delete from emp where rowid in ( select rid from ( select rowid rid, row_number() over(partition by empno order by empno) rn from emp ) where rn > 1;
delete from emp e1 where rowid not in where e1.empno = e2.empno );
delete from emp where rowid in ( select rid from ( select rowid rid, dense_rank() over(partition by empno order by rowid from emp ) where rn > 1;
delete from emp where rowid in ( select  rid from ( select rowid rid,rank() over (partition by emp_id order by rowid)rn from emp ) where rn > 1;
create or replace procedure delete_duplicate_enq as select * from enquiry;
delete enquiry where enquiry.enquiryno = z.enquiryno and rowid > any from enquiry where enquiry.enquiryno = z.enquiryno);
end delete_duplicate_enq;
delete from tablename  where rowid not in (select   min (rowid) from table group by columnname);
delete from dept where rowid in ( select rowid from dept select max(rowid) from dept;
constraint varchar2(30);
alter table add constraint unique --or primary key;
delete original_dups where rowid in (select row_id from exceptions_table);
create table new_table_with_no_dups as ( select field1, field2 ........ from original_dups t1 where not exists ( select null from exceptions_table t2 where t1.rowid = t2.row_id ) );
select groupfunction(column1), groupfunction(column2),..., count(column1), column1, column2... from our_table having count(column1) > 1;
delete from tablename a where a.rowid > any (select b.rowid from tablename b where a.fieldname = b.fieldname and a.fieldname2 = b.fieldname2 and ....so on.. to identify the duplicate rows....);
delete from tablename a where a.rowid > any (select b.rowid from tablename b where a.fieldname = b.fieldname and a.fieldname2 = b.fieldname2);
delete from t where rowid in ( select rid from (select rowid rid, row_number() over (partition by from t) where rn <> 1);
delete from your_table where rowid not in from your_table;
delete from our_table where rowid not in from our_table;
values ('622057', '12082014', 'student', '17389551'), ('2913659', '12082014', 'assistant','17389551'), ('6160230', '12082014', 'admin', '17389551');
update table_users set cod_user = (case when user_role = 'student' then '622057' date = '12082014' where user_role in ('student', 'assistant', 'admin') and;
update table_to_update set  cod_user= case when user_rol = 'student' then '622057' end ,date = '12082014' where user_rol in ('student','assistant','admin') and cod_office = '17389551';
update table1 set col1= col2 from (select col2, col3 from table2) as newtbl where col4= col3;
update push_setting set status = #{setting.status} where type = #{setting.type} and user_id = #{userid};
create temporary table  temp_table_users ( cod_user varchar(50);
update table_users t1 join temp_table_users tt1 using(user_rol,cod_office) set t1.cod_office = tt1.cod_office;
update table_name set cod_user = case when user_rol = 'student' then '622057' where user_rol in ('student','assistant','admin') and cod_office = '17389551';
select concat("firstname", ' ', "lastname") from "user";
select concat(firstname, ' ', lastname) from user;
select employee_number,f_name ::text ||','|| l_name::text  as "name",email_id,phone_number,designation from employee;
select concat(first_name,last_name)  from person where pid = 136;
select  a||', '||b from foo;
select a::text || b as ab from foo;
select concat_ws(', ', a, b) as ab from foo;
select concat(a, b) as ab from foo;
select coalesce(a, '') || coalesce(b, '') from foo;
select textcat(textcat(firstname,' '),lastname) as name from person;
select exists( select * from information_schema.tables where table_schema = 'company3' and;
select exists ( select from information_schema.tables where  table_schema = 'schema_name' and    table_name   = 'table_name';
select exists ( select from pg_catalog.pg_class c join   pg_catalog.pg_namespace n on n.oid = c.relnamespace where  n.nspname = 'schema_name' and    c.relname = 'table_name' and    c.relkind = 'r'    -- only tables;
select exists ( select from pg_tables where  schemaname = 'schema_name' and    tablename  = 'table_name';
select exists ( select from pg_catalog.pg_class c join   pg_catalog.pg_namespace n on n.oid = c.relnamespace where  n.nspname = 'schema_name' and    c.relname = 'table_name';
select 'schema_name.table_name'::regclass;
select to_regclass('schema_name.table_name');
create function relname_to_array(text,text default null) returns text[] as $f$ select array[n.nspname::text, c.relname::text] from   pg_catalog.pg_class c join pg_catalog.pg_namespace n on n.oid = c.relnamespace, regexp_split_to_array($1,'\.') t(x) -- not work with quoted names where  case else                           n.nspname = $2        and c.relname = $1 end $f$ language sql immutable;
create function relname_exists(text,text default null) returns boolean as $wrap$ select exists (select relname_to_array($1,$2)) create function relname_normalized(text,text default null,boolean default true) returns text as $wrap$ select coalesce(array_to_string(relname_to_array($1,$2), '.'), case when $3 then '' else null end);
select cola from tablea union select colb from tableb;
select name, name from segment order by 1;
select ..., iscoursedbased = cast( case when fc.courseid is not null then 1 else 0 end as bit ) from fc;
cast ( case when fc.courseid is not null then 1 else 0 end as bit);
case when fc.courseid is not null then 1 else 0 end as bit);
select @true = 1, @false = 0;  --can be combined with declare in sql 2008 select case when fc.courseid is not null then @true else @false end as ...;
as select case when fc.courseid is not null then cast(1 as bit) else cast(0 as bit) end as iscoursedbased select icoursebased from myview;
select cast(count(*) as bit) from [user] where (userid = 20070022);
select cast(count(1) as bit) as expr1 from [user] where (userid = 20070022);
select case when exists ( select * from [user] where userid = 20070022 ) then cast(1 as bit) else cast(0 as bit) end;
select cast(case when count(*) > 0 then 1 else 0 end as bit) from dummy where id = 1;
select distinct 1 as expr1 from [user] where (userid = 20070022);
case when exists ( select * from mytable where mytable.id = 1 ) then true else false end as bool) as "nameofmycolumn";
select 1 from [dbo].[user] where userid = 20070022;
select exists(select * from user where userid = 20070022);
if exists(select 1  from [user] where (userid = 20070022)) set @isavailable = 1 end;
alter database dbname set offline;
select @dbid = database_id, @isstatasyncon = is_auto_update_stats_async_on from sys.databases where name = 'db_name' if @isstatasyncon = 1 alter database [db_name] set  auto_update_statistics_async off select job_id from sys.dm_exec_background_job_queue where database_id = @dbid set @sqlstring = 'kill stats job ' + str(@jobid) end  end  alter database [db_name] set  single_user with rollback immediate drop database [db_name];
exec msdb.dbo.sp_delete_database_backuphistory @database_name = n'mydatabase' drop database [mydatabase];
alter database [mydatbase] set single_user with rollback immediate;
alter database [mydatabase] set single_user with rollback immediate;
server_name, online_status, exchange, disk_space, network_shares, date_time ) values ( 'm1', 'online', 'online', '100gb', 'online', sysdate();
select now(3), sysdate(3), unix_timestamp();
alter table servers modify column network_shares datetime not null default current_timestamp;
create table `servers` ( id int(11) not null primary key auto_increment, server_name varchar(45) not null, online_status varchar(45) not null, _exchange varchar(45) not null, disk_space varchar(45) not null, network_shares varchar(45) not null, date_time datetime not null default current_timestamp;
network_shares,date_time) values('m1','online','online','100gb','online',now() );
network_shares,date_time) values('m1', 'online', 'online', '100gb', 'online';
select * from [table_name];
select 1 from users;
select 1 from table_name;
select * from table1 t1 where exists ( select 1 from table2 t2 where t1.id= t2.id;
select * from table1 t1 where id in (select id from table2);
select 1 from table_name;
select 1 from table;
select * from anothertable where exists (select 1 from table where...);
select * from anothertable where exists (select * from table where...);
select * from anothertable where exists (select 1/0 from table where...);
select 1 from myusertable where user_id = 33487;
select * from myusertable where user_id = 33487;
select 1 from table;
select 1 from tablea having min(cola) < max(cola);
select cons_value from table_name;
select 1 from employee;
select * from sales.orders where convert(char(8), orderdate, 112) = @filterdate;
select * from sales.orders where orderdate = @filterdate;
select  *  from demo_date where date >= '3/1/2015' and date <=  '3/31/2015'.;
select datediff(dd, '01/01/2021 10:20:00', '02/01/2021 10:20:00');
select case when convert(date, getdate()) = convert(date,'2017-11-16 21:57:20.000') then 'ok' else '' end;
if cast(datefield1 as date) = cast(datefield2 as date);
from talib import func;
if the period is 10 then we need 9 previous candles or 15 x 9 = 135 mins on the interval department select symbol, max(ts), count(symbol) from ohlc_900 group by symbol cte as ( select symbol, ts, case when cnt >= 10 and ts >= maxts - interval '135 mins' then (row_number() over (partition by symbol order by ts) - (cnt - 10)) * c else null end as weighted_close from ohlc_900 ) select symbol, sum(weighted_close)/55 as wma from cte where weighted_close is not null;
select 'x' from <your_small_table> where <primay_key_coulmn> = <some_value>;
select 1 from dual;
if object_id('tempdb..#test_connection') is not null drop table #test_connection if object_id('tempdb..#resultserror') is not null drop table #resultserror if object_id('tempdb..#resultsgood') is not null drop table #resultsgood set @sql=' select 1 set @openquery = 'select * into ##test_connection from openquery(['+ @linkedserver +'],''' + @sql + ')' select * into #test_connection from ##test_connection drop table ##test_connection end try if object_id('dbo.usp_geterrorinfo') is not null -- it will always have somthing... create table #resultserror ( [errornumber]       int ) end end catch if (select errornumber from #resultserror where errornumber = '1038') is not null --'1038' for me showed a connection atleast. select '0' as [errornumber] else select * from #resultserror end;
select 1 from rdb$relation_fields rows 1;
select count(*);
select count(1);
select 1 from dual;
select 1 from any_table_that_you_know_exists_in_your_database;
select 1 from dual;
select 1 from any_existing_table where 1=0;
select 1 from information_schema.system_users;
select 1 from sysibm.sysdummy1;
select 1 from sysibm.sysdummy1;
select count(*) from systables;
select max(table_catalog) as x from information_schema.tables;
select count(*) as x from information_schema.system_users where 1=0;
select * from table group by foo;
select unique_id_col, count(1) as cnt from yourtable group by col_a;
select max(unique_id_col) as unique_id_col, count(1) as cnt from yourtable group by col_a, (unique_id_col*0 + col_a);
select cr.review_sk, cr.cs_sk, cr.full_name, tolist(to_char(cf.fact_date, 'mm/dd/yyyy')) "appt", cs.cs_id, cr.tracking_number from review cr, cs, fact cf where cr.cs_sk = cs.cs_sk and upper(cs.cs_id) like '%' || upper(i_cs_id) || '%' and row_delete_date_time is null and cr.review_sk = cf.review_wk (+) and cr.fact_type_code (+) = 183050;
select a , count(*) from my_table group by upper(a) .;
select upper(a) , count(*) from my_table group by upper(a) .;
select d.deptno, max(e.sal) from emp e, dept d where e.deptno = d.deptno;
select substr(year_month, 1, 4) from schema.tbl substr(year_month, 1, 4) year_month;
select employee_id, sum(salary) from employees;
select employee_id, sum(salary) from employees;
select * from recently natural join tracks;
select table1.name, table1.description ... from (values (id1,1), (id2,2), (id3,3) ...) as ordertbl(orderkey, orderidx);
select table1.id (values (10,1),(3,2),(4,3),(5,4),(7,5),(8,6),(9,7),(2,8),(6,9),(5,10);
select ... from ...;
select id from table1 where id in (1, 20, 45, 60);
select order_no, delivery_address from ifsapp.purchase_order_tab where order_no in ('52000077','52000079','52000167','52000297','52000204','52000409','52000126');
select * from table_name where id in (..,..,..,..);
select ... from ... where zip in (91709,92886,92807,...,91356) and user.status=1 limit 10;
select name, description, ... where id in (select display_order from table1 where...), (select name from table1 where...);
select name, description, ... from ... where id in([ids, any order]);
select @a-1+row_number() over(order by y.z.value('(/n)[1]', 'int') ) rw from ( select cast('<m>'+replicate('<n>1</n>', @b-@a+1)+'</m>' as xml ) x ) t;
create or alter  function [dbo].[_ican_tf_nums2](@a int, @b int) ( num int ) as begin union all select value + 1 as value from nums where nums.value < @b) select * from nums end -------------------------------------------------------------------------------------------------------------------;
select [number] = @start_num + row_number() over (order by (select null)) from string_split(replicate(' ',@end_num-@start_num-1),' ');
n as ( select d x from d where d > 0 and d <= @n union all select x * 10 + d from n, d where x * 10 + d <= @n ) select x from n;
create function numbers(@begin int, @len int) select 1 v from (values(0),(0),(0),(0),(0),(0),(0),(0),(0),(0),(0),(0),(0),(0),(0),(0)) d(v) ) select top (@len) @begin -1 + row_number() over(order by (select null)) v from d d0 select * from numbers(987654321,500000);
select unit from (values (0),(1),(2),(3),(4),(5),(6),(7),(8),(9)) v(unit) d as ( select (thousands+hundreds+tens+units) v from (select thousands = unit * 1000 from u) thousands where (thousands+hundreds+tens+units) <= 10000 ) select * from d order by v;
select value from dbo.intrange(-500, 1500) order by value  -- returns 2001 values create function dbo.intrange ( @starting as int, @ending as int ) as return ( select value from ( select @starting + from       (select 0 as v union all select 0x00001 as v) as bit00 where @ending - @starting < 0x100000 and intlist.value between @starting and @ending );
create or alter function dbo.fn_range(@start int, @end int)  returns table select n from (values (0),(1),(2),(3)) v(n) u8(n) as ( select x0.n | x1.n * 4 | x2.n * 16 | x3.n * 64 as n from u2 x0, u2 x1, u2 x2, u2 x3 ) select @start + s.n as n from ( select x0.n | isnull(x1.n, 0) * 256 | isnull(x2.n, 0) * 65536 as n from u8 x0 where s.n < @end - @start;
y as (select 0 z from z a, z b, z c, z d, z e, z f, z g, z h, z i, z j, z k, z l, z m, z n, z o, z p), n as (select row_number() over (partition by 0 order by z) n from y) select top (1+@e-@s) @s + n - 1 from n;
select ones.n + 10*tens.n + 100*hundreds.n + 1000*thousands.n from x ones,     x tens,      x hundreds,       x thousands;
select top (1+@upper-@lower) @lower + ones.n + 10*tens.n + 100*hundreds.n + 1000*thousands.n from x thousands;
alter function [dbo].[fn_generatenumbers] ( @start int, @end  int b1 as (select n from (values (0),(0x00000010),(0x00000020),(0x00000030),(0x00000040),(0x00000050),(0x00000060),(0x00000070),(0x00000080),(0x00000090),(0x000000a0),(0x000000b0),(0x000000c0),(0x000000d0),(0x000000e0),(0x000000f0)) as b1(n)), b2 as (select n from (values (0),(0x00000100),(0x00000200),(0x00000300),(0x00000400),(0x00000500),(0x00000600),(0x00000700),(0x00000800),(0x00000900),(0x00000a00),(0x00000b00),(0x00000c00),(0x00000d00),(0x00000e00),(0x00000f00)) as b2(n)), b3 as (select n from (values (0),(0x00001000),(0x00002000),(0x00003000),(0x00004000),(0x00005000),(0x00006000),(0x00007000),(0x00008000),(0x00009000),(0x0000a000),(0x0000b000),(0x0000c000),(0x0000d000),(0x0000e000),(0x0000f000)) as b3(n)), b4 as (select n from (values (0),(0x00010000),(0x00020000),(0x00030000),(0x00040000),(0x00050000),(0x00060000),(0x00070000),(0x00080000),(0x00090000),(0x000a0000),(0x000b0000),(0x000c0000),(0x000d0000),(0x000e0000),(0x000f0000)) as b4(n)), b5 as (select n from (values (0),(0x00100000),(0x00200000),(0x00300000),(0x00400000),(0x00500000),(0x00600000),(0x00700000),(0x00800000),(0x00900000),(0x00a00000),(0x00b00000),(0x00c00000),(0x00d00000),(0x00e00000),(0x00f00000)) as b5(n)), b6 as (select n from (values (0),(0x01000000),(0x02000000),(0x03000000),(0x04000000),(0x05000000),(0x06000000),(0x07000000),(0x08000000),(0x09000000),(0x0a000000),(0x0b000000),(0x0c000000),(0x0d000000),(0x0e000000),(0x0f000000)) as b6(n)), b7 as (select n from (values (0),(0x10000000),(0x20000000),(0x30000000),(0x40000000),(0x50000000),(0x60000000),(0x70000000)) as b7(n)) select s.n from ( select b7.n from b0 join b1 on b0.n <= @end-@start and b1.n <= @end-@start join b2 on b2.n <= @end-@start join b3 on b3.n <= @end-@start join b4 on b4.n <= @end-@start join b5 on b5.n <= @end-@start join b6 on b6.n <= @end-@start join b7 on b7.n <= @end-@start where @end >= s.n;
( select row_number() over (order by @count) + @start - 1 from @xml.nodes('/x') x(t) ) select num from generatenumbers;
( select row_number() over (order by @end) + @start - 1 from @xml.nodes('/x') x(t) ) select num from generatenumbers;
as ( select @start [sequence] union all select [sequence] + 1 from numcte where [sequence] < @end ) select * from numcte;
select rownum+1000 from all_objects fetch first 50 rows only;
select @initial as contador union all select contador+1 from cte_n where contador <@final;
create function [dbo].[sequence] (@start int, @end int) as begin set @i = @start;
select * from dbo.sequence (3,7);
select dateadd(hh,id,'2018-06-20 00:00:00') as hoursintheday from dbo.sequence (0,23) ;
select count(1) from [dbo].[sequence] ( 1000001;
) select  case when max(num) is null  then @startnum else max(num) + 1 end as num from    dbo.numbers;
) values (@num) set @num = @num + 1 end;
values ('~/content/galeria/p'+convert(varchar(10), @num)+'.jpg') set @num = @num + 1 end;
select @num set @num = @num + 1 end;
set @start = 1000 set @end = 1050 select  top (@end - @start+1) row_number() over (order by s.[object_id])+(@start - 1) [numbers] from    sys.all_objects s with (nolock);
select row_number() over (order by (select null)) as n from (values(0),(1),(2),(3),(4),(5),(6),(7),(8),(9)) x2(x), (values(0),(1),(2),(3),(4),(5),(6),(7),(8),(9)) x3(x), (values(0),(1),(2),(3),(4),(5),(6),(7),(8),(9)) x4(x), (values(0),(1),(2),(3),(4),(5),(6),(7),(8),(9)) x5(x);
select row_number() over (order by (select null)) as n from (values(0),(1),(2),(3),(4),(5),(6),(7),(8),(9)) x2(x), (values(0),(1),(2),(3),(4),(5),(6),(7),(8),(9)) x3(x), (values(0),(1),(2),(3),(4),(5),(6),(7),(8),(9)) x4(x), (values(0),(1),(2),(3),(4),(5),(6),(7),(8),(9)) x5(x) ) select numbers.n from numbers where n between @n1 and @n2;
select 1 as num union all select num*2 from numrange where num*2<=@size union all select num*2+1 from numrange where num*2+1<=@size ) select num+@startnum-1 from numrange order by num;
select top 50 row_number() over(order by a.name) + 1000 as rcount from sys.all_objects a;
create function [dbo].[fn_consecutivenumbers] ( @start int, @end  int select x268435456.x from (values (0),(1),(2),(3),(4),(5),(6),(7),(8),(9),(10),(11),(12),(13),(14),(15)) as x1(x) join (values (0),(16),(32),(48),(64),(80),(96),(112),(128),(144),(160),(176),(192),(208),(224),(240)) as x16(x) join (values (0),(256),(512),(768),(1024),(1280),(1536),(1792),(2048),(2304),(2560),(2816),(3072),(3328),(3584),(3840)) as x256(x) join (values (0),(4096),(8192),(12288),(16384),(20480),(24576),(28672),(32768),(36864),(40960),(45056),(49152),(53248),(57344),(61440)) as x4096(x) join (values (0),(65536),(131072),(196608),(262144),(327680),(393216),(458752),(524288),(589824),(655360),(720896),(786432),(851968),(917504),(983040)) as x65536(x) join (values (0),(1048576),(2097152),(3145728),(4194304),(5242880),(6291456),(7340032),(8388608),(9437184),(10485760),(11534336),(12582912),(13631488),(14680064),(15728640)) as x1048576(x) join (values (0),(16777216),(33554432),(50331648),(67108864),(83886080),(100663296),(117440512),(134217728),(150994944),(167772160),(184549376),(201326592),(218103808),(234881024),(251658240)) as x16777216(x) join (values (0),(268435456),(536870912),(805306368),(1073741824),(1342177280),(1610612736),(1879048192)) as x268435456(x) where @end >= select x from fn_consecutivenumbers(5, 500);
select dateadd(day,x, 0) dayx from fn_consecutivenumbers(datediff(day,0,'5/8/2015'), datediff(day,0,'5/31/2015')) select dateadd(hour,x, 0) hourx from fn_consecutivenumbers(datediff(hour,0,'5/8/2015'), datediff(hour,0,'5/8/2015 12:00 pm'));
select timeranges.starttime, timeranges.endtime, dateadd(minute,x, 0) minutex from timeranges datediff(hour,0,timeranges.endtime)) consecutivenumbers;
create assembly sqlutil from 'c:\path\to\assembly.dll' create function [seq](@start int, @end int) as external name [sqlutil].[yournamespace.sequencegenerator].[generate];
select * from dbo.seq(1, 1000000);
select ones.n + 10*tens.n + 100*hundreds.n + 1000*thousands.n from (values(0),(1),(2),(3),(4),(5),(6),(7),(8),(9)) ones(n), (values(0),(1),(2),(3),(4),(5),(6),(7),(8),(9)) tens(n), (values(0),(1),(2),(3),(4),(5),(6),(7),(8),(9)) hundreds(n), (values(0),(1),(2),(3),(4),(5),(6),(7),(8),(9)) thousands(n) where ones.n + 10*tens.n + 100*hundreds.n + 1000*thousands.n between @userinput1 and @userinput2;
select ones.n + 10*tens.n + 100*hundreds.n + 1000*thousands.n from x ones,     x tens,      x hundreds,       x thousands;
select top 100 from dbo.foo;
select @min=919859000000 ,@max=919859999999 select top (@max-@min+1) @min-1+row_number() over(order by t1.number) as n from master..spt_values t1;
create table #numrange( n int ) set nocount on set @i = 0 set @i = @i + 1 end  set @minnum = 1 set @maxnum = 1000000 select  num = a.n + from    #numrange a where   a.n + drop table #numrange;
select  isnull(@min,0)+number.number  as  number from    dbo.spt_values  as  number where   number."type"                   =   'p'     --integers and (   @max                            is null     --return all or  isnull(@min,0)+number.number    <=  @max    --return up to max ) select  isnull(@min,0)+value1.number+(value2.number*numbercount.numbers)  as  number from  dbo.spt_values            as  value1 select  sum(1)  as  numbers from    dbo.spt_values where   spt_values."type"   =   'p' --integers where   value1."type" = 'p'   --integers and value2."type" = 'p'   --integers and (   @max    is null     --return all or  isnull(@min,0)+value1.number+(value2.number*numbercount.numbers) );
select distinct n = number from master..[spt_values] where number between @start and @end;
( select n = row_number() over (order by [object_id]) from sys.all_objects ) select n from nums where n between @start and @end;
select @startnum as num union all select num+1 from gen where num+1<=@endnum ) select * from gen;
select ename,sal,rank() over (order by sal) rank from emp;
select ename,sal,dense_rank() over (order by sal) den_rank from emp;
select row_number() over (order by salary) as rownum, salary, rank() over (order by salary) as rnk, dense_rank() over (order by salary) as densernk from ( select 1000 as salary union all select 1000 as salary union all select 1000 as salary union all select 2000 as salary union all select 3000 as salary union all select 3000 as salary union all select 8000 as salary union all select 9000 as salary) a;
rownum  salary  rnk densernk;
select 10 deptno, 'rrr' empname, 10000.00 sal from dual union all select 11, 'nnn', 20000.00 from dual union all select 11, 'mmm', 5000.00 from dual union all select 12, 'kkk', 30000 from dual union all select 10, 'fff', 40000 from dual union all select 10, 'ddd', 40000 from dual union all select 10, 'bbb', 50000 from dual union all select 10, 'xxx', null from dual union all select 10, 'ccc', 50000 from dual) select empname, deptno, sal from q;
select empno from emp ;
select empno, deptno, sal, rank() over (partition by deptno order by sal) "rank" from   emp;
select empno, deptno, sal, dense_rank() over (partition by deptno order by sal) "rank" from   emp;
create table t as select 'a' v from dual union all select 'a'   from dual union all select 'a'   from dual union all select 'b'   from dual union all select 'c'   from dual union all select 'c'   from dual union all select 'd'   from dual union all select 'e'   from dual;
select v, row_number() over (order by v) row_number, rank()       over (order by v) rank, dense_rank() over (order by v) dense_rank from t;
['name' => 'dial rock 360', 'city' => 'yaounde', 'salary' => 20000000], ['name' => 'ndibou la menace', 'city' => 'dakar', 'salary' => 40000000];
['user_id'=>'coder 2', 'subject_id'=> 2048], //...;
array('user_id'=>'coder 1', 'subject_id'=> 4096), array('user_id'=>'coder 2', 'subject_id'=> 2048), //...;
select sum(numbackends) from pg_stat_database;
select  * from (select setting::int res_for_super from pg_settings where name=$$superuser_reserved_connections$$) q2, (select setting::int max_conn from pg_settings where name=$$max_connections$$) q3;
select count(*) from pg_stat_activity;
select state, count(*) from pg_stat_activity  where pid <> pg_backend_pid() group by 1 order by 1;
select a.* from a;
select a.* from a left join lateral ( select b.column1,b.column2,b.fk1 from b  limit 1;
select  * from    table1 t1 ( select  * from    t2 where   t1.col1 = t2.col1 -- only allowed because of lateral;
select  * from    table1 t1 ( select  * from    t2 where   t2.col1 = 42 -- no reference to outer query;
create table tbl (a1 int[], a2 int[]);
select * from tbl, unnest(a1, a2) u(elem1, elem2);  -- implicit lateral;
select *, unnest(a1) as elem1, unnest(a2) as elem2 from   tbl;
select * from   tbl t select * from   tbl t, lateral (select * from b where b.t_id = t.t_id) t;
select b.id as blog_id, extract( year from age(now(), b.created_on) date( created_on + ( extract(year from age(now(), b.created_on)) + 1 date( created_on + ( extract(year from age(now(), b.created_on)) + 1 from blog b;
select b.id as blog_id, age_in_years, date( created_on + (age_in_years + 1) * interval '1 year' date( created_on + (age_in_years + 1) * interval '1 year' from blog b select cast( extract(year from age(now(), b.created_on)) as int;
create or replace function delete_company(companyid varchar(255)) delete from company_settings where "company_id"=company_id;
delete from users where "company_id"=companyid;
delete from companies where id=companyid;
select * from ( select id, name, created_at from companies where created_at < '2018-01-01';
create table categories ( code char(4) not null primary key, categoryname varchar(63) not null unique create table courses ( courseid int not null primary key, bookid int not null, catcode char(4) not null, coursenum char(3) not null, coursesec char(1) not null, );
alter table courses add foreign key (catcode);
create table delivery( id int identity primary key, notenumber nvarchar(255) not null ) create table package( id int identity primary key, status int not null default 0, delivery_id int not null, constraint fk_package_delivery_id foreign key (delivery_id) references delivery (id) on delete cascade );
select column1, column2 from othertable;
select * into #temptablename;
select * from  total, answer, (case when application like '%stuff%' then 'morestuff' end) as application from firsttable where recieved = 1 and case when application like '%stuff%' then 'morestuff' end) data where application like '%morestuff%', '%');
select * from ( select col1, col2 from table1;
select * into #result from (select * from  #temp where [id] = @id) as t //<-- as t;
select * from (select * from tblorders where busidate ='2016-11-24' and locationid=12;
create global temporary table as select artistname, sum(songs) as numberofsongs from spotfy where artistname = 'bossadosamba';
select * from ( the query you want to use many times select * from #temp where this = that select * from #temp where this <> that select col1,col3 from #temp where this > that drop table #temp;
select * into #temptable from sampletable select * from #temptable drop table #temptable;
select 'drop table "' + table_name + '"' from information_schema.tables where table_name like '[prefix]%';
select 'if object_id(''' +table_name + ''') is not null begin drop table [' + table_name + '] end;' from information_schema.tables where table_name like '[prefix]%';
set @startstr = 'tablename' select @startstrlen = len(@startstr) select 'drop table ' + name from sysobjects where type = 'u' and left(name, @startstrlen) = @startstr;
select 'drop table [' + table_name + ']' from information_schema.tables where table_name like 'prefix%' if @@fetch_status != 0 break end close cmds;
create procedure usp_generatedrop as begin select @sql = coalesce(@sql, '') + 'drop table [' + table_name + ']' + char(13) + char(10) from information_schema.tables where table_name like @pattern if @printquery = 1 print @sql if @execquery = 1 exec (@sql) end;
select 'drop table ' + name from sysobjects where type = 'u' and sysobjects.name like '%test%';
( select object_schema_name(so.object_id) as schemaname, object_name(so.object_id) as tablename, so.object_id as tableid, 0 as ordinal from sys.objects as so where so.type = 'u' and so.is_ms_shipped = 0 and object_name(so.object_id) like 'myprefix%' union all select object_schema_name(so.object_id) as schemaname, object_name(so.object_id) as tablename, so.object_id as tableid, tt.ordinal + 1 as ordinal from sys.objects as so and f.parent_object_id != f.referenced_object_id where so.type = 'u' and so.is_ms_shipped = 0 and object_name(so.object_id) like 'myprefix%' ) select distinct t.ordinal, t.schemaname, t.tablename, t.tableid from tablescte as t ( select itt.schemaname as schemaname, itt.tablename as tablename, itt.tableid as tableid, max(itt.ordinal) as ordinal from tablescte as itt and t.ordinal = tt.ordinal;
select 'if object_id(''' + table_name + ''') is not null begin drop table "' + table_name + '" end;' from information_schema.tables where table_name like '[prefix]%';
select 'drop table databasename.schema.' + table_name from information_schema.tables where table_name like 'strmatch%';
select 'drop table "' || table_name || '";' from user_tables where table_name like 'yourtableprefix%';
select 'drop table "' || table_name || '" cascade constraints purge;' from user_tables where table_name like 'yourtableprefix%';
drop table cascade constraints purge;
select 'drop view "' || view_name || '";' from user_views where view_name like 'yourviewprefix%';
select concat(  'drop table `', table_name,  '`;' ) as query from information_schema.tables where table_name like  'wp_%';
select concat('drop table `', table_name,'`;') from information_schema.tables where table_name like 'table_prefix_goes_here%';
exec sp_msforeachtable 'if parsename("?",1) like ''%certainstring%'' drop table ?';
select 'drop table "' + t.name + '"' from tempdb.sys.tables t where t.name like '[prefix]%';
select @sql += ' drop table ' from sys.tables as t where t.name like 'something%';
@system_time date, @table_date nvarchar(8), @older_than int = 7 set @system_time = (select getdate() - @older_than) set @table_date = (select convert(char(8), @system_time, 112)) select @drop_command += n'drop table ' + quotename(schema_name(schema_id)) + '.' + quotename([name]) + ';' from <your_database_name>.sys.tables where [name] like 'table_%' and right([name],8) < @table_date select @drop_command exec sp_executesql @drop_command;
select name, min(score_a, score_b) as minimum_score from table;
(0,"cat26",30.9), (0,"cat13",22.1), (0,"cat95",19.6), (0,"cat105",1.3), (1,"cat67",28.5), (1,"cat4",26.8), (1,"cat13",12.6), (1,"cat23",5.3), (2,"cat56",39.6), (2,"cat40",29.7), (2,"cat187",27.9), (2,"cat68",9.8), (3,"cat8",35.6))).todf("hour", "category", "totalvalue");
($"hour" === $"max_hour") && ($"totalvalue" === $"max_value"));
first("category").alias("category"), first("totalvalue").alias("totalvalue"));
case class record(hour: integer, category: string, totalvalue: double);
(0,"cat26",30.9), (0,"cat13",22.1), (0,"cat95",19.6), (0,"cat105",1.3), (1,"cat67",28.5), (1,"cat4",26.8), (1,"cat13",12.6), (1,"cat23",5.3), (2,"cat56",39.6), (2,"cat40",29.7), (2,"cat187",27.9), (2,"cat68",9.8), (3,"cat8",35.6)).todf("hour", "category", "totalvalue");
select p.productid, p.name, c.categoryid, c.name as category from products p inner join productcategories c on p.categoryid = c.categoryidwhere c.categoryid = 1;
select p.productid, p.name, c.categoryid, c.name as category from productcategories c where c.categoryid = 1;
create or replace procedure ex(j in number) as select id into i from student where id=j;
if i is not null then end if;
select top 1 products.id from products where products.id = ?;
select top 1 1 from products where id = 'some value';
select anycolumn;
if exists (select * from products where id = ?) end else begin end;
select case when exists (select top 1 * from dbo.[yourtable] where [yourcolumn] = [yourvalue]) then cast (1 as bit) else cast (0 as bit) end;
update tablename set column=value where column=value if @@rowcount=0 end;
select case when exists (select 1 from dbo.[yourtable] with (nolock) where [yourcolumn] = [yourvalue]) then cast (1 as bit) else cast (0 as bit) end;
select distinct 1 products.id from products where products.id = ?;
select count(*) from products where products.id = ?;
if exists (select 1 from dbo.t1 where t1.name='scot') end  else begin end;
set ansi_nulls off if null = null else print 'false' set ansi_nulls on if null = null else print 'false';
set ansi_nulls off if null=null else print 2 set ansi_nulls on if null=null else print 2;
and op     null   true   false or op      null   true   false;
select null = null;
create table mytable ( key_col integer not null unique, data_col integer check (data_col = 55) values (1, null);
select 1 where isnull(nullparam1, -1) = isnull(nullparam2, -1);
where (value=@param or @param is null) and id=@anotherparam;
where value = null;
select 1 where exists ( select null select null );
while unknown and unknown is unknown.;
create role [myapprights];
create role db_executor;
select (select count(*) from tbl where colname is null) nulls, (select count(*) from tbl where colname is not null) nonnulls;
select count(a) from us where a is null;
select count(a) from us where a is not null;
select count(a) from us;
select count(*) from us select count(a) from us;
select count(a) not_nulls from us union  select count(*) - count(a) nulls from us;
select count(a) not_null, count(*) - count(a) nulls from us;
select (select count(*) from tablename where a = 'null') as total_null, (select count(*) from tablename where a != 'null') as total_not_null from tablename;
select sum(case a when null then 1 else 0) "null values", sum(case a when null then 0 else 1) "non-null values" from us;
select count(*) from us where a is null union all select count(*) from us where a is not null;
select count(*), 'null_tally' as narrative from us where a is null union select count(*), 'not_null_tally' as narrative from us where a is not null;
select sum(case when a is null then 1 else 0 end) count_nulls from us;
select count(*) - count(a), count(a) from us;
select count(0) as 'null_columna_records', ( select count(0) from your_table where columna is not null from your_table where columna is null;
select sum(nulls) as 'nulls', sum(notnulls) as 'notnulls' from union select 0 as 'nulls', count(*) as 'notnulls' from us where a is not null) as x;
select count(columnname) as countofnotnulls, count(isnull(columnname,1))-count(columnname) as countofnulls from table name;
select count(columnname) as countofnotnulls, count(*)-count(columnname) as countofnulls from table name;
select count(isnull(nullablecolumn,-1));
select count(n) from ( select *, row_number() over (order by [mycolumn] asc) n from ( select distinct [mycolumn] from [mytable];
select sum(isnull(a)) as all_null, sum(!isnull(a)) as all_not_null from us;
if object_id('tempdb..#us') is not null drop table #us create table #us ( a int null select * from #us select case when a is null then 'null' else 'non-null' end as 'null?', count(case when a is null then 'null' else 'non-null' end) as 'count' from #us select coalesce(cast(a as nvarchar),'null') as a, count(coalesce(cast(a as nvarchar),'null')) as 'count' from #us;
select [narrative] = case from [crmdw].[crm].[user] where [employeeid] is null union select count(*), 'count_not_nulls ' as narrative from [crmdw].[crm].[user] where [employeeid] is not null) s;
select count(*) - count(a) as 'null', count(a) as 'not null' from us;
select count(*) from us where a is not null;
select count(*) from us where a is null;
set nocount on select * from @table1 select count(1) as "count(1)" from @table1 select count(empid) "count(empid)" from @table1;
select count(isnull(empid,1)) from @table1;
select sum(case when a is null then 0 else 1 end) as count_notnull, sum(case when a is null then 1 else 0 end) as count_null from tab;
select count(*) filter (where a is null) count_nulls, count(*) filter (where a is not null) count_not_nulls from us;
select all_values select nvl2(a,'not null','null') as all_values from us );
select count_if(a is null) as nulls, count_if(a is not null) as not_nulls from us;
select case else 'not null' end a, count(1) from   us else 'not null' end;
select count(*) from us;
select count(a is null) from us;
select (case when a is null then 'null' else 'not-null' end) as a_null, (case when b is null then 'null' else 'not-null' end) as b_null, (case when c is null then 'null' else 'not-null' end) as c_null, ... from us;
select 'hello ' '&' ' world';
values (&stud_id, '&first_name' ,'&last_name', '&dob', &fees, '&gender');
values (&stud_id, '&first_name' ,'&last_name', '&dob', &&fees,'&gender');
set define off select 'coda & sid' from dual;
select * from mde_product where cfn = 'a3d"&"r01';
select itemname as itemname, substring(itemname, 1,1) as firstletter, count(itemname) from table1;
select itemname, firstletter, count(itemname) from ( select itemname, substring(itemname, 1, 1) as firstletter from table1;
select itemname as itemname, firstletter, count(itemname) from table1;
select col1 as col1_1, avg(col3) as col2_1 from (select gender as col1, maritalstatus as col2, yearlyincome as col3 from customer) as layer_1 select col2 as col1, avg(col3) from (select gender as col1, maritalstatus as col2, yearlyincome as col3 from customer) as layer_1;
create view vw_user_profile as select a.user_id, b.profile_description from tbl_user a left join tbl_profile b on a.user_id = b.user_id;
select profile_description from vw_user_profile where user_id = @id;
create procedure dbo.getdesc as begin select profile_description from vw_user_profile where user_id = @id end go;
create view vw_user_profile as select a.user_id, b.profile_description from tbl_user a left join tbl_profile b on a.user_id = b.user_id;
update vw_user_profile set profile_description='manager' where user_id=4;
update tbl_profile set profile_description='manager' where user_id=4;
create view junk as select * from [tablename];
('mary','maryann roberts');
delete from junk where id>4;
select @dataid = scope_identity();
( id int not null primary key ) ( objectid int not null, dataid int not null ) ( id int not null identity(1,1), data varchar(50) not null ) select objects.id, data.id from @object_table as objects, @data_table as data where objects.id = 1;
select data.data from @data_table as data inner join @link_table as link on data.id = link.dataid where objects.id = 1;
set ansi_nulls on set quoted_identifier on alter procedure insetintotwotable ( @name nvarchar(50), @email nvarchar(50) ) as begin set nocount on;
set xact_abort on;
set xact_abort on;
select @dataid = scope_identity();
select count(email) as count from table1 t1 join ( select company_domains as emailext from table2 where company = 'dell';
where interests like 'sports%' or interests like 'pub%';
where interests regexp '^sports|^pub';
select * from `table` where find_in_set('sports', interests)>0 or find_in_set('pub', interests)>0;
select * from table_name where colname rlike 'regex1|regex2|regex3';
select * from table where interests regexp 'sports|pub';
where id=123 and(interests like '%sports%' or interests like '%pub%');
where interests like '%sports%' or interests like '%pub%';
select * from `table` where find_in_set(interests, "sports,pub")>0;
where interests like '%sports%' or interests like '%pub%';
where interests regexp 'sports|pub';
select datediff(day,'20110101','20110301');
select datediff(day, @startdate, @enddate);
select datediff(day, '1/1/2011', '3/1/2011');
select datediff(day, @startdate, @enddate);
select datediff(day, '2005-12-31 23:59:59.9999999', '2006-01-01 00:00:00.0000000');
select (datediff(day,(@lastdate),getdate())) as differencedays/*this query will return no of days between firstdate & current date*/;
select datediff(day, startdate, enddate) as daycount;
select  (datediff(dd,'+char(39)+ convert(varchar(10),@fromdate  ,101)+;
if results.present? else return nil end end;
select employee_id from employee where employee_date_hired > to_date('31-dec-95','dd-mon-yy');
select employee_id from employee where employee_date_hired > to_date('31-12-1995','dd-mm-yyyy');
select employee_id from employee where employee_date_hired > date '1995-12-31';
select employee_id from employee where employee_date_hired > timestamp '1995-12-31 12:31:02';
alter session set nls_date_format = 'dd.mm.yyyy hh24:mi:ss';
select employee_id, count(*) from employee where employee_date_hired > date '1995-12-31';
select to_char (g.fecha, 'dd-mm-yyyy hh24:mi:ss') fecha_salida, g.numero_guia, g.bod_origen, g.tipo_guia, dg.doc_numero, dg.* from ils_det_guia dg, ils_guia g where dg.numero_guia = g.numero_guia and dg.tipo_guia = g.tipo_guia and dg.bod_origen = g.bod_origen and dg.lab_codigo = 56 and trunc(g.fecha) > to_date('01/02/15','dd/mm/yy');
select employee_id, count(*) from employee where to_char(employee_date_hired, 'dd-mon-yy') > '31-dec-95';
select count(*) from employee where to_char(employee_date_hired, 'yyymmmddd') > 19940620;
or to_char(employee_date_hired, 'yyymmmddd') > 19940620;
create function fn() as begin end;
create table foo ( id nvarchar(255), data nvarchar(255) ) create function dbo.getfoo(@aid nvarchar(255)) returns table as return ( select *, 0 as causeserror from foo where id = @aid union  select top 1 *, case else 'error in getfoo() - id "' + isnull(@aid, 'null') + '" does not exist' end from foo where (not exists (select id from foo where id = @aid)) ) select * from dbo.getfoo('green eggs') select * from dbo.getfoo('yellow eggs') drop function dbo.getfoo drop table foo;
create function dbo.ufn_test (@a tinyint) if @a>50 -- if @a > 50 - raise an error end  end  select column1, value1 from dbo.ufn_test(1) -- this is okay select column1, value1 from dbo.ufn_test(51) -- this will raise an error;
create function dbo.throwerror() as begin end;
create function [dbo].[throw] ( @error nvarchar(max) ) as begin end go if `error condition` set @error = 'my error' else set @error = '0' set @bit = [dbo].[throw](@error);
create procedure throw_error ( in err_msg varchar(255));
alter function [dbo].[getexchangerate] ( @currencyfrom char(3), @currencyto char(3), @ondate date ) as begin select top 1 from [factcurrencyrate] where fromcurrencycode=@currencyfrom and end go;
select * from lms_books_details where book_code not in;
select * from tbl_name order by id desc limit n;
select * from tbl_name except select top l-n * from tbl_name;
select * from   clientdetails from   clientdetails);
select @tablerowscount= count(*) from <your_table>;
select * from  <your_table> as l;
select * from ( select row_number() over(order by id) as sequencenumber, * from  <your_table> where sequencenumber > @tablerowscount-@n;
select * from table_name except select top;
select * from products except select top (77-10) * from products;
select top 10 * from products;
select * from products where productid in (select top 10 productid from products);
select * from products where productid not in;
select * from (select top 6 * from vwtable order by hours desc) t order by hours;
select * from ( select top n * from tablename t;
select orderid, customerid, orderdate from ( select row_number() over (partition by employeeid order by orderdate desc) as ordereddate,* from orders where ordlist.employeeid = 5 and ordlist.ordereddate <= 5;
select top(5) orderid, customerid, orderdate from orders where employeeid=5;
select col from [dbo].[table] set @step = @step + 1;
end close mytestcursor;
select top(n) * from tbl_name;
set @toppercent = .05 select @rowidtablea = (max(tableaid) - (max(tableaid) * @toppercent)) from tablea select @rowidtableb = (max(tablebid) - (max(tablebid) * @toppercent)) from tableb select * from tablea a where a.id > @rowidtablea and b.id > @rowidtableb and;
select * from "table" t order by "t.id_table" desc limit 5;
select * from orders where id >(select max(id)-10 from orders);
select  1 union all select  cnt + 1 from    hier where   cnt < @n ) select  cnt from    hier;
values (4815162342, 1, now());
create table test ( id int unsigned not null auto_increment, data varchar(64) default null, ts timestamp not null default current_timestamp on update current_timestamp, primary key (id);
select a from table1 select a from table2;
select a from table1 select a from table2;
select t1.a from table1 t1 ( select t2.a from table2 t2 where t2.a = t1.a where dt1.a is null;
"name": "database_name", "user": "user", "password": "password", "host": "/applications/xampp/xamppfiles/var/mysql/mysql.sock", "port": "", };
select * from ( select distinct app_id, name, storage_gb, history_created, to_char(history_date, 'dd.mm.yyyy') as history_date from history where where rownum <= 10;
where to_char(history_date, 'dd.mm.yyyy') = '06.02.2009');
where history_date = to_date ('06.02.2009', 'dd.mm.yyyy');
select * from ename, sal, row_number() over(order by sal desc nulls last) rnm from emp) where rnm<=10;
select distinct app_id, name, storage_gb, history_created, to_char(history_date, 'dd.mm.yyyy') as history_date from history where;
select * from users fetch next 10 rows only;
select tmp.row from ( select row, rank() over(partition by id order by id desc ) as rnk from table) tmp where tmp.rnk=1;
select row from table where id=( select max(id) from table );
select row from table order by id desc limit 1;
select * from table where id = (select max(id) from table);
select row from table order by id desc limit 1;
select * from table where id = (select max(id) from table);
select top 1  id, col2,  row_number() over (order by id desc)  from table;
select substring(field,3,9) as field from table order by substring(field,3,10)*1 desc;
select id, (case when isnumeric(id) = 1 then 0 else 1 end) isnum from @tmp;
select col from yourtable;
select col from yourtable;
select col from yourtable;
select * from tablename;
select * from tablename order by abs(column_name);
'user_profiles.id', 'user_profiles.user_id', 'user_profiles.membership_id', 'user_profiles.first_name', 'user_profiles.middle_name', 'user_profiles.last_name', 'user_profiles.mobile_number', 'countries.citizenship', 'states.name as state_of_origin', 'user_profiles.gender', 'user_profiles.created_at', 'user_profiles.updated_at' ) 'users', 'user_profiles.user_id', 'users.id' ) 'countries', 'user_profiles.nationality', 'countries.id' ) 'states', 'user_profiles.state_of_origin', 'states.id' ) `substring(:sortfield:,3,15)*1 ${sortdirection}`, { } ) page, per_page );
if (stmt != null) { stmt.close(); } if (conn != null) { conn.close(); };
if (str != null && str.length() > 0) {;
case 0: /* must be escaped for 'mysql' */ case '\n': /* must be escaped for logs */ case '\r': case '\\': case '\'': case '"': /* better safe than sorry */ if (escapedoublequotes) { case '\032': /* this gives problems on win32 */ case '\u00a5': case '\u20a9':;
select x,1 as c2,2 as c3 from generate_series(1,90000000) x;
update [table_name] set;
update [table_name] set;
values ('  ey     y select col_1 as input, ltrim(rtrim( replace( replace( replace( replace( replace( replace( replace( replace( replace( replace( replace(col_1,char(10),' ') from @tbl;
select ltrim(rtrim('amit tech corp '));
update table set companyname = ltrim(rtrim(companyname));
update tablename set columnname = rtrim(columnname);
update tablename set columnname = ltrim(rtrim(columnname));
update mytable set companyname = rtrim(companyname);
select ltrim(rtrim(yourcolumn)) from yourtable;
set @mytable = 'mytable' select column_name, row_number() over(order by column_name) as id into #tempcols from information_schema.columns where   data_type in ('varchar', 'nvarchar') and table_name = @mytable select @tri = count(*) from #tempcols select @i = 0 set @comma = ', ' select @trimmer = 'update [dbo].[' + @mytable + '] set ' if (@i = @tri) set @comma = '' end select  @trimmer = @trimmer + char(10)+ '[' + column_name + '] = ltrim(rtrim([' + column_name + ']))'+@comma from    #tempcols where id = @i select @i = @i+1 end  exec sp_executesql @trimmer drop table #tempcols;
select trim(columnname) from tablename;
select ltrim(rtrim(columnname)) from tablename;
select ltrim('    test    ') as trim;
select rtrim('    test    ') as trim;
select trim(columnname) from dual;
set companyname = ltrim(rtrim(companyname));
select trim('   sample   ');
update tablename set columnname = trim(columnname);
update tablename set columnname= ltrim(rtrim(columnname));
select column1, column2 from viewwhatever where @locationid = case @locationtype end;
select * from test where account_location = ( case locationtype else account_location end ) and account_location_area = ( case locationtype else account_location_area end );
where account_location = case @locationtype end;
select column1, column2 from viewwhatever where case when @locationtype = 'location' and account_location = @locationid then 1 else 0 end = 1;
select column1, column2 from viewwhatever where (@locationtype = 'location' and account_location = @locationid) or (@locationtype = 'area' and xxx_location_area = @locationid) or (@locationtype = 'division' and xxx_location_division = @locationid);
select @msgid, account_id from viewmailaccountsheirachy where case @smartlocationtype end  = @smartlocation;
where ( @smartlocationtype is null or account_location = ( case when @smartlocationtype is not null then @smartlocationtype else account_location end ) );
create table personsdetail(firstname nvarchar(20), lastname nvarchar(20), genderid int);
(n'ramesh', n'kumar', 1), (n'ram', n'lal', 2), (n'sunil', n'kumar', 3), (n'sunny', n'sehgal', 1), (n'malkeet', n'shaoul', 3), (n'jassy', n'sohal', 2);
select firstname, lastname, gender = case genderid else 'unknown' end from personsdetail;
case statement in sql server example case [ expression ] else result end  select contact_id, case website_id else 'bigactivities.com' end from contacts;
or  select contact_id, case when website_id = 1 then 'techonthenet.com' else 'bigactivities.com' end from contacts;
alter procedure [dbo].[rpt_340bclinicdruginventorysummary] @selecttype int, @selectedvalue varchar (50) as begin set nocount on;
select drugstock_drugname.n_cur_bal,drugname.cdrugname,clinic.cclinicname from drugstock_drugname where   (@clinicid = 0 and 1 = 1) or  (@clinicid != 0 and drugstock_drugname.clinicid_fk = @clinicid) and ((@selecttype = 1 and 1 = 1) or  (@selecttype = 2 and drugname.drugnameid_pk = @selectedvalue) or  (@selecttype = 3 and drugndc.drugid_pk = @selectedvalue) or  (@selecttype = 4 and drugname.cdrugclass = 'c2') or  (@selecttype = 5 and left(drugname.cdrugclass, 1) = 'c')) end;
create procedure [dbo].[temp_proc_select_city] as begin select * from tbl_city where @stateid = case when isnull(@stateid,0) = 0 then 0 else stateid end order by cityname end;
if not object_id('tempdb..contacts') is null drop table contacts create table contacts(id int, firstname varchar(100), lastname varchar(100)) select 1, 'omid', 'karami' union all select 2, 'alen', 'fars' union all select 3, 'sharon', 'b' union all select 4, 'poja', 'kar' union all select 5, 'ryan', 'lasr' set @firstname = 'omid' set @lastname = '' select firstname, lastname from contacts where firstname = case else firstname end and lastname = case else lastname end go;
from p in context.periods join f in context.facts on p.id equals f.periodid into fg from fgi in fg.where(f => f.otherid == 17).defaultifempty() where p.companyid == 100 select f.value;
from p in context.periods join f in context.facts on p.id equals f.periodid into fg from fgi in (from f in fg where f.otherid == 17 select f).defaultifempty() where p.companyid == 100 select f.value;
where c.displayondate > date.adddays(-1) select c;
if (!string.isnullorempty(pagename)) join p in db.announceonpages on c.announcementid equals p.announcementid join s in db.apppagenames on p.apppagenameid equals s.apppagenameid where s.apppageref.tolower() == pagename.tolower() select c;
from p in context.periods join f in context.facts p.otherid f.otherid from fgi in fg.defaultifempty() where p.companyid == 100 select f.value;
select f.value from period as p join facts as f on p.id = f.periodid where p.companyid = 100 and f.otherid = 17 union select null as value from period as p where p.companyid = 100 and not exists ( select * from facts as f where p.id = f.periodid and f.otherid = 17;
context.facts, period => period.id, fk => fk.periodid, (period, fact) => fact.where(f => f.otherid == 17) );
context.facts, p => new {p.id, otherid = 17}, f => new {id = f.periodid, f.otherid}, (p, f) => new {p, f}) pf => pf.f.defaultifempty(), (pf, f) => new myjoinentity value = f.value, // and so on...;
select province, n, city, population from ( select  @prev := '', @n := 0 ) init join ( select  @n := if(province != @prev, 1, @n + 1) as n, @prev := province, province, city, population from  canada province   asc, population desc where  n <= 3;
( select * from mytable where `group` = 1 limit 2 ) union all ( select * from mytable where `group` = 2 limit 2 );
select person, `group`, age from ( select person, `group`, age, (@num:=if(@group = `group`, @num +1, if(@group := `group`, 1, 1))) row_number from test t where x.row_number <= 2;
create table mytable (person, groupname, age);
select a.* from mytable as a having count(*) <= 2;
create table foo (person, groupname, age);
select a.person, a.groupname, a.age from foo as a where a.age >= (select min(b.age) from foo as b where (select count(*) from foo as c where c.groupname = b.groupname and c.age >= b.age) <= 2;
select a.person, a.group, a.age from person as a where where b.group = a.group and b.age >= a.age) <= 2;
select p.person, p.`group`, p.age from people p ( select max(age) as age, `group` from people group by `group` union select max(p3.age) as age, p3.`group` from people p3 inner join (select max(age) as age, `group` from people group by `group`) p4 on p3.age < p4.age and p3.`group` = p4.`group` group by `group` `group`, age desc, person;
select person, groupname, age from ( select person, groupname, age, @rn := if(@prev = groupname, @rn + 1, 1) as rn, @prev := groupname from mytable join (select @prev := null, @rn := 0) as vars where rn <= 2;
select person,[group],age from ( select * ,row_number() over(partition by [group] order by age desc) rn from mytable where rn <= 2;
select person, group, age from (select person, group, age, @group_rank := if(@group = group, @group_rank + 1, 1) as group_rank, @current_group := group from `your_table` where group_rank <= `n`;
select sex, substring_index(group_concat(cast(gpa as char ) order by gpa desc), ',',5) as subcategories from student group by sex;
select person, groupname, age from ( select person, groupname, age, (@rn:=if(@prev = groupname, @rn +1, 1)) as rownumb, @prev:= groupname from ( select person, groupname, age from persons join (select @prev:=null, @rn :=0) as vars where rownumb<=2;
select p1.person, p1.`group`, p1.age from person as p1 where ( select count( distinct ( p2.age ) ) from person as p2 where p2.`group` = p1.`group` and p2.age >= p1.age p1.`group` asc, p1.age desc;
select * from   table1 tb1 select * from   dblink('dbname=db2','select id, code from table2') as     tb2(id int, code text);
create extension if not exists dblink;
select datname from pg_database where datistemplate = false if table_exists then end if;
update my_table set field_1 = field_1 + 1 where pk_field = some_value;
instance=my_model, data=validated_data) if my_model_serializer.is_valid():;
if form.is_valid():;
drop schema public;
alter schema originaldbschema rename to public;
if (@key is null) select * from table t end else begin select * from table t where t.key=@key end;
select  [blah] from    emp where  ((@empid = -1) or (@empid = empid));
set @adate = null if (@adate is not null) end;
select 'test' where 1 = 'a' select 'test' where 1 = 1 or 1 = 'a';
select 'test' where 1 = 0 or 1 = 'a';
where 1 = 1 or 2 = 2;
where 1 = 0 and 1 = 1;
select * from table where 1=0 and (function call to complex operation);
select * from table where (a field from table) < 0 and (function call to complex operation);
where case when expr1 then expr2 else expr3 end = desiredresult;
select myint from mytable where myint >= 3 or myslowfunction('query #1', myint) = 1;
select myint from mytable where myslowfunction('query #2', myint) = 1 or myint >= 3;
select * from fieldvalues_text where fieldid in ( select fieldid from fields where userid=@userid ) and value like '%' + @search + '%';
alter role <your_login_role> set search_path to a,b,c;
alter database <database_name> set search_path to schema1,schema2;
alter role <role_name> set search_path to schema1,schema2;
create database <database_name> template <template_name>;
alter role <role_name> in database <db_name> set search_path to schema1,schema2;
select customerid, min(case dbcolumnname when 'firstname' then data end) firstname, min(case dbcolumnname when 'middlename' then data end) middlename, min(case dbcolumnname when 'lastname' then data end) lastname, min(case dbcolumnname when 'date' then data end) date from table;
select main.customerid, f.data as firstname, m.data as middlename, l.data as lastname, d.data as date from table main where f.dbcolumnname = 'firstname' and m.dbcolumnname = 'middlename' and l.dbcolumnname = 'lastname' and d.dbcolumnname = 'date';
select [firstname], [middlename], [lastname], [date] from #temp;
set @fullsql = @fullsql + 'select ' + replace(replace(@fulltext,'(',''),')','') set @fullsql = @fullsql + 'from #temp ' set @fullsql = @fullsql + 'pivot' set @fullsql = @fullsql + '(' set @fullsql = @fullsql + ' min([data])' set @fullsql = @fullsql + ' for [dbcolumnname] in '+@fulltext set @fullsql = @fullsql + ')' set @fullsql = @fullsql + 'as p' exec (@fullsql);
select  @str =  coalesce(@str +', ', '') from (select distinct daterange, id from ##pivot)d order by id;
select * from (select [customerid]  ,[demographic] ,[data] from [dbo].[pivot];
select customer_id, max(firstname) as firstname, max(lastname) as lastname ... from (  select customer_id, case when dbcolumnname='firstname' then data else null end as firstname, case when dbcolumnname='lastname' then data else null end as lastname, ... and so on ...;
( select customerid, -- grouping column from pivot2 ) select customerid, [firstname], [middlename], [lastname] from pivot_data;
from yourmaintable;
or (a.type in (1, 3) and a.container_id = p.hobt_id);
select  * from    sys.indexes i join sys.partitions p join sys.allocation_units a case when a.type in (1, 3) then  p.hobt_id then p.partition_id end;
select  * from    sys.indexes i join sys.partitions p join sys.allocation_units a else 0 end = 1;
select a.* from tablea a then rtrim(a.nobatiment) + '0' else a.nobatiment end ) = j1.columnname;
select  * from    sys.indexes i join sys.partitions p join sys.allocation_units a case when a.type in (1, 3) then a.container_id then a.container_id end = case when a.type in (1, 3) then p.hobt_id then p.partition_id end;
select  * from    sys.indexes i join sys.partitions p join sys.allocation_units a then p.hobt_id then p.partition_id else null;
case when @level  = 'lvl1' then  cw.lvl1 end = dashboard_group_level_matching.dashboard_level_name;
select main.columnname, compare.value previousvalue,  main.value currentvalue from ( select 'name' as columnname, 'john' as value union all select 'username' as columnname, 'jh001' as value union all select 'department' as columnname, 'hr' as value union all select 'phone' as columnname, null as value union all select 'dob' as columnname, '1993-01-01' as value union all select 'createdate' as columnname, '2017-01-01' as value union all select 'isactive' as columnname, '1' as value ( select 'name' as columnname, 'rahul' as value union all select 'username' as columnname, 'rh001' as value union all select 'department' as columnname, 'hr' as value union all select 'phone' as columnname, '01722112233' as value union all select 'dob' as columnname, '1993-01-01' as value union all select 'createdate' as columnname, '2017-01-01' as value union all select 'isactive' as columnname, '1' as value case when main.value is null and compare.value is null then 0 end = 1;
select * from emp;
set pagesize 50;
set feedback off;
set linesize 32767;
set trimspool on;
set underline off;
set headsep off;
select * from tblspc.${table} where rownum < 2;
set feedback off;
set linesize 32767;
set trimspool on;
set underline off;
set headsep off;
select * from tblspc.${table};
sql> set pagesize 20;
set sqlformat csv;
set echo off set heading off set feedback off set linesize 1024   -- or some other value, big enough set pagesize 50000 set verify off set trimspool on select trim( '"'   || replace(col1, '"', '""') || from   yourtable;
set echo off set heading off set feedback off set linesize 1024   -- or some other value, big enough set pagesize 50000 set verify off set trimspool on select trim( '"'   || replace(col1, '''', '''''') || from   yourtable;
set markup csv on;
select /*csv*/ table_name, tablespace_name from all_tables where owner = 'sys' and tablespace_name is not null;
set pagesize 50000--50k is the max as of 12c set linesize 10000 set trimspool on  --remove trailing blankspaces set underline off --remove the dashes/underlines under the col headers set colsep ~ select * from dw_tmc_project_vw;
select '"'||foo||'","'||bar||'"' from tab;
set pagesize 0 linesize 500 trimspool on feedback off echo off select '"' || empno || '","' || ename || '","' || deptno || '"' as text from emp;
set colsep ,     -- separate columns with a comma set pagesize 0   -- no header rows set trimspool on -- remove trailing blanks set headsep off  -- this may or may not be useful...depends on your headings. set linesize x   -- x should be the sum of the column widths set numw x       -- x should be the length you want for numbers (avoid scientific notation on ids) select table_name, tablespace_name from all_tables where owner = 'sys' and tablespace_name is not null;
set linesize 9999 set pagesize 50000 select x from ( select col1||';'||col2||';'||col3||';'||col4||';'||col5||';'||col6||';'||col7||';'||col8||';'||col9||';'||col10||';'||col11||';'||col12||';'||col13||';'||col14||';'||col15||';'||col16||';'||col17||';'||col18||';'||col19||';'||col20||';'||col21||';'||col22||';'||col23||';'||col24||';'||col25||';'||col26||';'||col27||';'||col28||';'||col29||';'||col30 as x from ( ...  here is the "core" select );
set heading off select col1_name||';'||col2_name||';'||col3_name||';'||col4_name||';'||col5_name||';'||col6_name||';'||col7_name||';'||col8_name||';'||col9_name||';'||col10_name||';'||col11_name||';'||col12_name||';'||col13_name||';'||col14_name||';'||col15_name||';'||col16_name||';'||col17_name||';'||col18_name||';'||col19_name||';'||col20_name||';'||col21_name||';'||col22_name||';'||col23_name||';'||col24_name||';'||col25_name||';'||col26_name||';'||col27_name||';'||col28_name||';'||col29_name||';'||col30_name from dual;
select x from ( select col1||';'||col2||';'||col3||';'||col4||';'||col5||';'||col6||';'||col7||';'||col8||';'||col9||';'||col10||';'||col11||';'||col12||';'||col13||';'||col14||';'||col15||';'||col16||';'||col17||';'||col18||';'||col19||';'||col20||';'||col21||';'||col22||';'||col23||';'||col24||';'||col25||';'||col26||';'||col27||';'||col28||';'||col29||';'||col30 as x from ( ...  here is the "core" select );
set colsep '","'     -- separate columns with a comma;
set colsep '|' set echo off set feedback off set linesize 1000 set pagesize 0 set sqlprompt '' set trimspool on set headsep off select '|', <table>.*, '|' from <table> where <conditions>;
create table employee( emp_pkey int identity(1, 1) constraint pk_employee_emp_pkey primary key, emp_ssn numeric not null unique, emp_fname varchar(16), emp_lname varchar(16) );
select distinct emp_lname from employee;
select col from table1 union select col from table2;
select col from table1 union all select col from table2;
select distinct;
select distinct;
select distinct;
select * from view;
select * from person where dob between '2011-01-01 00:00:00' and '2011-01-31 23:59:59';
select * from person where cast(dob as date) between '2011-01-01' and '2011-01-31';
select * from person where dob between '2011-01-01' and '2011-01-31 23:59:59';
select * from person join some_table ... where dob between some_table.initial_date and (some_table.final_date + interval 1 day - interval 1 second);
select * from person where date(dob) between '2011-01-01' and '2011-01-31';
select * from person where dob between '2011-01-01' and '2011-01-31 23:59:59';
select * from cases where date(created_at)='2013-05-01' and '2013-05-01';
select * from cases where created_at between '2013-05-01' and '2013-05-01';
select * from cases where '2013-05-01 22:25:19' between '2013-05-01 00:00:00' and '2013-05-01 00:00:00';
between '2013-05-01' and ''2013-05-01 23:59:59'';
select * from cases where cast(created_at as date) between '2013-05-01' and '2013-05-01';
select * from cases where created_at >= '2013-05-01' and created_at < '2013-05-02';
@enddate   date = '5/1/2013' select * from   cases where  datediff(day, created_at, @startdate) <= 0 and datediff(day, created_at, @enddate) >= 0;
select * from cases where date(created_at)='2013-05-01';
update table set field = null where something = something;
update users set password = null where id = 4;
update mytable set myfield = null where myfield = '';
update user set something_optional = null;
if (($_post['nullfield'] == 'null') || ($_post['nullfield'] == '')) {;
values ('$quantity','$itemname')");
values ('".$quantity."','$itemname')");
select * from table order by [some_column];
select col1, col2, ... from ... where ...;
select col1, col2, ...;
select postid from from dbforumentry;
select @start = 10,@end = 20;
from dbforumentry ) select postid, lastdate from postcte where rownumber > @start and rownumber <= @end;
select top 5 * from customers where country='germany' and customerid not in (select top 3 customerid from customers where country='germany' order by city);
select top 20 * from ( select *, row_number() over (order by columnid) as row_num from tablename where row_num>10;
( xcs_id integer );
select * from fb as a where a.dte <= @gapperiod;                               --only older records.;
select count(1) from fb where dte between cast(year(getdate()) as varchar(4)) + '-' + cast(month(dateadd(month, -1, getdate())) as varchar(2)) + '-20 00:00:00' and cast(year(getdate()) as varchar(4)) + '-' + cast(month(getdate()) as varchar(2)) + '-20 00:00:00';
select * from mytable where mydate < dateadd(month, -2, getdate());
select * from fb where dte <  dateadd(month, -2, getdate());
select * from fb where dte >= date(now() - interval 2 month);
select count(1) from fb where dte > date_sub(now(), interval 2 month);
select distinct col_name from mytable where col_name collate sql_latin1_general_cp1_ci_as like '%priceorder%';
select distinct col_name from mytable where upper(col_name) like upper('%priceorder%');
select distinct col_name from mytable where lower(col_name) like lower('%priceorder%');
select distinct col_name from mytable where col_name ilike '%priceorder%';
if  exists (select * from sys.check_constraints where object_id = object_id(n'[dbo].[check_rm_apertureidisvalid_t_zo_rem_ap_raum_reinigung]') and parent_object_id = object_id(n'[dbo].[t_zo_rem_ap_raum_reinigung]')) alter table dbo.t_zo_rem_ap_raum_reinigung drop constraint [check_rm_apertureidisvalid_t_zo_rem_ap_raum_reinigung] if  exists (select * from sys.objects where object_id = object_id(n'[dbo].[fu_constaint_validrmapertureid]') and type in (n'fn', n'if', n'tf', n'fs', n'ft')) drop function [dbo].[fu_constaint_validrmapertureid] create function [dbo].[fu_constaint_validrmapertureid]( @in_rm_apertureid uniqueidentifier ) as begin set @bnocheckforthiscustomer = 'false' set @bisinvalidvalue = 'false' if @in_status = 99 if @in_datumvon > @in_datumbis end  if @bnocheckforthiscustomer = 'true' if not exists ( select t_raum.rm_uid from t_raum where (1=1) and t_raum.rm_apertureid = @in_rm_apertureid and @in_datumvon >= t_raum.rm_datumvon and @in_datumbis <= t_raum.rm_datumbis and t_raum.rm_status <> 99 ) set @bisinvalidvalue = 'true' -- if ! end  if  exists (select * from sys.check_constraints where object_id = object_id(n'[dbo].[check_rm_apertureidisvalid_t_zo_rem_ap_raum_reinigung]') and parent_object_id = object_id(n'[dbo].[t_zo_rem_ap_raum_reinigung]')) alter table dbo.t_zo_rem_ap_raum_reinigung drop constraint [check_rm_apertureidisvalid_t_zo_rem_ap_raum_reinigung] alter table dbo.t_zo_rem_ap_raum_reinigung with nocheck add constraint [check_rm_apertureidisvalid_t_zo_rem_ap_raum_reinigung] check ( not ( dbo.fu_constaint_validrmapertureid(zo_rmrem_rm_uid, zo_rmrem_gueltigvon, zo_rmrem_gueltigbis, zo_rmrem_status) = 1 ) ) if  exists (select * from sys.check_constraints where object_id = object_id(n'[dbo].[check_rm_apertureidisvalid_t_zo_rem_ap_raum_reinigung]') and parent_object_id = object_id(n'[dbo].[t_zo_rem_ap_raum_reinigung]')) alter table dbo.t_zo_rem_ap_raum_reinigung check constraint [check_rm_apertureidisvalid_t_zo_rem_ap_raum_reinigung];
select * from information_schema.columns where table_name = 'abc';
select checksum_agg(binary_checksum(*)) from sample_table with (nolock);
select checksum_agg(binary_checksum(*)) from ( select 1 as numa, 1 as numb union all select 1 as numa, 1 as numb ( select 1 as numa, 2 as numb union all select 1 as numa, 2 as numb ( select 0 as numa, 0 as numb union all select 0 as numa, 0 as numb;
select value from configurationtable where applicationgroup = 'myappgroup' and keydescription = 'mykey';
2, 2, pi, , 3.14159, , 3, 4, fiscyearend, , , , 1/31/2015;
alter table table_name add column_name column-definition;
alter table employees add employeeid int not null identity (1, 1);
alter table table_name add (column_1 column-definition, column_2 column-definition, ...;
alter table table_name alter column column_name column_type;
alter table [tablename] add columnname datatype;
alter table [emp] add sr_no int;
alter table [emp] add sr_no int identity(1,1) not null;
alter table employees add employeeid numeric not null identity (1, 1) alter table employees add constraint ( employeeid allow_row_locks = on, allow_page_locks = on) on [primary];
select reverse(substring(reverse(@a), 2, 9999));
select stuff(x,len(x),1,'');
select left(txt, abs(len(txt + ',') - 2)) from t;
update tablename set columnname = left(columnname , len(columnname )-n) where clause;
set @string = '12354851' select left(@string, nullif(len(@string)-1,-1));
select left(@string, len(@string)-1) as tada;
create function [dbo].[truncright] (@string nvarchar(max), @len int = 1) as begin if len(@string)<@len end;
select @x='sam' select case when @x is null then @y else @x+','+@y end  select @x='sam' select @liststr = coalesce(@x + ', ' ,'') +coalesce(@y+',','') select left(@liststr,len(@liststr)-1);
set @string = 'asdfsdf1' set @string = case @string when null then null else (case len(@string) when 0 then @string else left(@string, len(@string) - 1) end ) end select @string;
select left('test string', len('test string')-1);
set @string = 'test string' select left(@string, len(@string) - 1) as mytrimmedcolumn;
set @string = '' select left(@string, len(@string) - 1);
select left(@string, nullif(len(@string)-1,-1));
select substring(@string, 1, nullif(datalength(@string)-1,-1));
select -- return comma delimited list of all payment reasons for this visit select distinct cast(convert(varchar, r1.codeid) + ' - ' + c.name + ', ' as varchar(max)) from visitreason r1 where p.id = r1.paymentid from payments p;
select replace(rtrim('a  b  c  d  '),'  ', ', ');
select reverse(stuff(reverse('a,b,c,d,'), 1, 1, ''));
set @string = 'test string' set @string = case @string when null then null else ( case len(@string) when 0 then @string else left(@string, len(@string) - 1) end ) end select @string;
select substring('test string', 1, (len('test string') - 1));
select adu.itemid, adu.startdate, internalcostprice from aduiteminternalcostprice adu  from aduiteminternalcostprice and startdate= max_date;
select last (column_name) as last_customer from table_name;
select * from yourtable where rowid =  @@identity;
select @x = max(id) from table_name;
select * from where id = @x;
select * from foo where id = (select max(id) from foo);
select * from tablename where id=(select max(id) from tablename);
select * from table;
select * from (select emp.*,rownum from emp order by rownum desc) where rownum=1;
select top 1 * from table order by id desc;
select * from table order by id desc limit 1;
select * from table order by id desc limit 1;
select * from table order by id desc limit 1;
select top 1 * from table order by id desc;
select top 1 * from table;
select * from table limit 1;
select max(id) from table;
select * from notes order by upper(title);
select * from notes order by lower(title);
select * from notes order by lower(title), title;
select * from table where field1 not like '%$x%';
select a from x where x.b not in (select b from y);
select a from x where x.b not in (1, 2, 3, 6);
select * from x where x.a not like '%text%';
select * from x where x.a not like 'text%';
101), try_convert(datetime, <datestring>, 102), try_convert(datetime, <datestring>, 103)));
values (convert(datetime,'18-06-12 10:34:09 pm',5));
select @maxlangid = max(langid) from sys.syslanguages set @langid = 0 select @alias = alias from sys.syslanguages where langid = @langid if @alias is not null set @sql = n'declare @testlang table (langdate datetime) set language ''' + @alias + n''';
values (''2012-06-18t10:34:09'')' exec sp_executesql @sql end try end catch end  select @langid = min(langid) from sys.syslanguages where langid > @langid end;
select * from table1 where somedate between '2000/01/01' and '2099/12/31';
values (foodate.tostring("mm/dd/yyyy"));
update .... where id = {here is your unique row id};
database = this.getreadabledatabase();
else //updation failed;
create function dbo.splitstrings ( @list       nvarchar(max), @delimiter  nvarchar(255) ) as return ( select item = y.i.value('(./text())[1]', 'nvarchar(4000)') from ( select x = convert(xml, '<i>';
select @split as split;
from @t t union all select t.iden, t.col1                                                                                                                              , charindex(@split, t.col1, t.pos + 1), cnt + 1 from cte t where charindex(@split, t.col1, t.pos + 1) > 0 ) select t1.*, t2.pos, t2.cnt from cte t1 join cte t2 and t2.cnt  = t1.cnt+1 and t2.pos > t1.pos;
b as (select substring(@s, i+1, iif(j>0, j, len(@s)+1)-i-1) s from a where i >= 0) select * from b;
b as (select n, substring(@s, i+1, iif(j>0, j, len(@s)+1)-i-1) s from a where i >= 0) select * from b;
select somestring as [*] for xml path('');
( select * from @dummy ) select casted.id from casted;
if exists (select * from sys.objects where type = 'tf' and name = 'tf_splitstring') drop function [dbo].[tf_splitstring] create function dbo.tf_splitstring @delimeter char = ',' ) as begin select @pos  = charindex(@delimeter, @stringtosplit) if @pos = 0 select @pos = len(@stringtosplit) select @name = substring(@stringtosplit, 1, @pos) end else begin select @name = substring(@stringtosplit, 1, @pos-1) end  select @name select @stringtosplit = substring(@stringtosplit, @pos+1, len(@stringtosplit)-@pos) end  end;
create function dbo.splitstring ( @stringtosplit nvarchar(max), @delim nvarchar(max)) as begin select @pos  = charindex(@delim, @stringtosplit) select @value = substring(@stringtosplit, 1, @pos - 1) select @value select @stringtosplit = substring(@stringtosplit, @pos + len(@delim), len(@stringtosplit) - @pos) end  select @stringtosplit end go;
select * from dbo.splitstring('test1 test2 test3', ' ');
select a.value('.', 'varchar(max)') from (select cast('<m>' + replace(@v, ',', '</m><m>') + '</m>' as xml) as col) as a;
create function dbo.splitstring ( @stringtosplit varchar(max) ) as begin select @pos  = charindex(',', @stringtosplit) select @name = substring(@stringtosplit, 1, @pos-1) select @name select @stringtosplit = substring(@stringtosplit, @pos+1, len(@stringtosplit)-@pos) end  select @stringtosplit end;
select * from dbo.splitstring('91,12,65,78,56,789');
alter function [dbo].func_split_string ( @input as varchar(max), @delimiter as varchar(10) = ";" ) ( id smallint identity(1,1), csv_value varchar(max) not null ) as begin select @pos = charindex(@delimiter,@input);
select @pos = len(@input) select @string = substring(@input, 1, @pos-1);
else select @string = substring(@input, 1, @pos);
select @input = substring(@input, @pos+len(@delimiter), len(@input)-@pos) end return end;
create function [dbo].[splitstring] as begin select @pos = charindex(@delim, @string) select @str = substring(@string, @prv, @pos - @prv) select @prv = @pos + len(@delim) end  end;
select ltrim( rtrim( substring( @stringtosplit, 1, charindex( @splitchar, @stringtosplit ) - 1 ) ) ) head union all  select ltrim( rtrim( substring( tail, 1, charindex( @splitchar, tail ) - 1 ) ) ) head from stringtosplit where charindex( @splitchar, tail ) > 0 union all  select ltrim( rtrim( tail ) ) head from stringtosplit where charindex( @splitchar, tail ) = 0 and len( tail ) > 0 ) select head from stringtosplit;
create function dbo.splitstring ( @stringtosplit varchar(max) ) as begin select @pos  = charindex(',', @stringtosplit) if @pos = 0 select @pos = len(@stringtosplit) select @name = substring(@stringtosplit, 1, @pos-1) select @name select @stringtosplit = substring(@stringtosplit, @pos+1, len(@stringtosplit)-@pos) end  end;
select * from string_split ('a,b', ',') cs;
create function [dbo].[fn_splitstring] (  @vdelimeter varchar (100) = @delimeter;
if @vdelimeter = ';' set @vcsv = replace(@vcsv, ';', '~!~#~');
set @vdelimeter = replace(@vdelimeter, ';', '~!~#~');
set @vcsv = replace(replace(replace(replace(replace(@vcsv, '&', '&amp;'), '<', '&lt;'), '>', '&gt;'), '''', '&apos;'), '"', '&quot;');
set @xml = '<i>' + replace(@vcsv, @vdelimeter, '</i><i>') + '</i>';
select x.i.value('.', 'varchar(max)') as columnname from @xml.nodes('//i')as x(i);
create function dbo.splitstring ( --create or alter as begin set @stringtosplit = @stringtosplit + ','             -- this should allow entries that end with a `,` to have a blank value in that "column" set @pos = coalesce(nullif(charindex(',', @stringtosplit),0),len(@stringtosplit+'_')) -- coalesce grabs first non-null value set @name = substring(@stringtosplit, 1, @pos-1)  --max size of string of type nvarchar is 4000 set @stringtosplit = substring(@stringtosplit, @pos+1, 4000) -- with substring fn (ms web): "if start is greater than the number of characters in the value expression, a zero-length expression is returned." end return end go;
select *,len(item+'_')-1 'l' from splitstring('a,,b');
select *,len(item+'_')-1 'l' from splitstring('a,,');
select *,len(item+'_')-1 'l' from splitstring('a,, ');
select *,len(item+'_')-1 'l' from splitstring('a,, c ');
create function splitstring ( @input nvarchar(max), @character char(1) ) item nvarchar(1000) ) as begin set @startindex = 1 if substring(@input, len(@input) - 1, len(@input)) <> @character set @input = @input + @character end  set @endindex = charindex(@character, @input) select substring(@input, @startindex, @endindex - 1) set @input = substring(@input, @endindex + 1, len(@input)) end  end go;
create function dbo.splitstring ( @list     nvarchar(max), @delim    nvarchar(255) ) as return ( select [value] from ( select [value] = ltrim(rtrim(substring(@list, [number], charindex(@delim, @list + @delim, [number]) - [number]))) from (select number = row_number() over (order by name) from sys.all_columns) as x where number <= len(@list) and substring(@delim + @list, [number], datalength(@delim)/2) = @delim;
create function dbo.splitstring ( @list     nvarchar(max), @delim    nvarchar(255) ) as return ( with n(n) as (select 1 union all select n+1 from n where n <= len(@list)) select [value] = substring(@list, n, charindex(@delim, @list + @delim, n) - n) from n where n <= len(@list) and substring(@delim + @list, n, datalength(@delim)/2) = @delim;
set @ids = ',99,206,124,8967,1,7,3,45234,2,889,987979,';
select me.value from dbo.myenum me;
create function dbo.getintidtablefromdelimitedstring ( @ids varchar(1000)  --this parameter must start and end with a comma, eg ',123,456,' ) select cast(substring(@ids,nums.number + 1,charindex(',',@ids,(nums.number+2)) - nums.number - 1) as int) as id from [master].[dbo].[spt_values] nums where nums.type = 'p' and    nums.number between 1 and datalength(@ids) and    substring(@ids,nums.number,1) = ',' and    charindex(',',@ids,(nums.number+1)) > nums.number;
alter function dbo.splitstring ( @stringtosplit varchar(1000), @splitpattern varchar(10) ) as begin select @pos  = patindex(@splitpattern, @stringtosplit) select @name = substring(@stringtosplit, 1, @pos-1) select @name select @stringtosplit = substring(@stringtosplit, @pos+1, len(@stringtosplit)-@pos) end  select @stringtosplit end select * from dbo.splitstring('stringa/stringb/x,y,z','%[/,]%');
update #emails set zipcode = substring(zipcode, 1, (charindex('-', zipcode)-1)) where zipcode like '%-%';
alter function [dbo].[cust_splitstring] ( @string nvarchar(4000), @delimiter nchar(1) ) as return ( with split(stpos,endpos) select 0 as stpos, charindex(@delimiter,@string) as endpos union all select endpos+1, charindex(@delimiter,@string,endpos+1) from split where endpos > 0 ) select 'id' = row_number() over (order by (select 1)), 'data' = substring(@string,stpos,coalesce(nullif(endpos,0),len(@string)+1)-stpos) from split );
create function uft_doublesplitter ( -- add the parameters for the function here @splitter1 char, @splitter2 char ) as begin svalue varchar(4000)) mid int, svalue varchar(4000)) set @string = @string+@splitter1 set @workingstring = substring(@string, 1, charindex(@splitter1, @string) - 1) select case else @workingstring end  set @string = substring(@string, len(@workingstring) + 2, len(@string)) end if isnull(@splitter2, '') != '' select @ostartloop = min(id), @oendloop = max(id) from @fresult select @istring = svalue+@splitter2, @imid = id from @fresult where id = @ostartloop set @iworkingstring = substring(@istring, 1, charindex(@splitter2, @istring) - 1) select @imid, case when @iworkingstring = '' then null else @iworkingstring end  set @istring = substring(@istring, len(@iworkingstring) + 2, len(@istring)) end  set @ostartloop = @ostartloop + 1 end insert into @result select mid as primarysplitid, row_number() over (partition by mid order by mid, id) as secondarysplitid , svalue from @sresult end else begin select id as primarysplitid, null as secondarysplitid, svalue from @fresult end return;
select * from uft_doublesplitter('valuea=valueb=valuec=valued==valuee&valuea=valueb=valuec===valuee&valuea=valueb==valued===','&',null) select * from uft_doublesplitter('valuea=valueb=valuec=valued==valuee&valuea=valueb=valuec===valuee&valuea=valueb==valued===','&','=');
select fn.svalue from uft_doublesplitter('valuea=valueb=valuec=valued==valuee&valuea=valueb=valuec===valuee&valuea=valueb==valued===', '&', '=')as fn where fn.mid = 2;
select ltrim(rtrim(split.a.value('.', 'varchar(100)'))) 'value' from ( select cast ('<m>' + replace(@string, @delimiter, '</m><m>') + '</m>' as xml) as data;
select id,ltrim(rtrim(split.a.value('.', 'varchar(100)'))) 'value' from ( select id,cast ('<m>' + replace(value, @delimiter, '</m><m>') + '</m>' as xml) as data from tablename;
set @stringtoseperate = '1,2,5' drop table #ids create table #ids (id int) select @position  = charindex(',', @stringtoseperate) select @commaseperatedvalue = substring(@stringtoseperate, 1, @position-1) select @commaseperatedvalue select @stringtoseperate = substring(@stringtoseperate, @position+1, len(@stringtoseperate)-@position) end  if (len(ltrim(rtrim(@stringtoseperate)))>0) select substring(@stringtoseperate, 1, @position) end  select * from #ids;
create function dbo.splitstring ( @stringtosplit varchar(max) ) set @ordernum=0 select @ordernum=@ordernum+1;
select @pos  = charindex('.', @stringtosplit) select @name = substring(@stringtosplit, 1, @pos-1) select @ordernum,@name select @stringtosplit = substring(@stringtosplit, @pos+1, len(@stringtosplit)-@pos) end select @ordernum=@ordernum+1;
select @ordernum, @stringtosplit end ;
select name from dbo.splitstring('elis.yd.crp1.1.cba.mdsp.t389.bt') where numorder=5;
update obj_disposition set code = concat('cd_', @a:=@a+1);
where user_id = :user_id');
'user_id' => $userid;
update member_profile set points = points + 1 where user_id = '".$userid."';
select ' 05.05 '+'.95';
update dbo.test set foo=concat(foo, 'bar') where 1=1;
select distinct so.name from syscomments sc where sc.text like '%your table name%';
select distinct so.name from syscomments sc where sc.text like '%tablename%';
select distinct o.name, o.xtype from syscomments c where c.text like '%tablename%';
select distinct object_name(object_id), object_definition(object_id) from sys.procedures where object_definition(object_id) like '%' + 'table_name' + '%';
select distinct o.name as object_name,o.type_desc from sys.sql_modules m where m.definition like '%table_name%';
exec sp_depends @objname = n'tablename';
select distinct so.name from sysobjects so, syscomments sc where so.id = sc.id and lower(text) like '%organizationtypeid%';
select so.name, text from sysobjects so, syscomments sc where so.id = sc.id and upper(text) like '%<table name>%';
exec sp_depends @objname = n'tablename';
select o.name from sys.sql_modules sm where sm.definition like '%<table name>%';
select name from sys.procedures where object_definition(object_id) like '%tablenameorwhatever%';
select distinct [table name] = o.name, [found in] = sp.name, sp.type_desc from sys.objects o inner join sys.sql_expression_dependencies  sd on o.object_id = sd.referenced_id and sp.type in ('p', 'fn') where o.name = 'yourtablename';
set quoted_identifier;
select * from schema_name.order;
select * from "order";
if (columns.length > 0) {;
create table t1( [id] [int] identity not null, [filler] [char](8000) null, primary key clustered ([id] asc));
select top 10 * from t1;
create table t2( [id] [int] identity not null, [filler] [char](8000) null, primary key clustered ([id] desc)) select object_name(object_id) as name, page_count, avg_fragmentation_in_percent, fragment_count, avg_fragment_size_in_pages from sys.dm_db_index_physical_stats(db_id(), object_id('t1'), 1, null, 'detailed') where  index_level = 0 union all select object_name(object_id) as name, page_count, avg_fragmentation_in_percent, fragment_count, avg_fragment_size_in_pages from sys.dm_db_index_physical_stats(db_id(), object_id('t2'), 1, null, 'detailed') where  index_level = 0;
select page_id, [id], geometry::point(page_id, [id], 0).stbuffer(4) from   t1 union all select page_id, [id], geometry::point(page_id, [id], 0).stbuffer(4) from   t2;
create index ix_index on mytable (col1, col2 desc);
select  * from    mytable col1, col2 desc;
select  * from    mytable col1 desc, col2;
select  * from    mytable col1, col2;
create table mytable ( pk int not null primary key, col1 int not null ) create index ix_mytable_col1 on mytable (col1);
select  col1, pk from    mytable col1, pk;
create index ix_mytable_col1_desc on mytable (col1 desc);
select  col1, pk from    mytable col1, pk desc;
select * from tbtest where email = sakira@gmail.com;
select * from tbtest where email = 'sakira@gmail.com';
create view reserved_passangers as select dbo.passenger.passname, dbo.passenger.address1, dbo.passenger.phone from dbo.passenger, dbo.reservation, dbo.flight where (dbo.passenger.passnum = dbo.reservation.passnum) and;
create view reserved_passangers as select dbo.passenger.passname, dbo.passenger.address1, dbo.passenger.phone from dbo.passenger, dbo.reservation where (dbo.passenger.passnum = dbo.reservation.passnum) and;
from dbo.category c left outer join;
from dbo.category c left outer join;
select * from schema.customerorders co where schema.co.id = 1  -- oops!;
update [page] set p.pagestatusid = 1 from [page] p join seed s on s.seedid = p.seedid where s.providercode = 'agd' and p.pagestatusid = 0;
update [page] set pagestatusid = 1 from [page] p join seed s on s.seedid = p.seedid where s.providercode = 'agd' and p.pagestatusid = 0;
update table1 set somefield = t2.somefieldvalue from table1 t1;
where t1.id = t2.id;
where table1.id = table2.id;
select id from (values (1),(2),(3),(4),(5)) as tbl(id) select * from mytable where thecolumn in (select id from @mylist);
set @mylist = ',1,2,3,4,' select * from mytable where @mylist like '%,' + cast(mycolumn as varchar(15)) + ',%';
select * from mytable where mycolumn in(select id from @mylist);
set @statuslist='1,2,3,4';
select value from dbo.sys_splittointegers_fn(@statuslist, ',');
select value from @status;
select * from mytable where mycolumn in (select value from @mylist);
select value from string_split(@inlist, ';') ) select * from [table] where [item] in (select tag from inlist);
set @mylist = '1,2,3,4' select * from mytable where mycolumn in (select value from string_split(@mylist,','));
select * from dbo.test as t where exists (select * from openjson(@filter) as tt where tt.[value] = t.id);
select * from [mytable] where -- when the id is at the leftmost position or -- when the id is at the rightmost position or -- when the id is between two delimiters or -- when the id is equal to the list;
select * from mytable where mycolumn in (select id from myidtable where id > 10);
select @list = '1,2,3' select @sql = 'select * from mytable where mycolumn in (' + @list + ')' exec sp_executesql @sql;
select 1 union all select 2 union all select 3 union all select 4 select * from mytable join @list l on mytable.mycolumn = l.id select * from mytable where mycolumn in (select id from @list);
select * from mytable where mycolumn in (select value from @mylist);
create function [dbo].[list_to_table] (@list varchar(4000)) if charindex(',',@list) = 0 or charindex(',',@list) is null end  set @c_pos = 0;
set @n_pos = charindex(',',@list,@c_pos);
set @c_pos = @n_pos;
set @l_pos = @n_pos;
set @n_pos = charindex(',',@list,@c_pos+1);
select * from table_1 where id in ('a','b','c');
select * from table_1 a inner join [dbo].[list_to_table] ('a,b,c') b on (a.id = b.item);
select object_name(f.parent_object_id) tablename, col_name(fc.parent_object_id,fc.parent_column_id) colname from sys.foreign_keys as f sys.foreign_key_columns as fc sys.tables t where object_name (f.referenced_object_id) = 'yourtablename';
select object_name(parent_object_id) parenttablename, object_name(referenced_object_id) reftablename, name from sys.foreign_keys where parent_object_id = object_id('tablename');
exec sp_helpconstraint 'table name';
select * from information_schema.key_column_usage where table_name='table name';
create procedure spshowrelationships ( @table varchar(250) = null, @relatedtable varchar(250) = null ) as begin if @table is null and @relatedtable is null select  object_name(k.constraint_object_id) foreginkeyname, object_name(k.parent_object_id) tablename, object_name(k.referenced_object_id) relatedtable, c.name relatedcolumnname, object_name(rc.object_id) + '.' + rc.name relatedkeyfield from sys.foreign_key_columns k if @table is not null and @relatedtable is null select  object_name(k.constraint_object_id) foreginkeyname, object_name(k.parent_object_id) tablename, object_name(k.referenced_object_id) relatedtable, c.name relatedcolumnname, object_name(rc.object_id) + '.' + rc.name relatedkeyfield from sys.foreign_key_columns k where object_name(k.parent_object_id) =@table if @table is null and @relatedtable is not null select  object_name(k.constraint_object_id) foreginkeyname, object_name(k.parent_object_id) tablename, object_name(k.referenced_object_id) relatedtable, c.name relatedcolumnname, object_name(rc.object_id) + '.' + rc.name relatedkeyfield from sys.foreign_key_columns k where object_name(k.referenced_object_id) =@relatedtable end;
exec sp_fkeys 'tablename';
select object_name(sfc.constraint_object_id) as constraint_name, object_name(parent_object_id) as table_name , ac1.name as table_column_name, object_name(referenced_object_id) as reference_table_name, ac2.name as reference_column_name from  sys.foreign_key_columns sfc join sys.all_columns ac1 on (ac1.object_id=sfc.parent_object_id and ac1.column_id=sfc.parent_column_id) join sys.all_columns ac2 on (ac2.object_id=sfc.referenced_object_id and ac2.column_id=sfc.referenced_column_id) where sfc.parent_object_id=object_id(<main table name>);
select ccu.table_name as sourcetable from information_schema.constraint_column_usage ccu;
select k_table = fk.table_name, fk_column = cu.column_name, pk_table = pk.table_name, pk_column = pt.column_name, constraint_name = c.constraint_name from information_schema.referential_constraints c select i1.table_name, i2.column_name from information_schema.table_constraints i1 where i1.constraint_type = 'primary key' 1,2,3,4 where pk.table_name='yourtable';
select object_name(f.parent_object_id) constable, object_name (f.referenced_object_id) reftable, col_name(fc.parent_object_id,fc.parent_column_id) colname from sys.foreign_keys as f sys.foreign_key_columns as fc sys.tables t constable;
select obj.name      as fk_name, sch.name      as [schema_name], tab1.name     as [table], col1.name     as [column], tab2.name     as [referenced_table], col2.name     as [referenced_column] from sys.foreign_key_columns fkc and col2.object_id =  tab2.object_id;
select constraint_name from information_schema.key_column_usage where constraint_name like 'pk%' and select constraint_name from information_schema.key_column_usage where constraint_name like 'fk%' and;
func<tsource, tkey> keyselector, iequalitycomparer<tkey> comparer) if (knownkeys.add(keyselector(element)));
if object_id('tempdb..#t') is not null drop table #t;
create table #t(id int not null identity(1,1) primary key, name varchar(10)) select * from #t;
update #t set name = nullif(name,'') select * from #t;
select isnull(null,'');
update #t set name = isnull(null,'') where name is null select * from #t drop table #t;
select  ct.id, isnull(nullif(ct.launchdate, ''), null) [launchdate] from    [dbo].[customertable] ct;
select * from table where isnull(ltrim(rtrim(col)),'')='';
select * from table where isnull(ltrim(rtrim(col)),'')<>'';
case when ltrim(rtrim(isnull([address1], ''))) <> '' then [address2] else '' end;
select * from #t where somecol = '' or somecol is null;
select * from #t where somecol = '' union all select * from #t where  somecol is null;
select * from #t where exists ((select null union select '') intersect select somecol);
select * from #t where iif(somecol <> '',0,1) = 1;
select * from #t where nullif(somecol,'') is null;
select * from #t where isnull(somecol,'') = '';
select * from   tablename where  columnname is null or;
select * from   yourtable where  yourcolumn is null or yourcolumn = '';
select * from table where (col is null or col = '');
select * from table where isnull(col, '') = '';
select * from   table where  column like '' or column is null or len(column) = 0;
select * from mytable where isnull(my_nullable_text_field,'') = '';
alter function [dbo].[isnull](@input nvarchar(50),@ret int = 0) as begin end;
where coalesce(char_length(fieldvalue), 0) = 0;
if fieldvalue in (null,''):;
select * from dbo.agenda where --if @dt_start is null or empty or --else select * from dbo.agenda where ( ( isnull( @dt_start,'' ) = '' and dt_start is not null ) or ( dt_start >= @dt_start ) ) and dt_end < getdate();
select isnull(column,'') column, * from table where column = '';
select * from appinfra.person where   len(rtrim(ltrim(nationalcode))) = 0 or  nationalcode is null;
select column_name from information_schema.key_column_usage where constraint_name='primary' and table_name='tablename' and table_schema='databasename';
select column_name from {databasename}.information_schema.key_column_usage where table_name like '{tablename}' and constraint_name like 'pk%';
as ( select  constraint_name= cast (pknukey.name as varchar(30)) , constraint_type=cast (pknukey.type_desc as varchar(30)) , parent_table_name=cast (pknutable.name as varchar(30)) , parent_col_name=cast ( pknukeycol.name as varchar(30)) , parent_col_name_data_type=  oparentcoldtl.data_type, reference_table_name='' , reference_col_name='' from sys.key_constraints as pknukey and pknucolidx.index_id = pknukey.unique_index_id and pknukeycol.column_id = pknucolidx.column_id and oparentcoldtl.column_name=pknukeycol.name union all select  constraint_name= cast (oconstraint.name as varchar(30)) , constraint_type='fk', parent_table_name=cast (oparent.name as varchar(30)) , parent_col_name=cast ( oparentcol.name as varchar(30)) , parent_col_name_data_type= oparentcoldtl.data_type, reference_table_name=cast ( oreference.name as varchar(30)) , reference_col_name=cast (oreferencecol.name as varchar(30)) from sys.foreign_key_columns fkc and fkc.parent_column_id=oparentcol.column_id/* id of the column. is unique within the object.column ids might not be sequential.*/ and oparentcoldtl.column_name=oparentcol.name and fkc.referenced_column_id=oreferencecol.column_id/* id of the column. is unique within the object.column ids might not be sequential.*/ ) select * from   all_keys_in_table where parent_table_name  in ('your_table_name') or reference_table_name  in ('your_table_name');
select * from sys.objects where type = 'pk' and  object_id = object_id ('tablename');
select * from sys.objects where type = 'pk' and  parent_object_id = object_id ('tablename');
select  i.name as indexname, object_name(ic.object_id) as tablename, col_name(ic.object_id,ic.column_id) as columnname from    sys.indexes as i inner join and i.index_id = ic.index_id where   i.is_primary_key = 1;
select * from sysobjects where xtype='pk' and;
select distinct sys.tables.object_id as tableid, sys.columns.column_id as columnid, sys.columns.name as columnname, sys.types.name as typename, sys.columns.precision as numericprecision, sys.columns.scale as numericscale, sys.columns.is_nullable as isnullable, (   select from information_schema.constraint_column_usage where table_name = sys.tables.name and from information_schema.table_constraints where table_name = sys.tables.name and ) sys.columns.max_length / 2 as charmaxlength /*bug*/ from sys.columns, sys.types, sys.tables where sys.tables.object_id = sys.columns.object_id and isprimarykey;
select column_name from information_schema.key_column_usage where objectproperty(object_id(constraint_schema + '.' + quotename(constraint_name)), 'isprimarykey') = 1 and table_name = 'tablename' and table_schema = 'schema';
exec sp_primarykeys @table_server = n'server_name', @table_name = n'table_name', @table_catalog = n'db_name', @table_schema = n'schema_name'; --frequently 'dbo';
select ku.table_name as tablename from information_schema.table_constraints as tc and tc.constraint_name = ku.constraint_name and ku.table_name='yourtablename' ku.table_name;
drop and create;
if exists (select * from   sys.objects where  object_id = object_id(n'[dbo].[foo]') and type in ( n'fn', n'if', n'tf', n'fs', n'ft' )) drop function [dbo].[foo];
if exists ( select  1 from    information_schema.routines where   specific_schema = 'dbo' and specific_name = 'foo' and routine_type = 'function' );
if exists ( select  1 from    information_schema.routines where   specific_schema = 'dbo' and specific_name = 'foo' and routine_type = 'procedure' );
if object_id('yourfunctionname', 'fn') is not null drop function [dbo].[yourfunctionname] end go;
if objectproperty (object_id('schemaname.scalarfuncname'), 'isscalarfunction') = 1 if objectproperty (object_id('schemaname.tablefuncname'), 'istablefunction') = 1 if objectproperty (object_id('schemaname.procname'), 'isprocedure') = 1;
if not exists (select * from   sys.objects where  object_id = object_id(n'[dbo].[foo]') and type in ( n'fn', n'if', n'tf', n'fs', n'ft' )) alter function [dbo].[foo] as ...;
select tablea.*, tableb.*, tablec.*, tabled.* from tablea join tableb join tablec join tabled where date(tablec.date)=date(now());
select a.namea, /* tablea.namea */ from tablea a where date(c.`date`) = curdate();
create view room_view as select a.*,b.* from j4_booking a inner join j4_scheduling b;
select "movie", array_to_string(array_agg(distinct "actor"),',') as actor from table1;
select movie, string_agg(actor, ', ') as actor_list from   tbl;
select movie, string_agg(actor, ', ' <b>order by actor</b>) as actor_list from   tbl;
if ($errors[0] != '00000'):;
if ($this->stmt->errorcode() != pdo::err_none): if (count ($this->values) > 0):;
if (!empty($params)) { if (is_object($v)) { if ($v instanceof \datetime) $v = $v->format('y-m-d h:i:s');
if ($indexed) { else { if ($k[0] != ':') $k = ':'.$k; //add leading colon if it was left out;
if (!$options) { if (empty($params)) { if (!$replaced) { if ($v === null) { if (!is_numeric($v)) {;
values (:val1, :val2, :val3)";
':val1'=>$val1, ':val2'=>$val2, ':val3'=>$val3, ));
':val1'=>$val1, ':val2'=>$val2, ':val3'=>$val3, );
select * from   my_table where  match (my_text_column) against ('xyz' in boolean mode) ;
where foo like '%bar';
where x is null;
where my_column = null;
create table t (x int, y int);
select 'x = null' as test , x, y from t where x = null union all select 'x != null', x, y from t where x != null union all select 'not (x = null)', x, y from t where not (x = null) union all select 'x = y', x, y from t where x = y union all select 'not (x = y)', x, y from t where not (x = y);
where x is null;
select year(0), month(0), day(0);
select year(getdate()), month(getdate()), day(getdate());
select year(yourdatefield), month(yourdatefield), day(yourdatefield);
select convert(varchar(7), <date_field>, 120), count(*) from <some_table>;
select convert(varchar(7), getdate(), 126);
select to_char(datefield,'mon') from your_table;
select to_char(sysdate, 'mon') from dual;
select month(datefield), year(datefield);
select datepart(yy, dateval) select datepart(mm, dateval) select datename(mm, dateval);
select dateadd(month, datediff(month, 0, <datefield>), 0) as [year_month_date_field] from <your_table>;
select [year] = year(getdate());
select [month.year] = stuff(convert(varchar(10), getdate(),104),1,3,'');
select * from table where substr(datetime_column, starting_position, number_of_strings)=required_year_and_month;
select substr(created, 1,7) from table;
select convert(varchar(11), transfer_date, 106);
select format(<your-date-field>,"yyyy-mm") as year-date from <your-table>;
select cast(year(<datecolumn>) as varchar) + '-' + cast(month(<datecolumn>) as varchar);
set @lcyear=(select  datepart(year,@date)) set @lcmonth=(select  datepart(month,@date));
select datename(m,getdate())+'-'+cast(datepart(yyyy,getdate()) as varchar) as fieldname;
select replace(right(convert(varchar(11), getdate(), 106), 8), ' ', '-');
select format(dateadd(month, 0, getdate()), 'mmmm', 'pt-pt') + ' ' + convert(varchar(10),year(getdate()),100);
select format(dateadd(month, 0, getdate()), 'mmmm', 'en-us') + ' ' + convert(varchar(10),year(getdate()),100);
select datename(month, getdate()) + '-' +  cast(year(getdate()) as nvarchar) as 'month-year';
select left(datename(month, getdate()), 3) + '-' +  cast(right(year(getdate()),2) as nvarchar(2)) as 'month-year';
select concat(month(datefield), '.', year(datefield)) from yourtable;
select * from your_table order by lenth(your_column) asc, your_column asc;
select cast('123' as integer);
select stuff from table where conditions;
select field,convert(substring_index(field,'-',-1),unsigned integer) as num from table;
select *, cast(substring_index(field, '-', -1) as unsigned) as num from tablename order by num;
select * from `table_name` order by;
create table new_table as select * from old_table;
select * from old_table;
create table new_table as select * from old_table;
create table new_table as select * from old_table where 1 = 2;
create table new_table_name as select column_name,[more columns] from existed_table;
create table dept as select empno, ename from emp;
select user_id from user_logs where login_date >= '2014-02-01' and login_date <  '2014-03-01';
where datepart('year',  login_date) = 2014 and datepart('month', login_date) = 2;
where ( date_trunc('day',table1.date_eval) = '2015-02-09' );
select user_id from user_logs where login_date between symmetric '2014-02-01' and '2014-02-28';
select user_id from user_logs where '[2014-02-01, 2014-03-01]'::daterange @> login_date;
select user_id from user_logs where login_date between '2014-02-01' and '2014-03-01';
select case else 'unknown' end as type from table t;
select   productnumber, category = case productline else 'not for sale' name from production.product;
select   productnumber, name, "price range" = case when listprice =  0 then 'mfg item - not for resale' else 'over $1000' end from production.product;
select businessentityid, salariedflag from humanresources.employee select businessentityid, lastname, territoryname, countryregionname from sales.vsalesperson where territoryname is not null else countryregionname end;
update humanresources.employee set vacationhours = else (vacationhours + 20.00) end ) inserted.vacationhours as aftervalue where salariedflag = 0;
select jobtitle, max(ph1.rate)as maximumrate from humanresources.employee as e join humanresources.employeepayhistory as ph1 on e.businessentityid = ph1.businessentityid having (max(case when gender = 'm' then ph1.rate else null end) > 40.00 or max(case when gender  = 'f' then ph1.rate else null end) > 42.00);
select   productnumber, name, "price range" = case when listprice =  0 then 'mfg item - not for resale' else 'over $1000' end from production.product;
create table t1 (id int not null, someval char(1));
alter table t1 add constraint [pk_id] primary key clustered (id);
create table t2 (fkid int, someotherval char(2));
alter table t2 add constraint fk_t2_t1 foreign key (fkid) references t1 (id);   --fails alter table t2 with check add constraint fk_t2_t1 foreign key (fkid) references t1 (id);    --fails alter table t2 with nocheck add constraint fk_t2_t1 foreign key (fkid) references t1 (id);  --succeeds alter table t2 check constraint fk_t2_t1;   --succeeds since the constraint is attributed as nocheck alter table t2 with check check constraint fk_t2_t1;    --fails delete from t2 where fkid not in (select id from t1);
alter table t2 with check check constraint fk_t2_t1;    --succeeds; orphans removed drop table t2;
select * from sys.foreign_keys where is_not_trusted = 1 ;
select * from sys.check_constraints where is_not_trusted = 1 ;
alter table [production].[productcosthistory] check constraint -- this means "enable the check or foreign key constraint".;
( select 'untrusted foreign key' as fktype from sys.foreign_keys fk where is_ms_shipped = 0 and fk.is_not_trusted = 1 union all  select 'untrusted check' as ktype from sys.check_constraints cc where cc.is_ms_shipped = 0 and cc.is_not_trusted = 1 ) select u.constrainttype from untrusted u;
select lock_escalation_desc from sys.tables where name='yourtablename';
alter table <tablename> set (lock_escalation = ...);
alter table alter column;
alter table set lock_escalation;
set lock_escalation = table;
create table [dbo].[test]( [id] [int] not null, [col1] [nvarchar](50) not null, [col2] [int] not null, constraint [pk_test] primary key clustered ( [id] asc;
alter table dbo.test set (lock_escalation = disable);
set quoted_identifier on set arithabort on set numeric_roundabort off set concat_null_yields_null on set ansi_nulls on set ansi_padding on set ansi_warnings on create table dbo.tmp_test ( id int not null, col1 nvarchar(10) not null, col2 int not null alter table dbo.tmp_test set (lock_escalation = disable) if exists(select * from dbo.test) select id, convert(nvarchar(10), col1), col2 from dbo.test with (holdlock tablockx)') drop table dbo.test alter table dbo.test add constraint ( id;
set lock_escalation;
set quoted_identifier on set arithabort on set numeric_roundabort off set concat_null_yields_null on set ansi_nulls on set ansi_padding on set ansi_warnings on alter table dbo.test add alter table dbo.test set (lock_escalation = disable);
alter table set lock_escalation;
alter table ... add;
alter table set lock_escalation;
select 'foo' like any('{foo,bar,%oo%}');
select * from tbl where id = any (array[1, 2]);
select * from tbl where id <> all (array[1, 2]);
select * from tbl where id <> all ('{1, 2}');  -- equivalent array literal select * from tbl where not (id = any ('{1, 2}'));
select * from tbl where (id = any ('{1, 2}')) is not true;
select * from table where column in(subquery);
select * from table where column = any(subquery);
select * from table where column in( ,  , );
create index tablename_timestampfield_date_idx on  tablename(date(timestampfield));
from c in customers select new name = date.key.tostring().substring(0, 10);
select sum(amount) as total, dateadd(day,0, datediff(day,0, created)) as created from sales;
select date(created) as saledate, sum(amount) from sales saledate;
select cast(created as date) as saledate, sum(amount) from sales cast(created as date);
datepart(month,datefield), datepart(day,datefield);
select sum(amount) from sales convert(varchar,created,101);
alter table dbo.sales add saleyear as year(created) persisted alter table dbo.sales add salemonth as month(created) persisted alter table dbo.sales add saleday as day(created) persisted;
select saleday, sum(amount) from dbo.sales;
create schema [schema_name] create table [schema_name].[table_name]( ...;
create table [schemaname].[tablename]; go;
create schema [schemaname];
alter user [yourusername] with default_schema = [yourschema];
if ( proc.exitcode!= 0 );
if (p.exitcode != 0);
if (!string.isnullorwhitespace(commandstring.trim()));
sqlscript, @"^\s*go\s*$", regexoptions.multiline | regexoptions.ignorecase);
if (command.trim() != string.empty);
regexoptions.multiline | regexoptions.ignorecase);
if (commandstring.trim() != "");
if (!checkdatabaseexist()) if (file.exists(application.startuppath + "\\script.sql"));
if (commandstring.trim() != "");
from employeetree;
set @startdate = '01/01/2009';
set @entdt = '12/31/2009';
( select @startdate datevalue union all select datevalue + 1 from    datelist where   datevalue + 1 < convert(varchar(15),@entdt,101) ) select count(*) as daycnt from ( select datevalue,datename(weekday, datevalue ) as weekday from datelist where datename(weekday, datevalue ) not in ( 'saturday','sunday' );
create function actionstate_preassigned() as begin end  create function actionstate_unassigned() as begin end ;
create procedure s_emp ( @enonumber int ) as select * from emp where emp_id=@enonumber;
create function u_emp ( @enonumber int ) as return ( select * from emp where emp_id=@enonumber );
create function v_emp (@pinteno int) as return select * from emp where emp_id=@pinteno;
select * from v_emp(10);
create procedure [dbo].[sp_report_loginsuccess] -- [sp_report_loginsuccess] '01/01/2010','01/30/2010' @todate datetime, @rolename varchar(50), @success int as if @rolename != 'all' if @success!=2 select * from vw_report_loginsuccess where logindatetime between  dbo.datefloor(@fromdate) and dbo.datesieling(@todate) and rtrim(upper(rolename)) = rtrim(upper(@rolename)) and success=@success end else begin select * from vw_report_loginsuccess where logindatetime between  dbo.datefloor(@fromdate) and dbo.datesieling(@todate) and rtrim(upper(rolename)) = rtrim(upper(@rolename)) end  end else begin if @success!=2 select * from vw_report_loginsuccess where logindatetime between  dbo.datefloor(@fromdate) and dbo.datesieling(@todate) and success=@success end else begin select * from vw_report_loginsuccess where logindatetime between  dbo.datefloor(@fromdate) and dbo.datesieling(@todate) end  end;
create view [dbo].[vw_report_loginsuccess] as select     '3' as userdetailid, dbo.tblloginstatusdetail.success, convert(varchar, dbo.tblloginstatusdetail.logindatetime, 101) as logindatetime, convert(varchar, dbo.tblloginstatusdetail.logoutdatetime, 101) as logoutdatetime, dbo.tblloginstatusdetail.tokenid, dbo.tbluserdetail.subscriberid, dbo.aspnet_roles.roleid, dbo.aspnet_roles.rolename from         dbo.tblloginstatusdetail inner join where     (dbo.tblloginstatusdetail.success = 0) union all select     dbo.tblloginstatusdetail.userdetailid, dbo.tblloginstatusdetail.success, convert(varchar, dbo.tblloginstatusdetail.logindatetime, 101) as logindatetime, convert(varchar, dbo.tblloginstatusdetail.logoutdatetime, 101) as logoutdatetime, dbo.tblloginstatusdetail.tokenid, dbo.tbluserdetail.subscriberid, dbo.aspnet_roles.roleid, dbo.aspnet_roles.rolename from         dbo.tblloginstatusdetail inner join where     (dbo.tblloginstatusdetail.success = 1) and (dbo.tbluserdetail.subscriberid like n'p%');
create view v_emp as select * from emp ;
select * from v_emp where emp_id=&eno;
create view [dbo].[vwpharmacyproducts] as select     pharmacyid, productid from         dbo.stock where     (totalqty > 0) create procedure [dbo].[usp_getproductbyfilter] if @ppharmacyid = 0 begin set @ppharmacyid = null end select  p.[productid], p.[strdisplayas] from [product] p where (p.[bdeleted] = 0) and (p.[productid] in (select vpp.productid from vwpharmacyproducts vpp where vpp.pharmacyid = @ppharmacyid) or @ppharmacyid is null );
where  (exam_id = @var);
create view v_emp as select      * from        emp e;
create view vwimportant_users as select vartype='%admin%', varminstatus=1) select status, name from sys.sysusers, params where status > varminstatus or name like vartype select * from vwimportant_users;
select status, name from sys.sysusers inner join params on 1=1 where status > varminstatus or name like vartype;
select status, name from sys.sysusers cross apply params where status > varminstatus or name like vartype;
create view updated_customers as select * from customer as aa where aa.updated_at between (select start_date from config where active = 1) and (select end_date from config where active = 1);
create view my_view as select * from tab where num = session_context(n'my_num');
exec sp_set_session_context 'my_num', 1;
select * from my_view;
exec sp_set_session_context 'my_num', 2;
select * from my_view;
create view emp_v as ( select emp_name, emp_id from emp;
) select emp_v.emp_name from emp_v where emp_v.emp_id = (id to restrict by);
create or replace view v_emp(eno number) as select * from emp where (emp_id = @parameter1);
set @sql = n' create or alter view dbo.wtemplogs as select * from dbo.y2019 where year(logdate) = ''_year_'' and month(logdate) = ''_month_''    ' select @sql = replace(replace(@sql,'_year_',@year),'_month_',@month) set @errmsg = @sql;
select        e.employeeid, s.companyname, o.shipname from            employees as e inner join where        (s.companyname = 'federal shipping');
select        e.employeeid, s.companyname, o.shipname from            employees e inner join where        (s.companyname = 'federal shipping');
in a <table reference> tr is exposed by tr if and only if tr;
select t1.cola, t2.colb, t3.colc from alongtablename as t1, anotherlongtablename as t2, yetanotherlongtablename as t3 where t1.cold = t2.cole...;
select salary * 2 as "double salary" from employee;
select p.productname, p.productgroup, p.productretailprice from   products as p;
select p.productname, p.productretailprice, o.quantity from   products as p where  o.orderid = 123456;
select p.productname, p.productretailprice, o.quantity from   products p where  o.orderid = 123456;
select p.productname as "product", p.productretailprice as "retail price", o.quantity as "quantity ordered" from   products p where  o.orderid = 123456;
select p.productname, p.productretailprice, o.quantity from products as p where o.orderid = 123456;
select productname, productretailprice, quantity from products natural join orders where orderid = 123456;
update t1 set t1.a = 'something', t2.b = 42, t3.c = t2.c where t1.a = 'blah';
select t2.t1_id, t2.t3_id, t1.a, t2.b, t2.c as t2_c, t3.c as t3_c from t1 where t1.a = 'blah';
select books.bookid, orders.orderid, orders.quantity as currentquantity, orders.quantity + 2 as newquantity, books.instock as currentstock, books.instock - 2 as newstock from books where orders.orderid = 1002;
update books set orders.quantity = orders.quantity + 2, books.instock = books.instock - 2 where orders.orderid = 1002;
update books set books.author_id = 99999 where authors.id is null;
and books.author_id is not null;
update books, orders set orders.quantity = orders.quantity + 2, books.instock = books.instock - 2 where books.bookid = orders.bookid and orders.orderid = 1002;
update table1 set a=b where c;
update table2 set a=b where d;
update table3 set a=b where e;
update table1,table2 set table1.col=a,table2.col2=b where items.id=month.id;
update table1, table2 set doc_availability = 0, last_update = now() where table1._id = table2._id and table1._id = 14;
select convert(datetime, '2016-01-01') as [date] --start union all select dateadd(day, 1, [date]) from [dates] where [date] < '2018-01-01' --end ) select [date] where holidaytable.hdate = [date]) as feiertag from [dates] where [date] between '2016-01-01' and '2016-31-12';
select d.date from ( select date(julianday('2010-01-20') + (a.a + (10 * b.a) + (100 * c.a))) as date from (select 0 as a union all select 1 union all select 2 union all select 3 union all select 4 union all select 5 union all select 6 union all select 7 union all select 8 union all select 9) as a where d.date between '2010-01-20' and '2010-01-24';
from (select 0 a union select 1 a union select 2 union select 3 union select 4 union select 5 union select 6 union select 7 union select 8 union select 9 ) d, (select 0 b union select 10 union select 20 union select 30 union select 40) m where '2016-01-05' + interval a + b day  <=  '2016-01-21');
create procedure generaterangedates(in datestart date, in dateend date) create temporary table if not exists dates (day date);
set datestart = date_add(datestart, interval 1 day);
if datestart <= dateend then iterate loopdate;
else leave loopdate;
end loop loopdate;
select day from dates;
drop temporary table if exists dates;
end $$ now() - interval 40 day, now();
create table #dates ([date] smalldatetime) set @since = dateadd(day,1,@since) end select [date] from #dates;
select day::date from generate_series('2010-01-20', '2010-01-24', interval '1 day') day;
set language  'spanish' ( select   dateadd( m , 1 ,fechadesde ) as fecha  from @table union all select  dateadd( m , 1 ,fecha ) from @table t inner join x on  dateadd( m , 1 ,x.fecha ) <= t.fechahasta ) select left( convert( varchar, fecha , 112 ) , 6 ) as periodo_id from x;
select convert(datetime, '1753-01-01') as [date] --start union all select dateadd(day, 1, [date]) from [dates] where [date] < '9999-12-31' --end ) select [date] from [dates] where [date] between '2013-01-01' and '2013-12-31';
select trunc(sysdate-dayincrement, 'dd') from dual, (select level as dayincrement from dual connect by level <= 30);
select dateadd(d, n, '0001-01-22') from numbers -- a table containing the numbers 0 through n where n <= 5;
select abs(datediff(d, '2014-08-22', '2014-12-25'));
select n = row_number() over(order by (select null)) - 1;
select d = dateadd(d, n, @date1) from ( select n = row_number() over(order by (select null)) - 1 from (select 'a' as s union all select 'a' union all select 'a') s where n <= abs(datediff(d, @date1, @date2));
create function dbo.generaterangedate ( @date1 date, @date2 date ) as return ( select d = dateadd(d, n + 32768, case when @date1 <= @date2 then @date1 else @date2 end) from dbo.generaterangesmallint(-32768, abs(datediff(d, @date1, @date2)) - 32768) create function dbo.generaterangesmallint ( @num1 smallint = -32768 ) as return ( with numbers(n) as ( select n from(values ) select top(abs(cast(@num1 as int) - cast(@num2 as int)) + 1) from numbers a;
select datetable.date from ( select dateadd(day,-(a.a + (10 * b.a) + (100 * c.a)),getdate()) as date from (select 0 as a union all select 1 union all select 2 union all select 3 union all select 4 union all select 5 union all select 6 union all select 7 union all select 8 union all select 9) as a union all select 5 union all select 6 union all select 7 union all select 8 union all select 9) as b union all select 5 union all select 6 union all select 7 union all select 8 union all select 9) as c where datetable.date between '2014-01-20' and '2014-01-24';
select 0 as a from dual union all select 1 from dual union all select 2 from dual union all select 3 from dual union all select 4 from dual union all select 5 from dual union all select 6 from dual union all select 7 from dual union all select 8 from dual union all select 9 from dual;
select date() - (a.a + (10 * b.a) + (100 * c.a)) as mydate from (select * from zerothru9q) as a,  from zerothru9q) as b,  from zerothru9q) as c;
select date() + (a.a + (10 * b.a) + (100 * c.a)) as mydate from (select * from zerothru9q) as a,  from zerothru9q) as b,  from zerothru9q) as c;
select mydate from todayminus1kq union select mydate from todayplus1kq;
select mydate from todayplusminus1kq where mydate between #05/01/2014# and #05/30/2014#;
create definer=`root`@`localhost` procedure `days`(in datestart date, in dateend date) create temporary table if not exists date_range (day date);
set datestart = date_add(datestart, interval 1 day);
select * from date_range;
drop temporary table if exists date_range;
select date_value from (select a.espr1+(10*b.espr1)+(100*c.espr1) as integer_value, dateadd("d",integer_value,dateserial([start_year], [start_month], [start_day])) as date_value from (select * from ( select top 1 "0" as espr1 from msysobjects union all select top 1 "1" as espr2 from msysobjects union all select top 1 "2" as espr3 from msysobjects union all select top 1 "3" as espr4 from msysobjects union all select top 1 "4" as espr5 from msysobjects union all select top 1 "5" as espr6 from msysobjects union all select top 1 "6" as espr7 from msysobjects union all select top 1 "7" as espr8 from msysobjects union all select top 1 "8" as espr9 from msysobjects union all select top 1 "9" as espr9 from msysobjects ( select top 1 "0" as espr1 from msysobjects union all select top 1 "1" as espr2 from msysobjects union all select top 1 "2" as espr3 from msysobjects union all select top 1 "3" as espr4 from msysobjects union all select top 1 "4" as espr5 from msysobjects union all select top 1 "5" as espr6 from msysobjects union all select top 1 "6" as espr7 from msysobjects union all select top 1 "7" as espr8 from msysobjects union all select top 1 "8" as espr9 from msysobjects union all select top 1 "9" as espr9 from msysobjects ( select top 1 "0" as espr1 from msysobjects union all select top 1 "1" as espr2 from msysobjects union all select top 1 "2" as espr3 from msysobjects union all select top 1 "3" as espr4 from msysobjects union all select top 1 "4" as espr5 from msysobjects union all select top 1 "5" as espr6 from msysobjects union all select top 1 "6" as espr7 from msysobjects union all select top 1 "7" as espr8 from msysobjects union all select top 1 "8" as espr9 from msysobjects union all select top 1 "9" as espr9 from msysobjects where date_value between dateserial([start_year], [start_month], [start_day]) and dateserial([end_year], [end_month], [end_day]);
create table  `example`.`numbers` ( `id` int(10) unsigned not null auto_increment, primary key  (`id`);
select x.start_date + interval n.id-1 day from numbers n join (select str_to_date('2010-01-20', '%y-%m-%d') as start_date from dual) x where x.start_date + interval n.id-1 day <= '2010-01-24';
select str_to_date('2010-01-20', '%y-%m-%d') from dual union all select str_to_date('2010-01-21', '%y-%m-%d') from dual union all select str_to_date('2010-01-22', '%y-%m-%d') from dual union all select str_to_date('2010-01-23', '%y-%m-%d') from dual union all select str_to_date('2010-01-24', '%y-%m-%d') from dual;
select a.date from ( select curdate() - interval (a.a + (10 * b.a) + (100 * c.a) + (1000 * d.a) ) day as date from (select 0 as a union all select 1 union all select 2 union all select 3 union all select 4 union all select 5 union all select 6 union all select 7 union all select 8 union all select 9) as a where a.date between '2010-01-20' and '2010-01-24';
select from days.day, count(mytable.field) as fields from days left join mytable on day=date where date between x and y;
create view digits as select 0 as digit union all select 1 union all select 2 union all select 3 union all select 4 union all select 5 union all select 6 union all select 7 union all select 8 union all select 9;
create view numbers as select ones.digit + tens.digit * 10 + hundreds.digit * 100 + thousands.digit * 1000 as number from digits as ones, digits as tens, digits as hundreds, digits as thousands;
create view dates as select subdate(current_date(), number) as date from numbers;
select date from dates where date between '2010-01-20' and '2010-01-24' date;
create view dates as select subdate(current_date(), number) as date from numbers union all select adddate(current_date(), number + 1) as date from numbers;
datediff(dd,starttime, endtime) as diff from dbo.testdate union all select starttime, diff - 1 as diff from cte where diff<> 0) select distinct dateadd(dd,diff, starttime) as starttime from cte;
select distinct convert(varchar(10), starttime, 101) as starttime, datediff(dd, starttime, endtime) as diff from dbo.testdate;
union all select starttime, diff-1 as diff from cte where diff<>0;
select distinct dateadd(dd,diff, starttime) as starttime from cte;
create table datesnumbers ( i mediumint not null, primary key (i) );
select a.i + (10 * b.i) + (100 * c.i) + (1000 * d.i) + (10000 * e.i) - 59999 as i from (select 0 as i union all select 1 union all select 2 union all select 3 union all select 4 union all select 5 union all select 6 union all select 7 union all select 8 union all select 9) as a, (select 0 as i union all select 1 union all select 2 union all select 3 union all select 4 union all select 5 union all select 6 union all select 7 union all select 8 union all select 9) as b, (select 0 as i union all select 1 union all select 2 union all select 3 union all select 4 union all select 5 union all select 6 union all select 7 union all select 8 union all select 9) as c, (select 0 as i union all select 1 union all select 2 union all select 3 union all select 4 union all select 5 union all select 6 union all select 7 union all select 8 union all select 9) as d, (select 0 as i union all select 1 union all select 2 union all select 3 union all select 4 union all select 5 union all select 6 union all select 7 union all select 8 union all select 9) as e;
select i, current_date() + interval i day as date from datesnumbers;
select to_date('20160210','yyyymmdd') - 1 + level as start_day from dual;
create view zero_to_nine as select 0 as n union all select 1 union all select 2 union all select 3 union all select 4 union all select 5 union all select 6 union all select 7 union all select 8 union all select 9;
create view date_range as select curdate() - interval (a.n + (10 * b.n) + (100 * c.n)) day as date from zero_to_nine as a;
select * from date_range;
select datetable.date from ( select date_format(adddate(now(),-(a.a + (10 * b.a) + (100 * c.a))),'%y-%m-%d') as date from (select 0 as a union all select 1 union all select 2 union all select 3 union all select 4 union all select 5 union all select 6 union all select 7 union all select 8 union all select 9) as a union all select 5 union all select 6 union all select 7 union all select 8 union all select 9) as b union all select 5 union all select 6 union all select 7 union all select 8 union all select 9) as c where datetable.date between now() - interval 14 day and now();
create definer=`root`@`localhost` procedure `generate_calendar_table`() select unix_timestamp('2014-01-01 00:00:00') into @startts;
select unix_timestamp('2025-01-01 00:00:00') into @endts;
if ( @startts < @endts ) then drop temporary table if exists calendar_table_tmp;
create temporary table calendar_table_tmp (ts int, dt datetime);
set @startts = @startts + 900;
select ts, dt from calendar_table_tmp;
select ts, dt, weekday(dt) as wd from calendar_table_tmp;
dates as (select adddate('1970-01-01',t4.d*10000 + t3.d*1000 + t2.d*100 + t1.d*10 +t0.d) as date from digits as t0, digits as t1, digits as t2, digits as t3, digits as t4) select * from dates where date between '2017-01-01' and '2017-12-31';
select '2019-01-01' as dt union select date_add(t.dt, interval 1 day) from t where date_add(t.dt, interval 1 day) <= '2019-04-30' ) select * from t;
select '2010-01-20' as date union all select date + interval 1 day from dates where date < '2010-01-24' ) select * from dates;
select date_add('2010-01-20', interval row day) from ( select @row := @row + 1 as row from (select 0 union all select 1 union all select 2 union all select 3 union all select 4 union all select 5 union all select 6 union all select 6 union all select 7 union all select 8 union all select 9) t2, (select 0 union all select 1 union all select 2 union all select 3 union all select 4 union all select 5 union all select 6 union all select 6 union all select 7 union all select 8 union all select 9) t3, (select 0 union all select 1 union all select 2 union all select 3 union all select 4 union all select 5 union all select 6 union all select 6 union all select 7 union all select 8 union all select 9) t4, (select @row:=-1) r where date_add('2010-01-20', interval row day) <= '2010-01-24';
select date_add('2010-01-20', interval 1 day);
select datediff('2010-01-24', '2010-01-20');
select @row := @row + 1 as row from (select 0 union all select 1 union all select 3 union all select 4 union all select 5 union all select 6 union all select 6 union all select 7 union all select 8 union all select 9) t2, (select 0 union all select 1 union all select 3 union all select 4 union all select 5 union all select 6 union all select 6 union all select 7 union all select 8 union all select 9) t3, (select 0 union all select 1 union all select 3 union all select 4 union all select 5 union all select 6 union all select 6 union all select 7 union all select 8 union all select 9) t4, (select @row:=0) r limit 4;
select date_add('2010-01-20', interval row day) from ( select @row := @row + 1 as row from (select 0 union all select 1 union all select 3 union all select 4 union all select 5 union all select 6 union all select 6 union all select 7 union all select 8 union all select 9) t2, (select 0 union all select 1 union all select 3 union all select 4 union all select 5 union all select 6 union all select 6 union all select 7 union all select 8 union all select 9) t3, (select 0 union all select 1 union all select 3 union all select 4 union all select 5 union all select 6 union all select 6 union all select 7 union all select 8 union all select 9) t4, (select @row:=-1) r where date_add('2010-01-20', interval row day) <= '2010-01-24';
select  'a' collate utf8_bin = 'a' collate utf8_bin;
select  'a' collate utf8_general_ci = '' collate utf8_general_ci;
select  locationname || '<p>' from location;
select  locationname || '<p>' from location;
create or replace function create_role_if_not_exists(rolename name) returns text as if not exists (select * from pg_roles where rolname = rolename) then else return format('role ''%i'' already exists', rolename);
select * from pg_user where usename = 'my_user';
select count(*) from pg_user where usename = 'my_user';
if num_users = 0 then create role my_user login password 'my_password';
if not exists ( select from pg_catalog.pg_roles  -- select list can be empty for this where  rolname = 'my_user') then create role my_user login password 'my_password';
drop role if exists my_user;
create role my_user login password 'my_password';
select * from pg_catalog.pg_user;
create role my_user login password 'my_password';
create role my_role with nologin;
create role if not exists;
create role test;
select 'create user my_user' where not exists (select from pg_catalog.pg_roles where rolname = 'my_user')\gexec;
select ltrim(rtrim(replace(replace(replace(name,'   ',' '),char(13), ' '),char(10), ' '))) from author;
select ltrim(rtrim(names)) as names from customer;
select rtrim(names) from customer;
select ltrim(names) from customer;
select ltrim(rtrim(names)) from customer;
alter table customer add constraint customer_names__whitespace check ( names not like ' %' and names not like '% ' and names not like '%  %';
select * from table1;
select * from where a.rownumber between 2 and 5;
select emp_no , sum(salary_amount) from emp_salary;
select * from ( select top 20              -- ($a) number of records to show from ( select top 29      -- ($b) last record position from table       -- replace this for table name (i.e. "customer") 2 asc 2 desc 2 asc;
select * from table;
create view v_table as select row_number() over (order by table_key) as row,* from table;
select * from v_table where row between 10 and 20;
select * from v_table where field = 'test' and row between 10 and 20;
select salesorderid, orderdate from sales.salesorderheader;
select * from table limit offset, row_count;
select * from ( select top #{offset+row_count} *, row_number() over (order by (select 1)) as rnum from table where rnum > offset;
select * from table1 limit 10,20;
select * from ( select top 30 *, row_number() over (order by (select 1)) as rnum from table1 where rnum > 10;
select top 10 * from table;
select * from table limit 0,10;
select top 10 * from table where id not in (select top 10 id from table order by id) from table order by id;
( select salesorderid, orderdate, row_number() over (order by orderdate) as 'rownumber' from sales.salesorderheader ) select * from orderedorders where rownumber between 10 and 20;
select top 10 * from (select top 20 from table order by id) order by id desc;
select * from sometable where rownum between 10 and 20;
select t1.* from ( select row_number over(order by id) as row, t1.* from ( ...original sql query... ) t1 where t2.row between @offset+1 and @offset+@count;
select  * from    ( select  top 20 from    table1 t field1 where   rn > 10;
create table #foo(rowid int identity(1, 1), myothercolumns) select * from #foo where rowid > 10;
select * from ( select row_number() over (order by (select 0)) as [count], * from table1 where [count] between 10 and 20;
set @start = '5000';  -- 0 , 5000 , set @end = '10000'; -- 5001, 10001 select * from ( select table_name,table_type, row_number() over (order by table_name) as row from information_schema.tables;
select 'filds' from 'table' where 'where' limit 'offset','per_page';
select 'filds' from 'table' where 'where' order by 'any' offset 'offset';
set global sql_mode = 'strict_trans_tables,no_zero_in_date,no_zero_date,error_for_division_by_zero,no_auto_create_user,no_engine_substitution';
update my_table set my_date_field=null where my_date_field='0000-00-00';
update my_table set my_date_field=null where my_date_field<'1000-01-01';
select @@session.sql_mode;
set session sql_mode = 'only_full_group_by,strict_trans_tables,no_zero_in_date,error_for_division_by_zero,no_auto_create_user,no_engine_substitution';
select @@global.sql_mode;
set global sql_mode = '...';
set session sql_mode= 'error_for_division_by_zero,no_auto_create_user,no_engine_substitution';
`updated` datetime not null default '0000-00-00 00:00:00';
select @@global.sql_mode global, @@session.sql_mode session;
set sql_mode = '';
set global sql_mode = '';
set sql_mode='';
create table    students    ( student_id  int not null, first_name  varchar(50) not null, last_name   varchar(50) not null, city    varchar(50) default null, badge_no    int default null;
create table students_new ( student_id  int not null, first_name  varchar(50) not null, last_name   varchar(50) not null, city    varchar(50) default null, badge_no    int default null, primary key(student_id) , foreign key(badge_no) references students(student_id) drop table students;
alter table students_new rename to students;
alter table [child] add column column_name integer references parent_table_name(column_id);
create table child( id integer primary key, parent_id integer, description text create table parent(id integer not null primary key);
update sqlite_master set sql = replace(sql, 'description text)', 'description text, foreign key (parent_id) references parent(id))';
update sqlite_master set sql = new_sql_definition where name = 'child' and type = 'table';
update sqlite_master set sql = replace(sql, 'my_last_column integer not null', 'my_last_column integer not null, foreign key (col1, col2) references other_table(col1, col2)') where name = 'child' and type = 'table';
select sql from sqlite_master where name = 'child' and type = 'table';
select replace(sql, ...) from sqlite_master where name = 'child' and type = 'table';
alter table [child] add constraint [cid];
create table child( id integer primary key, description text);
alter table child add column parent_id integer references parent(id);
alter table child add constraint fk_child_parent;
create table child ( id           integer primary key, parent_id    integer, description  text, foreign key (parent_id) references parent(id);
where time > 1000;
create table tblb (id serial, time integer);
create table tbla (id serial, time integer);
select id, time from dblink('dbname=dbtest', 'select id, time from tblb') as t(id integer, time integer) where time > 1000;
select id, time from dblink('dbname=dbtest', 'select id, time from tblb') as t(id integer, time integer) where time > $1;
select dblink_exec ( 'dbname=postgres', 'insert into tbla select id, time from dblink ( ''dbname=dbtest'', ''select id, time from tblb'' ) as t(id integer, time integer) where time > 1000;';
select a::integer,b,c,d from tablenameb;
resumopostagem, textopostagem, dtliberacaopostagem, idmediaimgpostagem, idcatolico, idminisermao, idtipopostagem textominisermao, diaminisermao, idmediaimgminisermao, idcatolico , idminisermao, 1 from minisermao;
select id, time from  dblink('dbname=dbname port=5432 host=10.10.90.190 user=postgresuser password=pass123', 'select id, time from tblb  where time>'''||1000||'''') as t1(id integer, time integer);
if (exists (select * from information_schema.tables where  table_name = 'd020915')) set @result=1 select @result as result end;
create database test create table dbo.tbltest (id int, name nvarchar(50));
if exists (select * from information_schema.tables where table_name = n'tbltest') end;
if exists (select * from test.information_schema.tables where table_schema = n'dbo'  and table_name = n'tbltest') end;
if object_id(n'dbo.tbltest', n'u') is not null end;
if object_id(n'test.dbo.tbltest', n'u') is not null end;
create table #temptable(id int) if object_id(n'tempdb.dbo.#temptable', n'u') is not null end go;
if exists(select 1 from sys.objects where  object_id = object_id(n'dbo.tbltest') and type = n'u') end;
if exists(select 1 from sys.tables where  name = n'tbltest' and type = n'u') end;
if exists(select name from sys.sysobjects where name = n'tbltest' and xtype = n'u') end;
if  not exists (select * from sys.tables where name = n'yourtable' and type = 'u') create table [schemaname].[yourtable]( .... ) end;
if  not exists (select * from sys.objects where object_id = object_id(n'[dbo].[yourtable]') and type in (n'u')) create table [dbo].[yourtable]( .... ) end;
if not exists (select 1 from tablename) create table ...;
if not exists (select name from sysobjects where name = 'tablename');
if object_id('mytable') is not null else print 'not accounted for';
if object_id('mytable', 'u') is not null else print 'not accounted for';
if object_id('tempdb.dbo.#mytable') is not null else print 'not accounted for';
set @username = 'mike' if not exists create table tblemp (id int primary key, name varchar(50)) end  else  end;
url: "something.php", data: { "b": data1, "c": data2 }, datatype: "html", beforesend: function() {}, error: function() { success: function(data) {;
contenttype: "application/json; charset=utf-8", url: "yoururlhere", data: { data1: value1, data2: value2, data3: value3 }, success: function (result) {;
url: $('form').attr("action"), data: $('#form0').serialize(), success: function (result) {;
url: "concessions.aspx/getconcessions", data: new_countries, ...;
url: '../php_handler_url.php', data: ser_data, }).success(function(response) {;
url: "some.php", data: { name: "john", location: "boston" };
if (country.length==0) { if (window.xmlhttprequest) { if (xmlhttp.readystate==4 && xmlhttp.status==200) {;
datatype: "json", url: "ajax/activity_save.php", data: {status: status, name: name},;
url: "create.php", data: {vendorname: $("#vendorname_new").val(), owner: $("#owner_new").val(), city: $("#city_new").val()}, success: function(){;
url: "ajax/activity_save.php", data: {'status': status, 'name': name}, success: function(msg) {...;
create table friends ( id serial primary key, data jsonb);
select data->'name' from friends;
select data->'name' as name, data->'work' as work from friends;
select data->>'name' as name, data->'work'->>0 as work from friends;
select data->>'name' as name, data->'work'->>0 as work from friends where data->>'name'='arya';
values ('{"objects":[{"src":"foo.png"}, {"src":"bar.png"}] ) select * from   reports r, <b>json_array_elements(r.data#>'{objects}') obj</b> where  obj->>'src' = 'foo.png';
select * from   reports r, <b>json_array_elements(r.data->'objects') obj</b> where  obj->>'src' = 'foo.png';
create index reports_data_gin_idx on reports select * from reports where data->'objects' @> '[{"src":"foo.png"}]';
select * from foo where bar = ':myvariable';
select * from foo where bar = :myvariable;
select * from foo where bar = :'myvariable';
select * from :myvariable.table1;
select * from table1 where :myvariable is null;
select * from table1 where column1 = :'myvariable';
select * from table1 where column1 = ':myvariable';
alter user :deployment_user with password :deployment_pass;
create function var(name text, val text) returns void as $$ create function var(name text) returns text as $$;
create table var ( sess bigint not null, key varchar not null, val varchar, constraint var_pkey primary key (sess, key) create function var(key varchar, val anyelement) returns void as $$ delete from var where sess = pg_backend_pid() and key = $1;
create function var(varname varchar) returns varchar as $$ select val from var where sess = pg_backend_pid() and key = $1;
select t.*, vars.answer, t.radius*vars.appr_pi from table as t, vars;
create temp table temp_session_variables ( "sessionsalt" text;
table "public.test" column |  type   |                     modifiers;
alter table tablename drop constraint fk_constraintname;
alter table tablename add constraint fk_constraintname;
alter table `tbl_celebrity_rows` add constraint `tbl_celebrity_rows_ibfk_1` foreign key (`celebrity_id`);
alter table child_table_name  with check add foreign key(child_column_name);
alter table childtablename drop foreign key `fk_table`;
alter table childtablename add constraint `fk_t1_t2_tt`;
select * from user_cons_columns where constraint_name = thecons and owner = theowner where delete_rule = 'no action' and constraint_name not like '%modified_by_fk'  -- these constraints we do not want delete cascade and constraint_name not like '%created_by_fk' else dbms_output.put(',');
else dbms_output.put(',');
alter table child_table_name add constraint fk_name;
alter database people rename to customers;
select pg_terminate_backend( pid ) from pg_stat_activity where pid <> pg_backend_pid( ) and datname = 'name of database';
alter database "name of database" rename to "new name of database";
select convert(varchar, getdate(), 100) -- mon dd yyyy hh:mmam select convert(varchar, getdate(), 101) -- mm/dd/yyyy  10/02/2008 select convert(varchar, getdate(), 102) -- yyyy.mm.dd  2008.10.02 select convert(varchar, getdate(), 103) -- dd/mm/yyyy select convert(varchar, getdate(), 104) -- dd.mm.yyyy select convert(varchar, getdate(), 105) -- dd-mm-yyyy select convert(varchar, getdate(), 106) -- dd mon yyyy select convert(varchar, getdate(), 107) -- mon dd, yyyy select convert(varchar, getdate(), 108) -- hh:mm:ss select convert(varchar, getdate(), 109) -- mon dd yyyy hh:mm:ss:mmmam (or pm) select convert(varchar, getdate(), 110) -- mm-dd-yyyy select convert(varchar, getdate(), 111) -- yyyy/mm/dd select convert(varchar, getdate(), 112) -- yyyymmdd select convert(varchar, getdate(), 113) -- dd mon yyyy hh:mm:ss:mmm select convert(varchar, getdate(), 114) -- hh:mm:ss:mmm(24h) select convert(varchar, getdate(), 120) -- yyyy-mm-dd hh:mm:ss(24h) select convert(varchar, getdate(), 121) -- yyyy-mm-dd hh:mm:ss.mmm select convert(varchar, getdate(), 126) -- yyyy-mm-ddthh:mm:ss.mmm;
select balancedue from ( select (invoicetotal - paymenttotal - credittotal) as balancedue from invoices where balancedue > 0;
select (invoicetotal - paymenttotal - credittotal) as balancedue from invoices where  (invoicetotal - paymenttotal - credittotal)  > 0;
select len(name) + column_id as x from sys.all_columns where len(name) + column_id > 30;
select x from ( select len(name) + column_id as x from sys.all_columns where x > 30;
select len(name) + column_id as x from sys.all_columns where column_id + len(name) > 30;
select name, column_id, x from ( select name, column_id, len(name) + column_id as x from sys.all_columns where x > 30;
select name, column_id, x from ( select name, column_id, len(name) + column_id as x from sys.all_columns where len(name) + column_id > 30;
select vars.balancedue from entity e select -- variables variable2 = ...some..long..complex..expression..etc... where vars.balancedue > 0;
select c.balancedue as balancedue from invoices where  c.balancedue  > 0;
select * from ( select (invoicetotal - paymenttotal - credittotal) as balancedue from invoices) as temp where balancedue > 0;
create table [dbo].[table_name]( [tableid] [int] identity(1,1) not null, [column_2] [datatype] not null, [column_3] [datatype] not null,  constraint [pk_table_name] primary key clustered ( [tableid] asc ) );
select * from olddb.dbo.yourtable;
select @@version;
create or replace view sales_flat_addresses as select sales_order_entity.parent_id as order_id, sales_order_entity.entity_id, concat(concat(ucase(mid(sales_order_entity_varchar.value,1,1)),mid(sales_order_entity_varchar.value,2)), "address") as type, group_concat( concat( eav_attribute.attribute_code," ::::: ", sales_order_entity_varchar.value ) from sales_order_entity and sales_order_entity.entity_type_id =12;
select cast(substring('x12312333333333', '([\d]{1,9})') as integer);
create or replace function cast_to_bigint(text);
select p from matchprofile p where concat(p.id, '') = :keyword;
select (nullif(regexp_replace(split_part(column1, '.', 1), '\d','','g'), '') from (values;
select avg(cast(mynumber as numeric)) from my table;
select case when myfield="" then 0 else myfield::integer end from mytable;
create or replace function convert_to_integer(v_input text);
select myfield::integer from mytable where myfield ~ e'^\\d+$';
select case when myfield~e'^\\d+$' then myfield::integer else 0 end from mytable;
select id, (0 || values)::integer from test_table order by id;
create table test_table ( id integer not null, description character varying, "values" character varying, constraint id primary key (id) );
create or replace function parse_int(s text) returns int as $$;
select parse_int('test12_3test');
create or replace function convert_to_int(text) if $1 = '' then  -- special case for empty string like requested else return $1::int;
end $func$  language plpgsql immutable;
where isdeleted = false;
select *, (select count(id)  from productmaster where productmaster.catid = categorymaster.id) as coun from categorymaster;
select * from common where common_id not in (select common_id from table1 where common_id is not null) and common_id not in (select common_id from table2 where common_id is not null);
select c.commonid, t1.commonid, t2.commonid from common c where t1.commonid is null and t2.commonid is null;
select t.common_id from common t where t1.common_id is null and t2.common_id is null;
select * from common c where not exists (select t1.commonid from table1 t1 where t1.commonid = c.commonid) and not exists (select t2.commonid from table2 t2 where t2.commonid = c.commonid);
( select common_id from table1 where common_id is not null );
select * from common where 1 not in (2) and 1 not in (3, null);
select * from common where not (1=2) and not (1=3 or 1=null);
select * from common where not (false) and not (false or unkown);
select * from common where true and not (unknown);
select * from common where unknown;
select * from common where not exists (select common_id from table1 where common_id = common.common_id) and not exists (select common_id from table2 where common_id = common.common_id);
select  * from    common table1 t1 where   t1.common_id is null;
select  * from    common where   not exists ( select  null from    table1 t1 where   t1.common_id = common.common_id );
select  * from    common where   common_id not in ( select  common_id from    table1 t1 );
( select  common_id from    table1 t1 );
select department_name,department_id from hr.departments dep where not exists where emp.department_id=dep.department_id );
select department_name,department_id from hr.departments dep where department_id not in (select department_id from hr.employees );
select department_id from hr.employees;
select department_name,department_id from hr.departments dep where department_id not in (select nvl(department_id,0) from hr.employees );
create table admission ( rno int primary key auto_increment, name varchar(25) not null, gender enum('m','f'), boolean_valu boolean, dob date, fees numeric(7,2) not null select * from admission;
if (is_string($key)) {;
if (is_string($key)) { if (is_string($value)) if (is_array($value)) if (is_null($value));
if (is_string($key)) { if (is_array($value)) if (is_null($value));
from fruit where calories < :calories and colour = :colour');
'conditions' => array( 'model.name like ' . $pdo->quote("%{$keyword1}%"), 'model.name like ' . $pdo->quote("%{$keyword2}%"), ), );
select * from `an_modules` as `m` left join `an_module_sites` as `ms` on m.module_id = ms.module_id where 1 and `module_enable` = :module_enable and `site_id` = :site_id and (`module_system_name` like :search or `module_version` like :search);
if (is_string($key)) { if (is_string($value)) if (is_array($value)) if (is_null($value)) if (is_array($values)) { if (isset($values_limit[$key])) {;
case \pdo::param_str: $type = 'string'; break;
case \pdo::param_bool: $type = 'boolean'; break;
case \pdo::param_int: $type = 'integer'; break;
case \pdo::param_null: $type = 'null'; break;
case 'string': $var = "'{$var}'"; break;
case 'integer': $var = "{$var}"; break;
case 'boolean': $var = $var ? 'true' : 'false'; break;
case 'null': $var = 'null';
if (!is_array($str)) { if (empty($str)) { if ($lastchar != "\\") { if ($prev === null) { if ($i % 2 !== 0) { if (preg_match("/(\?|:[a-z0-9_\-]+)/is", $s, $matches, preg_offset_capture)) { if ($key == '?') { if (array_key_exists($indexquestionmark, $params)) { if (array_key_exists($key, $params)) {;
if (is_string($key)) { if (is_array($value)) if (is_null($value));
if  exists (select * from sys.objects where object_id = object_id(n'[dbo].[startest]') and type in (n'u')) drop table [dbo].[startest] create table [dbo].[startest]( [id] [int] identity(1,1) not null, [a] [varchar](50) null, [b] [varchar](50) null, [c] [varchar](50) null select 'a1','b1','c1' union all select 'a2','b2','c2' union all select 'a3','b3','c3' if  exists (select * from sys.views where object_id = object_id(n'[dbo].[vstartest]')) drop view [dbo].[vstartest] create view dbo.vstartest as select * from dbo.startest if  exists (select * from sys.views where object_id = object_id(n'[dbo].[vexplicittest]')) drop view [dbo].[vexplicittest] create view dbo.[vexplicittest] as select a,b,c from dbo.startest select a,b,c from dbo.vstartest select a,b,c from dbo.vexplicittest if  exists (select * from sys.objects where object_id = object_id(n'[dbo].[startest]') and type in (n'u')) drop table [dbo].[startest] create table [dbo].[startest]( [id] [int] identity(1,1) not null, [a] [varchar](50) null, [b] [varchar](50) null, [d] [varchar](50) null, [c] [varchar](50) null select 'a1','b1','d1','c1' union all select 'a2','b2','d2','c2' union all select 'a3','b3','d3','c3' select a,b,c from dbo.vstartest select a,b,c from dbo.vexplicittest;
update master_user_profile set master_user_profile.fellow = 'y' where master_user_profile.user_id in ( select tran_user_branch.user_id from tran_user_branch where tran_user_branch.branch_id = 17);
select table1.id from table2;
select table1.column2 from table1;
select convert(datetime, switchoffset([columna], datepart(tzoffset, [columna] at time zone 'gmt standard time')));
select convert(datetime, switchoffset([columna], datepart(tzoffset, [columna] at time zone @timezone)));
exec sp_help 'sys.tables';
select * from sys.types where system_type_id = 231;
create procedure dbo.yyy_test ( @col_one    nvarchar(max), @col_two    nvarchar(max)  = 'default', @col_three  nvarchar(1), @col_four   nvarchar(1)    = 'default', @col_five   nvarchar(128), @col_six    nvarchar(128)  = 'default', @col_seven  sysname ) as begin select 1 end;
select  parm.name as parameter, parm.max_length, parm.parameter_id from    sys.procedures sp join sys.parameters parm on sp.object_id = parm.object_id where   sp.name = 'yyy_test';
select  parm.name as parameter, parm.max_length, parm.parameter_id, typ.name as data_type, typ.system_type_id, typ.user_type_id, typ.collation_name, typ.is_nullable from    sys.procedures sp join sys.parameters parm on sp.object_id = parm.object_id join sys.types typ on parm.system_type_id = typ.system_type_id where   sp.name = 'yyy_test';
select @table_name = 'stud_dtls' select table_schema from information_schema.tables where table_name = @table_name;
exec sp_fkeys @table;
exec sp_help @table;
select str_size  /* my variable usage */ from dual  /* or any other table, or mixed of joined tables */;
column 1 noprint new_value 1 select '' "1" from dual where 2!=2;
select nvl('&&1', 'vah') "1" from dual;
select &num from dual;
select stupid into stupidvar from stupiddata cc where stupidid = 2;
select stupid into stupidvar from stupiddata cc where stupidid = 2;
select evenmorestupid into evenmorestupidvar from evenmorestupiddata ccc where evenmorestupidid = 42;
select stupidvar, evenmorestupidvar from dual;
select * from proposal where prop_start_dt = &propp_start_dt;
select pk into x from table1 where col1 = 'test';
select pk into y from table2 where col2 = x;
select y,'text' from dual where exists(select * from table2);
select doh as your_num from dual;
select stupiddata from stupidtable where stupidcolumn = '&stupidvar';
select code from product where code = fl-208;
top earners = 1;
if ($current_row[$yid-1]) $out_button.= "<a  class='button' href='/$your_url/".$current_row[$yid-1]."'>button_previous</a>";
if ($current_row[$yid+1]) $out_button.= "<a  class='button' href='/$your_url/".$current_row[$yid+1]."'>button_next</a>";
select ifnull((select id from table where id < :id order by id desc limit 1),0) as previous, ifnull((select id from table where id > :id order by id asc limit 1),0) as next;
select * from `my_table` where id = (select (id) from my_table where position = ($position+1)) limit 1;
select * from my_table where id = (select (id) from my_table where `position` = ($position-1)) limit 1;
create procedure `pobierz_posty`(in iduser bigint(20), in size int, in page int) set start_element:= size * page;
select distinct * from post where id_users .... end;
create table student(id int, name varchar(30), age int);
(2 ,'reddy', 26), (3 ,'vasu',  50), (5 ,'manoj', 10), (6 ,'raja',  52), (7 ,'vinod', 27);
select name, (select name from student s1 where s1.id < s.id (select name from student s2 where s2.id > s.id from student s where id = 7;
select next_id from ( select id as cur_id, (select min(id) from `foo` where id>cur_id) as next_id from `foo` where next_id is not null;
select row from (select @rownum:=@rownum+1 row, a.* from articles a, (select @rownum:=0) r where id = 50;
select * from articles limit 21, 1;
select * from articles limit 19, 1;
select current_row.row, current_row.id, previous_row.row, previous_row.id from ( select @rownum:=@rownum+1 row, a.* from articles a, (select @rownum:=0) r select @rownum2:=@rownum2+1 row, a.* from articles a, (select @rownum2:=0) r;
else { else { else { else {;
select @prev_col_a, @prev_col_b, @prev_col_c, @prev_col_a := col_a as col_a, @prev_col_b := col_b as col_b, @prev_col_c := col_c as col_c from table, (select @prev_col_a := null, @prev_col_b := null, @prev_col_c := null) prv;
select row from (select @rownum:=@rownum+1 row, a.* from articles a, (select @rownum:=0) r where id = 50;
select * from articles limit 19, 3;
select * from `foo` limit number++ , 1;
select * from `foo` limit number-- , 1;
select * from `foo` limit 1 , 1 select * from `foo` limit 2 , 1 select * from `foo` limit 3 , 1;
select * from `foo` limit -1 , 1 select * from `foo` limit -2 , 1 select * from `foo` limit -3 , 1 select * from `foo` limit 3 , 1 select * from `foo` limit 2 , 1 select * from `foo` limit 1 , 1;
create table users ( userid int not null auto_increment, username varchar(45), usernameid varchar(45), primary key (userid);
create definer=`root`@`localhost` procedure `printpreviousidbyselectediduser`( in id int, in search_name varchar(45) ) select concat(ns.userid) as 'previous id' from users ns where ns.username=search_name and ns.userid in (select min(ns.userid) from users ns where ns.userid > id union select max(ns.userid) from users ns where  ns.userid < id) limit 1 ;
create definer=`root`@`localhost` procedure `getprevioususerid`( in id int, in search_name varchar(45) ) select concat(ns.userid) as 'previous id' from users ns where ns.username=search_name and  ns.userid < id   order by ns.userid desc limit 1;
select * from `table` where table_id < 3 order by `table_id` desc limit 1;
select * from story where catagory=100 and  ( id =(select max(id) from story where id < 5 and catagory=100 and order by created_at desc) or id=(select min(id) from story where id > 5 and catagory=100 order by created_at desc) );
if (!empty($next_id)) { if (!empty($prev_id)) {;
select * from ( select @rownum:=@rownum+1 row, case a.id when 'currentarticleid' then @currentrow:=@rownum else null end as 'current_row', a.* from articles a, (select @currentrow:=0) c, (select @rownum:=0) r where row > @currentrow - 2 limit 3;
select * from ( select @rownum:=@rownum+1 row, case a.id when '100' then @currentrow:=@rownum else null end as 'current_row', a.* from articles a, (select @currentrow:=0) c, (select @rownum:=0) r where row > @currentrow - 2 limit 3;
select * from foo where ( id = ifnull((select min(id) from foo where id > 4),0) or  id = ifnull((select max(id) from foo where id < 4),0) );
select * from foo where id = (select min(id) from foo where id > 4);
select * from foo where id = (select max(id) from foo where id < 4);
select * from foo where id>4 order by id limit 1;
select * from foo where id > 4 order by id limit 1;
select * from foo where id < 4 order by id desc limit 1;
select  a.* from    table1 a where   b.id is null;
select id, name from   table1 where  id not in (select id from table2);
select count(*) from ( (select id from table1) except (select id from table2) select table1.* from ( (select id from table1) except (select id from table2);
select count(id) from tbla a where a.id not in (select b.id from tblb b)    --for count select id from tbla a where a.id not in (select b.id from tblb b)    --for results;
select  l.* from    t_left l t_right r where   r.value is null;
select  l.* from    t_left l where   l.value not in ( select  value from    t_right r );
select  l.* from    t_left l where   not exists ( select  null from    t_right r where   r.value = l.value );
select ... where ... in (select...);
select t1.id, t1.name from   table1 t1 where  not exists ( select top 1 null from table2 t2 where t1.id = t2.id );
database project;
select t1.* from lms_attendance as t1 and t1.time < t2.time where t2.user is null;
select t1.* from lms_attendance as t1 and t1.time < t2.time where t2.user is null and t1.time is not null;
select id,user, max(time), io from lms_attendance group by user;
select user, time from ( select user, time from lms_attendance --where clause where (select count(0) from table where user = t.user and time > t.time) = 0;
select result from ( select vorsteuerid as result, count(*) as anzahl from kreditorenrechnung where kundeid = 7148;
select * from lms_attendance group by user order by time desc;
select b.* from max(`lms_attendance`.`time`) as `time` from `lms_attendance` `lms_attendance`.`user`) a join  from `lms_attendance` ) b and a.time = b.time;
select t1.* from lms_attendance t1 where t1.time = (select max(t2.time) from lms_attendance t2 where t2.user = t1.user);
select t1.* from lms_attendance t1 where t1.id = (select t2.id from lms_attendance t2 where t2.user = t1.user limit 1);
select t1.* from lms_attendance as t1 and (t1.time < t2.time or (t1.time = t2.time and t1.id < t2.id)) where t2.user is null;
create table lms_attendance create view latest_all as select la.user, max(la.time) time from lms_attendance la create view latest_io as select la.* from lms_attendance la join latest_all lall and lall.time = la.time;
values (1, 9, 1370931202, 'out'), (2, 9, 1370931664, 'out'), (3, 6, 1370932128, 'out'), (4, 12, 1370932128, 'out'), (5, 12, 1370933037, 'in');
select * from latest_io;
select distinct first_value(id) over (partition by lms_attendance.user order by lms_attendance.time desc) as id, first_value(user) over (partition by lms_attendance.user order by lms_attendance.time desc) as user, first_value(time) over (partition by lms_attendance.user order by lms_attendance.time desc) as time, first_value(io) over (partition by lms_attendance.user order by lms_attendance.time desc) as io from lms_attendance;
select id, max(user) as user, max(time) as time, max(io) as io from lms_attendance group by id;
if (<condition>) is not null then end if;
if (@skipme) is not null then /* @skipme returns null if never set or set to null */ end if;
if <some error condition> then set message_text = 'your custom error message';
create definer=`root`@`%` procedure `save_package_as_template`( in package_id int , in bus_fun_temp_id int  , out o_message varchar (50) , out o_number int ) select count(*)  into v_workflow_count from workflow w where w.package_id = if  v_workflow_count = 0 then select 'no work flow ' as 'workflow_status' ;
set o_message ='work flow is not created for this package.';
set  o_number = -2 ;
select 'work flow  created ' as 'workflow_status' ;
set o_message ='successful';
set  o_number = 1 ;
end ;-- this_proc block end here end;
create procedure sp_reporting(in tablename varchar(20)) if tablename is not null then end if;
create procedure sp_reporting(in tablename varchar(20)) if tablename is not null then end if;
create procedure sp_reporting_2(in tablename varchar(20));
create procedure sp_reporting(in tablename varchar(20)) if tablename is null then end if;
drop procedure if exists $procname;
create procedure $procname($params) select $fields from $tables where $where if error = 0 then select $vars;
else select 1 as error;
select left(subject , 10) from tbl;
select substring(subject, 1, 10) from tbl;
select * from `table` limit 0, 10;
select * from (select row_number () over (order by user_id) user_row_no, a.* from temp_emp a) where user_row_no > 1 and user_row_no <11;
select top 10 ...;
select ... limit 10;
set rowcount 10 select ...;
select top 10 ...;
select top 100 * from mytable select top 100 cola, colb from mytable;
select ... order by num desc limit 10;
select a.names, count(b.post_title) as num from wp_celebnames a join wp_posts b on instr(b.post_title, a.names) > 0 where b.post_date > date_sub(curdate(), interval 1 day) limit 10;
where rownum <= 10  and whatever_else ;
select  top(12) month, year, code from tempemp;
select ... limit [num] offset [num];
select first 10 * from mytable;
select a.names, count(b.post_title) as num from wp_celebnames a join wp_posts b on instr(b.post_title, a.names) > 0 where b.post_date > date_sub(curdate(), interval 1 day);
alter table one add two_id int default 123, foreign key(two_id) references two(id);
alter table product add foreign key (product_id) references product(product_id);
alter table one add two_id integer constraint fk foreign key (two_id) references two(id);
alter table one add two_id integer, add constraint foreign key(two_id) references two(id);
alter table one add two_id integer, foreign key(two_id) references two(id);
alter table `table_name` add `column_name` integer unsigned, add constraint constrain_name foreign key(column_name) references foreign_table_name(id);
alter table one add two_id integer foreign key (two_id) references two (id);
alter table tablename add newcolumnname integer, foreign key(newcolumnname) references [foreignkey_tablename](foreign_key_column);
alter table one add two_id integer references two;
alter table tablename add columnname datatype, constraint fkname foreign key(fkcolumnname);
alter table tablename add columnname datatype, foreign key(fkcolumnname) references pktablename(pktablecolumnname);
alter table one add two_id integer constraint fk_two_id references two(id);
alter table one add two_id int foreign key;
alter table one add two_id integer constraint fk foreign key references two(id);
table name: user;
table user table friends;
create table if not exists `friends` ( `id` int(11) not null, `user_id` int(11) not null, `friend_id` int(11) not null;
( select friend_id from friends where user_id = 1 select distinct ff.friend_id from friends f join friends ff on ff.user_id = f.friend_id where f.user_id = 1 );
create database;
create database;
create schema if not exists;
create database if not exists;
create schema if not exists;
create database;
create schema if not exists;
create extension if not exists dblink;
create database;
create extension create extension;
select 1 from pg_database where datname = 'my_db';
create database;
create database;
select 'create database mydb' where not exists (select from pg_database where datname = 'mydb')\gexec;
if exists (select from pg_database where datname = 'mydb') then else perform dblink_exec('dbname=' || current_database()  -- current db end if;
drop database if exists dbname;
create database dbname;
create extension if not exists dblink; -- enable extension if exists (select 1 from pg_database where datname = _db) then else perform dblink_connect('host=localhost user=' || _user || ' password=' || _password || ' dbname=' || current_database());
"select * from foo where id in %s", [tuple(ids)]);
"select * from foo where id = any (%s)", [list(ids)]);
if t[-2] == ',':;
select name from students where id in {repr(tuple(map(str, l)))};
select name  from students  where id in ('a', 'b', 'c');
select * from students where and date in {dates_str};
select * from students  where  and date in (date '2020-11-24',date '2020-12-28');
select name from studens where id in (1, 5, 8);
select name from studens where id in (1, 5, 8);
select name from studens where id = 1 or id = 5 or id = 8;
select field1, field2 from @reportoption;
values (temp.field1, temp.field2);
create table reportoption (reportoptionid int identity(1, 1), field1 int, field2 int) create table practice (practiceid int identity(1, 1), field1 int, field2 int) create table practicereportoption (practicereportoptionid int identity(1, 1), practiceid int, reportoptionid int, field1 int, field2 int) values (p.field1, p.field2) select  * from    practicereportoption drop table reportoption drop table practice drop table practicereportoption;
select field1, field2 from @practice order by practiceid asc;
update m set m.practiceid = s.practiceid from @practicereportoption as m join cte as s on s.row = m.practicereportoptionid select * from @practicereportoption;
if ( !$bla ) if ( !$beepboop ) create table if not exists history ( id int not null auto_increment, insertdate timestamp default now(), alterdate timestamp(8) default now(), deletedate timestamp(8), altercount int default 0, selectcount int default 0,  )engine=innodb;
if ( !$bla ) if ( !$beepboop ) create table if not exists history ( id int not null auto_increment, insertdate timestamp default now(), alterdate timestamp(8) default now(), deletedate timestamp(8), altercount int default 0, selectcount int default 0,  )engine=innodb;
create table if not exists history ( id int not null auto_increment, insertdate timestamp default now(), alterdate timestamp(8) default now(), deletedate timestamp(8), altercount int default 0, selectcount int default 0,  )engine=innodb;
select name, id, xtype, uid, info, status, base_schema_ver, replinfo, parent_obj, crdate, ftcatid, schema_ver, stats_schema_ver, type, userstat, sysstat, indexdel, refdate, version, deltrig, instrig, updtrig, seltrig, category, cache from sysobjects where category = 0 and xtype in ('u', 'p', 'fn', 'if', 'tf');
select      name, id, xtype, uid, info, status, base_schema_ver, replinfo, parent_obj, crdate, ftcatid, schema_ver, stats_schema_ver, type, userstat, sysstat, indexdel, refdate, version, deltrig, instrig, updtrig, seltrig, category, cache from sysobjects where category = 0 and xtype in ('u', 'p', 'fn', 'if', 'tf');
if object_id('validaterequestpost') is null exec ('create procedure validaterequestpost @errorstates varchar(255) output as begin select @errorstates = @errorstates end;
drop procedure if exists usp_name;
if exists (select * from   sysobjects where  id = object_id('[dbo].[sp_cp_test]') and objectproperty(id, 'isprocedure') = 1 and xtype = 'p' and name = 'sp_cp_test') set @proc=@alter + @proc exec (@proc) end else begin set @proc=@create + @proc exec (@proc) end ;
if object_id('procedurename','p') is not null drop proc procedurename create procedure [dbo].[procedurename];
if not exists (select * from dbo.sysobjects where id = object_id(n'[dbo].[xxx]') and objectproperty(id, n'isprocedure') = 1) create procedure dbo.xxx;
if object_id('spname') is null else -- exists;
if object_id('mysproc', 'p') is not null drop proc mysproc create proc mysproc as begin end;
if  exists (select * from sys.objects where object_id = object_id(n'[dbo].[yoursproc]') and type in (n'p', n'pc')) drop procedure [dbo].[yoursproc] create procedure yoursproc...;
if object_id('yoursp') is null exec ('create procedure dbo.yoursp as select 1') alter procedure dbo.yoursp as ...;
alter table table_name modify (column_name drop identity);
alter table yourtable drop column yourcolumn;
alter table yourtable add tempid int not null default -1;
update yourtable set tempid = id;
select * from information_schema.table_constraints where table_name = 'yourtable';
alter table yourtable drop constraint pk_yourtable_id;
select * from information_schema.table_constraints where table_name = 'othertable';
alter table othertable drop constraint fk_othertable_yourtable;
alter table yourtable drop constraint pk_yourtable_id;
alter table yourtable drop column id;
exec sp_rename 'yourtable.tempid', 'id', 'column';
alter table yourtable add constraint pk_yourtable_id primary key (id);
alter table othertable add constraint fk_othertable_yourtable foreign key (yourtable_id) references yourtable(id);
values  ( 'client' );
alter table tablename add newcolumn int update tablename set newcolumn=existingcolumnname alter table tablename drop column existingcolumnname;
exec sp_rename 'tablename.oldcolumn' , 'newcolumnname', 'column';
set quoted_identifier on set arithabort on set numeric_roundabort off set concat_null_yields_null on set ansi_nulls on set ansi_padding on set ansi_warnings on alter table dbo.si_provider_profile drop constraint df_si_provider_profile_sidtdatetimestamp alter table dbo.si_provider_profile drop constraint df_si_provider_profile_sibhotelpreloaded create table dbo.tmp_si_provider_profile ( si_lprovider_profile_id int not null, si_lserko_integrator_token_id int not null, si_sserko_integrator_provider varchar(50) not null, si_sserko_integrator_profile varchar(50) not null, si_dtdate_time_stamp datetime not null, si_lprovider_id int null, si_sdisplay_name varchar(10) null, si_lpurchased_from int null, si_sprovider_uniqueid varchar(255) null, si_bhotel_pre_loaded bit not null, si_ssitename varchar(255) null alter table dbo.tmp_si_provider_profile set (lock_escalation = table) alter table dbo.tmp_si_provider_profile add constraint alter table dbo.tmp_si_provider_profile add constraint if exists(select * from dbo.si_provider_profile) select si_lprovider_profile_id, si_lserko_integrator_token_id, si_sserko_integrator_provider, si_sserko_integrator_profile, si_dtdate_time_stamp, si_lprovider_id, si_sdisplay_name, si_lpurchased_from, si_sprovider_uniqueid, si_bhotel_pre_loaded, si_ssitename from dbo.si_provider_profile with (holdlock tablockx)') exec sp_rename 'dbo.si_provider_profile.pk_si_provider_profile', 'pk_si_provider_profile_old';
alter table dbo.si_provider_profile add constraint ( si_lprovider_profile_id;
select t1.* from invoice t1;
exec sp_rename '[sometable].[id]', 'oldid';
alter table [sometable] add id int null exec ('update [sometable] set id = oldid') alter table [sometable] nocheck constraint all alter table [sometable] drop constraint [pk_constraintname];
alter table [sometable] drop column oldid alter table [sometable] alter column [id] integer not null alter table [sometable] add constraint pk_jobinfo primary key (id) alter table [sometable] check constraint all end try select error_message () end catch;
alter table users add newusernum int;
update users set newusernum=usernum;
alter table users drop column usernum;
exec sp_rename 'users.newusernum' , 'usernum', 'column';
alter table [original] switch to [original2];
exec sys.sp_rename;
create table original ( id int identity primary key create nonclustered index ix_original_value on original (value);
select 'abcd' union all select 'defg';
create table original2 ( id int primary key create nonclustered index ix_original_value2 on original2 (value);
select 'original', * from original union all select 'original2', * from original2;
alter table original switch to original2;
select 'original', * from original union all select 'original2', * from original2;
if not exists (select * from original) drop table original;
exec sys.sp_rename 'original2.ix_original_value2', 'ix_original_value', 'index';
exec sys.sp_rename 'original2', 'original', 'object';
update original set id = id + 1;
select * from original;
select top 25 * from ( select top 75 * from   table;
select * from ( select top (@pagesize) * from ( select top (@pagenumber * @pagesize) * from tablename;
select rowno = row_number() over( order by columnname asc ) from tablename ) select * from results where rowno between (@pagenumber-1)*@pagesize+1 and @pagenumber*@pagesize;
select col1, col2 from ( select col1, col2, row_number() over (order by id) as rownum from mytable where myderivedtable.rownum between @startrow and @endrow;
select * from (select row_number() over(order by id) rownr, id from tbl) t where rownr between 10 and 20;
set @offset = 120000 set @limit = 10 select * from ( select row_number() from table ) as a where a.rownum between (@offset) and (@offset + @limit-1);
set rowcount @rowcount select * from mytable into #resultset where mytable.type = 1 select * from ( select *, row_number() over(order by sortconst asc) as rownumber from ( select *, 1 as sortconst from #resultset where rownumber between @offset and @rowcount drop table #resultset;
top (25) ... where key > @last_key order by key;
select  * from     mytable;
set rowcount [offset+limit];
set rowcount 75 -- (50 + 25) end close mycursor set rowcount 0;
select tablename.col1, tablename.col2, tablename.col3, ... from ( ( select col1 from ( select col1, row_number() over (order by col1 asc) as rownum from tablename where ([condition]) ) as t1 where t1.rownum between [offset] and [offset + limit] ) as t2 inner join tablename on t2.col1=tablename.col1;
[limit] the maximum results.;
select top 2 * from table1 where rank >= @rank and id > @id;
select top @limit * from ( select row_number() over (order by colunx asc) offset, * from (  select * from mytable where offset > @offset;
select * from mytable;
select * from mytable;
select top 75 * from mytable select top 50 * from mytable;
select * from mytable order by id offset 50 rows fetch next 25 rows only;
select 0 as tmp,column1 from table1 order by tmp offset 5000000 rows fetch next 50 rows only;
select departmentid, name, groupname from humanresources.department;
select @tablename=coalesce(@tablename+',','')+t.table_catalog+'.'+ t.table_schema+'.'+o.name from sysindexes as i where i.indid < 2 and objectproperty(o.id,'ismsshipped') = 0 and i.rowcnt >350 and o.xtype !='tf';
select insrowtbl.pk, insrowtbl.username, attr.insrow.value('local-name(.)', 'nvarchar(128)') as fieldname, attr.insrow.value('.', 'nvarchar(max)') as fieldvalue from ( select i.lastmodifiedby as username, convert(xml, (select i.* for xml raw)) as insrowcol from inserted as i;
select id from (values (2, 1, 'value of indicator 1 for entity 2', 'value of indicator 2 for entity 2', 'value of indicator 3 for entity 2'), (3, 1, 'value of indicator 1 for entity 3', 'value of indicator 2 for entity 3', 'value of indicator 3 for entity 3'), (4, 2, 'value of indicator 1 for entity 4', 'value of indicator 2 for entity 4', 'value of indicator 3 for entity 4') ( indicatorvalue;
select id, entityid, indicatorname, indicatorvalue from yourtable ( indicatorvalue;
select id, entityid, indicatorname, indicatorvalue from yourtable ( select 'indicator1', indicator1 union all select 'indicator2', indicator2 union all select 'indicator3', indicator3 union all select 'indicator4', indicator4;
select id, entityid, indicatorname, indicatorvalue from yourtable ( values ('indicator1', indicator1), ('indicator2', indicator2), ('indicator3', indicator3), ('indicator4', indicator4);
@query  as nvarchar(max) select @colsunpivot from information_schema.columns as c where c.table_name = 'yourtable' and set @query indicatorname, indicatorvalue from yourtable ( indicatorvalue exec sp_executesql @query;
select id, entityid, (select t.* for xml raw('row'), type) as data from temp1 as t select c.id, c.entityid, f.c.value('local-name(.)', 'nvarchar(128)') as indicatorname, f.c.value('.', 'nvarchar(max)') as indicatorvalue from cte1 as c ) select * from cte2 where indicatorname like 'indicator%';
select a.[id] from  @yourtable a from  openjson((select a.* for json path,without_array_wrapper )) where [key] not in ('id','other','columns','toexclude');
exec sp_msforeachtable 'alter table ? nocheck constraint all' exec sp_msforeachtable 'truncate table ?' exec sp_msforeachtable 'alter table ? check constraint all';
exec sp_msforeachtable 'alter table ? nocheck constraint all' exec sp_msforeachtable 'delete from ?' exec sp_msforeachtable 'alter table ? with check check constraint all';
if exists (select name from  sysobjects where name = 'sp_deleteallconstraints' and type = 'p') drop procedure dbo.sp_deleteallconstraints create procedure sp_deleteallconstraints as exec sp_msforeachtable 'alter table ? nocheck constraint all' exec sp_msforeachtable 'alter table ? disable trigger all' if exists (select name from  sysobjects where name = 'sp_deletealldata' and type = 'p') drop procedure dbo.sp_deletealldata create procedure sp_deletealldata as exec sp_msforeachtable 'delete from ?' if exists (select name from  sysobjects where name = 'sp_enableallconstraints' and type = 'p') drop procedure dbo.sp_enableallconstraints;
select @name = (select top 1 [name] from sysobjects where [type] = 'p' and category = 0 order by [name]) select @sql = 'drop procedure [dbo].[' + rtrim(@name) +']' exec (@sql) select @name = (select top 1 [name] from sysobjects where [type] = 'p' and category = 0 and [name] > @name order by [name]) end go select @name = (select top 1 [name] from sysobjects where [type] = 'v' and category = 0 order by [name]) select @sql = 'drop view [dbo].[' + rtrim(@name) +']' exec (@sql) select @name = (select top 1 [name] from sysobjects where [type] = 'v' and category = 0 and [name] > @name order by [name]) end go select @name = (select top 1 [name] from sysobjects where [type] in (n'fn', n'if', n'tf', n'fs', n'ft') and category = 0 order by [name]) select @sql = 'drop function [dbo].[' + rtrim(@name) +']' exec (@sql) select @name = (select top 1 [name] from sysobjects where [type] in (n'fn', n'if', n'tf', n'fs', n'ft') and category = 0 and [name] > @name order by [name]) end go select @name = (select top 1 table_name from information_schema.table_constraints where constraint_catalog=db_name() and constraint_type = 'foreign key' order by table_name) select @constraint = (select top 1 constraint_name from information_schema.table_constraints where constraint_catalog=db_name() and constraint_type = 'foreign key' and table_name = @name order by constraint_name) select @sql = 'alter table [dbo].[' + rtrim(@name) +'] drop constraint [' + rtrim(@constraint) +']' exec (@sql) select @constraint = (select top 1 constraint_name from information_schema.table_constraints where constraint_catalog=db_name() and constraint_type = 'foreign key' and constraint_name <> @constraint and table_name = @name order by constraint_name) end select @name = (select top 1 table_name from information_schema.table_constraints where constraint_catalog=db_name() and constraint_type = 'foreign key' order by table_name) end go select @name = (select top 1 table_name from information_schema.table_constraints where constraint_catalog=db_name() and constraint_type = 'primary key' order by table_name) select @constraint = (select top 1 constraint_name from information_schema.table_constraints where constraint_catalog=db_name() and constraint_type = 'primary key' and table_name = @name order by constraint_name) select @sql = 'alter table [dbo].[' + rtrim(@name) +'] drop constraint [' + rtrim(@constraint)+']' exec (@sql) select @constraint = (select top 1 constraint_name from information_schema.table_constraints where constraint_catalog=db_name() and constraint_type = 'primary key' and constraint_name <> @constraint and table_name = @name order by constraint_name) end select @name = (select top 1 table_name from information_schema.table_constraints where constraint_catalog=db_name() and constraint_type = 'primary key' order by table_name) end go select @name = (select top 1 [name] from sysobjects where [type] = 'u' and category = 0 order by [name]) select @sql = 'drop table [dbo].[' + rtrim(@name) +']' exec (@sql) select @name = (select top 1 [name] from sysobjects where [type] = 'u' and category = 0 and [name] > @name order by [name]) end go;
set scripting options;
select 'truncate table ' + d.name + ';' from   sys.tables d where  type = 'u';
set nocount on select 'use [' + db_name() +']';
( select 0 as lvl, t.object_id as tblid from sys.tables t where t.is_ms_shipped = 0 and t.object_id not in (select f.referenced_object_id from sys.foreign_keys f) union all  select a.lvl + 1 as lvl, f.referenced_object_id as tblid from a and a.tblid <> f.referenced_object_id ) select 'delete from ['+ object_schema_name(tblid) + '].[' + object_name(tblid) + ']' from a;
exec sp_msforeachtable 'alter table ? nocheck constraint all' exec sp_msforeachtable 'alter table ? disable trigger all' exec sp_msforeachtable 'delete from ?' exec sp_msforeachtable 'alter table ? check constraint all' exec sp_msforeachtable 'alter table ? enable trigger all' exec sp_msforeachtable 'select * from ?';
set @mydoc = select @mydoc.query('/*:root/*:child') -- whole tag select @mydoc.value('(/*:root/*:child)[1]', 'varchar(255)') -- only value;
select roles from mytable where roles.exist('(/*:root/*:role[contains(.,"beta")])') = 1;
select * from ( select onlinecontractid, distributorid, sponsorid, [requestxml].value(n'/onlinecontractds[1]/properties[1]/name[1]', 'nvarchar(30)') as [name] from [onlinecontract]) as olc where olc.name like '%email%' and olc.value like '%email%' and olc.locale='uk en';
select * from table1 where roles.exist ('/root/role = sql:variable("@role")') = 1;
select roles from mytable where roles.value('(/root/role)[1]', 'varchar(max)') like 'stringtosearchfor';
select [data] from [dbo].[codesystemcodes_data] where cast([data] as xml).value('(/utilities.codesystems.codesystemcodes/@codesystem)[1]', 'varchar(max)') = '2';
create table mytable (roles xml);
select * from from mytable cross apply where rolename like '%ga%';
set @role = 'beta' select roles from @t where roles.exist('/root/role/text()[. = sql:variable("@role")]') = 1;
where col like '%beta%';
set @role = 'et' select roles from @t where roles.exist('/root/role/text()[contains(., sql:variable("@role"))]') = 1;
table [dbo].[log_xml] contains columns parametrs (xml),timeedit (datetime);
select parametrs,timeedit from [dbo].[log_xml] where parametrs.value('(//*:record/batch)[1]', 'varchar(max)') like '%a1%';
select * from xmltable where convert(varchar(max),xmlfield) like '%<role>'+@role+'</role>%';
select * from from mytable (nolock) where texty like '%mysearchtext%';
create table toll_booths ( id            integer       not null primary key, name          varchar(255)  not null, ... ) create table cars ( vin           varchar(17)   not null primary key, license_plate varchar(10)   not null, ... ) create table drive_through ( id            integer       not null primary key, toll_booth_id integer       not null references toll_booths(id), vin           varchar(17)   not null references cars(vin), at            timestamp     default current_timestamp not null, amount        numeric(10,4) not null, ... );
select @myvariable;
select @myvariable = 'john said to emily "hey there emily"' select @myvariable;
create function [dbo].[sdf_splitstring] ( @sstring nvarchar(2048), @cdelimiter nchar(1) ) as begin if @sstring is null return @ipos int if substring( @sstring, 1, 1 ) = @cdelimiter set @istart = 2 end else set @istart = 1 set @ipos = charindex( @cdelimiter, @sstring, @istart ) if @ipos = 0 set @ipos = len( @sstring )+1 if @ipos - @istart > 0 values  ( substring( @sstring, @istart, @ipos-@istart )) else insert into @tparts set @istart = @ipos+1 if @istart > len( @sstring ) end return end;
create function fnsplittotableint ( @param nvarchar(4000) ) ( select 1 union all select number + 1 from numbers where number < 4000 found as ( select number as posidx, convert(int, ltrim(rtrim(convert(nvarchar(4000), substring(@param, number, charindex(n',' collate latin1_general_bin, @param + n',', number) - number))))) as value from numbers where number <= len(@param) and substring(n',' + @param, number, 1) = n',' collate latin1_general_bin ) select posidx, case when isnumeric(value) = 1 then convert(int, value) else convert(int, null) end as value from found;
select * from fnsplittotableint ( '9, 8, 7, 6, 5, 4, 3, 2, 1, 0, ' + );
create function [dbo].[split]( @delimited nvarchar(max), @delimiter nvarchar(100) as begin set @xml = n'<t>' + replace(@delimited,@delimiter,'</t><t>') + '</t>' select  r.value('.','varchar(max)') as item from  @xml.nodes('/t') as records(r) end;
select * from dbo.split('1,2,3,4,5,6,7,8,9,10,11,12,13,14,15',',');
create function [dbo].[csvtoint] ( @array varchar(4000)) as begin set @separator = ',' set @array = @array + ',' select @separator_position = patindex('%,%' , @array) select @array_value = left(@array, @separator_position - 1) values (cast(@array_value as int)) select @array = stuff(@array, 1, @separator_position, '') end;
set ansi_nulls on set quoted_identifier on create function [dbo].[splitintobigints] as return ( with splittedxml as( select cast('<v>' + replace(@list, @splitter, '</v><v>') + '</v>' as xml) as splitted ) select x.v.value('.', 'bigint') as value from splittedxml );
create function dbo.[string.split] ( @text varchar(max), @delimiter varchar(100), @index int ) as begin ( select 0 a, 1 b union all select b, convert(int,charindex(@delimiter, @text, b) + len(@delimiter)) from cte where b > a ) select substring(@text,a,case when b > len(@delimiter) then b-a-len(@delimiter) else len(@text) - a + 1 end) value from cte where a >0 select      @r from        @a where       id = @index + 1 end  select dbo.[string.split]('121,2,3,0',',',1) -- gives '2';
set @str = '1,2,3,4,5,6,7,8,9,10,11,12,13,14,15' set @delimiter = ',' set @xml = cast(('<x>'+replace(@str, @delimiter, '</x><x>')+'</x>') as xml) select c.value('.', 'varchar(10)') as value from @xml.nodes('x') as x(c);
set @str = '1,2,3,4,5,6,7,8,9,10,11,12,13,14,15' set @delimiter = ',' ( select 0 a, 1 b union all select b, charindex(@delimiter, @str, b) + len(@delimiter) from cte where b > a ) select substring(@str, a, case when b > len(@delimiter) then b - a - len(@delimiter) else len(@str) - a + 1 end) value from cte where a > 0;
set @csv = @csv + ',';
set @csv = replace(@csv, ',,', ',');
select charindex(',', @csv) idx, substring(@csv, 1, charindex(',', @csv) - 1) [value] union all select charindex(',', @csv, idx + 1), substring(@csv, idx + 1, charindex(',', @csv, idx + 1) - idx - 1) from ctecsv where charindex(',', @csv, idx + 1) > 0 ) select [value] from ctecsv;
create function [dbo].[delimitedsplit8k] select 1 union all select 1 union all select 1 union all select 1 union all select 1 union all select 1 union all select 1 union all select 1 union all select 1 union all select 1 select top (isnull(datalength(@pstring),0)) row_number() over (order by (select null)) from e4 ctestart(n1) as (--==== this returns n+1 (starting position of each "element" just once for each delimiter) select 1 union all select t.n+1 from ctetally t where substring(@pstring,t.n,1) = @pdelimiter ctelen(n1,l1) as(--==== return start and length (for use in substring) select s.n1, isnull(nullif(charindex(@pdelimiter,@pstring,s.n1),0)-s.n1,8000) from ctestart s ) select itemnumber = row_number() over(order by l.n1), item       = substring(@pstring, l.n1, l.l1) from ctelen l;
select try_cast(value as int) from   string_split ('1,2,3,4,5,6,7,8,9,10,11,12,13,14,15', ',');
select c.value('.', 'varchar(10)') as value from @xml.nodes('x') as x(c);
create function [dbo].[udf_split] ( @liststring nvarchar(max), @delimiter  nvarchar(1000), @includeempty bit) as begin select @id = 1, @l = len(replace(@delimiter,' ','^')), @liststring = @liststring + @delimiter, @currentposition = 1 select @nextposition = charindex(@delimiter, @liststring, @currentposition) set  @item = ltrim(rtrim(substring(@liststring, @currentposition, @nextposition-@currentposition))) if      @includeempty=1 or len(@item)>0 begin set @id = @id+1 end set  @currentposition = @nextposition+@l set  @nextposition = charindex(@delimiter, @liststring, @currentposition) end return end;
set ansi_nulls on set quoted_identifier on alter function [dbo].[split] as begin set @list = replace(@list,'''','') select value = ltrim(rtrim(substring(@list,1,charindex(@spliton,@list)-1))) set @list = substring(@list,charindex(@spliton,@list)+len(@spliton),len(@list)) end  select value = ltrim(rtrim(@list)) end go select * from [clv].[split] ('1,2,3,3,3,3,',',');
create function split ( @delimited nvarchar(max), @delimiter nvarchar(100) ( -- id column can be commented out, not required for sql splitting string ) as begin set @xml = n'<root><r>' + replace(@delimited,@delimiter,'</r><r>') + '</r></root>' select r.value('.','varchar(max)') as item from @xml.nodes('//root/r') as records(r) end go;
select * from dbo.split(n'1,2,3,4,6',',');
select ril.* from (select ril.*, row_number() over (order by t_stamp desc) as seqnum from raceway_input_labo ril where seqnum = 1;
select * from (select rownum, deptno, ename from scott.emp ) where rownum <= 3 rownum    deptno    ename select * from ( select deptno, ename from scott.emp ) where rno <= 3;
where m_api_log.created_date between to_date('10/23/2015 05:00', 'mm/dd/yyyy hh24:mi') and to_date('10/30/2015 23:59', 'mm/dd/yyyy hh24:mi');
select t.* from raceway_input_labo t where t.t_stamp = (select max(t_stamp) from raceway_input_labo) limit 1;
drop view if exists view_name;
if object_id('nview', 'v') is not null drop view nview;
if object_id( 'nprocedure', 'p' ) is not null drop procedure dbo.sprocname;
if exists( select 1 from   sys.objects where  object_id = object_id('[schemaname].[viewname]') and type_desc = 'view' ) end;
if not exists ( select 1 from   sysobjects where  name = '[schemaname].[viewname]' and xtype = 'v' ) end;
if exists ( select 1 from sys.views where object_id = object_id(n'[schemaname].[viewname]') ) end;
if exists ( select 1 from   information_schema.views where  table_name = 'viewname' and table_schema = 'schemaname' ) end;
if exists( select object_id('viewname', 'v') ) end;
if exists ( select 1 from   sys.sql_modules where  object_id = object_id('[schemaname].[viewname]') ) end;
if exists(select 1 from sys.objects where object_id=object_id(@viewname) and type_desc='view') end;
if exists (select * from sys.views where object_id = object_id(n'[dbo].[mytable]') );
select cast('['+schema_name(schema_id)+'].['+name+']' as sysname) as viewname from sys.views set @cmd='select * from '+@viewname exec (@cmd) end try end catch end close check_cursor;
select 1 else select 0", viewname));
if exists(select * from sys.views where name = '');
select count(*) from information_schema.views where table_name = 'myview' and table_schema = 'myschema';
select foo, bar, fizz, buzz from initial_table;
select * from old_tablename;
select columns.... from initial_table where column=value;
set identity_insert sometablewithidentity on;
set identity_insert sometablewithidentity off;
create table students ( student_id serial primary key, player_name text;
create table tests ( subject_id serial, subject_name text, higheststudent_id integer references students;
create table tests ( subject_id serial, subject_name text, higheststudent_id integer references students (student_id);
create table tests ( subject_id serial, subject_name text, higheststudent_id integer, constraint fk_tests_students;
create table tests ( subject_id serial, subject_name text, higheststudent_id integer alter table tests add constraint fk_tests_students;
select group_concat(accountsno) as accounts from `tblaccounts` group by mobilenumber;
select group_concat(taskname) from tasks;
select group_concat(taskname) from tasks;
select group_concat(distinct taskname order by taskname desc) from tasks;
select group_concat(distinct taskname separator ' + ') from tasks;
select group_concat(taskid, ') ', taskname separator ' ') from tasks;
select ar.artistname, group_concat(al.albumname) from artists ar;
select concat(col1, ',', col2) as foo_bar from table1;
select p.id, p.name, group_concat(s.name) as site_list from sites s;
select result.* from ( [query 1] union [query 2];
select * from ( select 1 as rank, id, add_date from table union all select 2 as rank, id, add_date from table where distance < 5 union all select 3 as rank, id, add_date from table where distance between 5 and 15;
select field1, field2, '1' as union_sort union select field1, field2, '2' as union_sort union select field1, field2, '3' as union_sort;
select * from (select values1 from table1 order by orderby1) as a union all select * from (select values2 from table2 order by orderby2) as b;
union (select * from table where distance>0 and distance<=5 order by add_date);
union (select * from table where distance>0 and distance<=5);
table1.column2, foo1.column4 from table1, table2, foo1, table5 where table5.somerecord = table1.column1 ) union  );
union (select add_date,col2 from table_name) union (select add_date,col2 from table_name);
select * from ( select col1, col2 from table a limit by 200 union all select * from ( select cola, colb from table b limit by 300;
union all (select 2 as rank, id, add_date from my_table where distance between 5 and 15 order by rank limit 9999999999) union all (select 3 as rank, id, add_date from my_table where distance between 5 and 15 order by id limit 9999999999);
set @job_name = n'some title';
set @description = n'periodically do something';
set @owner_login_name = n'login';
set @database_name = n'database_name';
if exists(select job_id from msdb.dbo.sysjobs where (name = @job_name)) exec msdb.dbo.sp_delete_job end  exec  msdb.dbo.sp_add_job @enabled=1, @notify_level_eventlog=0, @notify_level_email=2, @notify_level_netsend=2, @notify_level_page=2, @delete_level=0, @description=@description, @category_name=n'[uncategorized (local)]', @owner_login_name=@owner_login_name;
exec msdb.dbo.sp_add_jobserver @job_name=@job_name;
exec msdb.dbo.sp_add_jobstep @step_name=n'execute sql', @step_id=1, @cmdexec_success_code=0, @on_success_action=1, @on_fail_action=2, @retry_attempts=0, @retry_interval=0, @os_run_priority=0, @subsystem=n'tsql', @command=n'exec my_stored_procedure; -- or any sql statement', @database_name=@database_name, @flags=0;
exec msdb.dbo.sp_update_job @enabled=1, @start_step_id=1, @notify_level_eventlog=0, @notify_level_email=2, @notify_level_netsend=2, @notify_level_page=2, @delete_level=0, @description=@description, @category_name=n'[uncategorized (local)]', @owner_login_name=@owner_login_name, @notify_email_operator_name=n'', @notify_netsend_operator_name=n'', @notify_page_operator_name=n'';
exec msdb.dbo.sp_add_jobschedule @name=n'daily', @enabled=1, @freq_type=4, @freq_interval=1, @freq_subday_type=1, @freq_subday_interval=0, @freq_relative_interval=0, @freq_recurrence_factor=1, @active_start_date=20170101, --yyyymmdd;
exec msdb.dbo.sp_add_job @enabled = 1, @description = n'procedure execution every day' ;
exec msdb.dbo.sp_add_jobstep @step_name = n'run procedure', @subsystem = n'tsql', @command = 'exec backupfromconfig';
exec msdb.dbo.sp_add_schedule @freq_type = 4,  -- daily start @active_start_time = '230000' ;   -- start time 23:00:00 exec msdb.dbo.sp_attach_schedule @schedule_name = n'everyday schedule' ;
exec msdb.dbo.sp_add_jobserver @server_name = @@servername ;
exec sp_add_schedule;
@databasename nvarchar(512) set @databasename = 'databasename' set @pathname = 'c:\dbbackup\dbdata\dbbackup' + convert(varchar(8), getdate(), 112) + '_' + replace((convert(varchar(8), getdate(), 108)),':','-')+ '.bak' backup database @databasename to disk = @pathname with noformat, init, name = n'', skip, norewind, nounload, stats = 10;
select substring(master.dbo.fn_varbintohexstr(hashbytes('md5', 'helloworld')), 3, 32);
select convert(nvarchar(32),hashbytes('md5', 'hello world'),2);
select convert(varchar(32),hashbytes('md5', 'hello world'),2) select upper(master.dbo.fn_varbintohexsubstring(0, hashbytes('md5', 'hello world'), 1, 0));
select count(id), `tag` from `images-tags` limit 20;
select count(id), `tag` from `images-tags` limit 20;
select count(id), `tag` from `images-tags` limit 20;
select 'tag', counts.cnt from ( select count(*) as cnt, 'tag' from 'images-tags';
select count(id) as thecount, `tag` from `images-tags` limit 20;
select  data_collector_id , count (data_collector_id ) as frequency from rent_flats where is_contact_person_landlord = 'true';
update b set column2 = a.column2, column3 = a.column3 from a where a.id = b.id;
update b set column2 = (select column2 from a where id = b.id), column3 = (select column3 from a where id = b.id);
select 'update b set   (' || string_agg(        quote_ident(column_name), ',') || ') from   a where  b.id = 123 and    a.id = b.id' from   information_schema.columns where  table_name   = 'a'       -- table name, case sensitive and    table_schema = 'public'  -- schema name, case sensitive and    column_name <> 'id'      -- all columns except id end $do$;
where  b.id = 123;
update b set   (  column1,   column2,   column3) from   a where  b.id = 123    -- optional, to update only selected row and    a.id = b.id;
update b set   (column1, column2, column3, column4) ) from ( select * from   a where  b.id is null  -- only if anything actually changes and    a.id = 123    -- optional, to update only selected row where b.id = ab.id;
where  b.id is null;
update tbl_b b set   (  column1,   column2,   column3) from   tbl_a a where  b.id = 1 and    a.id = b.id;
update a a, b b, set a.column1=b.column1 where b.id=1;
update a a, b b, set a.column1=b.column1, a.column2=b.column2 where b.id=1;
create table a ( id            int, column1       text, column2       text, column3       text create table b ( column4       text;
update b set column1 = a.column1, column2 = a.column2, column3 = a.column3 from a where a.id = b.id and b.id = 1;
:conditions => ["name like  ? or postal_code like ?", "%#{search}%","%#{search}%"],   order => 'name' end;
where mycolumn like '%\_%' escape '\';
select m.* from manager m where m.managerid    like  '[_]%' and   m.managername  like '%[_]%';
select * from manager where managerid like '\_%' escape '\' and managername like '%\_%' escape '\';
select * from manager where managerid like '#_%' escape '#' and managername like '%#_%' escape '#';
where mycolumn like '%\\_%';
select * from manager where managerid like '\_%' escape '\' and managername like '%\_%' escape '\';
select greatest(a.date0, b.date0) as date0, least(a.date1, b.date1) as date1 from a, b where b.x = a.x;
select greatest(a.date0, b.date0) as `date0`,least(a.date0, b.date0) as `date1` from a join  b;
select least(null,now());
select greatest(null,now());
as basis for the keys in the row dictionary. and databases usually generate names for these columns in a as a result, accessing the columns through dictionary keys;
if fetch is none:;
if fetch is none:;
delete from @tablevariablename;
drop table @temptablevariable -- invalid;
set @tablename = '_rj_tempov4' set @sql = 'drop table dbo.' + quotename(@tablename) + '';
if  exists (select * from sys.objects where object_id = object_id(@tablename) and type in (n'u')) exec sp_executesql @sql;
select * from dbo.my_table t where t.createdon > '2021-01-01' select * from #recent_records drop table #recent_records;
select * from dbo.my_table t where t.createdon > '2021-01-01' select * from #recent_records;
alter user orphanuser with login = correctedloginname;
if @test= 1 select *from production.product where productid = 980;
end -- generate a constraint violation error. delete from production.product where productid = 980;
if @test= 1 select *from production.product where productid = 980;
if @@trancount > 0 end end try select error_number() as errornumber if @@trancount > 0 end catch;
if @@trancount > 0 and @test = 0;
delete from production.product where productid = 980;
end try select error_number() as errornumber if @@trancount > 0 end catch;
if @@trancount > 0;
select u.name, u.subject, u.marks from student s ( marks;
select * from ( select name, subject, case subject end as marks from studentmarks where marks is not null;
select name, subject, marks from studentmarks values (maths,'maths'),(science,'science'),(english,'english') where marks is not null;
alter database [yourdbname] set offline with rollback immediate;
alter database [yourdbname] set online;
select @spid = min(spid)  from master..sysprocesses  where dbid = db_id('<database_name>') and spid != @@spid set @sql = 'kill ' + cast(@spid as varchar) exec (@sql) select @spid = min(spid) from master..sysprocesses where dbid = db_id('<database_name>') and spid != @@spid end ;
alter database adventureworksdw set single_user;
alter database adventureworksdw set single_user from ...;
alter database databasename set offline with rollback immediate;
from disk = 'path of bak file' move 'logfile_log' to 'd:\newdata\data_log.ldf',replace alter database databasename set online with rollback immediate;
set @sql = 'del c:\prodaeandaexdatabackup\ae11.bak' exec master..xp_cmdshell @sql;
set @cmdstring = 'copy \\share\sqldbbackup\ae11.bak c:\prodaeandaexdatabackup' exec master..xp_cmdshell @cmdstring;
from disk = n'c:\prodaeandaexdatabackup\ae11.bak' move 'ae11_log' to 'd:\sql_logs\ae11.ldf', recovery;
from disk = 'c:\program files\microsoft sql server\mssql12.mssqlserver\mssql\backup\my_db_backup.bak';
alter database my_db set single_user with rollback immediate;
from disk = 'c:\program files\microsoft sql server\mssql12.mssqlserver\mssql\backup\my_db_backup.bak' move 'com.my_db' to 'c:\program files\microsoft sql server\mssql12.mssqlserver\mssql\data\com.my_db.mdf', move 'com.my_db_log' to 'c:\program files\microsoft sql server\mssql12.mssqlserver\mssql\data\com.my_db_log.ldf' alter database my_db set multi_user;
select replicate('0',6-len(employeeid)) + employeeid;
select replicate('0',6-len(rtrim(employeeid))) + rtrim(employeeid);
select right(employeeid,(len(employeeid) - patindex('%[^0]%',employeeid)) + 1);
select right('000000' + convert(nvarchar, employeeid), 6) as empidtext, employeeid from dbo.requestitems where id=0;
select replicate('0', 6 - len(employeeid)) + convert(varchar, employeeid) as employeeid from dbo.requestitems where id=0;
select cast(replace(str(employeeid,6),' ','0')as char(6)) from dbo.requestitems where id=0;
select stuff('000000', 6-len(@empnumber)+1, len(@empnumber), @empnumber);
select stuff('000000', 6-len(employeeid)+1, len(employeeid), employeeid) as employeecode from dbo.requestitems where id=0;
select format(employeeid, '000000') from dbo.requestitems where id=0;
select format(employeeid,'000000') from dbo.requestitems where id=0;
select right(replicate('0',6) + employeeid, 6) from dbo.requestitems where id=0;
select employeeid*1 as employeeid;
@length tinyint = 15, @decimals tinyint = 0 select replicate('-', charindex('-', @n, 1)) + replace(replace(str(@n, @length, @decimals), '-', ''), ' ', '0');
select concat(repeat('0', 6-length(emplyeeid)), emplyeeid) as emplyeeid from dbo.requestitems`;
select concat(col1, '<delimiter>', col2, ...) as concat_column_name from <table_name>;
select col1 || col2 as concat_column_name from <table_name>;
"new_column", concat( when(col("col1").isnotnull, col("col1")).otherwise(lit("null")), when(col("col2").isnotnull, col("col2")).otherwise(lit("null"))));
"new_column", concat( when(col("col1").isnotnull(), col("col1")).otherwise(lit("null")), when(col("col2").isnotnull(), col("col2")).otherwise(lit("null"))));
concat(col("col1"), lit("_"), col("col2"), lit("_"), col("col3")));
if (instance == null) {;
"new_column", concat( when(col("col1").isnotnull, col("col1")).otherwise(lit("null")), when(col("col2").isnotnull, col("col2")).otherwise(lit("null"))));
from pyspark.sql import functions as sf;
sf.concat(sf.col('colname1'),sf.lit('_'), sf.col('colname2')));
from pyspark.sql import functions as f;
from pyspark.sql.functions import concat, col, lit;
case class mydf(col1: string, col2: string) array(mydf("a", "b"), mydf("c", "d"), mydf("e", "f"));
from pyspark.sql.functions import concat, lit;
update sqlite_sequence set seq=0 where name='table_name';
values = new contentvalues();
delete from your_table;
delete from sqlite_sequence where name='your_table';
select * from table_name where date_field = date_sub(current_date(),interval 1 day);
select * from ttable where datediff(day,ttable.datetimecolumn ,getdate()) = 1 -- yesterday;
where `date` = curdate() - interval 1 day;
select * from table where day(datefield) = (day(getdate())-1) and month(datefield) = (month(getdate())) and year(datefield) = (year(getdate()));
where cast(columnname as date) = cast(getdate() -1 as date);
set @end = dateadd(second, 86399, @end);
select * from table_name where cast(column_name as date) =;
select * from `login` where `dattime` <= subdate(now(),1) and `dattime` > subdate(now(),2);
select * from tablename where date >= dateadd(day, datediff(day, 1, getdate()), 0) and date < dateadd(day, datediff(day, 0, getdate()), 0);
select * from tablename where date >= dateadd(day, -1, convert(date, getdate())) and date < convert(date, getdate());
select dateadd(day,datediff(day,0,getdate()),0);
select dateadd(day,datediff(day,1,getdate()),0);
select * from yourtable where yourdate >= dateadd(day,datediff(day,1,getdate()),0) and yourdate < dateadd(day,datediff(day,0,getdate()),0);
select * from table_name where;
select * from `tablename` where 1=1 and column2 = 'value2';
and <condition>;
select * from `tablename` where 1=1 and (columnname1 = 'value' or columnname2 = 'value');
select * from `tablename` where 1=1 and (columnname1 = 'value' or columnname2 = 'value');
select * from tablename where 1;
select * from tablename where 1=1;
create table [dbo].[tblsysidentities]( [inttableid] [int] not null, [intidentitylast] [int] not null, [strtable] [varchar](100) not null, [tsconcurrency] [timestamp] null, constraint [pk_tblsysidentities] primary key clustered ( [inttableid] asc;
if object_id ('dbo.trgtblsystrackermessagesidentity', 'tr') is not null drop trigger dbo.trgtblsystrackermessagesidentity;
create trigger trgtblsystrackermessagesidentity set @introwcount = (select count(*) from inserted) set @inttrackermessageid = (select intidentitylast from tblsysidentities where inttableid=1) update tblsysidentities set intidentitylast = @inttrackermessageid + @introwcount where inttableid=1 [inttrackermessageid], [inttrackerid], [strmessage], [inttrackermessagetypeid], [datcreated], [strcreatedby]) select @inttrackermessageid + row_number() over (order by [datcreated]) as [inttrackermessageid], [inttrackerid], [strmessage], [inttrackermessagetypeid], [datcreated], [strcreatedby] from inserted;
select top 1 @inttrackermessageid + @introwcount from inserted;
select * from your_table where some_column is null or some_column = '';
create table your_table (id int, some_column varchar(10));
select id from your_table where some_column is null or some_column = '';
select x from some_table where some_column is null or some_column = '';
where some_column is null or some_column = '';
where ifnull(some_column, '') = '';
where coalesce(some_column, '') = '';
where ifnull(length(some_column), 0) = 0;
alter database scoped configuration set identity_cache=off ;
select @newid = max(yourbuggedidcolumn) from your_table_name;
set ansi_nulls on set quoted_identifier on alter procedure [dbo].[resettablenameidentityafterrestart] as begin select @id =  max(id) from [databasename].dbo.[tablename] end;
exec sp_procoption 'resetorderidentityafterrestart', 'startup', 'on';
alter database scoped configuration  set identity_cache = off;
select names from nicknames where id = 1;
alter product add color varchar(80);
if itemexpected and char not in [']', ',', '[']: if mode == "int": if i in ["true", "true"]:;
if string[-1] == ',':;
set @somevar := '';
select @somevar as user_name from users where (@somevar := `u_name`) = "john";
select user_name from ( select name as user_name from   users where  user_name = "john";
select u_name as user_name from users having user_name = "john";
select nodes.*, (select (count(*) from attachments where attachments.nodeid = nodes.id) as attachmentcount from nodes where attachmentcount > 0;
select nodes.*, (select (count(*) from attachments where attachments.nodeid = nodes.id) as attachmentcount from nodes where (select (count(*) from attachments where attachments.nodeid = nodes.id) > 0;
select u_name as user_name from users having user_name = "john";
select u_name as user_name from users where u_name = "john";
select u_name as user_name , (select last_name from users2 where id=users.id) as user_last_name from users  where u_name = "john" having user_last_name ='smith';
select  patient, patient_id from `patient` where patient in ('user4', 'user3');
select  patient, patient_id from `patient` where patient = 'user1' or patient = 'user2';
select u_name as user_name from users where u_name = 'john';
select u_name as user_name from   users where  u_name = "john";
select user_name from ( select u_name as user_name from   users ) where  u_name = "john";
select u_name as user_name from users where u_name = "john";
select distinct(u_name) as user_name from users where u_name = "john";
where somecomplicatedfunctionof(table.column) = @param --silly;
rowid int not null identity(1,1) primary key, someuniquecolumn varchar(25) not null, somenotuniquecolumn varchar(50) null, unique(someuniquecolumn) );
set transaction isolation level read uncommitted;
select   i.make, i.model, i.price from     dbo.inventory i where    i.color = 'red' and    i.price between 15000 and 18000;
create index idx01 on dbo.inventory (price, color) create index idx02 on dbo.inventory (color, price);
select * from orders (nolock) where username = 'momma';
update table set @variable = column = @variable + othercolumn;
update table set @variable = @variable + othercolumn, column = @variable;
select * from table1 where table1.id not in ( select table1id from table2);
select table1.* from table1 where table2.id is null;
select * from table1 intersect  select * from table2;
select distinct t1 from table1 where exists (select t2 from table2 where table1.t1 = t2 );
select cola, colb from table1 t1 where exists (select * from table2 where column = t1.cola);
create table customer ( id integer not null primary key, name varchar(150) not null, city varchar(30), state varchar(30), zip varchar(10));
create index k1_customer on customer(id, name);
select telephone from users where name='john';
database development;
select * into #temp from master..spt_values select @starttime = getdate() update #temp set number = 0 select datediff(ms, @starttime, getdate()) select @starttime = getdate() update #temp set number = 0 where name = @name end select datediff(ms, @starttime, getdate()) drop table #temp;
select <...> from a.table1 t1 join b.table2 t2 on t2.column2 = t1.column1;
select * select t1.*,t2.column2 select a.table1.column1, t2.*;
select * from a.tablea join b.tableb;
select * from a.tablea join b.tableb;
select <...> from a.table1 t1 join b.table2 t2 on t2.column2 = t1.column1;
select <...> from a.tablea join b.tableb;
set collation_connection = 'utf8_general_ci';
alter database your_database_name character set utf8 collate utf8_general_ci;
alter table your_table_name convert to character set utf8 collate utf8_general_ci;
alter table keywords character set utf8; -- run once;
set names 'utf8';
set character set 'utf8';
alter table `my_table` change `my_column` `my_column` varchar(10) charset utf8;
set collation_connection = 'latin1_swedish_ci';
select field1, field2, uniqueid from mytable where uniqueid = @id;
select field2, null, ..., field529, field1 from mytable where field1 = @id;
select newguid(), // don't know this syntax, sorry column2, uniqueid, from mytable where uniqueid = @id;
select field1, field2, null, key from mytable where uniqueid = @id;
select * into #temprow from sourcetable where keycolumn = 'abc';
update #temprow set keycolumn = 'xyz';
delete #temprow;
drop table #temprow;
set @columnstocopyvalues = ''</p> select @columnstocopyvalues = @columnstocopyvalues  + [name] + ', ' from sys.columns c where c.object_id = object_id('yourtablename') and name not in ('indentitycolumn','column1','column2') select @columnstocopyvalues = substring(@columnstocopyvalues, 0, len(@columnstocopyvalues)) exec (@query);
select rcrdid+112, profesion, name, surname, age, rcrdtyp, rcrdlcu, rcrdlct, rcrdlcd from frien01p;
set getcolumns = conn.execute(sqlcolums);
if colname = "original-identity-field-name" then ' assuming that your primary key is the first field dont worry about commas and spaces else columnlistsource = columnlistsource & colname end if;
select * into temptable from mytable_t where id = 1;
alter table temptable drop column id;
drop table temptable;
select * into #temptable from [mytable] where [indexfield] = :id;
alter table #temptable drop column [indexfield];
drop table #temptable;
alter table tablename modify setting boolean null;
alter table tablename change column setting setting bit(1) null default null;
select p.person_id, nvl(a.nb_apptmts, 0) from from person) p (select person_id, count(*) as nb_apptmts from appointment;
select person.person_id, count(appointment.person_id) as "number_of_appointments" from person;
select person.person_id, count(appointment.person_id) as "number_of_appointments" from person;
select wardno,count(wardcode) from maipadh;
select wardno,count(wardcode) from mswardh;
select person.person_id, count(appointment.person_id) as "number_of_appointments" from appointment;
select person.person_id, (select count(*) from appointment where person.person_id = appointment.person_id) as 'appointments' from person;
select * from information_schema.tables where isnumeric(table_name) = 1 and cast(table_name as int) <> 0;
select * from mytable where param = cast('10; drop table other' as varchar(30));
select * from product;
select distinct(product_name), (select count(product_name) from product  where product_name = prod.product_name) as `product_count` from product as prod;
select count(1) from (select distinct productid where keyword = '$keyword') temp;
select count(distinct productid) where keyword='$keyword';
select count(productid),  keyword  from `table_name` group by keyword;
select count(distinct productid) from table_name where keyword='$keyword';
select count(distinct productid) from  table_name where keyword='$keyword';
select count(*) from t1 group by keywork;
select count(*), productid from products where keyword = '$keyword';
values (160,145);
select weight, desiredweight from anothertable where id = 1;
update users set weight = 160, desiredweight = 145 where id = 1;
select val1 , val2  from tablexshoulatnotbeusers where somecondition;
update users set weight=160, desiredweight=145  where id = 1;
create temporary table xtable ( weight int(11), desiredweight int(11) ;
select weight, desiredweight from users where [condition] select weight , desiredweight from xtable;
select '$userweight', '$userdesiredweight' from (select 1 a ) dummy where '$userweight' != '' and '$userdesiredweight'!='';
select '$userweight', '$userdesiredweight' from (select 1 a ) dummy where '$userweight' != '' and '$userdesiredweight'!='';
update users set weight=160,desiredweight=145 where id=1;
select account_no, name from customers where city = 'newark';
select count(*) from customers where city = 'newark';
select supplier_id, supplier_name, 'advertising' from suppliers where not exists (select * from clients where clients.client_id = suppliers.supplier_id);
select 10345, 'ibm', 'advertising' from dual where not exists (select * from clients where clients.client_id = 10345);
select from users where id = 1;
update users set (weight = 160, desiredweight = 145) where id = 1;
update users set weight=160, desiredweight= 145 where id = 1;
select from users where id = 1;
update table set column = value where columnid = 1;
update users set weight='160',desiredweight ='145' where id =1;
select column1, column2, column3, ... from table1 where condition;
select table_name, pg_size_pretty( pg_relation_size(quote_ident(table_name)) ) from information_schema.tables where table_schema = 'public';
select current_database() as database, pg_size_pretty(total_database_size) as total_database_size, schema_name, table_name, pg_size_pretty(total_table_size) as total_table_size, pg_size_pretty(table_size) as table_size, pg_size_pretty(index_size) as index_size from ( select table_name, table_schema as schema_name, pg_database_size(current_database()) as total_database_size, pg_total_relation_size(table_name) as total_table_size, pg_relation_size(table_name) as table_size, pg_indexes_size(table_name) as index_size from information_schema.tables where table_schema=current_schema() and table_name like 'table_%';
database  | total_database_size | schema_name | table_name | total_table_size | table_size | index_size;
select table_name, pg_size_pretty( pg_total_relation_size(quote_ident(table_name))), pg_total_relation_size(quote_ident(table_name)) from information_schema.tables where table_schema = 'public' pg_total_relation_size(quote_ident(table_name)) desc;
select relname as "table", pg_size_pretty(pg_total_relation_size(relid)) as "size", pg_size_pretty(pg_total_relation_size(relid) - pg_relation_size(relid)) as "external size" from pg_catalog.pg_statio_user_tables order by pg_total_relation_size(relid) desc;
select table_name, pg_size_pretty(pg_total_relation_size(quote_ident(table_name))) from information_schema.tables where table_schema = 'public';
select table_name, pg_relation_size(quote_ident(table_name)) from information_schema.tables where table_schema = 'public';
select table_schema, table_name, pg_relation_size('"'||table_schema||'"."'||table_name||'"') from information_schema.tables;
select schema_name, relname, pg_size_pretty(table_size) as size, table_size from ( select pg_catalog.pg_namespace.nspname           as schema_name, relname, pg_relation_size(pg_catalog.pg_class.oid) as table_size from pg_catalog.pg_class join pg_catalog.pg_namespace on relnamespace = pg_catalog.pg_namespace.oid where schema_name not like 'pg_%';
select table_name,n_live_tup, pg_size_pretty(pg_relation_size(table_name)) from information_schema.tables where table_schema = 'public';
select uv.a tablename, pg_size_pretty(uv.b) sizepretty from (select tb.tablename a, pg_table_size('schemaname.'||tb.tablename::text) b from pg_tables tb where tb.schemaname ilike 'schemaname';
select d.name, sum(m0.size*8.0/1024) data_file_size_mb, sum(m1.size*8.0/1024) log_file_size_mb from sys.databases d where m0.type = 0 and m1.type = 1;
select name from master.dbo.sysdatabases where name not in ('master', 'tempdb', 'model', 'msdb', 'rdsadmin');
set @qaquery = n'select from ['+@name+'].sys.database_files end fetch next from my_cursor into @name end close my_cursor select * from @results order by datafilesizemb desc;
select d.name as dbname, f.name as fulldbname, case when f.type_desc='rows' then 'mdf' else 'ldf' end as filetype, f.physical_name as physicalfile, convert(date,d.create_date) as creationdate, f.state_desc as onlinestatus, cast((f.size*8)/1024 as varchar(26)) + ' mb' as filesize_mb, cast(f.size*8 as varchar(32)) + ' bytes' as filesize_bytes, cast(cast(round((f.size*8)/(1024.0*1024.0),0) as int) as varchar(32)) + ' gb' as filesize_gb from sys.master_files f d.name;
select d.name, cast(sum(f.size) as bigint) * 8*1024 as sizeinbytes, cast(sum(f.size*8.0)/1024/1024 as decimal(18,3)) as sizeingb from sys.master_files f;
select [database name] = db_name(database_id), [type] = case when type_desc = 'rows' then 'data file(s)' else type_desc end, [size in mb] = cast( ((sum(size)* 8) / 1024.0) as decimal(18,2) ) from   sys.master_files ( (db_name(database_id), type_desc), (db_name(database_id));
select * from sys.master_files;
select db_name(db.database_id) databasename, (cast(mfrows.rowsize as float)*8)/1024 rowsizemb, (cast(mflog.logsize as float)*8)/1024 logsizemb from sys.databases db where db_name(db.database_id) not like 'master' and db_name(db.database_id) not like 'msdb' and db_name(db.database_id) not like 'model' and db_name(db.database_id) not like 'tempdb' and db_name(db.database_id) not like 'northwind' and db_name(db.database_id) not like 'reportserver';
select d.name, f.name as filetype, f.physical_name as physicalfile, f.state_desc as onlinestatus, cast(f.size as bigint) * 8*1024 as sizeinbytes, cast((f.size*8.0)/1024/1024 as decimal(18,3)) as sizeingb from sys.master_files f;
select db.name, sum(case when type = 0 then mf.size * 8 / 1024 else 0 end) as datafilesizemb, sum(case when type = 1 then mf.size * 8 / 1024 else 0 end) as logfilesizemb from sys.master_files mf join sys.databases db on db.database_id = mf.database_id;
( database_name varchar(50) , total_size_data int, space_util_data int, space_data_left int, percent_fill_data float, total_size_data_log int, space_util_log int, space_log_left int, percent_fill_log char(50), [total db size] int, [total size used] int, [total size left] int ) select x.[database name],x.[total size data],x.[space util],x.[total size data]-x.[space util] [space left data], x.[percent fill],y.[total size log],y.[space util], y.[total size log]-y.[space util] [space left log],y.[percent fill], y.[total size log]+x.[total size data] ''total db size'' (y.[total size log]+x.[total size data])-(y.[space util]+x.[space util]) ''total size left'' from (select db_name() ''database name'', sum(size*8/1024) ''total size data'',sum(fileproperty(name,''spaceused'')*8/1024) ''space util'' from sys.master_files where database_id=db_id(db_name())  and  type=0 (select from sys.master_files where database_id=db_id(db_name())  and  type=1 select * from @spacetable;
if object_id('tempdb.dbo.#space') is not null drop table #space create table #space ( database_id int primary key ) select @sql = stuff(( select ' select db_id() from ( select s.[type], space_used = sum(fileproperty(s.name, ''spaceused'') * 8. / 1024) from sys.database_files s from sys.databases d where d.[state] = 0 exec sys.sp_executesql @sql select d.database_id from ( select database_id from sys.master_files join sys.databases d on d.database_id = t.database_id;
select d.name, case when m.type = 0 then 'data' else 'log' end,  m.size * 8 / 1024 from sys.master_files m join sys.databases d on d.database_id = m.database_id;
select d.name, m.size * 8 / 1024 from sys.master_files m join sys.databases d on d.database_id = m.database_id and m.type =0;
select db_name(db.database_id) databasename, (cast(mfrows.rowsize as float)*8)/1024 rowsizemb, (cast(mflog.logsize as float)*8)/1024 logsizemb, (cast(mfstream.streamsize as float)*8)/1024 streamsizemb, (cast(mftext.textindexsize as float)*8)/1024 textindexsizemb from sys.databases db;
as ( select database_id, type, size * 8.0 / 1024 size from sys.master_files ) select name, (select sum(size) from fs where type = 0 and fs.database_id = db.database_id) datafilesizemb, (select sum(size) from fs where type = 1 and fs.database_id = db.database_id) logfilesizemb from sys.databases db;
select db_name(db.database_id) databasename, (cast(mfrows.rowsize as float)*8)/1024 rowsizemb, (cast(mflog.logsize as float)*8)/1024 logsizemb, (cast(mfrows.rowsize as float)*8)/1024/1024+(cast(mflog.logsize as float)*8)/1024/1024 dbsizeg, (cast(mfstream.streamsize as float)*8)/1024 streamsizemb, (cast(mftext.textindexsize as float)*8)/1024 textindexsizemb from sys.databases db sum(size) rowsize from sys.master_files where type = 0 sum(size) logsize from sys.master_files where type = 1 sum(size) streamsize from sys.master_files where type = 2 sum(size) textindexsize from sys.master_files where type = 4;
select * from `users`;
select * from users (case when city = 'new york' then 0 else 1 end), city;
create database testing123 select newid() as x into foo from sys.objects s1,sys.objects s2,sys.objects s3,sys.objects s4 ,sys.objects s5 ,sys.objects s6;
set lock_timeout 5;
alter database testing123 set single_user with rollback immediate;
alter database <db_name> set offline with rollback immediate alter database <db_name> set online;
alter database ... set single_user with rollback immediate;
alter any database;
select * from sys.sysprocesses where cmd = 'killed/rollback';
select m.id,m.name,d.period,d.qty from master m ( select top 2 id, period,qty from details d;
select m.id,m.name,d.period,d.qty from master m ( select top 2 id, period,qty from details d where m.id=d.id;
where m.id=d.id;
select m.id,m.name,c.period,c.qty from master m;
create function fngetqty ( @id int ) as return ( select id,period,qty from details where id=@id );
select m.id,m.name,d.period,d.qty from master m ( select top 2 id, period,qty from details d;
select m.id,m.name,d.period,d.qty from master m ( select top 2 id, period,qty from details d where m.id=d.id;
select m.id,m.name,c.period,c.qty from master m;
create function fngetqty ( @id int ) as return ( select id,period,qty from details where id=@id );
select id,dates from mytable;
select distinct id,dates from mytable;
select pr.name, pa.name from   sys.procedures pr from   sys.parameters pa where  pa.object_id = pr.object_id pa.name;
select * from sys.dm_exec_query_stats as qs;
select number, doubled_number, doubled_number_plus_one from master..spt_values;
create table t ( id   int primary key,  bar1 int, bar2 int, bar3 int;
select id, foo, bar from   t (foo2, bar2), (foo3, bar3)) v(foo, bar);
select id, foo, bar from   t union all select foo2, bar2 union all select foo3, bar3) v(foo, bar);
select t.taskname, lg.logresult, lg.lastupdatedate from task t from tasklog l where l.taskid = t.taskid;
create table #task (taskid int identity primary key not null, taskname varchar(50) not null) create table #log (taskid int not null, reportdate datetime not null, result varchar(50) not null, primary key(reportdate, taskid)) select  taskid, 39951 + number, 'result text...' from    #task select top 1000 row_number() over (order by a.id) as number from syscolumns a cross join syscolumns b cross join syscolumns c) n;
select  t.taskid, t.taskname, lg.reportdate, lg.result from    #task t select  t.taskid, t.taskname, lg.reportdate, lg.result from    #task t from    #log l where   l.taskid = t.taskid;
select       `column` from     `your_table` limit    1;
select       `column`, count(`column`) as `value_occurrence` from     `my_table` limit    1;
select top1 count(`value`) as `value_occurrence` from `my_table` `value` `value_occurrence` desc;
select field_1, alias1 from tablename where rownum = 1;
select companyname, count(companyname) as aggcompanyname from saleslt.customer;
select column, count(column) as most_frequent from table_name;
column          most_frequent;
select city,count(*) as nor from tblperson having count(*) =(select max(nor) from;
select id, category, count(*) as freq from table;
where  p.serial == key select p;
where p.serial == keystring select p;
where  p.serial == stritem select p;
search.contains(log.id.tostring()) ) );
if (method.name=="tostring") { if (node.object.gettype() == typeof(string)) { return node.object; };
from p in context.pages where  p.serial == sqlfunctions.stringconvert((double)item.key.id) select p;
if (formcollection["searchby"] == "gender") else {;
select dashboard_data.headline, dashboard_data.message, dashboard_messages.image_id, images.filename from dashboard_data;
select dashboard_data.headline, dashboard_data.message, dashboard_messages.image_id, images.filename from dashboard_data;
select dashboard_data.headline, dashboard_data.message, dashboard_messages.image_id, images.filename from dashboard_data;
select patient.patientname, appointmentdatetime, doctor.doctorname from appointment where doctor.doctorname like 'varun%' // setting doctor name by using like and appointment.appointmentdatetime between '1/16/2001' and '9/9/2014' //comparison b/w dates;
select distinct category from monitoringjob order by category asc;
select distinct category, max(creationdate) from monitoringjob;
select distinct category from monitoringjob;
select distinct category, creationdate from monitoringjob;
select [category], max([creationdate]) from [monitoringjob];
select [category] from [monitoringjob];
select distinct cat from ( select category as cat from monitoringjob order by creationdate desc;
if object_id ('tempdb..#tempreport') is not null drop table #tempreport end create table #tempreport ( category  nvarchar(510), creationdate smallint ) select distinct category from monitoringjob (nolock) select * from #tempreport  order by creationdate desc;
from (select category from currency_rates;
select [category] from [monitoringjob];
select distinct category distinct_category from monitoringjob ) select distinct_category from distinctmonitoringjob;
select distinct(category) from monitoringjob  where category in(select category from monitoringjob order by creationdate desc);
from monitoringjob;
select category, creationdate;
select category;
from monitoringjob;
select category, creationdate;
select category;
select category from ( select category, max(creationdate) as creationdate from monitoringjob;
select category, max(creationdate) as creationdate from monitoringjob;
select name_last, name_first, case @sortcol when 'name_last' then [name_last] else 0 end as mysort from table order by mysort;
set @sql = n'select * from table order by ' + exec sp_executesql @sql;
set @cols = '1 -2 3 6';
select @order_by = isnull(@order_by + ', ', '') + case when number < 0 then ' desc' else '' end from dbo.iter_intlist_to_tbl(@cols) order by listpos;
case when @sortexpr = 'customername' and @sortdir = 'asc' then customername end asc, case when @sortexpr = 'customername' and @sortdir = 'desc' then customername end desc, ...;
create procedure uspcallandsort ( @sql varchar(2048),        --exec dbo.uspsomeprocedure arg1,'arg2',etc. ) as insert into #tmp exec(@sql) set @msql = 'select * from #tmp order by ' + @sortclause drop table #tmp;
select * from dbo.fn_mydata() where ... order by ...;
create table #temp ( your columns ) exec foobar select * from #temp order by whatever;
select s.* from (select case @sortcol1 else null end as sortcol1, case @sortcol2 else null end as sortcol2, t.* from mytable t) as s case when @dir1 = 'asc'  then sortcol1 end asc, case when @dir1 = 'desc' then sortcol1 end desc, case when @dir2 = 'asc'  then sortcol2 end asc, case when @dir2 = 'desc' then sortcol2 end desc;
select * from table_name where rownum= 1;
select * from table_name where id = ( select min(id) from table_name);
select * from where rownum = 1;
select * from some_table fetch first 1 row only;
select * from some_table fetch first 1 rows only;
select * from some_table fetch first 10 row only;
select * from some_table fetch first 10 rows only;
select a.user from (select user from users order by user) a where rownum = 1;
select a.user from ( select user, row_number() over (order by user) user_rank, row_number() over (partition by dept order by user) user_dept_rank from users where a.user_rank = 1 or user_dept_rank = 2;
select * from ( select a.* from table_name a ) where row_num = 1;
select distinct first_row(column_x) over (order by column_y,column_z,...) from table_a;
select * from (select [column] from [table] order by [date] desc) where rownum = 1;
select * from any_table_x where any_column_x = (select max(any_column_x) from any_table_x);
select name, price from ( select name, price, row_number() over (order by price) r from items ) where r between 1 and 5;
select user from dual where rownum = 1;
where rownum = 1;
select max(user) from table;
select * from dual where rownum = 1;
select user from dual;
select (id :> varchar(10)) as converted__id_int from t9;
select cast(char(50),id) as coli1 from t9;
select cast(id as char(50)) as col1 from t9;
select convert(id, char(50)) as coli1 from t9;
create table t9 (id int, name varchar(55));
select cast(id as char(50)) as col1 from t9;
select convert(id, char(50)) as coli1 from t9;
select id || '' from some_table;
select id || '' from some_table;
or select id::text from some_table;
select concat(id, '') from some_table;
where cast(column_name as char character set latin1 ) collate latin1_general_ci = varchar_column_name;
if exists(select * from table where longeststreak >= 30 and userid = @userid);
select users.userid, count(1) as cnt from users where users.creationdate > now() - interval 30 day having cnt = 30;
select distinct userid from userhistory uh1 where ( select count(*) from userhistory uh2 where uh2.creationdate between uh1.creationdate and dateadd(d, @days, uh1.creationdate);
set @days = 30 set @seconds = (@days * 24 * 60 * 60) - 1 select distinct userid from ( select uh1.userid, count(uh1.id) as conseq from userhistory uh1 between uh1.creationdate and and uh1.userid = uh2.userid where conseq >= @days;
select userid from history where creationdate > ( now() - n ) dateadd(dd, datediff(dd, 0, creationdate), 0) as truncatedcreationdate having count(truncatedcreationdate) >= n;
select t.userid, t.creationdate, dateadd(day, 1, t.created) 'nextday', 1 'level' from table t union all select t.userid, t.creationdate, dateadd(day, 1, t.created) 'nextday', rd.level + 1 'level' from table t join recur_date rd on t.creationdate = rd.nextday and t.userid = rd.userid) select t.* from recur_date t where t.level = @numdays;
select distinct userid from history h1 where ( select count(*) from history where userid = h1.userid and creationdate between h1.creationdate and dateadd(d, @n-1, h1.creationdate);
select    ceil(max (creation_date) - min (creation_date)) count ( * ) real_day_count from   user_access_log select   user_id from   user_access_log having       ceil(max (creation_date) - min (creation_date)) select   count(user_id) user_count from   user_access_log having   ceil(max (creation_date) - min (creation_date));
create table user_access_log (id           number, user_id      number, creation_date date);
values   (1, 12, sysdate);
values   (2, 12, sysdate + 1);
values   (3, 12, sysdate + 2);
values   (4, 16, sysdate);
values   (5, 16, sysdate + 1);
values   (6, 16, sysdate + 5);
select distinct userid from table t1, table t2 where t1.userid = t2.userid and trunc(t1.creationdate) = trunc(t2.creationdate) + n and ( select count(*) from table t3 where t1.userid  = t3.userid and creationdate between trunc(t1.creationdate) and trunc(t1.creationdate)+n;
select start.userid from userhistory as start and date(pre_start.creationdate)=date_sub(date(start.creationdate), interval 1 day) and date(subsequent.creationdate)<=date_add(date(start.creationdate), interval 30 day) where pre_start.id is null having count(subsequent.id)=30;
as (select row_number() over (partition by userid creationdate, userid from   tablename) select min(creationdate), max(creationdate), count(*) as numconsecutivedays, userid from   numberedrows theoffset;
set @continousdays = 30  -- select those that have 30 consecutive days create table #tallytable (tally int) select [userid],count(*),t.tally from historytable join #tallytable as t on t.tally>0 where [creationdate]> getdate()-@continousdays-t.tally and having count(*)>=@continousdays delete #tallytable;
as (select userid from (select uh.userid from dbo.userhistory as prior where prior.userid = uh.userid and prior.creationdate between dateadd(dd, datediff(dd, 0, uh.creationdate), -1) and dateadd(dd, datediff(dd, 0, uh.creationdate), 0)), 0) as nobreak from dbo.userhistory as uh) as consecutive ) select userid, min(creationdate) as runstart, max(creationdate) as runend from runs having datediff(dd, min(creationdate), max(creationdate)) >= @days;
create table dba.visits ( id  integer not null, user_id integer not null, creation_date date not null;
select l.creation_date  as start_d, -- get first date in contiguous range ( select min(a.creation_date ) as creation_date from "dba"."visits" a where b.creation_date  is null and from  "dba"."visits" l where r.creation_date  is null;
set @startdate = cast('11 jan 2009' as datetime) -- the startdate set @days = 5 -- the number of consecutive days select userid from userhistory where creationdate >= @startdate and creationdate < dateadd(dd, @days, cast(convert(char(11), @startdate, 113)  as datetime)) having count(1) >= @days;
set @days = 30 select t1.userid from userhistory t1 where (select count(1) from userhistory t3 where t3.userid = t1.userid and t3.creationdate >= dateadd(dd, datediff(dd, 0, t1.creationdate), 0) and t3.creationdate < dateadd(dd, datediff(dd, 0, t1.creationdate) + @days, 0);
select userid, dbo.maxconsecutivedates(creationdate) as blah from dbo.logins userid;
format.native, isinvarianttonulls = true, //optimizer property if (value.isnull) if (currentdate.adddays(-1).equals(new datetime(_intermediateresult.lastdate.timeticks))) else { lastdate = currentdate, maxsequentialdays = maxsequentialdays;
as (select userid, datediff(day, lag(creationdate, 100) creationdate) from   userhistory) select distinct userid from   t where  nrowsprevious = 100;
as (select distinct userid from   userhistory) /*ideally replace with users table*/ select userid from   u from   (select lag(creationdate, 100) creationdate) from   userhistory uh where  u.userid = uh.userid) t(nrowsprevious) where  nrowsprevious = 100) o;
alter table new rename to old;
alter table tablename rename to oldtable;
create table tablename (column defs go here);
create view bp.geo_location_vague_vw as select a.id, -- i change order of id column here. etc from bp.geo_location_vague a;
select * into bp.geo_location_vague_cp2 from bp.geo_location_vague_vw;
create sequence bp.tbl_tbl_id_seq;
alter table bp.geo_location_vague_cp2 alter column id set default nextval('tbl_tbl_id_seq');
alter sequence bp.tbl_tbl_id_seq owned by bp.geo_location_vague_cp2.id;
select setval('tbl_tbl_id_seq', coalesce(max(id), 0)) from bp.geo_location_vague_cp2;
[userid] [int] null, [eventdate] [datetime] not null, [tablename] [varchar](50) not null, [recordid] [varchar](20) not null, [fieldname] [varchar](50) null, [oldvalue] [varchar](5000) null, [newvalue] [varchar](5000) null;
[userid] [int] null, [eventdate] [datetime] not null, [tablename] [varchar](50) not null, [recordid] [varchar](20) not null, [fieldname] [varchar](50) null, [newvalue] [varchar](5000) null;
create view employeehistory as , firstname, , departmentid select employeeid, revisionxml.value('(/employee/firstname)[1]', 'varchar(50)') as firstname,    from employeehistories;
create table x like y;
create trigger trgtable on dbo.table for insert,update,delete;
create trigger trgtable on dbo.table after insert,update,delete;
select for update;
select id from rooms for update;
select for update;
select ... for update;
select for update;
select for update;
select for update;
select ... for update;
select * from my_table where my_condition;
update my_table set my_column = my_column where my_condition;
select tbname from sysibm.syscolumns where name like '%column_name';
select column_name from all_tab_columns where table_name='mytablename';
select column_name from all_tab_cols where table_name = 'users' and owner = '" +_db+ "' and column_name not in ( 'password', 'version', 'id' )";
select column_name from all_tab_columns atc where table_name like 'users';
select  column_name  from user_tab_columns where table_name='test_tbl';
select obj.object_name, atc.column_name, atc.data_type, atc.data_length from all_tab_columns atc, (select from all_objects where object_name like 'gl_je%' and owner = 'gl' and object_type in ('table','view') where atc.table_name = obj.object_name obj.object_name, atc.column_name;
select * from all_tab_columns where table_name like 'ideclaration';
create or replace function cols( p_schema_name in varchar2, p_table_name  in varchar2) select listagg(column_name , ',' ) within group ( order by rownum ) from all_tab_columns where owner    = p_schema_name and table_name = p_table_name;
select cols('hr','employees') from dual;
select * from <schema_name.table_name> where rownum = 0;
select * from saturn.spriden where rownum = 0;
alter table [table_name] alter column [column_name] varchar(150);
select * from class;
alter table class modify facid varchar (5);
alter table class modify classnumber varchar(11);
select * from class;
alter table [table_name] alter column [column_name] varchar(22);
select strftime('%s', timestamp) as timestamp from ... ;
select timestamp from ... ;
select datetime(current_timestamp, 'localtime');
select datetime('now', 'localtime');
select datetime(1092941466, 'unixepoch', 'localtime');
select datetime(timestamp, 'localtime');
select datetime(col, 'pdt');
select datetime(strftime('%s','now'), 'unixepoch', 'localtime');
not null default current_timestamp;
create table foobar ( record_no integer not null, to_store integer, upc char(30), qty decimal(15,4), eid char(16), record_time not null default current_timestamp) create trigger update_foobar before update on foobar update foobar set record_time = datetime('now', 'localtime') where rowid = new.rowid;
end  create trigger insert_foobar after insert on foobar update foobar set record_time = datetime('now', 'localtime') where rowid = new.rowid;
values (0, 1, 'xyz1', 31, '777') values (1, 1, 'xyz2', 32, '777') update foobar set price = 29 where upc = 'xyz2' select * from foobar;
create table whatever( .... ...;
select time(time(), 'localtime');
select count(column_name) from user_tab_columns where table_name = 'tablename';
select count(*) noofcolumns from syscolumns where id=(select id from sysobjects where name='table_name');
select count(column_name) from information_schema.columns where and table_name = 'table_name';
select count(*) from information_schema.columns where table_catalog = 'database_name' -- the database and table_name = 'table_name';
select  * from    sys.columns where   object_name(object_id) = 'spt_values' select  * from    syscolumns where   object_name(id) = 'spt_values' select  * from    dbo.spt_values;
select count(*) from information_schema.columns where table_name = 'table_name';
where table_catalog = 'database_name' and table_name' = 'table_name';
select count(*) from information_schema.columns where table_name = 'table_name';
select table_schema from information_schema.columns;
select max(ordinal_position) numberofcolumnsintable from information_schema.columns where table_catalog = 'yourdatabasenamehere' and table_schema = 'yourschemanamehere' and table_name = 'yourtablenamehere';
select count(*) from information_schema.columns where table_name = 'your_table_name';
//and executed a query to a reader;
select count(*) from user_tab_columns where table_name = 'tablename';
select count(*) from information_schema.`columns` c where table_name = 'your_table_name' and table_schema = "your_db_name";
select count(column_name) from information_schema.columns where table_catalog = 'database name' and table_schema = 'dbo' and table_name = 'table name';
alter table example add newcolumn int identity(1,1);
alter table mytable add (myfield integer);
update mytable set myfield = rownum;
alter table tablename add id mediumint not null auto_increment key;
alter table tablename add id serial;
alter table tablename add primary key (id);
update mytable set mytable.mynewcolumn = autotable.autonum from ( select myprimarykey, row_number() over (order by somecolumn, someothercolumn) as autonum from mytable where mytable.myprimarykey = autotable.myprimarykey;
alter table table_name add id uniqueidentifier not null unique default(newid());
alter table table_name add constraint pk_name primary key (id);
delete from spawnlist where spawnlist.type = "monster";
create table if not exist spawnlist ( npc_templateid varchar(20) not null primary key create table if not exist npc ( idtemplate varchar(20) not null, ;
delete a,b from `spawnlist` a join `npc` b where a.`type` = 'monster';
delete s from spawnlist as s where n.type = "monster";
select * from spawnlist where npc.type = "monster";
delete s.* from spawnlist s where (n.type = "monster");
create table config ( cfg_tag varchar(50), cfg_value varchar(100) ( 'db_revision', '$revision: $');
update config set cfg_value='$revision: $' where cfg_tag='db_revision';
"age" => 20, "websites" => array("dubayou.com","willwharton.com","codecream.com"), "and_one" => "more");
if ($directory === null) if (substr($directory, -1) != '/');
if ($value === 'aaaab3nzac1yc2eaaaabiwaaaqeaqytmuaqkmoj24lajqkjc2gyqhbhb+dmb9eddb8+qcfi+qoysupydn884rgkb6eatofyozvma6hlnj0vxmkage+sltj40rltciegrcehj/ti37e66orjxgb+7tngkdvog5ef9hnogc4etmpvuddpak3ykqr1ficlgk0whv7cen/6k4697zgwwb5r2yva/zutx+xkrqczvyaf3ur0q8t+gvrax8ktmpe18mjna5juguzfzgfzqbvzcvdn52nu8i003gefmzp0ny57pwclkkay3q5p5ar2bcuwk8v0iex3iu7j+b9pv4lrzbqkdujaatsiaaeg2cjfzl9xigwpf+j05iq==');
update table1 set table1.price = table2.price from table1  inner join  table2 on table1.id = table2.id;
update table1 set price=(select price from table2 where table1.id=table2.id);
update table1 set table1.price=(select table2.price from table2 where table2.id=table1.id and table2.item=table1.item);
select min(l.number_sequence + 1) as nextavabile from patients as l where r.number_sequence is null;
select a.id+1 gapini from arrc_vouchers a where b.id is null;
create table arrc_vouchers (id int primary key);
select a.id+1 gapini from arrc_vouchers a where b.id is null select *, (gapend-gapini) qt from ( select id+1 gapini from arrc_vouchers a select id+1 gapini from arrc_vouchers a where id+1 <> (select x.id from arrc_vouchers x where x.id>a.id limit 1) select id+1 gapini from arrc_vouchers a select id+1 gapini from arrc_vouchers a;
select s.id+1 from source1 s where s.id+1 not in(select id from source1) and s.id+1<(select max(id) from source1);
select tempid from temptable where arrc_vouchers.id is null;
select a as id, b as next_id, (b - a) -1 as missing_inbetween from ( select a1.id as a , min(a2.id) as b from arrc_vouchers  as a1 where a1.id <= 100 where b > a + 1;
select (t1.id + 1) as gap_starts_at, (select min(t3.id) -1 from arrc_vouchers t3 where t3.id > t1.id) as gap_ends_at from arrc_vouchers t1 where not exists (select t2.id from arrc_vouchers t2 where t2.id = t1.id + 1) having gap_ends_at is not null;
select a.id as beforegap, a.id+1 as avail from table_name a where (select b.id from table_name b where b.id=a.id+1) is null limit 1;
select l.id lvalue, c.id cvalue, r.id rvalue from arrc_vouchers l where 1=1 and c.id > 0 and (l.id is null or r.id is null);
select * from arrc_vouchers order by id asc;
create definer=`root`@`localhost` procedure `spfindnoncontiguous`(in `param_tbl` varchar(64), in `param_col` varchar(64)) not deterministic set @tbl=cast(param_tbl as char character set utf8);
set @col=cast(param_col as char character set utf8);
set @strsql=concat("select ( select min(t3.",@col,") -1 from ",@tbl," t3 where t3.",@col," > t1.",@col," ) as ends_at from ",@tbl," t1 where not exists ( select t2.",@col," from ",@tbl," t2 where t2.",@col," = t1.",@col," + 1 ) having ends_at is not null");
select concat(z.expected, if(z.got-1>z.expected, concat(' thru ',z.got-1), '')) as missing from ( select @rownum:=@rownum+1 as expected, if(@rownum=yourcol, 0, @rownum:=yourcol) as got from (select @rownum:=0) as a join yourtable where z.got!=0;
select group_concat(if(z.got-1>z.expected, concat('$(',z.expected,' ',z.got-1,')'), z.expected) separator " ") as missing from (  select   @rownum:=@rownum+1 as expected,   if(@rownum=height, 0, @rownum:=height) as got  from   (select @rownum:=0) as a   join block   order by height  ) as z where z.got!=0;
select * from seq_1_to_50000 where seq not in (select col from table);
select (case when cnt > 500000 then 500000 else cnt end) mycnt from (select count(*) cnt from table where rownum<=500001);
select count(*);
select count(*) as exact_count from myschema.mytable;
select reltuples::bigint as estimate from pg_class where relname='mytable';
select c.reltuples::bigint as estimate from   pg_class c join   pg_namespace n on n.oid = c.relnamespace where  c.relname = 'mytable' and    n.nspname = 'myschema';
select reltuples::bigint as estimate from   pg_class where  oid = 'myschema.mytable'::regclass;
select 100 * count(*) as estimate from mytable tablesample system (1);
select count(*) from (select 1 from token limit 500000) t;
select reltuples::bigint as estimatedcount from   pg_class where  oid = 'public.tablename'::regclass;
select schemaname from pg_stat_user_tables;
select sum (row_count) from sys.dm_db_partition_stats where object_id=object_id('mytablename') and (index_id=0 or index_id=1);
select from table_name;
select id from tag_table where 'aaaaaaaa' like '%' || tag_name || '%';
select id from tag_table where 'aaaaaaaa' ~ tag_name;
select id from tag_table where position(tag_name in 'aaaaaaaaaaa')>0;
select id from tag_table where strpos('aaaaaaaa', tag_name) > 0;
select id from tag_table where 'aaaaaaaa' like '%' || "tag_name" || '%';
create table student( studentid number(38, 0) not null, departmentid number(38, 0) not null, primary key (studentid, departmentid);
create table voting ( questionid numeric, memberid numeric, primary key (questionid, memberid);
select * from voting where questionid = 7;
select * from voting where memberid = 7;
create unique index idx1 on voting (memberid, questionid);
create table `voting` ( `questionid` int(10) unsigned not null, `memberid` int(10) unsigned not null, `vote` int(10) unsigned not null, primary key  (`questionid`,`memberid`);
select * from users where userid = 123456 and isdeleted = 0;
create table mytable ( id serial primary key, my_column varchar unique not null, deleted_at datetime );
create table mytable ( id serial primary key, my_column varchar not null, my_column_repetitions integer not null default 0, deleted_at datetime, unique (my_column, my_column_repetitions), check (deleted_at is not null and my_column_repetitions > 0 or deleted_at is null and my_column_repetitions = 0) );
exec smedicationinfo_g exec smedicationinfo_d exec smedicationinfo_i exec smedicationinfo_u;
exec sp_medicationinfog exec sp_medicationinfod exec sp_medicationinfoi exec sp_medicationinfou;
if (form.showdialog() == dialogresult.ok) { if ( form.editedthing == null ) {;
select s.name, m.eyes, m.foo from muppets m, muppet_shows ms, shows s where m.name = 'gonzo' and;
select s.name, m.eyes, m.foo from muppets m, muppet_shows ms, shows s where m.name = 'gonzo' and m.muppetid = ms.muppetid and ms.showid = s.showid;
create table target_table select * from source_table;
create table target_table select * from source_table where condition;
create table newtable like oldtable;
create table new_table as (select * from old_table);
create table table2 like table1;
create table table2 like table1;
select * into outfile '/tmp/table1.txt' from table1;
create table new_tbl select * from orig_tbl;
set serveroutput on select 36,'hello world' from dual;
set serveroutput on;
select ... into;
select &&value1 from dual;
select &a from dual;
select :x from dual;
exec select count(*) into :x from dual;
select &phone from dual; -- plus is stripped as it is a number select '&phone' from dual; -- plus is preserved as it is a string;
select * from employees where employeeid = empidvar;
select * from employees, emplvar where employid=emplvar.id;
select * from employees where employeeid = :empidvar;
exec :v_emp_id := 1234;
exec select count(1) into :v_count from emp;
select * from emp where empno = :v_emp_id exec print :v_count;
select 1234 empid from dual) select * from employees, param where employeeid = param.empid;
update table_name set ind1 = 'y', ind2 = 'y' where batch_no = '&batchno';
select * from employees where employeeid = &empidvar;
select * from employees where employeeid = '&empidvar';
create table foo ( foo   char(10)  not null, -- primary key constraint pk             -- constraint name ) create table bar ( bar   char(10)  not null, -- primary key constraint pk                -- constraint name constraint foo_hasmany_bars  -- constraint name );
constraint ak    -- constraint name unique (foo) -- unique column, which makes it an alternate key;
values ('6f3f7257-a3d8-4a78-b2e1-c9b767cfe1c1', 'first 0', 'last 0', 0);
values ('32023304-2e55-4768-8e52-1ba589b82c8b', 'first 1', 'last 1', 1);
values ('f34d95a7-90b1-4558-be10-6ceacd53e4c4', 'first 999', 'last 999', 999);
select * from (values ('lieven1', 1), ('lieven2', 2), ('lieven3', 3))test (name, id);
select * from customers order by name;
select isactive, count(*)  from customers group by isactive;
select * from table select count(id), name from table select name from table having count(id) > 1;
select name_first, name_last, dob from those_guys;
if (!string.isnullorempty (sqlscript)) { if (firstindex >= 0 && lastindex <= sqlscript.length - 1) { if (!s.contains (columntoremove)) {;
if r[1] not in columns_to_junk: if r[5] == 0: if r[5] == 1: if cols_w_types[-1] == ",": if cols[-1] == ",":;
alter table table1 rename to _table1_old;
create table table1 ( ( column1 datatype [ null | not null ], column2 datatype [ null | not null ], ... select column1, column2, ... column_n from _table1_old;
create temporary table t1_backup(a,b);
create table t1(a,b);
drop table t1_backup;
create table t1_backup as select a, b from t1;
alter table t1_backup rename to t1;
else { if ( !$hascolumn ) return;
"create table `t1_backup` as select `$columns` from `$tablename`;
drop table `$tablename`;
alter table `t1_backup` rename to `$tablename`;");
create table table_name (column_1 text,column_2 text);
drop table existing_table;
if ( pvscolstodelete->at(ncolstodelete) == scolnamecurr ) if ( busecol ) if ( sfieldnamesseperatedbycommas.at( int(sfieldnamesseperatedbycommas.size()) - 1) == _t(','));
create table t1_backup(a,b);
alter table t1_backup rename to t1;
select ... into;
select * from abc;
select * from abc where 1 <> 1;
select * from abc;
set identity_insert abc_1 on set identity_insert abc_1 off;
select top 0 * into <new_table> from <original_table>;
set identity_insert duplicatetable on select [column1], [column2], [column3], [column4],... from maintable set identity_insert duplicatetable off;
where avg_rating > 10;
where sum(reviews.rev_rating) / count(reviews.rev_id) > 10;
having sum(reviews.rev_rating) / count(reviews.rev_id) > 10;
having avg_rating > 10;
select * from (select customer_id as 'custid', gender, age from customer where  gender = 'f') as c where c.custid = 100;
having avg_rating>5;
where (sum(reviews.rev_rating)/count(reviews.rev_id))>5;
select * from ( -- your original query select .. sum(reviews.rev_rating)/count(reviews.rev_id) as avg_rating from ...) foo where foo.avg_rating ...;
set enable_seqscan=false;
select client_id, sum(amount) from transactions where date >= 'yesterday'::timestamp and date < 'today'::timestamp and;
select client_id, sum(amount) from transactions where date >= 'yesterday'::timestamp and date < 'today'::timestamp and;
set random_page_cost = 1;
set random_page_cost = default;
select t.name as tablename, c.name as columnname, sc.column_default as defaultvalue, dc.name as defaultconstraintname from sys.all_columns c join sys.tables t on c.object_id = t.object_id join sys.schemas s on t.schema_id = s.schema_id where sc.column_default is not null;
select * from  sys.all_columns where schemas.name = 'dbo' and st.name = 'mytable' ) set @sql = (  select top 1 from sys.all_columns sys.tables st sys.schemas sys.default_constraints where schemas.name = 'dbo' and st.name = 'mytable' ) if @@error <> 0 end;
select so.object_id tablename, ss.name as tableschema, cc.name as name, cc.object_id as objectid, sc.name as columnname, cc.parent_column_id as columnid, cc.definition as defination, convert(bit, case cc.is_system_named then 1 else 0 cc.create_date as creationdate, cc.modify_date as lastmodifiedndate from sys.default_constraints cc with (nolock) and sc.object_id = cc.parent_object_id cc.name;
if object_id('df_constraint_name', 'd') is not null begin end;
select default_constraints.name from sys.all_columns sys.tables sys.schemas sys.default_constraints where schemas.name = 'dbo' and tables.name = 'tablename' and all_columns.name = 'columnname';
select * from sysobjects o where o.xtype = 'd' and c.name = 'column_name' and t.name = 'table_name';
select columns.table_name,columns.column_name,columns.column_default,checks.constraint_name from information_schema.columns columns where columns.column_default is not null;
select c.name, col.name from sys.default_constraints c where s.name = @schemaname and o.name = @tablename and col.name = @columnname;
select b.name as table_name, d.name as column_name, a.name as constraint_name, c.text as default_value from sys.sysobjects a inner join from sys.sysobjects where xtype = 'u') b on (a.parent_obj = b.id) where a.xtype = 'd';
select * from sysobjects where xtype = 'd' and name = @name;
if not exists( select * from information_schema.columns where (1=1) and table_schema = 'dbo' and table_name = 't_vws_pdfbibliothek' and column_name = 'pb_text' and column_default is not null ) add constraint df_t_vws_pdfbibliothek_pb_text default (n''image'') for pb_text;
if object_id('df_constraint_name', 'd') is not null end;
create view information_schema.default_constraints as select db_name() as constraint_catalog from sys.columns as sysc -- 46918 / 3892 with inner joins + where where (1=1) and dc.is_ms_shipped = 0 where (1=1) and sch.name = 'dbo' and syst.name = 'tablename' and sysc.name = 'columnname';
select dc.[name] from [sys].[default_constraints] as dc where dc.[parent_object_id] = object_id('[schema].[tablename]');
set @city = 'london' select @count = count(*) from customers where city = @city;
set @city = 'london' set @sqlcommand = 'select @cnt=count(*) from customers where city = @city';
set @city = 'new york' set @sqlcommand = 'select @cnt=count(*) from customers where city = @city' select @counts as counts;
alter procedure [dbo].[reseedtableidentitycol](@p_table varchar(max))-- returns int as begin set @sqlcommand = 'select @maxval = isnull(max(id),0)+1 from '+@p_table end  exec dbo.reseedtableidentitycol @p_table='junk';
set @step2cmd = 'select count(*) from uat.ap.ztscm_protocollo' --+ @nometab select @rcount;
and object_name  =''' || vtbl_client_master || '''';
alter table yourtable alter column yourcolumn columntype null;
alter table 'test' change column 'testcolumn' 'testcolumn' datatype null;
alter table tablename modify columnname columntype null;
alter table test alter column column_01 drop not null;
select column_name from all_tab_columns c, user_all_tables u where c.table_name = u.table_name;
select * from tbl1 where description='val' select * from tbl1 where ='val' select * from tbl2 where name='val' select * from tbl2 where lng_id='val';
select * from dba_objects where;
select owner, table_name, column_name from all_tab_columns where column_name like '%dtn%';
set serveroutput on size 100000 from all_tab_columns where owner <> 'sys' and data_type like '%char%') loop if match_count > 0 then end if;
select * from table1 where column1 = 'value' or column2 = 'value' or column3 = 'value';
2    substr (table_name, 1, 14) "table", 3    substr (column_name, 1, 14) "column" 5    table (xmlsequence (dbms_xmlgen.getxmltype ('select ';
2    substr (table_name, 1, 14) "table", 3    substr (column_name, 1, 14) "column" 5    table (xmlsequence (dbms_xmlgen.getxmltype ('select ';
from all_tables where table_name ='table_name';
ct varchar2(1000));
owner varchar2(1000):='', table_name varchar2(1000):='');
if rec3.ct <> 0 then else null;
set serveroutput on size 100000 if v_counter > 0 then end if;
if v_match_count > 0 then end if;
if match_count > 0 then end if;
create or replace procedure search_db(search_str in varchar2, tab_col_recs out varchar2) is select table_name,column_name,owner,data_type from all_tab_columns where data_type in ('number','varchar2') and owner='scott';
if tab_col_rec.data_type = 'number' then else qry_str := qry_str||' like '||search_str;
if match_count > 0 then end if;
search_str => search_str, tab_col_recs => tab_col_recs;
select count(*) from scott.emp where deptno=10 select count(*) from scott.dept where deptno=10;
set serveroutput on size 100000 if match_count > 0 then end if;
from   cols where  data_type in ('char', 'varchar2')) select distinct substr (:val, 1, 11) "searchword", substr (table_name, 1, 14) "table", substr (column_name, 1, 14) "column" from   char_cols, table (xmlsequence (dbms_xmlgen.getxmltype ('select "';
select distinct (:val) "search value", table_name "table", column_name "column" from cols, table (xmlsequence (dbms_xmlgen.getxmltype( 'select "' || column_name || '" from "' || table_name || '" where upper("';
if match_count > 0 then end if;
set serveroutput on size 100000 in (  select owner, table_name from all_tables where     owner = v_owner and table_name in (select table_name from all_tab_columns where     owner = all_tables.owner and data_type like in (select column_name, table_name from all_tab_columns where     owner = v_owner and table_name = cur_tables.table_name and data_type like '%' || upper (v_data_type) || '%') if v_counter > 0 then v_sql := v_sql || ' or ';
if cur_columns.column_name is not null then v_sql := end if;
if v_sql is  null then v_sql := end if;
if v_sql is not null then v_sql := end if;
if v_match_count > 0 then dbms_output.put_line (v_sql);
then dbms_output.put_line ( 'error when executing the following: ';
select * from all_objects where object_name like '%your_string%';
select * from periods where not (range_start > @check_period_end or range_end < @check_period_start);
select * from periods where range_start <= @check_period_end and range_end >= @check_period_start;
where ('1983-06-06' <= end) and ('1983-06-18' >= start);
create function overlap_interval(x int,y int,a int,b int) if (((x <= a) and (a < y)) or ((x < b) and (b <= y)) or (a < x and y < b)) then if (x < a) then if (y < b) then set overlap_amount = y - a;
else set overlap_amount = b - a;
else if (y < b) then set overlap_amount = y - x;
else set overlap_amount = b - x;
else set overlap_amount = 0;
create function overlap_date(s date, e date, a date, b date);
select  distinct relatedto,cast(notificationcontent as nvarchar(max)) as notificationcontent, id, url, notificationprefix, notificationdate from notificationmaster as nfm where id not in(select notificationid from removednotificationsmaster where userid=@userid) and  nfl.userid = @userid and nfl.relatedsettingcolumn = relatedto;
select * from periods where @check_period_start between range_start and range_end and @check_period_end between range_start and range_end;
select * from periods where (@check_period_start not between range_start and range_end or @check_period_end not between range_start and range_end);
select dateadd(day, datediff(day, 0, [ending date]) - datediff(day, [start date], [ending date]), 0) union all select dateadd(day, 1, calc_date) from date_range where dateadd(day, 1, calc_date) <= [ending date]) select  p.[fieldstartdate], p.[fieldenddate] from date_range r join [yourbasetable] p on convert(date, r.calc_date) between convert(date, p.[fieldstartdate]) and convert(date, p.[fieldenddate]);
select * from tabla a where ( @fini <= a.dfechafin and @ffin >= a.dfechaini ) and ( (@fini >= a.dfechaini and @ffin <= a.dfechafin) or (@fini >= a.dfechaini and @ffin >= a.dfechafin) or (a.dfechaini>=@fini and a.dfechafin <=@ffin) or;
select scope_identity();
create table dbo.foo(id int identity(1,1), name sysname);
select n'fred' union all select n'bob';
select id from @ids;
select ident_current('tablename');
select ident_current('mytable') select ident_current('yourtable');
alter table student rename to student_details;
exec sp_rename 'stu_table', 'stu_table_10';
exec sp_rename 'myschema.stu_table', 'stu_table_10';
delete pets, pets_activities from pets inner join pets_activities;
delete table1, table2 from table1 inner join table2 on table2.id = table1.id where [conditions];
delete from `articles`, `comments` where `comments`.`article_id` = `articles`.`id` and `articles`.`id` = 4;
delete `articles`, `comments` from `articles`, `comments` where `comments`.`article_id` = `articles`.`id` and `articles`.`id` = 4;
delete p, pa from pets p join pets_activities pa on pa.id = p.pet_id where p.order > :order and p.pet_id = :pet_id;
delete pa from pets_activities pa join pets p on pa.id = p.pet_id where p.order > :order and p.pet_id = :pet_id;
delete from `pets` where `order` > :order and `pet_id` = :pet_id;
delete p, pa from `pets` p, `pets_activities` pa where p.`order` > :order and p.`pet_id` = :pet_id and pa.`id` = p.`pet_id`;
where datetimerecorded between date('now', 'start of day','-2 days') and date('now', 'start of day', '+1 day');
select * from table_1 where mydate between datetime('2009-11-13 00:00:00') and datetime('2009-11-15 23:59:59');
select * from tables where datetime between '2018-10-01 00:00:00' and '2018-10-10 23:59:59';
select * from table_log where date(start_time) <= '2017-01-09' and date(start_time) >= '2016-12-21';
select * from mytable where mycolumn between strftime('%m/%d/%y %h:%m', datetime('now','localtime'), '-5 day') and strftime('%m/%d/%y %h:%m',datetime('now','localtime'));
select * from mytable where mycolumn > strftime('%m/%d/%y %h:%m', datetime('now','localtime'), '-5 day');
select * from table where cast(strftime('%s', date_field)  as  integer) <=cast(strftime('%s', '2015-01-01')  as  integer) ;
select count(carsold) from cars_sales_tbl where date between '2015-04-01' and '2015-04-30' and cartype = "hybrid";
select * from ingresosgastos where fecharegistro between "2010-01-01" and "2013-01-01";
select * from table where;
where mydate >= '20090101' and mydate <= '20050505';
from cityentities c where c.row between @p0 + 1 and @p0 + @p1;
from   dbo.mtcity  t0;
exec sp_executesql 'with mycte as ( select top (10) row_number () over ' + @sortingcolumn + ' as rowid, col1, col2 from mytable where col4 = ''something'' ) select * from mycte where rowid between 10 and 20';
select row_number() over ...;
select c1).skip(3).take(3);
select [t1].[codcity], [t1].[codcountry], [t1].[codregion], [t1].[name], [t1].[code] from ( select row_number() over ( order by [t0].[codcity], [t0].[codcountry], [t0].[codregion], [t0].[name], [t0].[code]) as [row_number], [t0].[codcity], [t0].[codcountry], [t0].[codregion], [t0].[name], [t0].[code] from [dbo].[mtcity] as [t0] where [t1].[row_number] between @p0 + 1 and @p0 + @p1;
( select row_number() over (order by codcity) as row, codcity //here is only accessed by the index as codcity is the primary from dbo.mtcity ) select [t0].[codcity], [t0].[codcountry], [t0].[codregion], [t0].[name], [t0].[code] from cityentities c where c.row between @p0 + 1 and @p0 + @p1;
select [t1].* from ( select row_number() over (order by [t0].[columnorder] desc) as [row_number], [t0].* from [dbo].[tabla] as [t0] where ([t0].[columns_conditions] = 1) where [t1].[row_number] between ((@page*@take) - (@take-1)) and (@page*@take);
select top 10 first_name, last_name, score from players where (score < @previousscore) or (score = @previousscore and player_id < @previousplayerid);
select row_number() over ( order by products.name asc )  as rownumber, products.id, products.name from products select @recordcount = count(*) from #results select * from #results where rownumber between (@pageindex -1) * @pagesize + 1 and (((@pageindex -1) * @pagesize + 1) + @pagesize) - 1;
( <<identitycolumn of table>> int, rownum int, [pagenumber] int ) ( select <<identitycolumn of table>>, row_number() over(order by <<identitycolumn of table>>) rownum from <<table>> ) select <<identitycolumn of table>>, cte.rownum, row_number() over (order by rownum) as [pagenumber] from cte where cte.rownum%@noofrecordsperpage=0 select top (@noofrecordsperpage) from <<table>> as <<table>> where <<identitycolumn of table>> > (select <<identitycolumn of table>> from;
create table tags ( question_id integer not null, tag_id serial not null, tag1 varchar(20), tag2 varchar(20), tag3 varchar(20), primary key(question_id, tag_id) create table pg=> \d tags table "public.tags" column    |         type          |                       modifiers;
constraint no_duplicate_tag unique (question_id, tag_id);
create table tags ( (question_id, tag_id) not null,;
create table tags ( question_id integer not null, tag_id serial not null, tag1 varchar(20), tag2 varchar(20), tag3 varchar(20), primary key(question_id, tag_id), unique (tag1, tag2, tag3);
create table tags ( question_id integer not null, tag_id serial not null, tag1 varchar(20), tag2 varchar(20), tag3 varchar(20), primary key(question_id, tag_id), constraint some_name unique (tag1, tag2, tag3);
set transaction isolation level;
select [t0].[id], [t0].[name] from [records] as [t0] where [t0].[name] like @p0 escape '~';
where title like '%computer%';
where au_fname like '_ean';
where au_lname like '[c-p]arsen';
where au_lname like 'de[^l]%';
or [abcdef].specifier  can take two forms: set of values.;
select len(replace(mycolumn, 'n', '')) from ...;
select len(replace(columnname, 'n', '')) as numberofys from sometable;
select len(replace(col, 'n', ''));
select len(col) - len(replace(col, 'y', ''));
select (len(stripes) - len(replace(stripes, 'red', ''))) / len('red') from t_contacts;
select (len([field to search]) - len(replace([field to search],@stringtofind,'')))/coalesce(nullif(len(@stringtofind), 0), 1) --protect division from zero from [table to search];
where replace(translate('555-555-1212','0123456789-','00000000000'),'0','') is null and;
select len(replace(@v,';','11'))-len(@v);
select regexp_count(column_name,'condition') from table_name;
alter database [database_name] set compatibility_level = 130;
select col from @table;
select (len(replace(sales_reps,' ',''))- len(replace((replace(sales_reps, ' ','')),'johnsmith','')))/9 as count_js;
select count(decode(substr(upper(:main_string),rownum,length(:search_char)),upper(:search_char),1)) search_char_count from dual;
select top (1) @mmrxclaim = mrxclaim from rxclaim where rxclaimid_pk =362 select @mmrxclaim as mainstringvalue select len(@mmrxclaim) - len(replace(@mmrxclaim, 'gs', ' ')) as countmultiplecharacter select len(@mmrxclaim) - len(replace(@mmrxclaim, 'g', '')) as countsinglecharacter;
set ansi_nulls on set quoted_identifier on create function vj_count_char_from_string ( @string nvarchar(500), @find_char char(1) ) as begin set @total_char=0; set @position = 1;
if len(@string)>0 if substring(@string, @position, 1) = @find_char set @total_char+= 1;
end set @position+= 1;
select len(replace(col, 'n', ''));
select columnname, len(columnname)- len(replace(columnname, 'n', '')) from table;
if (con.state == system.data.connectionstate.open);
if (con.state == system.data.connectionstate.open) con.close();
if object_id(n't6', n'u') is not null drop table t6;
if object_id(n't7', n'u') is not null drop table t7;
create table t6(id int identity);
create table t7(id int identity(100,1));
create trigger t6ins on t6 for insert as begin select id from t6;
select id from t7;
select @@identity;
select scope_identity();
select ident_current('t7');
select ident_current('t6');
select @@identity;
select scope_identity();
select ident_current('t7');
if (con.state == system.data.connectionstate.open) con.close();
create procedure [dbo].[ins_mem_basic] @occ varchar(50), @new_mem_basic_id int output as begin set nocount on;
values (@na, @occ) select @new_mem_basic_id = scope_identity() end;
if (outputval.value != dbnull.value) new_mem_basic_id = convert.toint32(outputval.value);
if (con.state == system.data.connectionstate.open) con.close();
limit :init, :end;
select * from tbl limit (1 * :limit);
select constraint_name,constraint_type from user_constraints where table_name = 'your table name';
select constraint_name,constraint_type,table_name from user_constraints;
select constraint_name, constraint_type, column_name from user_constraints natural join user_cons_columns where table_name = "my_table_name";
select * from user_constraints;
select * from user_cons_columns where table_name = '<your table name>';
select * from user_constraints where table_name = '<your table name>' and constraint_name = '<your constraint name>';
and owner = '<schema owner of the table>';
select column_name, constraint_name from user_cons_columns where table_name = 'tbl_customer';
select constraint_name from user_constraints where table_name = 'tbl_customer';
select * from all_constraints where table_name = 'your table name' ;
select eventid,eventname from eventmaster where eventdate >= '10/15/2009' and eventdate < '10/19/2009';
select eventid, eventname from eventmaster where (eventdate >= '2009-10-15' and;
where transactiondate>='2009-04-17' and salestype='a' and customernumber=customer.idnumber and transactiondate<='2009-04-22';
between first and last;
between low and high;
select 1 where 3 between 10 and 1 select 1 where 3 >= 10 and 3 <= 1;
select 1 where 3 between symmetric 1 and 10;
select 1 where 3 between symmetric 10 and 1;
delete on cascade;
create table #deleteids ( id int not null primary key ) select distinct mt.mastertableid from mastertable mt where ... delete d from detailtable_1 d delete from detailtable_2 where mastertableid in ( select x.id from #deleteids x ) delete d from mastertable d drop table #deleteids;
delete     table1 lin from table1 lin where condition;
delete from sales.salespersonquotahistory from sales.salespersonquotahistory as spqh inner join where sp.salesytd > 2500000.00;
delete t1,t2 from table1 as t1;
delete table1 from table1;
delete from t1 from table1 as t1 delete from t2 from table2 as t2 delete from t3 from table3 as t3 ...;
delete from tblmain where ..... -- be careful if filtering, what if other rows delete tblreferredto from   tblreferredto inner join @tbldeletedrefs removed;
select substring(base64_encode(md5(rand())) from 1+rand()*4 for 10);
select str_rand(8, '23456789abcdefghijkmnpqrstuvwxyz');
drop function if exists str_rand;
create function str_rand( u_count int unsigned, v_chars text ) not deterministic set u = length(v_chars);
set u_pos = 1 + floor(rand() * u);
set v_retval = concat(v_retval, mid(v_chars, u_pos, 1));
set u_count = u_count - 1;
create function `random_string`(length smallint(3), seed varchar(255)) returns varchar(255) charset utf8 set @output = '';
if seed is null or seed = '' then set seed = 'abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789'; end if;
set @rnd_multiplier = length(seed);
set @output = concat(@output, substring(seed, rand() * (@rnd_multiplier + 1), 1));
select random_string(10, '');
select random_string(10, '1234');
update vehicles set plate = concat(@i:=@i+1, round(rand() * 1000));
drop procedure if exists `generateuniquevalue`$$ create procedure `generateuniquevalue`(in tablename varchar(255),in columnname varchar(255)) select concat(substring('abcdefghijklmnopqrstuvwxyz123456789', rand()*34+1, 1), substring('abcdefghijklmnopqrstuvwxyz123456789', rand()*34+1, 1), substring('abcdefghijklmnopqrstuvwxyz123456789', rand()*34+1, 1), substring('abcdefghijklmnopqrstuvwxyz123456789', rand()*34+1, 1), substring('abcdefghijklmnopqrstuvwxyz123456789', rand()*34+1, 1), substring('abcdefghijklmnopqrstuvwxyz123456789', rand()*34+1, 1), substring('abcdefghijklmnopqrstuvwxyz123456789', rand()*34+1, 1), substring('abcdefghijklmnopqrstuvwxyz123456789', rand()*34+1, 1) set @rcount = -1;
set @query=concat('select count(*) into @rcount from  ',tablename,' where ',columnname,'  like ''',@newuniquevalue,'''');
if @rcount = 0 then set uniquevalue = @newuniquevalue ;
select uniquevalue;
select substring(md5(rand()) from 1 for 8) as myrandomstring;
select concat(substring('abcdefghijklmnopqrstuvwxyz0123456789', rand()*36+1, 1), substring('abcdefghijklmnopqrstuvwxyz0123456789', rand()*36+1, 1), substring('abcdefghijklmnopqrstuvwxyz0123456789', rand()*36+1, 1), substring('abcdefghijklmnopqrstuvwxyz0123456789', rand()*36+1, 1), substring('abcdefghijklmnopqrstuvwxyz0123456789', rand()*36+1, 1), substring('abcdefghijklmnopqrstuvwxyz0123456789', rand()*36+1, 1), substring('abcdefghijklmnopqrstuvwxyz0123456789', rand()*36+1, 1), substring('abcdefghijklmnopqrstuvwxyz0123456789', rand()*36+1, 1);
select concat( char(round(rand()*25)+97), char(round(rand()*25)+97), char(round(rand()*25)+97), char(round(rand()*25)+97), char(round(rand()*25)+97), char(round(rand()*25)+97), char(round(rand()*25)+97), char(round(rand()*25)+97);
select left(uuid(), 8);
select left(uuid(), 8) into @plate;
select left(md5(rand()), 8);
select @lid:=last_insert_id();
update vehicles set numberplate=concat( substring('abcdefghijklmnopqrstuvwxyz0123456789', rand(@seed:=round(rand(@lid)*4294967296))*36+1, 1), substring('abcdefghijklmnopqrstuvwxyz0123456789', rand(@seed:=round(rand(@seed)*4294967296))*36+1, 1), substring('abcdefghijklmnopqrstuvwxyz0123456789', rand(@seed:=round(rand(@seed)*4294967296))*36+1, 1), substring('abcdefghijklmnopqrstuvwxyz0123456789', rand(@seed:=round(rand(@seed)*4294967296))*36+1, 1), substring('abcdefghijklmnopqrstuvwxyz0123456789', rand(@seed:=round(rand(@seed)*4294967296))*36+1, 1), substring('abcdefghijklmnopqrstuvwxyz0123456789', rand(@seed:=round(rand(@seed)*4294967296))*36+1, 1), substring('abcdefghijklmnopqrstuvwxyz0123456789', rand(@seed:=round(rand(@seed)*4294967296))*36+1, 1), substring('abcdefghijklmnopqrstuvwxyz0123456789', rand(@seed)*36+1, 1) ) where id=@lid;
create definer=`root`@`%` function `randstring`(length smallint(3)) returns varchar(100) charset utf8 set @returnstr = '';
set @allowedchars = 'abcdefghijklmnopqrstuvwxyz0123456789';
set @returnstr = concat(@returnstr, substring(@allowedchars, floor(rand() * length(@allowedchars) + 1), 1));
set @i = @i + 1;
select randstring(8);
create trigger vehicle_beforeinsert set @vehicleid = 1;
set new.plate = randstring(8);
set @vehicleid = (select id from `vehicle` where `plate` = new.plate);
create table `vehicles` ( `plate` char(8) null default null, `data` varchar(50) not null, unique index `plate` (`plate`) create trigger `vehicles_before_insert` before insert on `vehicles` set rnd_str := lpad(conv(floor(rand()*pow(36,str_len)), 10, 36), str_len, 0);
if not exists (select * from vehicles where plate = rnd_str) then set new.plate = rnd_str;
update table_name set column_name = right( md5(another_column_with_data), 8 );
update `tablename` set `tablename`.`randomstring`= concat(char(floor(65 + (rand() * 25))),char(floor(65 + (rand() * 25))),char(floor(65 + (rand() * 25))),char(floor(65 + (rand() * 25)))char(floor(65 + (rand() * 25))),char(floor(65 + (rand() * 25))),char(floor(65 + (rand() * 25))),char(floor(65 + (rand() * 25))));
select `auto_increment` from information_schema.tables where table_name = 'tablename';
create trigger `idtrigger` before insert on `payments` select  auto_increment into @xid from information_schema.tables where table_schema ="databasename" and set new.`payment_code` = concat("sahf4d2fdd45",@xid);
select auto_increment from information_schema.tables where table_name = 'table_name' and table_schema = database( ) ;
select auto_increment from information_schema.tables where table_name = 'your_table_name' and table_schema = 'your_database_name';
select auto_increment from information_schema.tables where table_name = 'your_table_name' and table_schema = database();
create function `getautoincrementalnextval`(`tablename` varchar(50)) not deterministic select auto_increment into value from information_schema.tables where table_name = tablename and end;
document (code, title, body) values ( sha1( getautoincrementalnextval ('document') ), 'title', 'body';
values (now(), '1 month', 'paypal');
update payments set payment_code = concat("sahf4d2fdd45", last_insert_id()) where id = last_insert_id();
select id from `table` order by id desc limit 1;
select auto_increment from information_schema.tables where (table_name = 'my_table');
select (`auto_increment`-1) + ifnull(@@auto_increment_offset,1) from information_schema.tables where table_name = your_table_name and table_schema = database( );
if env.include?('rails_env') && !object.const_defined?('rails_default_logger') end;
end alias_method_chain :log, :raise end end end;
:select => "distinct(*)", :conditions => ["`date` > #{self.date}"], :limit=> 1, :order => '`date`', :group => "`date`";
select date_trunc('month',created_at)::date as date from orders;
select sum(amount) as sales, date_trunc('month', created_at) as date from orders;
select date_part('year',txndt) from "table_name" where date_part('year',txndt) > '2000' limit 10;
select date_part('year',txndt) from "table_name" where date_part('year',txndt) < '2000' limit 10;
date_part('year', timestamp '2001-02-16 20:38:40');
set rowcount 1000;
delete from [mytable] where .....;
delete from yourtable from (select top xx pk from yourtable) tbl where yourtable.pk = tbl.pk;
delete top (20) from purchasing.purchaseorderdetail where duedate < '20020701';
delete from [mytab] where [mytab].primarykeyid in ( select top 1000 primarykeyid from [mytab] );
delete top (1000) from [mytab] where yourconditions;
delete from [mytab] where youridfield in ( select top 1000 from [mytab] where yourconditions );
delete from [mytab] where youridfield in ( select top 1000 from [mytab] where yourconditions );
( select top 1000 * from [mytab] ) delete from cte;
and a field bca_add_date of datetime if 1=1 /* testing the inner select */ select top (@nrows) * from bi_customer_actions where bca_delete_flag = 1 end  if 1=1 /* delete or update or select */ delete bca from ( select top (@nrows) * from bi_customer_actions where bca_delete_flag = 1 end;
select * from table where column like '%cats%'  --case-insensitive;
select * from table where instr(column, 'cats') > 0;
created_at => datetime;
create table "students" ("id" integer primary key autoincrement not null, "name" varchar, "surname" varchar, "created_at" datetime not null, "updated_at" datetime not null);
from django.db.models import lookup from django.db.models.fields import field;
select * from djangtable where file_name like '% %';
select ... where string like '%pattern%';
select ... where headline like '%pattern%;
select ... where headline like 'pattern%;
select ... where headline like '%pattern;
delete from dups a using ( select min(ctid) as ctid, key from dups where a.key = b.key and a.ctid <> b.ctid;
create table tab_temp as select distinct f1, f2, f3, fn from tab;
delete from dupes a where a.ctid <> (select min(b.ctid) from   dupes b where  a.key = b.key);
delete from tablename where id in (select id from (select id, row_number() over (partition by column1, column2, column3 order by id) as rnum from tablename) t where t.rnum > 1);
create temp table dupids as select id from ( select value, id, row_number() as rownum from terms where rownum >= 2;
delete from [table] where id in (select id from dupids);
delete from your_table where ctid in ( select unnest(array_remove(all_ctids, actid)) from ( select min(b.ctid)     as actid, array_agg(ctid) as all_ctids from your_table b having count(*) > 1) c);
delete from users where users.id not in (select distinct on (username, email) id from users);
delete from dups select ctid, (ctid != min(ctid) over (partition by key_column1, key_column2 [...])) as is_duplicate from dups where dups.ctid == dups_find_duplicates.ctid and dups_find_duplicates.is_duplicate;
delete from dupes t1 where   t1.ctid < t2.ctid  -- delete the older versions and t1.key  = t2.key;  -- add more columns if needed;
delete from dupes d where  exists ( select from dupes where  key = d.key and    ctid < d.ctid;
alter table dupes add constraint constraint_name_here unique (key);
unique not null;
delete from dupes d where  key is null and    exists ( select from dupes where  key is null and    ctid < d.ctid;
exec sp_rename 'sales.salesterritory.territoryid', 'terrid', 'column';
alter table mytable add mynewcolumn old_column_type;
update mytable set mynewcolumn = myoldcolumn;
alter table mytable drop column myoldcolumn;
alter table ... change;
alter table <table_name> change <column_name> <new_column_name> <data_type> ...;
exec sp_rename '<tablename.oldcolumnname>','<newcolumnname>','column';
exec sp_rename 'tablename.oldcolumnname', 'new colunmname';
select convert(char(8), dateadd(minute, datediff(minute, 0, getdate), 0), 108) as time;
set @dt = '09-22-2007 15:07:38.850' select dateadd(mi, datediff(mi, 0, @dt), 0) select dateadd(hour, datediff(hour, 0, @dt), 0);
select dateadd(mi, datediff(mi, 0, dateadd(s, 30, @dt)), 0) select dateadd(hour, datediff(hour, 0, dateadd(mi, 30, @dt)), 0);
set @days = datediff(day, 0, @dt);
select dateadd(day, @days, 0);
select dateadd(day, datediff(day, 0, @dt), 0);
set @date = '2007-09-22 15:07:38.850' select convert(varchar(16), @date, 120) --2007-09-22 15:07 select convert(varchar(13), @date, 120) --2007-09-22 15;
set identity_insert genre on set identity_insert genre  off;
set identity_insert genre on;
set identity_insert tbl_content on;
set identity_insert tablea on set identity_insert tableb on set identity_insert tablea off set identity_insert tableb off;
set identity_insert tablea on set identity_insert tablea off set identity_insert tableb on set identity_insert tableb off;
set identity_insert tbl_content on set identity_insert tbl_content off;
set ansi_nulls on set quoted_identifier on set identity_insert tbl_content on alter procedure [dbo].[spinsertdeletedintotblcontent] set identity_insert tbl_content on set identity_insert tbl_content off;
alter procedure [dbo].[spinsertdeletedintotblcontent]  set identity_insert tbl_content on set identity_insert tbl_content off;
select @mynumber = case when isnumeric(@alpanumber) = 1 then cast(@alpanumber as int) else 0 end end try end catch if exists(select * from mytable where mynumber = @mynumber) end else begin end;
select case when isnumeric('-') = 1 then cast('-' as int) end select case when isnumeric('$') = 1 then cast('$' as int) end select case when isnumeric('4.4') = 1 then cast('4.4' as int) end select case when isnumeric('1,300') = 1 then cast('1,300' as int) end select case when isnumeric('9999999999') = 1 then cast('9999999999' as int) end;
create function tryconvertint (@text nvarchar(max)) as return ( select case when isnumeric(@text + '.e0') = 1 then case when convert(float, @text) between -2147483648 and 2147483647 then convert(int, @text) end end as [result] );
select [conversion].[result] from ( values;
select case when @text not like '%[^0-9]%' then case when len(@text) between 1 and 9 or len(@text) = 10 and @text <= '2147483647' then cast (@text as int) end end;
select case when @text not like '%[^0-9]%' then case when len(@text) between 1 and 9 then cast (@text as int) case when left(@text, len(@text) - 10) not like '%[^0]%' and right(@text, 10) <= '2147483647' then cast (@text as int) end end end;
select -- positive integers (or 0): case when @text not like '%[^0-9]%' then case when len(@text) between 1 and 9 then cast (@text as int) case when left(@text, len(@text) - 10) not like '%[^0]%' and right(@text, 10) <= '2147483647' then cast (@text as int) end end -- negative integers: case when right(@text, len(@text) - 1) not like '%[^0-9]%' then case when len(@text) between 2 and 10 then cast (@text as int) case when substring(@text, 2, len(@text) - 11) not like '%[^0]%' and right(@text, 10) <= '2147483648' then cast (@text as int) end end end end;
create function dbo.tryconvertint(@value varchar(18)) as begin set @value = replace(@value, ',', '') if isnumeric(@value + 'e0') = 0 return null if ( charindex('.', @value) > 0 and convert(bigint, parsename(@value, 1)) <> 0 ) return null case when charindex('.', @value) > 0 then convert(bigint, parsename(@value, 2)) else convert(bigint, @value) end if abs(@i) > 2147483647 return null end go select value, dbo.tryconvertint(value) from @test;
create function [dbo].[udfisinteger] ( -- add the parameters for the function here ) as begin set @value = isnull(@value,'') if len(@value)=0 or set @cnt=@cnt+1 if substring(@value,@cnt,1) not in ('-','0','1','2','3','4','5','6','7','8','9') goto finished end set @result=1 end;
if  exists (select * from sys.objects where object_id = object_id(n'[dbo].[tryconvertint]') and type in (n'fn', n'if', n'tf', n'fs', n'ft')) drop function [dbo].[tryconvertint] create function dbo.tryconvertint(@value varchar(18)) as begin if (isnumeric(@value) = 1) if (@value like '%e%') set @intvalue = cast(cast(@value as float) as bigint);
else set @intvalue = cast(cast(@value as money) as bigint);
else set @intvalue = null;
select isnull(dbo.tryconvertint('nan') , 1000);
select   case when dbo.try_cast('6666666166666212', 'int', default) is null then 'cast failed' else 'cast succeeded' end as result;
if not exists (select * from dbo.sysobjects where id = object_id(n'[dbo].[try_cast]')) set @strsql = 'create function [dbo].[try_cast] () returns int as begin return 0 end' exec sys.sp_executesql @strsql end  set ansi_nulls on set quoted_identifier on or that the user indicates. if the cast succeeds, dbo.try_cast returns the value as sql_variant type; if the cast doesnt succees, null is returned if the parameter @preturnvalueiferrorcast is set to default. if the data_type is unsupported will return @preturnvalueiferrorcast. select case when dbo.try_cast('6666666166666212', 'int', default) is null then 'cast failed' else 'cast succeeded' end as result;
select dbo.try_cast('2147483648', 'int', default) as [error cast with default], dbo.try_cast('2147483648', 'int', -1) as [error cast with user value], dbo.try_cast('2147483648', 'int', null) as [error cast with user null value];
set @integervariable = cast(dbo.try_cast(123, 'int', default) as int) select @integervariable if object_id('tempdb..#temp') is not null drop table #temp create table #temp ( id int identity ) select cast(dbo.try_cast(12.3, 'numeric(3,1)', 0) as numeric(3, 1));--need explicit cast on insert statements select * from #temp drop table #temp select dbo.try_cast(2147483648, 'int', 0) as [cast failed] select dbo.try_cast('aaaa0101', 'date', default) as [cast failed] select dbo.try_cast(1.23, 'numeric(3,1)', default) as [cast failed] select dbo.try_cast('a', 'bit', default) as [cast failed] select dbo.try_cast(4, 'xml', default) as [unsupported];
update by:      javier eduardo pardo moreno level 16, state 5, line 16 error converting data type varchar to float. alter function dbo.try_cast ( @pexpression as varchar(8000), @pdata_type as varchar(8000), @preturnvalueiferrorcast as sql_variant = null ) as begin if @pdata_type = 'int' if isnumeric(@pexpression) = 1 and @pexpression not in ('-','+','$','.',',','\')    --jepm20170216 if @pexpressionint between - 2147483648.0 and 2147483647.0 end else begin end --fin if @pexpressionint between - 2147483648.0 and 2147483647.0 end else begin end -- fin if isnumeric(@pexpression) = 1 end -- fin if @pdata_type = 'int' if @pdata_type in ('date','datetime') if isdate(@pexpression) = 1 if @pdata_type = 'date' end  if @pdata_type = 'datetime' end  end else begin if isdate(@pexpressiondatereplaced) = 1 if @pdata_type = 'date' end  if @pdata_type = 'datetime' end  end else begin end end --fin if isdate(@pexpression) = 1 end --fin if @pdata_type = 'date' if @pdata_type like 'numeric%' if isnumeric(@pexpression) = 1 set @pexpression = replace(@pexpression, ',','.') set @totaldigitsofvalue = len(replace(@pexpression, '.','')) set @totaldecimalsofvalue = case charindex('.', @pexpression) then 0 else len(cast(cast(reverse(convert(varchar(50), @pexpression, 128)) as float) as bigint)) end set @totalwholedigitsoftype = @totaldigitsoftype - @totaldecimalsoftype set @totalwholedigitsofvalue = @totaldigitsofvalue - @totaldecimalsofvalue if (@totaldigitsofvalue <= @totaldigitsoftype) and (@totaldecimalsofvalue <= @totaldecimalsoftype) and (@totalwholedigitsofvalue <= @totalwholedigitsoftype) set @pexpressionnumeric = cast (round(@pexpression, @totaldecimalsofvalue) as float) end else begin end else begin end --fin if isnumeric(@pexpression) = 1 end --if @pdata_type like 'numeric%' if @pdata_type like 'bit' if isnumeric(@pexpression) = 1 end else begin end --fin if isnumeric(@pexpression) = 1 end --if @pdata_type like 'bit' if @pdata_type like 'float' if isnumeric(replace(replace(@pexpression, char(13), ''), char(10), '')) = 1 end else begin if replace(@pexpression, char(13), '') = '' --only white spaces are replaced, not new lines end else begin end --if replace(@pexpression, char(13), '') = '' end --fin if isnumeric(@pexpression) = 1 end --if @pdata_type like 'float' end;
set @text = '100' select case when isnumeric(@text) = 1 then cast(@text as int) else null end set @text = 'xxx' select case when isnumeric(@text) = 1 then cast(@text as int) else null end;
alter table location_key drop constraint pinky;
alter table your_table add constraint pinky unique(yourcolumn);
create table customer ( id int primary key identity (1,1) , name nvarchar(128) ) alter table customer add constraint u_name unique(name);
create function [dbo].[udf_striphtml] (@htmltext varchar(max)) set @start = charindex('<',@htmltext) set @end = charindex('>',@htmltext,charindex('<',@htmltext)) set @length = (@end - @start) + 1 set @htmltext = stuff(@htmltext,@start,@length,'') set @start = charindex('<',@htmltext) set @end = charindex('>',@htmltext,charindex('<',@htmltext)) set @length = (@end - @start) + 1 end return ltrim(rtrim(@htmltext)) end go;
create function dbo.striphtml( @text varchar(max) ) returns varchar(max) as set @textxml = replace( @text, '&', '' );
( select chunks.chunk.query('.') from @textxml.nodes('/') as chunks(chunk) ) select @result = contents.value('.', 'varchar(max)') from doc end go select dbo.striphtml('this <i>is</i> an <b>html</b> test');
create function [dbo].[striphtml] (@htmltext varchar(max)) as begin set @start = charindex('<',@htmltext) set @end = charindex('>',@htmltext,charindex('<',@htmltext)) set @length = (@end - @start) + 1 if (upper(substring(@htmltext, @start, 3)) <> '<br') and (upper(substring(@htmltext, @start, 2)) <> '<p') and (upper(substring(@htmltext, @start, 2)) <> '<b') and (upper(substring(@htmltext, @start, 3)) <> '</b') set @htmltext = stuff(@htmltext,@start,@length,'') end  set @start = charindex('<',@htmltext, @end) set @end = charindex('>',@htmltext,charindex('<',@htmltext, @start)) set @length = (@end - @start) - 1 end  end;
create function [dbo].[striphtml] (@htmltext varchar(max)) as begin set @start = charindex('<',@htmltext) set @end = charindex('>',@htmltext,charindex('<',@htmltext)) set @length = (@end - @start) + 1 if (upper(substring(@htmltext, @start, 4)) <> '<br>') and (upper(substring(@htmltext, @start, 5)) <> '</br>') set @htmltext = stuff(@htmltext,@start,@length,'') end -- this else and set is important else set @length = 0;
set @start = charindex('<',@htmltext, @end-@length) set @end = charindex('>',@htmltext,charindex('<',@htmltext, @start)) set @length = (@end - @start) + 1 end  end;
alter function [dbo].[udf_striphtml] ( @htmltext varchar(max) ) as begin set @start = charindex('&amp;', @htmltext) set @end = @start + 4 set @length = (@end - @start) + 1 set @htmltext = stuff(@htmltext, @start, @length, '&') set @start = charindex('&amp;', @htmltext) set @end = @start + 4 set @length = (@end - @start) + 1 end  set @start = charindex('&lt;', @htmltext) set @end = @start + 3 set @length = (@end - @start) + 1 set @htmltext = stuff(@htmltext, @start, @length, '<') set @start = charindex('&lt;', @htmltext) set @end = @start + 3 set @length = (@end - @start) + 1 end  set @start = charindex('&gt;', @htmltext) set @end = @start + 3 set @length = (@end - @start) + 1 set @htmltext = stuff(@htmltext, @start, @length, '>') set @start = charindex('&gt;', @htmltext) set @end = @start + 3 set @length = (@end - @start) + 1 end  set @start = charindex('&amp;amp;', @htmltext) set @end = @start + 4 set @length = (@end - @start) + 1 set @htmltext = stuff(@htmltext, @start, @length, '&') set @start = charindex('&amp;amp;', @htmltext) set @end = @start + 4 set @length = (@end - @start) + 1 end  set @start = charindex('&nbsp;', @htmltext) set @end = @start + 5 set @length = (@end - @start) + 1 set @htmltext = stuff(@htmltext, @start, @length, ' ') set @start = charindex('&nbsp;', @htmltext) set @end = @start + 5 set @length = (@end - @start) + 1 end  set @start = charindex('<br>', @htmltext) set @end = @start + 3 set @length = (@end - @start) + 1 set @htmltext = stuff(@htmltext, @start, @length, char(13) + char(10)) set @start = charindex('<br>', @htmltext) set @end = @start + 3 set @length = (@end - @start) + 1 end  set @start = charindex('<br/>', @htmltext) set @end = @start + 4 set @length = (@end - @start) + 1 set @htmltext = stuff(@htmltext, @start, @length, char(13) + char(10)) set @start = charindex('<br/>', @htmltext) set @end = @start + 4 set @length = (@end - @start) + 1 end  set @start = charindex('<br />', @htmltext) set @end = @start + 5 set @length = (@end - @start) + 1 set @htmltext = stuff(@htmltext, @start, @length, char(13) + char(10)) set @start = charindex('<br />', @htmltext) set @end = @start + 5 set @length = (@end - @start) + 1 end  set @start = charindex('<style', @htmltext) set @end = charindex('</style>', @htmltext, charindex('<', @htmltext)) + 7 set @length = (@end - @start) + 1 set @htmltext = stuff(@htmltext, @start, @length, '') set @start = charindex('<style', @htmltext) set @end = charindex('</style>', @htmltext, charindex('</style>', @htmltext)) + 7 set @length = (@end - @start) + 1 end  set @start = charindex('<', @htmltext) set @end = charindex('>', @htmltext, charindex('<', @htmltext)) set @length = (@end - @start) + 1 set @htmltext = stuff(@htmltext, @start, @length, '') set @start = charindex('<', @htmltext) set @end = charindex('>', @htmltext, charindex('<', @htmltext)) set @length = (@end - @start) + 1 end  end;
alter function [dbo].[udf_striphtml] ( @htmltext varchar(max) ) as begin set @htmltext = replace(@htmltext, '<br>',char(13) + char(10)) set @htmltext = replace(@htmltext, '<br/>',char(13) + char(10)) set @htmltext = replace(@htmltext, '<br />',char(13) + char(10)) set @htmltext = replace(@htmltext, '<li>','- ') set @htmltext = replace(@htmltext, '</li>',char(13) + char(10)) set @htmltext = replace(@htmltext, '&rsquo;' collate latin1_general_cs_as, ''''  collate latin1_general_cs_as) set @htmltext = replace(@htmltext, '&quot;' collate latin1_general_cs_as, '"'  collate latin1_general_cs_as) set @htmltext = replace(@htmltext, '&amp;' collate latin1_general_cs_as, '&'  collate latin1_general_cs_as) set @htmltext = replace(@htmltext, '&euro;' collate latin1_general_cs_as, ''  collate latin1_general_cs_as) set @htmltext = replace(@htmltext, '&lt;' collate latin1_general_cs_as, '<'  collate latin1_general_cs_as) set @htmltext = replace(@htmltext, '&gt;' collate latin1_general_cs_as, '>'  collate latin1_general_cs_as) set @htmltext = replace(@htmltext, '&oelig;' collate latin1_general_cs_as, 'oe'  collate latin1_general_cs_as) set @htmltext = replace(@htmltext, '&nbsp;' collate latin1_general_cs_as, ' '  collate latin1_general_cs_as) set @htmltext = replace(@htmltext, '&copy;' collate latin1_general_cs_as, ''  collate latin1_general_cs_as) set @htmltext = replace(@htmltext, '&laquo;' collate latin1_general_cs_as, ''  collate latin1_general_cs_as) set @htmltext = replace(@htmltext, '&reg;' collate latin1_general_cs_as, ''  collate latin1_general_cs_as) set @htmltext = replace(@htmltext, '&plusmn;' collate latin1_general_cs_as, ''  collate latin1_general_cs_as) set @htmltext = replace(@htmltext, '&sup2;' collate latin1_general_cs_as, ''  collate latin1_general_cs_as) set @htmltext = replace(@htmltext, '&sup3;' collate latin1_general_cs_as, ''  collate latin1_general_cs_as) set @htmltext = replace(@htmltext, '&micro;' collate latin1_general_cs_as, ''  collate latin1_general_cs_as) set @htmltext = replace(@htmltext, '&middot;' collate latin1_general_cs_as, ''  collate latin1_general_cs_as) set @htmltext = replace(@htmltext, '&ordm;' collate latin1_general_cs_as, ''  collate latin1_general_cs_as) set @htmltext = replace(@htmltext, '&raquo;' collate latin1_general_cs_as, ''  collate latin1_general_cs_as) set @htmltext = replace(@htmltext, '&frac14;' collate latin1_general_cs_as, ''  collate latin1_general_cs_as) set @htmltext = replace(@htmltext, '&frac12;' collate latin1_general_cs_as, ''  collate latin1_general_cs_as) set @htmltext = replace(@htmltext, '&frac34;' collate latin1_general_cs_as, ''  collate latin1_general_cs_as) set @htmltext = replace(@htmltext, '&aelig' collate latin1_general_cs_as, ''  collate latin1_general_cs_as) set @htmltext = replace(@htmltext, '&ccedil;' collate latin1_general_cs_as, ''  collate latin1_general_cs_as) set @htmltext = replace(@htmltext, '&egrave;' collate latin1_general_cs_as, ''  collate latin1_general_cs_as) set @htmltext = replace(@htmltext, '&eacute;' collate latin1_general_cs_as, ''  collate latin1_general_cs_as) set @htmltext = replace(@htmltext, '&ecirc;' collate latin1_general_cs_as, ''  collate latin1_general_cs_as) set @htmltext = replace(@htmltext, '&ouml;' collate latin1_general_cs_as, ''  collate latin1_general_cs_as) set @htmltext = replace(@htmltext, '&agrave;' collate latin1_general_cs_as, ''  collate latin1_general_cs_as) set @htmltext = replace(@htmltext, '&acirc;' collate latin1_general_cs_as, ''  collate latin1_general_cs_as) set @htmltext = replace(@htmltext, '&auml;' collate latin1_general_cs_as, ''  collate latin1_general_cs_as) set @htmltext = replace(@htmltext, '&aelig;' collate latin1_general_cs_as, ''  collate latin1_general_cs_as) set @htmltext = replace(@htmltext, '&ccedil;' collate latin1_general_cs_as, ''  collate latin1_general_cs_as) set @htmltext = replace(@htmltext, '&egrave;' collate latin1_general_cs_as, ''  collate latin1_general_cs_as) set @htmltext = replace(@htmltext, '&eacute;' collate latin1_general_cs_as, ''  collate latin1_general_cs_as) set @htmltext = replace(@htmltext, '&ecirc;' collate latin1_general_cs_as, ''  collate latin1_general_cs_as) set @htmltext = replace(@htmltext, '&euml;' collate latin1_general_cs_as, ''  collate latin1_general_cs_as) set @htmltext = replace(@htmltext, '&icirc;' collate latin1_general_cs_as, ''  collate latin1_general_cs_as) set @htmltext = replace(@htmltext, '&ocirc;' collate latin1_general_cs_as, ''  collate latin1_general_cs_as) set @htmltext = replace(@htmltext, '&ouml;' collate latin1_general_cs_as, ''  collate latin1_general_cs_as) set @htmltext = replace(@htmltext, '&divide;' collate latin1_general_cs_as, ''  collate latin1_general_cs_as) set @htmltext = replace(@htmltext, '&oslash;' collate latin1_general_cs_as, ''  collate latin1_general_cs_as) set @htmltext = replace(@htmltext, '&ugrave;' collate latin1_general_cs_as, ''  collate latin1_general_cs_as) set @htmltext = replace(@htmltext, '&uacute;' collate latin1_general_cs_as, ''  collate latin1_general_cs_as) set @htmltext = replace(@htmltext, '&ucirc;' collate latin1_general_cs_as, ''  collate latin1_general_cs_as) set @htmltext = replace(@htmltext, '&uuml;' collate latin1_general_cs_as, ''  collate latin1_general_cs_as) set @htmltext = replace(@htmltext, '&quot;' collate latin1_general_cs_as, '"'  collate latin1_general_cs_as) set @htmltext = replace(@htmltext, '&amp;' collate latin1_general_cs_as, '&'  collate latin1_general_cs_as) set @htmltext = replace(@htmltext, '&lsaquo;' collate latin1_general_cs_as, '<'  collate latin1_general_cs_as) set @htmltext = replace(@htmltext, '&rsaquo;' collate latin1_general_cs_as, '>'  collate latin1_general_cs_as) set @start = charindex('<style', @htmltext) set @end = charindex('</style>', @htmltext, charindex('<', @htmltext)) + 7 set @length = (@end - @start) + 1 set @htmltext = stuff(@htmltext, @start, @length, '') set @start = charindex('<style', @htmltext) set @end = charindex('</style>', @htmltext, charindex('</style>', @htmltext)) + 7 set @length = (@end - @start) + 1 end  set @start = charindex('<', @htmltext) set @end = charindex('>', @htmltext, charindex('<', @htmltext)) set @length = (@end - @start) + 1 set @htmltext = stuff(@htmltext, @start, @length, '') set @start = charindex('<', @htmltext) set @end = charindex('>', @htmltext, charindex('<', @htmltext)) set @length = (@end - @start) + 1 end  end;
set @malformedxml = @xml.query('for $x in //. return ($x)//text()') set @strippedtext = cast(@malformedxml as varchar(max));
set @malformedxml = @xml.query('for $x in //. return concat((($x)//text())[1]," ")') set @strippedtext = cast(@malformedxml as varchar(max));
select cast(html_column.query('for $x in //. return concat((($x)//text()) as varchar(max)) from table;
set @htmltext = replace(@htmltext, '&lt;' collate latin1_general_cs_as, '<'  collate latin1_general_cs_as) set @htmltext = replace(@htmltext, '&gt;' collate latin1_general_cs_as, '>'  collate latin1_general_cs_as);
select replace(replace(replace(cast(cast(replace([columnnamehere], '&', '&amp;') as xml).query('for $x in //. return concat((($x)//text())[1]," ")') as varchar(max)), '&amp;', '&'), '&nbsp;', ' '), '&#x20;', ' ') from [tablename];
select cast(cast([columnnamehere] as xml).query('for $x in //. return concat((($x)//text())[1]," ")') as varchar(max)) from [tablename];
select column1, try_convert(xml, column2).value('.', 'nvarchar(max)') as col2, column3 from   dbo.tablename;
select utl_raw.cast_to_varchar2(dbms_lob.substr(<your_blob_field>,2000,1)) from <your_table>;
create or replace package read_gzipped_entity_package as end read_gzipped_entity_package;
create or replace package body read_gzipped_entity_package is select utl_compress.lz_uncompress(compressed_blob_column_name) from   table_name where  id = entity_id;
end read_gzipped_entity_package;
select read_gzipped_entity_package.read_entity('entity_id') from dual;
select to_char(dbms_lob.substr(blob_field, 3900)) from table_with_blob;
select to_char(blob_field) from table_with_blob where id = '<row id>';
select my_id from my_table where my_id='my_id' ) select * from unzipped_text where dbms_lob.instr(my_blob, utl_raw.cast_to_raw('my_search_string'))>0;
select * from my_table where dbms_lob.instr(my_uncompressed_blob, utl_raw.cast_to_raw('my_search_string'))>0;
select dbms_lob.substr(blob_field_name) from table_name;
select utl_raw.cast_to_varchar2(dbms_lob.substr(blob_field)) from table_with_blob where id = '<row id>';
select t1.*, sq.* from table1 t1, (select a,b,c from table2 ...) sq where ...;
select a.salesorderid, b.foo from a join b bo on bo.id = ( select top 1 id from b bi where bi.salesorderid = a.salesorderid ) where a.date between '2000-1-4' and '2010-1-4';
select salesorderid, foo from ( select a.salesorderid, b.foo, row_number() over (partition by b.salesorderid order by b.whatever) as rn from a join b on b.salesorderid = a.salesorderid where a.date between '2000-1-4' and '2010-1-4' where rn;
select a.salesorderid, a.orderdate, sq.max_foo, sq.max_foo2 from a ( select b.salesorderid, max(b.foo) as max_foo, max(b.foo2) as max_foo2 from b b.salesorderid;
select a.salesorderid, a.orderdate, b1.foo, b1.foo2 from a where b2.salesorderid is null;
select a.salesorderid, a.orderdate, foofromb.* from a, (select top 1 b.foo from b where a.salesorderid = b.salesorderid where a.date between '2000-1-4' and '2010-1-4';
select a.salesorderid, a.orderdate, s.orderdate, s.salesorderid from a a from b b where a.salesorderid = b.salesorderid) as s where a.date between '2000-1-4' and '2010-1-4';
select @errormessage = error_message() + ' occurred at line_number: ' + cast(error_line() as varchar(50)), @errorseverity = error_severity(), @errorstate = error_state();
create procedure;
create procedure errortesting as begin set nocount on;
select 1/0 end go;
alter procedure;
exec errortesting;
where t2.phonenumber is not null or t3.phonenumber is not null;
select t.phonenumber1, t.phonenumber2, t1.someotherfieldforphone1, t2.someotherfieldforphone2 from table1 t join table2 t1 on t1.phonenumber = t.phonenumber1 join table2 t2 on t2.phonenumber = t.phonenumber2;
select table1.phonenumber1 as phonenumber, table2.someotherfield as otherfield from table1 join table2 union select table1.phonenumber2 as phonenumber, table2.someotherfield as otherfield from table1 join table2;
select t.phonenumber1, t.phonenumber2, t.phonenumber3 from ( ( table1 as t left join table2 as t3 on t.phonenumber3 = t3.phonenumber ) );
if (rs != null) { if (data.get(j) != null) { if (conn != null) { string username, string password) {;
string displayname = metadata.getcolumnlabel(i);
case types.array:;
select col1, col2 as my_alias from table;
{ "col1": 1, "col2": 2 };
{ "col1": 1, "my_alias": 2 };
if (rsmd.getcolumntype(i) == java.sql.types.varchar) {;
if (indent != null) jsonwriter.setindent(indent);
if (closewriter) jsonwriter.close();
if (stmt != null) stmt.close();
if (conn != null) conn.close();
if (closewriter && jsonwriter != null) jsonwriter.close();
if (columntype.equals("date")) {;
set sql_mode = "no_auto_value_on_zero";
set time_zone = "+00:00";
create database if not exists `jdbc_tutorial` default character set latin1 collate latin1_swedish_ci;
drop function if exists `getage`$$ create definer=`root`@`localhost` function `getage` (`in_dob` date) returns int(11) no sql if date_format(now(),'00-%m-%d') >= date_format(in_dob,'00-%m-%d') then set l_age=date_format(now(),'%y')-date_format(in_dob,'%y');
else -- yet to have a birthday this year set l_age=date_format(now(),'%y')-date_format(in_dob,'%y')-1;
drop table if exists `beatles`;
create table if not exists `beatles` ( `id` int(11) not null, `first_name` varchar(255) default null, `last_name` varchar(255) default null, `date_of_birth` date default null, primary key (`id`);
"lastname": "lennon", "dateofbirth": "1940-10-09", "id": 100 { "lastname": "mccartney", "dateofbirth": "1942-06-18", "id": 101 { "lastname": "harrison", "dateofbirth": "1943-02-25", "id": 102 { "lastname": "starr", "dateofbirth": "1940-07-07", "id": 103;
"lastname": "lennon", "age": 75 { "lastname": "mccartney", "age": 73 { "lastname": "harrison", "age": 72 { "lastname": "starr", "age": 75;
case types.integer: if (rs.wasnull()) { case types.bigint: if (rs.wasnull()) { case types.decimal: case types.numeric: case types.float: case types.real: case types.double: if (rs.wasnull()) { case types.nvarchar: case types.varchar: case types.longnvarchar: case types.longvarchar: case types.boolean: case types.bit: if (rs.wasnull()) { case types.binary: case types.varbinary: case types.longvarbinary: case types.tinyint: case types.smallint: if (rs.wasnull()) { case types.date: case types.timestamp: case types.blob: case types.clob: case types.array: case types.struct: case types.distinct: case types.ref: case types.java_object:;
{"name":"field-2","type":"type-2"}, ..., {"name":"field-n","type":"type-n"}], "records":[[value-1-1,value-1-2,...,value-1-n], [value-2-1,value-2-2,...,value-2-n]]};
select json_arrayagg(json_object(*)) from t;
select * from t;
select to_jsonb(array_agg(t)) from t;
jsonexception { if (rsmd.getcolumntype(i) == java.sql.types.array) {;
case java.sql.types.array: case java.sql.types.bigint: case java.sql.types.boolean: case java.sql.types.blob: case java.sql.types.double: case java.sql.types.float: case java.sql.types.integer: case java.sql.types.nvarchar: case java.sql.types.varchar: case java.sql.types.tinyint: case java.sql.types.smallint: case java.sql.types.date: case java.sql.types.timestamp:;
if (ordinalvalue == 1) {;
case 1: case 2:;
second, third, fourth, fifth, sixth, seventh, eighth, ninth, tenth if (j == testenum.first.ordinal()) { case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: case 8: case 9: case first: case second: case third: case fourth: case fifth: case sixth: case seventh: case eighth: case ninth:;
select dateadd(s,1274756183,'19700101 05:00:00:000');
create function dbo.fn_converttodatetime (@datetime bigint) as begin set @localtimeoffset = datediff(second,getdate(),getutcdate()) set @adjustedlocaldatetime = @datetime - @localtimeoffset;
select @unix_time = 1111111111 select [datetime from unix time] = dateadd(!precision!,@unix_time,'1970-01-01');
select dateadd(s, [unixtime], '1970-01-01') from [table];
create function [dbo].[unixtimestamptogmtdatetime] as begin select @gmtdatetime = case when dateadd(ss, @unixtimestamp/1000, '1970-01-01') between convert(datetime, convert(varchar(4), year(dateadd(ss, @unixtimestamp/1000, '1970-01-01') )) + '-03-' + convert(varchar(2), (31 - (5 * year(dateadd(ss, @unixtimestamp/1000, '1970-01-01') )/4 + 4) % 7)) + ' 01:00:00', 20) and convert(datetime, convert(varchar(4), year(dateadd(ss, @unixtimestamp/1000, '1970-01-01') )) + '-10-' + convert(varchar(2), (31 - (5 * year(dateadd(ss, @unixtimestamp/1000, '1970-01-01') )/4 + 1) % 7)) + ' 02:00:00', 20) then dateadd(hh, 1, dateadd(ss, @unixtimestamp/1000, '1970-01-01')) else dateadd(hh, 0, dateadd(ss, @unixtimestamp/1000, '1970-01-01')) end return @gmtdatetime end;
select dateadd(s, timestamp, '1970-01-01 00:00:00') from your_table;
select from_unixtime(timestamp) from your_table;
select dateadd(s, convert(int,left(1462924862735870900, 10)), '1970-01-01') from table;
create function [dbo].[convertunixtimestamp] (@datetime [bigint]) returns datetime as begin dateadd(second, (cast(@datetime as bigint) / 1000)%60, dateadd(minute, ((cast(@datetime as bigint) / 1000)/60)%60, dateadd(hour, ((cast(@datetime as bigint) / 1000)/60)/60, '19700101')))) end;
create table [dbo].[cfg_day_light_savings_time]( [begin_date] [datetime] null, [end_date] [datetime] null, [year_date] [smallint] null ('2002-04-07 02:00:00.000',   '2002-10-26 01:59:59.997',    2002), ('2003-04-06 02:00:00.000',   '2003-10-25 01:59:59.997',    2003), ('2004-04-04 02:00:00.000',   '2004-10-30 01:59:59.997',    2004), ('2005-04-03 02:00:00.000',   '2005-10-29 01:59:59.997',    2005), ('2006-04-02 02:00:00.000',   '2006-10-28 01:59:59.997',    2006), ('2007-03-11 02:00:00.000',   '2007-11-03 01:59:59.997',    2007), ('2008-03-09 02:00:00.000',   '2008-11-01 01:59:59.997',    2008), ('2009-03-08 02:00:00.000',   '2009-10-31 01:59:59.997',    2009), ('2010-03-14 02:00:00.000',   '2010-11-06 01:59:59.997',    2010), ('2011-03-13 02:00:00.000',   '2011-11-05 01:59:59.997',    2011), ('2012-03-11 02:00:00.000',   '2012-11-03 01:59:59.997',    2012), ('2013-03-10 02:00:00.000',   '2013-11-02 01:59:59.997',    2013), ('2014-03-09 02:00:00.000',   '2014-11-01 01:59:59.997',    2014), ('2015-03-08 02:00:00.000',   '2015-10-31 01:59:59.997',    2015), ('2016-03-13 02:00:00.000',   '2016-11-05 01:59:59.997',    2016), ('2017-03-12 02:00:00.000',   '2017-11-04 01:59:59.997',    2017), ('2018-03-11 02:00:00.000',   '2018-11-03 01:59:59.997',    2018), ('2019-03-10 02:00:00.000',   '2019-11-02 01:59:59.997',    2019), ('2020-03-08 02:00:00.000',   '2020-10-31 01:59:59.997',    2020), ('2021-03-14 02:00:00.000',   '2021-11-06 01:59:59.997',    2021), ('2022-03-13 02:00:00.000',   '2022-11-05 01:59:59.997',    2022), ('2023-03-12 02:00:00.000',   '2023-11-04 01:59:59.997',    2023), ('2024-03-10 02:00:00.000',   '2024-11-02 01:59:59.997',    2024), ('2025-03-09 02:00:00.000',   '2025-11-01 01:59:59.997',    2025), ('1967-04-30 02:00:00.000',   '1967-10-29 01:59:59.997',    1967), ('1968-04-28 02:00:00.000',   '1968-10-27 01:59:59.997',    1968), ('1969-04-27 02:00:00.000',   '1969-10-26 01:59:59.997',    1969), ('1970-04-26 02:00:00.000',   '1970-10-25 01:59:59.997',    1970), ('1971-04-25 02:00:00.000',   '1971-10-31 01:59:59.997',    1971), ('1972-04-30 02:00:00.000',   '1972-10-29 01:59:59.997',    1972), ('1973-04-29 02:00:00.000',   '1973-10-28 01:59:59.997',    1973), ('1974-01-06 02:00:00.000',   '1974-10-27 01:59:59.997',    1974), ('1975-02-23 02:00:00.000',   '1975-10-26 01:59:59.997',    1975), ('1976-04-25 02:00:00.000',   '1976-10-31 01:59:59.997',    1976), ('1977-04-24 02:00:00.000',   '1977-10-31 01:59:59.997',    1977), ('1978-04-30 02:00:00.000',   '1978-10-29 01:59:59.997',    1978), ('1979-04-29 02:00:00.000',   '1979-10-28 01:59:59.997',    1979), ('1980-04-27 02:00:00.000',   '1980-10-26 01:59:59.997',    1980), ('1981-04-26 02:00:00.000',   '1981-10-25 01:59:59.997',    1981), ('1982-04-25 02:00:00.000',   '1982-10-25 01:59:59.997',    1982), ('1983-04-24 02:00:00.000',   '1983-10-30 01:59:59.997',    1983), ('1984-04-29 02:00:00.000',   '1984-10-28 01:59:59.997',    1984), ('1985-04-28 02:00:00.000',   '1985-10-27 01:59:59.997',    1985), ('1986-04-27 02:00:00.000',   '1986-10-26 01:59:59.997',    1986), ('1987-04-05 02:00:00.000',   '1987-10-25 01:59:59.997',    1987), ('1988-04-03 02:00:00.000',   '1988-10-30 01:59:59.997',    1988), ('1989-04-02 02:00:00.000',   '1989-10-29 01:59:59.997',    1989), ('1990-04-01 02:00:00.000',   '1990-10-28 01:59:59.997',    1990), ('1991-04-07 02:00:00.000',   '1991-10-27 01:59:59.997',    1991), ('1992-04-05 02:00:00.000',   '1992-10-25 01:59:59.997',    1992), ('1993-04-04 02:00:00.000',   '1993-10-31 01:59:59.997',    1993), ('1994-04-03 02:00:00.000',   '1994-10-30 01:59:59.997',    1994), ('1995-04-02 02:00:00.000',   '1995-10-29 01:59:59.997',    1995), ('1996-04-07 02:00:00.000',   '1996-10-27 01:59:59.997',    1996), ('1997-04-06 02:00:00.000',   '1997-10-26 01:59:59.997',    1997), ('1998-04-05 02:00:00.000',   '1998-10-25 01:59:59.997',    1998), ('1999-04-04 02:00:00.000',   '1999-10-31 01:59:59.997',    1999), ('2000-04-02 02:00:00.000',   '2000-10-29 01:59:59.997',    2000);
create function [dbo].[unixtimetopacific] as begin select  @pacificdatetime =  dateadd(hour,case when @interimdatetime between begin_date and end_date then -7 else -8 end  ,@interimdatetime) from cfg_day_light_savings_time  where  year_date = datepart(year,@interimdatetime) if @pacificdatetime is null select @pacificdatetime= dateadd(hour, -7, @interimdatetime) end;
create function [dbo].[unixtimetoeastern] as begin select  @easterndatetime =  dateadd(hour,case when @interimdatetime between begin_date and end_date then -4 else -5 end  ,@interimdatetime) from cfg_day_light_savings_time  where  year_date = datepart(year,@interimdatetime) if @easterndatetime is null select @easterndatetime= dateadd(hour, -4, @interimdatetime) end;
create function [dbo].[unixtimetocentral] as begin select  @centraldatetime =  dateadd(hour,case when @interimdatetime between begin_date and end_date then -5 else -6 end  ,@interimdatetime) from cfg_day_light_savings_time  where  year_date = datepart(year,@interimdatetime) if @centraldatetime is null select @centraldatetime= dateadd(hour, -5, @interimdatetime) end;
create function [dbo].[unixtimetomountain] as begin select  @mountaindatetime =  dateadd(hour,case when @interimdatetime between begin_date and end_date then -6 else -7 end  ,@interimdatetime) from cfg_day_light_savings_time  where  year_date = datepart(year,@interimdatetime) if @mountaindatetime is null select @mountaindatetime= dateadd(hour, -6, @interimdatetime) end;
create function [dbo].[unixtimetohawaii] as begin select  @hawaiidatetime =  dateadd(hour,-10,@interimdatetime) from cfg_day_light_savings_time  where  year_date = datepart(year,@interimdatetime) end;
create function [dbo].[unixtimetoarizona] as begin select  @arizonadatetime =  dateadd(hour,-7,@interimdatetime) from cfg_day_light_savings_time  where  year_date = datepart(year,@interimdatetime) end;
create function [dbo].[unixtimetoalaska] as begin select  @alaskadatetime =  dateadd(hour,case when @interimdatetime between begin_date and end_date then -8 else -9 end  ,@interimdatetime) from cfg_day_light_savings_time  where  year_date = datepart(year,@interimdatetime) if @alaskadatetime is null select @alaskadatetime= dateadd(hour, -8, @interimdatetime) end;
select * from (values (1514808000), (1527854400)) as tests(unixtimestamp);
select *, dateadd(second, unixtimestamp, '1970-01-01') at time zone 'utc' at time zone 'pacific standard time' from (values (1514808000), (1527854400)) as tests(unixtimestamp);
select dateadd(s, @unixtime+datediff (s, getutcdate(), getdate()), '1970-01-01');
create function dbo.convertunixtime (@input int) as begin set @unix = cast(dateadd(s, @input, '1970-01-01') at time zone 'utc' at time zone 'pacific standard time' as datetime) end;
select   dbo.convertunixtime([unixtimestamp]) from     yourtable;
select [datetime] = dateadd(second, @adjustedtimestamp % 1000, dateadd(second, @adjustedtimestamp / 1000, '19700101'));
select @ts = datediff_big(nanosecond, @epoch, @d) / 100; -- 'now' in ticks according to unix epoch select @timepart = (@ts % @ticksofday) / @ticksofday; -- extract time part and scale it to fractional part (i. e. 1 hour is 1/24th of a day) select @datepart = (@ts - @timepart) / @ticksofday; -- extract date part and scale it to fractional part select @restored = cast(@epochdiff + @datepart + @timepart as datetime); -- rebuild parts to a datetime value select @d original, @ts unix64, @restored restored;
select dateadd(millisecond, cast(right(@value, 3) as int) - datediff(millisecond,getdate(),getutcdate()), dateadd(second, cast(left(@value, 10) as int), '1970-01-01t00:00:00'));
create function dbo.convertunixtodatetime(@datetime bigint) as begin;
select { d '2013-10-01' };
select { ts '2013-10-01 13:45:01' };
where checktime >= '2019-01-24 15:01:36.000' and checktime <= '2019-01-25 16:01:36.000';
alter authorization on schema::[db_datareader] to [dbo] alter authorization on schema::[db_datareader] to [db_datareader] alter authorization on schema::[db_datawriter] to [dbo] alter authorization on schema::[db_datawriter] to [db_datawriter] alter authorization on schema::[db_securityadmin] to [dbo] alter authorization on schema::[db_securityadmin] to [db_securityadmin] alter authorization on schema::[db_accessadmin] to [dbo] alter authorization on schema::[db_accessadmin] to [db_accessadmin] alter authorization on schema::[db_backupoperator] to [dbo] alter authorization on schema::[db_backupoperator] to [db_backupoperator] alter authorization on schema::[db_ddladmin] to [dbo] alter authorization on schema::[db_ddladmin] to [db_ddladmin] alter authorization on schema::[db_owner] to [dbo] alter authorization on schema::[db_owner] to [db_owner];
alter schema myschema transfer dbo.mytable;
alter schema dbo transfer myschema.mytable;
alter schema dbo transfer [domain\jonathan].moviedata;
select specific_schema as 'schema', specific_name as 'name' from information_schema.routines where specific_schema <> 'dbo' union all  select table_schema as 'schema', table_name as 'name' from information_schema.tables where table_schema <> 'dbo' @tab sysname, @sql varchar(500) set @sql = 'alter schema dbo transfer [' + @schema + '].[' + @tab +']' exec (@sql) end ;
alter schema dbo transfer jonathan.moviedata;
alter schema targetschema transfer sourceschema.tablename;
alter schema dbo transfer jonathan.moviedata;
select 'alter schema dbo transfer ' + table_schema + '.' + table_name from information_schema.tables where table_schema = 'jonathan';
select @old = 'jonathan' if exists (select null from information_schema.tables where quotename(table_schema)+''.''+quotename(table_name) = ''?'' and table_schema = ''' + @old + ''' );
select  o.name from    sys.objects o where   type in ('p', 'u', 'v') set @sql = 'alter schema '+ @newschema +' transfer '+ @oldschema + '.' +  @name end try end catch end close   objcursor;
alter schema dbo transfer myoldschema.xx_getuserinformation;
update q set q.questionid = a.questionid from questiontrackings q where q.questionid is null -- and other conditions you might want;
select * from questiontrackings q where q.questionid is null -- and other conditions you might want;
update "questiontrackings" set "questionid" = (select "questionid" from "answers" where "answerid"="questiontrackings"."answerid") where "questionid" is null and ...;
update questiontrackings set questionid = (select questionid from answertrackings where answertrackings.answerid = questiontrackings.answerid) where questionid is null and exists(select questionid from answertrackings where answertrackings.answerid = questiontrackings.answerid);
update questiontrackings set questionid = a.questionid from questiontrackings q, questionanswers a where q.questionid is null;
select p.post_title,m.meta_value sale_price ,n.meta_value   regular_price from  wp_postmeta m and m.meta_key = '_sale_price' and  n.meta_key = '_regular_price' and p.post_type = 'product';
update  wp_postmeta m and m.meta_key = '_sale_price' and  n.meta_key = '_regular_price' and p.post_type = 'product' set m.meta_value = n.meta_value;
update table1 inner join table2 on table1.column1 = table2.column1 set table1.column2 = table2.column4 where table1.column3 = 'randomcondition';
update a from table1 a inner join table2 b on a.column1 = b.column1 set a.column2 = b.column4 where a.column3 = 'randomcondition';
update table1 inner join table2 on table1.col1 =  table2.col1 set table1.col1 =  table2.col2;
update questiontrackings set questionid = (select questionid from answertrackings where answertrackings.answerid = questiontrackings.answerid) where questionid is null and answerid is not null;
[value] int ) values (1),(2),(4),(5),(6),(10),(20),(21),(22),(50),(51),(52),(53),(54),(55) select [starttable].[value]+1 [start] from ( select [value] from @table join ( select [value] from @table where [starttable].[value]+1 <>[endtable].[value];
select temp.id from (select row_number() over () as num from 'table-name') as temp where id not in (select id from 'table-name');
select t1.c+1 as gap from t as t1 left outer join t as t2 on (t1.c+1=t2.c) where t2.c is null order by gap asc limit 1;
select min(t1.c)+1 as gap from t as t1 left outer join t as t2 on (t1.c+1=t2.c) where t2.c is null;
select  id + 1 from    mytable mo where   not exists ( select  null from    mytable mi where   mi.id = mo.id + 1 ) id limit 1;
select  top 1 from    mytable mo where   not exists ( select  null from    mytable mi where   mi.id = mo.id + 1 ) id;
select  * from    ( select  id + 1 as gap from    mytable mo where   not exists ( select  null from    mytable mi where   mi.id = mo.id + 1 ) id ) where   rownum = 1;
select  min(id) + 1 from    mytable mo where   not exists ( select  null from    mytable mi where   mi.id = mo.id + 1 );
select  -- top 1 from    ( select  id, lag(id) over (order by id) previd from    mytable where   previd <> id - 1 id;
select min(t1.id)+1 from mytable t1 where not exists (select id from mytable where id = (t1.id + 1));
select min(t1.id)+1 from mytable t1 where not exists (select id from mytable where id = (t1.id + 1)) and id > 2000;
create table artificial_range( id int not null primary key auto_increment, name varchar( 20 ) null ) ;
select a.id from artificial_range a where not exists ( select * from your_table b where b.counter = a.id) ;
select min(p1.field) + 1 as gap from table1 as p1 where p2.field is null;
select `table`.`num` + 1 from `table` where `alt`.`num` is null limit 1;
select top 1 `num` + 1 from `table` where `alt`.`num` is null;
select `num` + 1 from `table` where `alt`.`num` is null and rownum = 1;
select min(id+1) from ( select 0 as id union all select min(id + 1) from tablex) as t1 where id+1 not in (select id from tablex);
select min(id) from ( select 0 id union all select [youridcolumn]+1 from [yourtable] where --filter the rest of your key-- [yourtable] and --filter the rest of your key-- where [youridcolumn] is null;
select min([columnname]) from [tablename] where [columnname]-1 not in (select [columnname] from [tablename]) and [columnname] <> (select min([columnname]) from [tablename]);
select a.id -- find numbers from the range that do not exist in main table from a where b.id is null;
set @sql = from    '+@table_name+' mo where   not exists ( select  null from    '+@table_name+' mi where   mi.'+@column_name+' = mo.'+@column_name+' + 1 ) '+@column_name exec (@sql) select * from @missing_id set @sql = ' select @low = max('+@column_name+') + 1 from '+@table_name set @sql = @sql + ' select @high = min('+@column_name+') - 1 from '+@table_name set @sql = @sql + 'select @low,@high' end  select row_number() over(order by lower_missing_range) as 'gap number',* from @final_range;
select min(counter + 1) first_gap from my_table a where not exists (select 'x' from my_table b where b.counter = a.counter + 1) and a.counter <> (select max(c.counter) from my_table c);
select min(n) from ( select  case when lead(i,1,0) over(order by i)>i+1 then i+1 else null end n from mytable) w;
select rowid from ( select `id_column`, row_number() over(order by `id_column`) as rowid from `your_table` where `id_column` <> rowid;
select cardnumber - 1 from (select @row_number := 0) as t, ( select (@row_number:=@row_number+1), cardnumber, cardnumber-@row_number as diff from cards where diff >= 1 limit 0,1;
create table #id ( id integer );
select row_number()over ( order by a.id ) as seq from #id as a with(nolock) ) select top 1 gap_start from ( select (j.id+1) as gap_start from       source as j where (j.id - (k.id-1)) <> 0;
select nvl(min(id + 1),1) as gap from mytable mo where 1=1 and not exists ( select  null from    mytable mi where   mi.id = mo.id + 1 ) and exists ( select  null from    mytable mi where   mi.id = 1 );
create table sequential(id int not null, name varchar(10) null);
select a.* from sequential a left join sequential b on a.id = b.id + 1 where b.id is null and a.id <> (select min(id) from sequential) union select a.* from sequential a left join sequential b on a.id = b.id - 1 where b.id is null and a.id <> (select max(id) from sequential);
from django.core.paginator import paginator from djangoapp.models import model;
if index % 100 == 0:;
end = min(start + _batch_size, total);
from django.core.paginator import paginator;
host=db_config['host'], user=db_config['user'], port=int(db_config['port']), passwd=db_config['password'], db=db_config['name']) if record is none:;
create function;
create procedure #mytemp as select getdate() into #mytemptable;
create proc dostuff as begin set @sql = ' create function dbo._object_name_twopart (@object_id int) end ' create the function by executing the string, with a conditional object drop upfront if object_id('dbo._object_name_twopart') is not null drop function _object_name_twopart exec (@sql) select object_id, dbo._object_name_twopart(object_id) from sys.objects where type = 'u' drop function _object_name_twopart end go;
exec sp_executesql @add_a_b_func, @add_a_b_parm, 2, 3, @c = @result output;
if object_id('tempdb..##fn_divide') is not null drop procedure ##fn_divide create procedure ##fn_divide (@numerator real, @denominator real) as select division = case when @denominator != 0 and @denominator is not null and  @numerator != 0 and @numerator is not null then else 0 end return end go exec ##fn_divide 6,4;
set @returnstatus = null;
exec @returnstatus = dbo.ufngetsalesorderstatustext @status = 2;
create procedure yourstoredprocedure ( @param1    int ) as if isnull(@param1,0)>5 set @param3=getdate() end else begin set @param3='1/1/2010' end return 0;
exec @returnvalue=yourstoredprocedure 1,null, @outputparameter output;
create function [dbo].[mydatefunction] as return ( --- query your table or view or whatever and select the results. select datevalue from mytable where id = @myparameter;
set @mydate = (select datevalue from mydatefunction(@myparameter));
create function testdatefunction() end;
set @mydate = (select dbo.testdatefunction());
exec sp_executesql @checkvalue set @resultval = (select * from @temptable) delete @temptable select @resultval;
create table #eventid (eventid int) set @eventid = (select * from #eventid) drop table #eventid;
exec @resultforpos = storedprocedurename 'inputparameter' select @resultforpos;
alter table tbl_name alter column col_name type varchar (11);
alter table your_table add index (giver_id, recipient_id);
description: sequelize.text;
}, { tablename: 'people', name: { plural: 'people';
dialect: config.db.dialect, define: { freezetablename: true logging: false;
select concat(year(now()), '-01-01') as start, -- fist day of current year;
select convert(date, dateadd(yy, datediff(yy, 0,  dateadd(day, -1,getdate())), 0), 103 ) as startofyear, convert(date, dateadd(yy, datediff(yy, 0, datediff(day, -1,getdate()))+1, -1), 103 )as endofyear;
select datefromparts(year(getdate()), 1, 1) firstday, datefromparts(year(getdate()),12,31) lastday;
select datefromparts(year(getdate()), 1, 1) as 'first day of current year';
select datefromparts(year(getdate()), 12, 31) as 'end of current year';
select '01/01/' + ltrim(str(year(current_timestamp))) select '12/31/' + ltrim(str(year(current_timestamp)));
concat(year(getdate()),'-12-31') lastofyear;
select * from `table` where year(date_column) = '2012';
select '01/01/' + convert(varchar(4), datepart(yy, getutcdate())), '31/12/' + convert(varchar(4), datepart(yy, getutcdate()));
select dateadd(yy, datediff(yy, 0, getdate()), 0) as startofyear, dateadd(yy, datediff(yy, 0, getdate()) + 1, -1) as endofyear;
select dateadd(yy, datediff(yy, 0, getdate()), 0) as startofyear, dateadd(yy, datediff(yy, 0, getdate()) + 1, -1) as lastdayofyear, dateadd(yy, datediff(yy, 0, getdate()) + 1, 0) as firstofnextyear, dateadd(ms, -3, dateadd(yy, datediff(yy, 0, getdate()) + 1, 0)) as lasttimeofyear;
select dateadd(yy, datediff(yy, 0, '20150301'), 0) as startofyearformarch2015, dateadd(yy, 2015 - 1900, 0) as startofyearfor2015;
select convert(varchar(12),(dateadd(month,(month(getdate())-1) * -1, dateadd(day,(day(getdate())-1) * -1,getdate()))),103) as startyear, convert(varchar(12),dateadd(month,12 - month(getdate()), dateadd(day,(31 - day(getdate())),getdate())),103) as endyear;
select '01/01/'+cast(year(getdate()) as varchar(4)) as [first day], '12/31/'+cast(year(getdate()) as varchar(4)) as [last day];
create table users ( userid int,date_of_birth date );
select datediff(year,date_of_birth, getdate()) - (case when (dateadd(year, datediff(year,date_of_birth, getdate()),date_of_birth)) > getdate() then 1 else 0 end) as years, month(getdate() - (dateadd(year, datediff(year, date_of_birth, getdate()), date_of_birth))) - 1 as months, day(getdate() - (dateadd(year, datediff(year,date_of_birth, getdate()), date_of_birth))) - 1 as days, from users;
select dateadd(dd,-datepart(dy,getdate())+1,getdate());
select dateadd(dd,-datepart(dy,getdate())+1,getdate());
select dateadd(dd,-1,dateadd(yy,datediff(yy,0,getdate())+1,0));
select to_date(substr(sysdate,1, 4) || '01/01'), to_date(substr(sysdate,1, 4) || '12/31') from dual;
select convert (date,dateadd(year,datediff(year,0,getdate()),0));
select convert (date,dateadd(year, datediff(year,0,getdate()) + 1, -1));
select colname1, colname2,colname3 from tablename;
/var/log/mysql/* rw, /var/run/mysqld/mysqld.pid w, /var/run/mysqld/mysqld.sock w, **/data/ r, /data/* rw,**;
delete from table1 where (schema,id,lac,cid) in (select schema,id,lac,cid from table1 where lac = 0 limit 1000);
delete from logtable where log_id in ( select log_id from logtable order by timestamp limit 10);
delete from logtable where id = any (array(select id from logtable order by timestamp limit 10));
delete from logtable where ctid in ( select ctid from logtable limit 10 );
delete from logtable as t1 where t1.ctid < (select t2.ctid from logtable as t2  where (select count(*) from logtable t3  where t3.ctid < t2.ctid ) = 10 limit 1);
select employeename from employeetable where len(employeename) > 4;
select employeename from employeetable where length(employeename) > 4;
create index employeetable_employeename_length on employeetable(length(employeename));
select * from openquery(link_db,'select cast(state as varchar(40)) from database');
select column1 || column2 as column3 from table_name;
select column1 || '.' || column2 as column3 from table_name;
select (column1 || ' '|| column2) from table;
select concat(concat(column1,' '), column2);
select concat(column1, column2);
select concat(column1, ' ', column2) select concat_ws(' ', column1, column2);
select concat(column1, ' ' ,column2) as newcolumn;
select title, firstname, lastname, isnull(title,'') + ' ' + isnull(firstname,'') + ' ' + isnull(lastname,'') as fullname from customer;
select concat(description,ifnull(' sn: ', serial_number),'')) from my_table;
select collumn1 + ' - ' + collumn2 as 'fullname' from tablename;
select column1 || column2 as column3 from table;
select concat(column1 ,column2) as column3 from table;
select u.*, p.*, max(date) from payments p join users u on u.id=p.user_id and u.package = 1;
select  a.*, c.* from users a select user_id, max(date) as maxdate from ( select user_id, date from payments where a.package = 1;
select u.*, p.*, max(p.date) from payments p join users u on u.id=p.user_id and u.package = 1;
select  a.*, c.* from users a ( select user_id, max(date) maxdate from payments where a.package = 1;
select u.*, p.* from ( select max(p.date) as date, p.user_id from payments as p where u.package = 1;
select u.* from users as u select p.*, @num := if(@id = user_id, @num + 1, 1) as row_number, @id := user_id as tmp from payments as p, (select @num := 0) x, (select @id := 0) y where u.package = 1;
select u.*, p.* from users as u select id from payments as p2 where p2.user_id = u.id limit 1 );
select u.*, p.* from users as u where not exists ( select 1 from payments as p2 where p2.user_id = p.user_id and );
select u.* from users as u select p.*, @num := if(@id = user_id, @num + 1, 1) as row_number, @id := user_id as tmp from (select * from payments order by p.user_id asc, date desc) as p, (select @num := 0) x, (select @id := 0) y ) where u.package = 1;
select u.*, v.* from users as u from payments where id in ( select max(id) from payments;
select u.*, p.* from users as u left join ( select *, row_number() over(partition by userid order by [date] desc) as rowno from payments;
select user.id, max(payment.id) from user inner join payment on (user.id = payment.user_id) group by user.id;
as (select granted_role from   dba_role_privs select 'system'     typ, grantee      grantee, privilege    priv, admin_option ad, '--'         tabnm, '--'         colnm, '--'         owner from   dba_sys_privs where  grantee = '&user' or grantee in (select granted_role from   data) union select 'table'    typ, grantee    grantee, privilege  priv, grantable  ad, table_name tabnm, '--'       colnm, owner      owner from   dba_tab_privs where  grantee = '&user' or grantee in (select granted_role from   data);
select privilege, obj_owner, obj_name, username, listagg(grant_target, ',') within group (order by grant_target) as grant_sources, -- lists the sources of the permission from ( -- gets all roles a user has, even inherited ones select distinct connect_by_root grantee as granted_user, granted_role from dba_role_privs ) select privilege, obj_owner, obj_name, username, replace(grant_target, username, 'direct to user') as grant_target, admin_or_grant_opt, hierarchy_opt from ( -- system privileges granted directly to users select privilege, null as obj_owner, null as obj_name, grantee as username, grantee as grant_target, admin_option as admin_or_grant_opt, null as hierarchy_opt from dba_sys_privs where grantee in (select username from dba_users) union all -- system privileges granted users through roles select privilege, null as obj_owner, null as obj_name, all_roles_for_user.granted_user as username, grantee as grant_target, admin_option as admin_or_grant_opt, null as hierarchy_opt from dba_sys_privs join all_roles_for_user on all_roles_for_user.granted_role = dba_sys_privs.grantee union all -- object privileges granted directly to users select privilege, owner as obj_owner, table_name as obj_name, grantee as username, grantee as grant_target, grantable, hierarchy from dba_tab_privs where grantee in (select username from dba_users) union all -- object privileges granted users through roles select privilege, owner as obj_owner, table_name as obj_name, grantee as username, all_roles_for_user.granted_role as grant_target, grantable, hierarchy from dba_tab_privs join all_roles_for_user on all_roles_for_user.granted_role = dba_tab_privs.grantee where username = 'user_name' privilege, obj_owner, obj_name, username;
select * from dba_sys_privs;
select * from user_sys_privs;
select * from user_tab_privs;
select * from user_role_privs;
select * from dba_role_privs connect by prior granted_role = grantee start with grantee = '&user' order by 1,2,3;
select * from dba_sys_privs  where grantee = '&user' or grantee in (select granted_role from dba_role_privs connect by prior granted_role = grantee start with grantee = '&user') order by 1,2,3;
select * from dba_tab_privs  where grantee = '&user' or grantee in (select granted_role from dba_role_privs connect by prior granted_role = grantee start with grantee = '&user') order by 1,2,3,4;
select * from somewhere limit 18446744073709551610 offset 5;
select * from tbl limit 95, 18446744073709551615;
select @a:=@a + 1 as counter, table.* from table having counter > 4;
select * from table_name where id > x;
select count(*) from table_name;
select * from table_name limit count_result offset desired_offset;
select * from table_name limit desired_offset, count_result;
where .... and id > <youroffset>;
set @my_offset = 5;
set @rows = (select count(*) from my_table);
select * from table1 where id=1; delete table1;
select * from people where created_on <= '26.09.2015' or '1'<>' 21:21:43';
select concat('repair table ', table_name, ';') from information_schema.tables where table_schema='mydatabase';
create definer = 'root'@'localhost' procedure mydatabase.repair_all() set @sql = concat("repair table `", tablename, "`");
create table table_name( column1 integer autoincrement, column2 datatype, column3 datatype, ..... );
id integer primary key   autoincrement, name           text      not null, age            int       not null, address        char(50), salary         real;
values ( 'manoj kumar', 40, 'meerut,up,india', 200000.00 );
select *from tb_company_info;
create table if not exists room(room_id integer primary key, name varchar(25) not null, home_id varchar(25) not null);
select * from room;
create table people (id integer primary key autoincrement, first_name varchar(20), last_name varchar(20));
create table people (id integer primary key autoincrement, first_name string, last_name string);
values (null, "john", "smith");
select * from `table` where timestamp >= curdate();
select * from `table` where `timestamp` like concat(curdate(),'%');
select * from `table` where date(`timestamp`) = curdate();
select * from `table` where cast(`timestamp` to date) == cast(now() to date);
where timestamp >= curdate() and timestamp < curdate() + interval 1 day;
create table test                            --- simple table default 'sample data' values ('2013-02-08 00:01:12'), ---                                      --- insert about 7k rows;
select * from test where date(timestamp) = curdate()            ---  using date(timestamp);
select * from test where timestamp >= curdate() and timestamp < curdate() + interval 1 day;
select * from `table_name` where timestamp >= '2018-07-07';
select * from `table_name` where timestamp >=  curdate();
where cast(timecalled as date) = cast(getdate() as date);
select * from yourtable where created >= current_date;
select shp_awb_no,shpr_ctry_cd, recvr_ctry_cd, case when shpr_ctry_cd = record_ctry_cd then "o" else "i" end as route from shipment_details where record_ctry_cd = "jp" and "o" = case when shpr_ctry_cd = record_ctry_cd then "o" else "i" end;
select distinct case when opportunity='' then '(blank)' else opportunity end as opp,len(opportunity) from [dbo].[tbl];
select distinct [opportunity] from [dbo].[tbl]   where    (  case when   opportunity ='' then '(blank)' else opportunity end in (select opp from @opp));
case len('testperson');
(len('testperson') = 0 and co.personentered  = co.personentered) or;
select d.distname,e.blkname,a.childid,a.studyingclass from tbl_admissionregister a where case when len('3601')=4   then c.distcd;
where co.dtentered = case then co.dtentered else '2011-01-01' end;
where case len('testperson') else co.personentered like '%testperson' end;
where ( (len('testperson') = 0 and co.personentered = co.personentered ) or (len('testperson') <> 0 and co.personentered like '%testperson') );
select tl.storenum [store #], co.ccnum [fuelfirst card #], co.dtentered [date entered], case st.reasonid else 'unknown' end [status], case st.ccstatustypename else st.ccstatustypename end [reason], upper(replace(replace(co.personentered,'rt\\\\',''),'racetrac\\\\','')) [person entered], co.comments [comments or notes] from comments co where case when (len([testperson]) = 0 and co.personentered  = co.personentered) or (len([testperson]) <> 0 and co.personentered like '%'+testperson) then 1 else 0 end = 1 and;
where case len('testperson') case when co.personentered  = co.personentered then 1 else 0 end else case when co.personentered like '%testperson' then 1 else 0 end end = 1 and cc.ccnum = case len('testffnum') else 'testffnum' end and case len('2011-01-09 11:56:29.327') else case len('2012-01-09 11:56:29.327') case when co.dtentered >= '2011-01-09 11:56:29.327' then 1 else 0 end else case when co.dtentered between '2011-01-09 11:56:29.327' and '2012-01-09 11:56:29.327' then 1 else 0 end end end = 1 and tl.storenum < 699;
select tum1.userid,tum1.first_name + ' ' +tum1.last_name as name,tum1.business_title,tum1.manager_id,tum2.first_name + ' ' + tum2.last_name as [manager name],tum1.project,tum1.project_code,tum1.rcc_code,tum1.department,tcm.company_name, case when tum1.gender_id=1 then 'male' else 'female' end 'gender' case when tum1.inactive=0 then 'still in company' else 'left company' end 'active/inactive' from tbl_user_master tum1 join tbl_company_master tcm on tcm.company_code=tum1.company_code join tbl_user_master tum2 on tum1.manager_id=tum2.userid where tum1.userid in ('54545414');
select * from emp_master where emp_last_name= case emp_first_name end;
select * from table_name where xyz=202 and dbkey=(case @v  when a then 'some value 1' else 'some value 2';
and cli.pe_nom like '%' + isnull(@nomclient, cli.pe_nom) + '%';
where (len('testperson') <> 0 or co.personentered  = co.personentered) and else 'testffnum' end ) and;
select * from table where 1 = case when table.col = 100 then 1 and table.col2 = 'myname';
select table.date from table where table.date > '2020-01-01'::date - interval '10 day';
select table.date from table where date between current_date and current_date - interval '10 day';
select table.date from table where date > current_date - interval '10' day;
select "date" from "table" where "date" > (current_date - interval '10 days');
select table.date from table where date > current_date - interval '10 day';
select distinct current_date, current_date - interval '10' day, current_date - interval '10 days' from pg_language;
select col1, col2, col3, col4, col5 from table1 union select col1, col2, col3, null as col4, null as col5 from table2````;
create table test1_1790 ( col_a varchar2(30), col_b number, col_c date);
create table test2_1790 ( col_a varchar2(30), col_c date, col_b number);
select * from test1_1790 union all select * from test2_1790;
select col_a, col_b, col_c from test1_1790 union all select col_a, col_c, col_b from test2_1790;
select id_table_a, desc_table_a, table_b.id_user as iuserid, table_c.field as ifield union select id_table_a, desc_table_a, table_c.id_user as iuserid, table_c.field as ifield;
select t1.col1, t1.col2, t1.col3, t2.col4, t2.col5 from table1 t1 join table2 t2;
select * from taba select * from tabb;
select * from @left select * from @right;
2, "b", 3, "c"];
select col1, col2, col3, col4, col5 from table1 union select col1, col2, col3, null as col4, null as col5 from table2;
select empsalary from employee where salary = 0 or 1=1;
select empsalary from employee where salary = 0; drop table employee;
end using end using;
where salary = @sal;");
if not exists ...;
select ... for update;
select ... lock in share mode;
if ($balance < $amount_being_paid) { update your account set balance = $balance;
update receiver account set balance = $balance;
table and database designers;
alter table students modify age int(5) first;
alter table  tablename  drop column  columnname;
alter table  tablename  add columnname columntype;
create table testtable ( column1 int, column2 varchar(255) select * from testtable;
alter table testtable add column2_new varchar(255);
alter table testtable add column1_new int;
update testtable set column1_new = column1, column2_new = column2;
alter table testtable drop column column1;
alter table testtable drop column column2;
select * from testtable;
alter table table name;
create table new as select column1,column2,column3,....columnn from table_name;
drop table table_name;
select * from table_name;
alter table `status` change `priority` `priority` int(11) null default null after `price`;
set quoted_identifier on set arithabort on set numeric_roundabort off set concat_null_yields_null on set ansi_nulls on set ansi_padding on set ansi_warnings on create table dbo.tmp_emps ( id int null, ename varchar(20) null alter table dbo.tmp_emps set (lock_escalation = table) if exists(select * from dbo.emps) select id, ename from dbo.emps with (holdlock tablockx)') drop table dbo.emps;
select * from foobar;
select bar, foo from foobar;
select * from table1;
select column1, column5, column4, column3, coulmn2 from table1;
create table' or in the;
create table mytable( a int null, b varchar(50) null, c datetime null create view vw_mytable as select c, a, b from mytable;
select * from mytable;
select * from vw_mytable;
set @tablename = 'mytablename' set @where = '' drop table if exists #tmp_col2row create table #tmp_col2row ) set @execstr = n' insert into #tmp_col2row (field_name , field_value) ' select @execstr += (select n'select '''+c.name+''' ,convert(nvarchar(max),'+quotename(c.name) + ') from ' + quotename(@tablename)+@where+char(10)+' union all ' from sys.columns as c where (c.object_id = object_id(@tablename)) select @execstr = left(@execstr,len(@execstr)-len(' union all ')) exec (@execstr) select * from #tmp_col2row;
and c.system_type_id = 56   --56 = type int;
select @colsunpivot = stuff((select ','+quotename(c.name) from sys.columns as c where c.object_id = object_id(@tabletopivot) and;
select name, system_type_id from sys.types order by name;
( select 'paul' as name, color, paul as value from yourtable union all select 'john' as name, color, john as value from yourtable union all select 'tim' as name, color, tim as value from yourtable union all select 'eric' as name, color, eric as value from yourtable ) select name, [red], [green], [blue] from ( select * from cte ( max(value);
set ansi_nulls on set quoted_identifier on create procedure transposesplit @inputtosplit varchar(8000) as begin set nocount on;
select @tabletopivot = '#tempsplitedtable' select @columntopivot = 'col_number' create table #tempsplitedtable ( col_number int ) col_number ) select row_number() over ( order by ( select 100 ) from [db].[escheme].[fnsplit](@inputtosplit, @delimeter) select @colsunpivot = stuff(( select ',' + quotename(c.name) from [tempdb].sys.columns as c where c.object_id = object_id('tempdb..' + @tabletopivot) and c.name <> @columntopivot set @querypivot = 'select @colsresult = (select  '','' from ' + @tabletopivot + ' t where ' + @columntopivot + ' <> '''' exec sp_executesql @querypivot select @colspivot = stuff(@colsresult.value('.', 'nvarchar(max)'), 1, 1, '') set @query = 'select name, rowid, ' + @colspivot + ' from ( select ' + @columntopivot + ' , name, value, row_number() over (partition by ' + @columntopivot + ' order by ' + @columntopivot + ') as rowid from ' + @tabletopivot + ' ( value for name in (' + @colsunpivot + ') ( max(value) exec (@query) drop table #tempsplitedtable end go;
set @inputtosplit = 'hello|beautiful|world' set @delimeter = '|';
set ansi_nulls on set quoted_identifier on alter procedure [dbo].[sqltranspose] @fieldnametranspose nvarchar(max) = '' as begin set nocount on;
@query  as nvarchar(max), @querypivot  as nvarchar(max), @colspivot as  nvarchar(max), @columntopivot as nvarchar(max), @tabletopivot as nvarchar(max), @colsresult as xml select @tabletopivot = @tablename;
select @columntopivot = @fieldnametranspose select @colsunpivot = stuff((select ','+quotename(c.name) from sys.columns as c where c.object_id = object_id(@tabletopivot) and set @querypivot = 'select @colsresult = (select  '','' from '+@tabletopivot+' t where '+@columntopivot+' <> '''' exec sp_executesql @querypivot, n'@colsresult xml out', @colsresult out select @colspivot = stuff(@colsresult.value('.', 'nvarchar(max)'),1,1,'') set @query from ( select '+@columntopivot+' , name, value, row_number() over (partition by '+@columntopivot+' order by '+@columntopivot+') as rowid from '+@tabletopivot+' ( value for name in ('+@colsunpivot+') ( sum(value) end;
exec sqltranspose 'yourtable', 'color';
create table tbl ( color varchar(10), paul int, john int, tim int, eric int);
select * from tbl;
create table yourtable([color] varchar(5), [paul] int, [john] int, [tim] int, [eric] int);
values ('red', 1, 5, 1, 3), ('green', 8, 4, 3, 5), ('blue', 2, 2, 9, 1);
select name, sum(case when color = 'red' then value else 0 end) red, sum(case when color = 'green' then value else 0 end) green, sum(case when color = 'blue' then value else 0 end) blue from ( select color, paul value, 'paul' name from yourtable union all select color, john value, 'john' name from yourtable union all select color, tim value, 'tim' name from yourtable union all select color, eric value, 'eric' name from yourtable;
select name, [red], [green], [blue] from ( select color, name, value from yourtable ( value for name in (paul, john, tim, eric) ( sum(value);
@query  as nvarchar(max), @colspivot as  nvarchar(max) select @colsunpivot = stuff((select ','+quotename(c.name) from sys.columns as c where c.object_id = object_id('yourtable') and select @colspivot = stuff((select  ',' from yourtable t set @query from ( select color, name, value from yourtable ( value for name in ('+@colsunpivot+') ( sum(value);
create view view_clients_credit_usage as select client_id, sum(credits_used) as credits_used from credit_usage create view view_credit_status as select credit_orders.client_id, sum(credit_orders.number_of_credits) as purchased, ifnull(t1.credits_used,0) as used from credit_orders where credit_orders.payment_status='paid';
table a = base table with some columns table b = table a + extra column id of type bigint with random numbers table c = table a + extra column id of type text with random 16-char ascii strings;
if (file != null);
erroraction, errorvariable, warningaction, warningvariable, outbuffer, pipelinevariable, and outvariable. for more information, see;
select p.fullname as 'fullname', substring_index(p.fullname, ' ', 1) as 'firstname', substring(p.fullname, locate(' ',p.fullname), (length(p.fullname) - (length(substring_index(p.fullname, ' ', 1)) + length(substring_index(p.fullname, ' ', -1)))) substring_index(p.fullname, ' ', -1) as 'lastname', (length(p.fullname) - length(replace(p.fullname, ' ', '')) + 1) as 'name qt' from people as p limit 100;
select substring_index(substring_index(chaptername, ' ', 1), ' ', -1) as  from courses where `id`=1;
select (case when locate('(', locationname) = 0 then horse_name else left(locationname, locate('(', locationname) - 1) from   tblcountry;
create definer=`root`@`localhost` function `getnameinitials`(`fullname` varchar(500), `separator` varchar(1)) returns varchar(70) charset latin1 set `fullname` = trim(`fullname`);
set `position` = locate(`separator`, `fullname`);
if not `position` then return left(`fullname`,1);
set `fullname` = concat(`fullname`,`separator`);
set `result` = left(`fullname`, 1);
set `fullname` = substr(`fullname`, `position` + 1);
set `position` = locate(`separator`, `fullname`);
if not `position` or not length(`fullname`) then leave cycle;
set `result` = concat(`result`,left(`fullname`, 1));
select `getnameinitials`('kaleem ul hassan', ' ') as `nameinitials`;
select substring_index(substring_index('sachin ramesh tendulkar', ' ', 1), ' ', -1) as first_name, substring_index(substring_index('sachin ramesh tendulkar', ' ', 2), ' ', -1) as middle_name, substring('sachin ramesh tendulkar',length(substring_index('sachin ramesh tendulkar', ' ', 2))+1) as last_name;
create definer=`root`@`%` procedure `sp_split`(str nvarchar(6500), dilimiter varchar(15), tmp_name varchar(50)) set end_index      = instr(str, dilimiter);
set part       = substring(str, 1, end_index - 1);
set remain_len = length(str) - end_index;
set str = substring(str, end_index + 1, remain_len);
set end_index  = instr(str, dilimiter);
create definer=`root`@`%` procedure `sp_split_insert`(tb_name varchar(255), tb_value nvarchar(6500)) set @sql = concat('insert into ', tb_name,'(item) values(?)');
set @parama = tb_value;
create definer=`root`@`%` procedure `test_split`(test_text nvarchar(255)) create temporary table if not exists tb_search ( item nvarchar(6500) select * from tb_search where length(trim(item)) > 0;
drop table tb_search;
drop function if exists `split_name`$$ create function split_name (p_fullname text, p_part integer) set p_fullname=rtrim(ltrim(p_fullname));
set v_words=(select sum(length(p_fullname) - length(replace(p_fullname, ' ', ''))+1));
if v_words=1 then if p_part=1 then set v_name=p_fullname;
set v_name=null;
set v_name=null;
else set v_name=null;
if p_part=1 then set v_name=substring(p_fullname, 1, locate(' ', p_fullname) - 1);
set v_name=substring(p_fullname, locate(' ', p_fullname) + 1);
set v_name=null;
else set v_name=null;
if p_part=1 then set v_name=substring(p_fullname, 1, locate(' ', p_fullname) - 1);
set p_fullname=substring(p_fullname, locate(' ', p_fullname) + 1);
set v_name=substring(p_fullname, 1, locate(' ', p_fullname) - 1);
set p_fullname=reverse (substring(p_fullname, locate(' ', p_fullname) + 1));
set p_fullname=substring(p_fullname, 1, locate(' ', p_fullname) - 1);
set v_name=reverse(p_fullname);
else set v_name=null;
if p_part=1 then set v_name=substring(p_fullname, 1, locate(' ', p_fullname) - 1);
set p_fullname=reverse(substring(p_fullname, locate(' ', p_fullname) + 1));
set p_fullname=substring(p_fullname, locate(' ', p_fullname,substring_index(p_fullname,' ',1)+1) + 1);
set v_name=reverse(p_fullname);
set p_fullname=reverse (substring(p_fullname, locate(' ', p_fullname) + 1));
set p_fullname=substring(p_fullname, 1, locate(' ', p_fullname) - 1);
set v_name=reverse(p_fullname);
else set v_name=null;
else set v_name=null;
select split_name('md. obaidul haque sarker',1) as first_name, split_name('md. obaidul haque sarker',2) as middle_name, split_name('md. obaidul haque sarker',3) as last_name;
drop function if exists split_string;
create function set n = length(s) - length(replace(s, del, '')) + 1;
if i > n then else return substring_index(substring_index(s, del, i) , del , -1 ) ;
end $ set @agg = "g1;g2;g3;g4;" ;
select split_string(@agg,';',1) ;
select split_string(@agg,';',2) ;
select split_string(@agg,';',3) ;
select split_string(@agg,';',4) ;
select split_string(@agg,';',5) ;
select split_string(@agg,';',6) ;
select substring_index(substring_index(msgrest, ' ', 1), ' ', -1) as emailid locate(' ', `msgrest`) > 0, trim(substring(substring(`msgrest`, locate(' ', `msgrest`) +1), locate(' ', substring(`msgrest`, locate(' ', `msgrest`) +1)) +1)), null from inbox;
set delim = '|';
set fullstr = concat(fullstr, delim);
set maxlen = length(fullstr);
set endpos = locate(delim, fullstr, inipos);
set item =  substr(fullstr, inipos, endpos - inipos);
if item <> '' and item is not null then end if;
set inipos = endpos + 1;
create function split_str( x varchar(255), delim varchar(12), pos int ) length(substring_index(x, delim, pos -1)) + 1), delim, '');
select split_str(string, delimiter, position);
select split_str('a|bb|ccc|dd', '|', 3) as third;
select substring_index(substring_index(fullname, ' ', 1), ' ', -1) as first_name, if(  length(fullname) - length(replace(fullname, ' ', ''))>1, substring_index(substring_index(fullname, ' ', 2), ' ', -1) ,null) as middle_name, substring_index(substring_index(fullname, ' ', 3), ' ', -1) as last_name from registeredusers;
select substring_index(substring_index(fullname, ' ', 1), ' ', -1) as first_name, trim( substr(fullname, locate(' ', fullname)) ) as last_name from registeredusers;
select substring_index(name, ' ', 1) as fname, substring_index(substring_index(name,' ', 2), ' ',-1) as mname, substring_index(name, ' ', -1) as lname from mytable;
case when length(substring_index(substring_index(name, ' ', 2), ' ', -1)) > 2 then else case when length(substring_index(substring_index(f.nome, ' ', 3), ' ', -1)) > 2 then end end as mname;
drop procedure if exists splitstr;
create procedure `splitstr`(in str varchar(2000), in delim varchar(1)) create temporary table if not exists tb_split ( item varchar(2000) set inipos = 1;
set fullstr = concat(str, delim);
set maxlen = length(fullstr);
set endpos = locate(delim, fullstr, inipos);
set item =  substr(fullstr, inipos, endpos - inipos);
if item <> '' and item is not null then end if;
set inipos = endpos + 1;
select * from tb_split;
drop table tb_split;
select count(distinct(concat(tag,entryid))) from customers where id>0;
select count(distinct tag) as tag_count, count(distinct (case when entryid > 0 then tag end)) as positive_tag_count from your_table_name;
select count(tag) as 'tag count' from table;
select count(tag) as 'negative tag count' from table where entryid > 0;
select count(distinct t.tag) as distincttag, count(distinct t2.tag) as distinctpositivetag from table t;
select  distinct a.[tag], count(a.[tag]) as tag_count, (select count(*) from [tagtbl] as b where a.[tag]=b.[tag] and b.[id]>0) from [tagtbl] as a group by a.[tag];
select e1.employeeid, e1.firstname, e1.lastname, e1.supervisorid, e2.firstname as supervisorfirstname, e2.lastname as supervisorlastname from employee e1;
select t2.name from category t1 join category t2 where t1.name = 'kitchen';
select e.name, me.name as manager from dbo.employees e;
select * from table t1, table t2 where t1.id = t2.id;
select e.employee as employee, b.employee as boss from emptable e, emptable b where e.manager_id = b.empolyee_id;
select col.column_name from information_schema.constraint_column_usage col where col.constraint_name = tab.constraint_name and col.table_name = tab.table_name and constraint_type = 'primary key' and col.table_name = '<your table name>';
select * from information_schema.table_constraints where constraint_type = 'primary key';
select constraint_catalog as databasename, constraint_schema as schemaname, table_name as tablename, constraint_name as primarykey from information_schema.table_constraints where constraint_type = 'primary key' and table_name = 'yourtable';
select t.name as 'table', i.name as 'index', it.xtype,  and c.colid = k.colid and c.id = t.id and k.keyno = 1 and k.id = t.id) as 'column1',  and c.colid = k.colid and c.id = t.id and k.keyno = 2 and k.id = t.id) as 'column2',  and c.colid = k.colid and c.id = t.id and k.keyno = 3 and k.id = t.id) as 'column3',  and c.colid = k.colid and c.id = t.id and k.keyno = 4 and k.id = t.id) as 'column4',  and c.colid = k.colid and c.id = t.id and k.keyno = 5 and k.id = t.id) as 'column5',  and c.colid = k.colid and c.id = t.id and k.keyno = 6 and k.id = t.id) as 'column6',  and c.colid = k.colid and c.id = t.id and k.keyno = 7 and k.id = t.id) as 'column7',  and c.colid = k.colid and c.id = t.id and k.keyno = 8 and k.id = t.id) as 'column8',  and c.colid = k.colid and c.id = t.id and k.keyno = 9 and k.id = t.id) as 'column9',  and c.colid = k.colid and c.id = t.id and k.keyno = 10 and k.id = t.id) as 'column10',  from sysobjects t where it.xtype = 'pk';
select a.name,col.column_name from information_schema.constraint_column_usage col , (select name from dbo.sysobjects where xtype='u') as a where col.constraint_name = tab.constraint_name and col.table_name = tab.table_name and constraint_type = 'primary key ' and col.table_name = a.name;
select a.table_name as [table_name], a.constraint_name as [primary_key] from information_schema.table_constraints a, information_schema.constraint_column_usage b where constraint_type = 'primary key' and a.constraint_name = b.constraint_name;
select tc.table_name as [table_name], tc.constraint_name as [primary_key] from information_schema.table_constraints tc where tc.constraint_type = 'primary key' and where type = 'u');
as ( select  constraint_name= cast (pknukey.name as varchar(30)) , constraint_type=cast (pknukey.type_desc as varchar(30)) , parent_table_name=cast (pknutable.name as varchar(30)) , parent_col_name=cast ( pknukeycol.name as varchar(30)) , parent_col_name_data_type=  oparentcoldtl.data_type, reference_table_name='' , reference_col_name='' from sys.key_constraints as pknukey and pknucolidx.index_id = pknukey.unique_index_id and pknukeycol.column_id = pknucolidx.column_id and oparentcoldtl.column_name=pknukeycol.name union all select  constraint_name= cast (oconstraint.name as varchar(30)) , constraint_type='fk', parent_table_name=cast (oparent.name as varchar(30)) , parent_col_name=cast ( oparentcol.name as varchar(30)) , parent_col_name_data_type= oparentcoldtl.data_type, reference_table_name=cast ( oreference.name as varchar(30)) , reference_col_name=cast (oreferencecol.name as varchar(30)) from sys.foreign_key_columns fkc and fkc.parent_column_id=oparentcol.column_id/* id of the column. is unique within the object.column ids might not be sequential.*/ and oparentcoldtl.column_name=oparentcol.name and fkc.referenced_column_id=oreferencecol.column_id/* id of the column. is unique within the object.column ids might not be sequential.*/ ) select * from   all_keys_in_table where parent_table_name  in ('your_table_name') or reference_table_name  in ('your_table_name');
select column_name from information_schema.key_column_usage where objectproperty(object_id(constraint_schema+'.'+constraint_name), 'isprimarykey') = 1 and table_name = '<i><your table name></i>';
select t.table_schema, t.table_name, stuff(( select ', ' + c.column_name from information_schema.columns c where c.table_schema = t.table_schema and t.table_name = c.table_name stuff(( select ', ' + c.column_name from information_schema.constraint_column_usage c and c.table_name = tc.table_name where c.table_schema = t.table_schema and t.table_name = c.table_name and tc.constraint_type = 'primary key' from information_schema.tables t;
select column_name from information_schema.key_column_usage where table_name = 'tablename';
select c.name as column_name, i.name as index_name, c.is_identity from sys.indexes i where i.is_primary_key = 1 and i.object_id = object_id('<schema>.<tablename>');
select s.name as schemaname, t.name as tablename, tc.name as columnname, ic.key_ordinal as keyordernr from sys.schemas s and i.index_id=ic.index_id and ic.column_id=tc.column_id where i.is_primary_key=1;
select distinct constraint_name as [constraint], table_schema as [schema], table_name as tablename from information_schema.key_column_usage where table_name = 'mytablename';
as (select kcu.table_name from   [linkserver].information_schema.key_column_usage kcu join [linkserver].information_schema.table_constraints as tc on tc.constraint_name = kcu.constraint_name where  tc.constraint_type = 'primary key') select           schema_name ( select ', ' from    sysinfo si1 where  si1.table_name = si2.table_name from sysinfo si2 where table_name = case then @tablename else table_name end group by si2.table_name, si2.schema_name;
as (select s.name as schema_name from   [linkserver].sys.schemas s join [linkserver].sys.tables t on s.schema_id = t.schema_id join [linkserver].sys.indexes i on t.object_id = i.object_id join [linkserver].sys.index_columns ic on i.object_id = ic.object_id and i.index_id = ic.index_id join [linkserver].sys.columns tc on ic.object_id = tc.object_id and ic.column_id = tc.column_id where  i.is_primary_key = 1) select           schema_name ( select ', ' from    sysinfo si1 where  si1.table_name = si2.table_name from sysinfo si2 where table_name = case then @tablename else table_name end group by si2.table_name, si2.schema_name;
select name from sys.objects where type = @typeofkey and  parent_object_id = object_id (@tablename);
select keys.table_schema, keys.table_name, keys.column_name, keys.ordinal_position from information_schema.key_column_usage keys and cons.table_name = keys.table_name and cons.constraint_name = keys.constraint_name where cons.constraint_type = 'primary key';
select  schema_name(t.schema_id) as [schema_name], t.name as tablename, col_name(ic.object_id,ic.column_id) as primarykeycolumnname, i.name as primarykeyconstraintname from    sys.tables t and i.index_id = ic.index_id where object_name(ic.object_id) = 'yourtablenamehere';
select f.name as foreignkeyconstraintname from sys.foreign_keys as f where object_name(f.referenced_object_id) = 'yourtablenamehere';
select tc.constraint_name as indexname,tc.table_name as tablename,tc.table_schema as schemaname,kc.column_name as column_name from information_schema.table_constraints tc,information_schema.key_column_usage kc where tc.constraint_type = 'primary key' and kc.table_name = tc.table_name and kc.table_schema = tc.table_schema and kc.constraint_name = tc.constraint_name and tc.table_schema='<schema_name>';
( select tc.constraint_schema from information_schema.table_constraints tc where tc.table_name=@table and ccu.constraint_name=tc.constraint_name union select table_schema,'column', table_name, column_name, is_nullable, data_type,character_maximum_length, numeric_precision from information_schema.columns where table_name=@table and column_name not in (select column_name from information_schema.constraint_column_usage where table_name = @table) ) select cast(iif(constraint_type='primary key',1,0) as bit) primarykey from cte case constraint_type else 3 end;
select l.table_schema, l.table_name, l.column_name, r.typename select column_name, table_name, table_schema from information_schema.key_column_usage where objectproperty(object_id(constraint_schema + '.' + quotename(constraint_name)), 'isprimarykey') = 1 select object_name(c.object_id) tablename ,c.name as columnname ,t.name as typename from sys.columns as c join sys.types as t on c.user_type_id=t.user_type_id;
select distinct substring ( stuff(( select distinct ',' + [column_name] from information_schema.key_column_usage where objectproperty(object_id(constraint_schema + '.' + quotename(constraint_name)), 'isprimarykey') = 1 and table_name = 'tablename' and table_schema = 'schema';
update table1 set col1 = subquery.col2, col2 = subquery.col3 from ( select t2.foo as col1, t3.bar as col2, t3.foobar as col3 from table2 t2 inner join table3 t3 on t2.id = t3.t2_id where t2.created_at > '2016-01-01' where table1.id = subquery.col1;
update table1 set (col1, col2) = (col2, col3) from othertable where othertable.col1 = 123;
update table1 set col1 = othertable.col2, col2 = othertable.col3 from othertable where othertable.col1 = 123;
select col1, col2 from othertable;
select item from dbo.splitcommastring(@myparameter);
create type [dbo].[stringlist] as table( [item] [nvarchar](max) null;
create procedure [dbo].[sp_usestringlist] as begin select l.item from @list l;
select name from fruits exec sp_usestringlist @list;
create type [dbo].[stringlist1] as table( [item] [nvarchar](max) null, [counts][nvarchar](20) null);
create procedure [dbo].[sp_usestringlist1] as begin select l.item,l.counts from @list l;
select l.item,l.counts into temptable from @list l;
set @counter = 0 set @totalprints = (len(@script) / 8000) + 1 set @counter = @counter + 1 end;
set @string = replace(  replace(@string, char(13) + char(10), char(10))   , char(13), char(10)) if charindex(char(10), @string) between 1 and 4000 set @currentend =  charindex(char(10), @string) -1 set @offset = 2 end else begin set @currentend = 4000 set @offset = 1 end print substring(@string, 1, @currentend) set @string = substring(@string, @currentend+@offset, len(@string)) end /*end while loop*/;
set @counter = 0 set @totalprints = (len(@sql) / 4000) + 1 set @counter = @counter + 1 end print len(@sql);
select cast('<root><![cdata[' + @mylongstring + ']]></root>' as xml);
select [processing-instruction(x)]=@script for xml path(''),type;
set @counter = 0 set @counter1 = 0 set @totalprints = (len(@query) / 4000) + 1 set @counter1 = @counter1+4000 set @counter = @counter + 1 end;
create procedure [dbo].[print] as begin @i int = 0, @s int = 0, -- substring start posotion set @n = ceiling(len(@sql) / 8000.0);
set @l = 8000 - charindex(char(13), reverse(substring(@sql, @s, 8000)));
set @i = @i + 1;
set @s = @s + @l + 2; -- accumulation + cr/lf end  end;
create procedure [internal].[longprint] as begin set nocount on;
set @msg = replace(@msg, char(13) + char(10), char(10));
set @msg = replace(@msg, char(13), char(10));
set @msglen = len(@msg);
if @msglen = 0 end  set @currlineendidx = charindex(char(10), @msg);
if @currlineendidx between 1 and 4000 set @currlineendidx = @currlineendidx - 1 set @skipcount = 2;
end else begin set @currlineendidx = 4000;
set @skipcount = 1;
end  set @currlinestartidx = @currlineendidx + @skipcount;
set @currlineendidx = charindex(char(10), @msg, @currlinestartidx);
set @currlinelen = @currlineendidx - @currlinestartidx;
if @currlinelen between 1 and 4000 set @currlineendidx = @currlineendidx - 1 set @skipcount = 2;
end else begin set @currlineendidx = @currlinestartidx + 4000;
set @skipcount = 1;
set @sqlall = '-- insert all your sql here' set @newline = nchar(13) + nchar(10) set @nextspace = @nextspace + 1 end print substring(@sqlall,@i,3000+@nextspace) set @i = @i+3000+@nextspace set @nextspace = 0 end print '   ';
set @i = @i+4000 end;
set @sql=replace(@sql,char(10),char(13)+char(10)) set @sql=replace(@sql,char(13)+char(13)+char(10),char(13)+char(10) ) set @position=charindex(char(10),@sql) set @sql=substring(@sql,@position+1,len(@sql));
exec (n'if exists (select * from tempdb.sys.objects where object_id = object_id(n''tempdb..#printmax'') and type in (n''p'', n''pc'')) drop procedure #printmax;');
exec (n'create procedure #printmax(@iinput nvarchar(max)) as begin if @iinput is null set @searchlength = 4000;
set @reverseddata = left(@iinput collate database_default, @searchlength);
set @reverseddata = reverse(@reverseddata collate database_default);
set @linebreakindex = charindex(char(10) + char(13), @reverseddata collate database_default);
set @iinput = right(@iinput, len(@iinput) - @searchlength if len(@iinput) > 0;
create or alter;
exec (n'create or alter procedure #printmax(@iinput nvarchar(max)) as begin if @iinput is null set @searchlength = 4000;
set @reverseddata = left(@iinput collate database_default, @searchlength);
set @reverseddata = reverse(@reverseddata collate database_default);
set @linebreakindex = charindex(char(10) + char(13), @reverseddata collate database_default);
set @iinput = right(@iinput, len(@iinput) - @searchlength + @linebreakindex - 1);
if len(@iinput) > 0;
create procedure [dbo].[printmax](@iinput nvarchar(max)) as begin set @i = charindex(@newline, @iinput) if @i>8000 or @i=0 set @i=8000 set @iinput = substring(@iinput, @i+1, len(@iinput)) end end;
set @result = 'test' exec [dbo].[print_unlimited] @result alter procedure [dbo].[print_unlimited] as  set @string = replace(replace(@string, char(13) + char(10), char(10)), char(13), char(10)) if charindex(char(10), @string) between 1 and 4000 set @currentend =  charindex(char(10), @string) -1 set @offset = 2 end else begin set @currentend = 4000 set @offset = 1 end print substring(@string, 1, @currentend) set @string = substring(@string, @currentend + @offset, len(@string)) end /*end while loop*/ end try select @errormessage = error_message() end catch end;
if (condition1) if (condition2) if (condition3);
select * from table1 where (col1 = @param1 or @param1 is null) and (col2 = @param2 or @param2 is null) and (col3 = @param3 or @param3 is null);
if (firstpass) else {;
if (!condition) if (!str.contains(" where "));
if (condition1) conditions.add("col1=0");
if (conditions.any());
if (condition1) if (condition2) if (condition3);
if (condition1) querysub+="and col1=0 ";
if (condition2) querysub+="and col2=1 ";
if (condition3) querysub+="and col3=2 ";
if (querysub.startswith("and")) if (query.endswith("where "));
select * from table1;
select * from table1 where cond1;
connection = conn, commandtype = commandtype.storedprocedure if (condition1) if (condition2) if (condition3);
create procedure dbo.sample_proc ( --using varchar(50) generically ) as begin check that the value of the parameter select * from sampletable where (col1 = @condition1 or @condition1 is null) and   (col2 = @condition2 or @condition2 is null) and   (col3 = @condition3 or @condition3 is null) end;
if (clause.length <= 0);
if (condition 1) if (condition 2);
if (condition1) conditions+="and col1=0 ";
if (condition2) conditions+="and col2=1 ";
if (condition3) conditions+="and col3=2 ";
if (conditions.length > 0);
if (condition1) whereclause += " col1 = @param1 and "; // <---- put conditional operator at the end if (condition2) whereclause += " col1 = @param2 or ";
if (!string.isnullorempty(whereclause));
if (condition1) query+="and col1=0 ";
if (condition2) query+="and col2=1 ";
if (condition3) query+="and col3=2 ";
select * from table1 where 1=1 and col1=0 and col2=1 and col3=2;
select * from table1 where col1=0 and col2=1 and col3=2;
select * from table1 where 1=1;
select * from table1;
if (condition1) query+="and col1=0 ";
if (condition2) query+="and col2=1 ";
if (condition3) query+="and col3=2 ";
if (condition1) query.append(" col1=0 and");
if (condition2) query.append(" col2=0 and");
if (condition1) if (condition2) if (condition3) if (conditions != "");
(!condition1 ? "col1" : "0"), (!condition2 ? "col2" : "1"), (!condition3 ? "col3" : "2"));
select concat(title,' ',forename,' ',surname) as name * from customer c;
select    concat(title, ' ', forename, ' ', surname) as name from      customer c join      ( select    max(id) max_id, customer_id from      customer_data join      customer_data cd on (cd.id = c_max.max_id) where     concat(title, ' ', forename, ' ', surname) like '%smith%' limit     10, 20;
create table customer (customer_id int);
create table customer_data ( id int, customer_id int, title varchar(10), forename varchar(10), surname varchar(10);
select    concat(title, ' ', forename, ' ', surname) as name from      customer c join      ( select    max(id) max_id, customer_id from      customer_data join      customer_data cd on (cd.id = c_max.max_id);
select concat(title,' ',forename,' ',surname) as name * from customer c where name like '%smith%' and d.id = ( select max(d2.id) from customer_data as d2 where d2.customer_id = d.customer_id ) limit 10, 20;
select max(d.id), d2.*, concat(title,' ',forename,' ',surname) as name from customer as c where concat(title, ' ', forename, ' ', surname) like '%smith%';
select c.*, from client as c where cch.cchid = ( select max(cchid) from client_calling_history where client_id = c.client_id and cal_event_id = c.cal_event_id );
select    concat(title, ' ', forename, ' ', surname) as name from      customer c select * from  customer_data order by id desc where     concat(title, ' ', forename, ' ', surname) like '%smith%' limit     10, 20;
create table customer ( id int unsigned not null auto_increment primary key, current_data_id int unsigned null default null create table customer_data ( id int unsigned not null auto_increment primary key, customer_id int unsigned not null, title varchar(10) not null, forename varchar(10) not null, surname varchar(10) not null;
select c.*, d.title, d.forename, d.surname from customer c where ...;
update customer set current_data_id = last_insert_id() where id = 2;
set @customer_id = last_insert_id();
update customer set current_data_id = last_insert_id() where id = @customer_id;
select replace(replace from         country_name '&<countryname>', ''), '&<countryname>', '') as countrynames;
select distinct hold_reason from ap.ap_holds_all aph where status_flag not in ('r') and invoice_id = p2_invoiceid;
if (v_count = 1) then v_holdreasons := rhr.hold_reason;
else v_holdreasons := v_holdreasons || ', ' || rhr.hold_reason;
select listagg(country_name,',') within group (order by country_name) cnt from countries;
select @test = coalesce(@test + ',', '') + field2 from #test select field2= @test;
select rtrim ( xmlagg (xmlelement (e, country_name || ',')).extract ('//text()'), ',') from countries;
select rtrim(xmlagg(xmlelement(e,country_name || ',')).extract('//text()'),',') country_name from;
select listagg(table_name, ', ') within group (order by table_name) from user_tables;
select wm_concat(table_name) from user_tables;
select * 3  select deptno, 4         case when row_number() over (partition by deptno order by ename)=1;
select country_name||', ' country from countries;
create table countries ( country_name varchar2 (100));
select substr (sys_connect_by_path (country_name , ','), 2) csv from (select country_name , row_number () over (order by country_name ) rn, count (*) over () cnt from countries) where rn = cnt;
select listagg(country_name,', ') within group(order by country_name) csv from countries;
update  table set     columnx = case when condition then 25 else columnx end, columny = case when condition then columny else 25 end;
update table set columny = (case when condition then columny else 25 end);
update [contacts] set contactno=(case else contactno;
update table set field1 = case when field1 = condition1 then 'result1';
if (condition) is true update table set columnx = 25 end else begin update table set columny = 25 end;
update table set columny = (case when condition2 then 25 end)`;
update table set columnx = 25 where condition1 update table set columny = 25 where condition1`;
create table [dbo].[tbltest]( [colx] [int] null, [coly] [int] null, [colconditional] [bit] null, [id] [int] identity(1,1) not null;
update tbltest set colx = 25 where colconditional = 1 update tbltest set coly = 25 where colconditional = 0;
from app import sqlalchemydb as db chance.status=="1", db.func.date(chance.apply_time)<=end, db.func.date(chance.apply_time)>=start).count();
select count(id) from chance where repo_id=:repo_id and status='1' and date(apple_time) <= end and date(apple_time) >= start;
and_(user.birthday <= '1988-01-17', user.birthday >= '1985-01-17'));
from sqlalchemy import and_, func;
create table [dbo].[history]( [id] [int] identity(1,1) not null, [requestid] [int] not null, [employeeid] [varchar](50) not null, [datestamp] [datetime] not null, constraint [pk_history] primary key clustered ( [id] asc;
create table history ( id int primary key identity(1,1) not null, . . .;
create table teppp ( id int identity(1,1) primary key, name varchar(10 )unique, addresss varchar(10) ) select * from teppp;
alter function [dbo].[checker]() returns int as begin  return 0 end;
delete from vt30 where rt < dateadd(year, -1, getdate());
delete top(1000000) from vt30 where rt < dateadd(year, -1, getdate());
alter database yourdb set recovery simple;
alter database yourdb set recovery full;
delete from tablename where condition;
delete top(1000) from tablename wherecondition;
select name, log_reuse_wait, log_reuse_wait_desc, is_cdc_enabled from sys.databases where name = 'xx_system';
select databasepropertyex('xx_system', 'ispublished');
exec sp_repldone null, null, 0,0,1;
exec sp_removedbreplication xx_system;
exec sp_replcounters;
create function sum_n_product_with_tab (x int) select $1 + tab.y, $1 * tab.y from tab;
create or replace function word_frequency(_max_tokens int) select t.txt from  ( select t.txt from   token t where  t.chartype = 'alphabetic' limit  _max_tokens end $func$  language plpgsql;
select * from word_frequency(123);
create or replace function word_frequency(_max_tokens int) select t.txt, t.cnt from  ( select t.txt, count(*) as cnt from   token t where  t.chartype = 'alphabetic' limit  _max_tokens end $func$  language plpgsql;
where x=y or x=z or...;
select  p.id, p.fixedid, p.azienda_id, p.categoria_id, p.linea, p.tipo, p.nome from prodotto p where p.azienda_id = 2699 and p.anno = ( select max(p2.anno) from prodotto p2 where p2.fixedid = p.fixedid );
select  p.id, p.fixedid, p.azienda_id, p.categoria_id, p.linea, p.tipo, p.nome from prodotto p where p.azienda_id = 2699 and (p.fixedid, p.anno) in ( select p2.fixedid, max(p2.anno) from prodotto p2 where p.azienda_id = p2.azienda_id );
update d set category = c.categoryname from [data] d join [cats] c on c.id = d.catid;
update d set category = (select top(1) c.categoryname from [cats] c where c.id = d.catid) from [data] d;
"type": "php", "request": "launch", "program": "${file}", "cwd": "${filedirname}", "port": 9000, "xdebugsettings": { "max_children": -1;
set nocount on select @tablename = name, @idfield = idfield, @idinsert = idinsert, @excluded = excluded from (select *, row_number() over(order by (select 1)) as rowid from @tables) t where t.rowid = @cnt select @execsql = @execsql + ( ( select case when not exists(select * from @excludedfields where fieldname = name) then ', ' + name else '' end from sys.columns where object_id = object_id('dbo.' + @tablename) ( ( select case when not exists(select * from @excludedfields where fieldname = name) then case when exists(select * from @numbertypes where sysid = system_type_id) then '' else ''''''''' + ' end + case when exists(select * from @numbertypes where sysid = system_type_id) then '' else ' + ''''''''' end + else '' end from sys.columns where object_id = object_id('dbo.' + @tablename) delete @excludedfields set @cnt = @cnt + 1 end  end ;
if object_id('tool.create_insert', 'p') is null alter procedure tool.create_insert(@schema    varchar(200) = 'dbo', @table     varchar(200), @where     varchar(max) = null, @top       int = null, @insert    varchar(max) output) as begin @select        varchar(max), @error         varchar(500), @query         varchar(max);
select @insert_fields = isnull(@insert_fields + ', ', '') + c.name, @select = case type_name(c.system_type_id) else isnull(@select + ' + '', '' + ', '') + 'isnull(cast(' + c.name + ' as varchar), ''null'')' end from sys.columns c with(nolock) where s.name = @schema and t.name = @table;
if @insert_fields is null or @select is null set @error = 'there''s no ' + @schema + '.' + @table + ' inside the target database.';
set @insert_fields = 'insert into ' + @schema + '.' + @table + '(' + @insert_fields + ')';
if isnull(@where, '') <> '' and charindex('where', ltrim(rtrim(@where))) < 1 set @where = 'where ' + @where;
end else begin set @where = '';
set @query = 'select ' + isnull('top(' + cast(@top as varchar) + ')', '') + @select + ' from ' + @schema + '.' + @table + ' with (nolock) ' + @where;
set @insert = isnull(@insert + char(10), '') + '--' + upper(@schema + '.' + @table);
select @insert = @insert + char(10) + @insert_fields + char(10) + 'values(' + v.description + ');' + char(10) + 'go' + char(10) from @values v where isnull(v.description, '') <> '';
@part   varchar(max), @start  int, @end    int;
exec tool.create_insert @schema = 'dbo', @table = 'customer', @where  = 'id = 1', @insert = @insert output;
set @end = charindex(char(10), @insert);
if @end = 0 set @end = len(@insert) + 1;
set @insert = substring(@insert, @end + 1, len(@insert) - @end + 1);
@part   varchar(max), @start  int, @end    int;
exec tool.create_insert @schema = 'dbo', @table = 'customer', @top    = 100, @insert = @insert output;
set @end = charindex(char(10), @insert);
if @end = 0 set @end = len(@insert) + 1;
set @insert = substring(@insert, @end + 1, len(@insert) - @end + 1);
create procedure sp_generate_insertscripts ( @table_name varchar(max), @filter_condition varchar(max)='' ) as begin set nocount on @quoted_data varchar(max), @text varchar(max) select @csv_column=stuff ( ( select ',['+ name +']' from sys.all_columns where object_id=object_id(@table_name) and ) select @quoted_data=stuff ( ( select ' isnull(quotename('+name+','+quotename('''','''''')+'),'+'''null'''+')+'','''+'+' from sys.all_columns where object_id=object_id(@table_name) and ) select @text='select ''insert into '+@table_name+'('+@csv_column+')values('''+'+'+substring(@quoted_data,1,len(@quoted_data)-5)+'+'+''')'''+' insert_scripts from '+@table_name + @filter_condition set nocount off end;
select [whatever you need];
from [... etc ...];
drop table [temp.table_name];
create procedure dbo.convertquerytoinsert (@input nvarchar(max), @target nvarchar(max)) as begin select @fields = coalesce(@fields + ', ', '') + '[' + name +']', @select = coalesce(@select + ', ', '') + ''''''' + isnull(cast([' + name + '] as nvarchar(max)), ''null'')+''''''' from tempdb.sys.columns where [object_id] = object_id(n'tempdb..'+@input);
create table #convertquerytoinserttemp (strings nvarchar(max)) exec sp_executesql @stmt select 'insert into ' + @target + ' (' + @fields + ') values (' + replace(strings, '''null''', 'null') +')' from #convertquerytoinserttemp drop table #convertquerytoinserttemp set @stmt = 'drop table ' + @input exec sp_executesql @stmt end;
create table dummy (id int, comment nvarchar(50), timestamp datetime) select * into #temptableforconvert from dummy where id < 3 exec dbo.convertquerytoinsert '#temptableforconvert', 'dbo.dummy';
select 'insert into table values(id=' + id + ', name=' + name + ')' from users;
select * from table where id between 1 and;
select * from table where id between;
select .. from yourtable where foo = ? and bar = ?;
select t1.id, t1.name from table_1 t1 where not exists(select id from table_2 t2 where t2.id = t1.id);
select t1.id, t1.name from table_1 t1 where t1.id not in (select id from table_2);
select t1.id, t1.name from table_1 t1 where t2.id is null;
in backward compatible syntax;
select distinct * from table_1 where table_1.id >1;
select t1.name from table_1 t1;
delete from table2 where id = (select id from table1);
select c1, c2, c3 from t2 where ....;
if (select count(1) from t1 where a1 = @c1 and a2 = @c2 values (@c1, @c2, @c3) end close my_cursor;
select lpad(42::text, 4, '0');
select rpad(numcol::text, 3, '0'), -- zero-pads to the right up to the length of 3 from   my_table;
select to_char(column_1, 'fm000') as column_2 from some_table;
t2 as (select * from bb b join t1 on t1.field1 = b.field1);
from ...) from abc ....) /*this one uses "abc" multiple times*/ select from xyz....   /*using abc, xyz multiple times*/;
as (select * from tab1 where conditions... t2 as (select * from tab2 where conditions... ) select * from t1, t2 where t1.col1=t2.col2;
select * from set2;                      -- set2 projected;
values ('col1_val', (select ref1 from ref1_tbl where lookup_val = 'lookup1'), (select ref2 from ref2_tbl where lookup_val = 'lookup2'), 'init-load';
select col1, 'str_val', int_val, col4, col5, col6 from table_a;
select id, 'data1', 'data2', 'data3' from table2 where col_a = 'something';
select app.name as "app", ${optional(" app.owner as "owner", "):showowner} from activity_records act, servers sv, applications app where act.server_id = sv.id and act.app_id = app.id and sv.id = ${integer(0,50):serverid} and app.id in ${integerlist(50):appid};
select app.name as "app", app.owner as "owner", sv.name as "server", sum(act.trans_ct) as "trans" from activity_records act, servers sv, applications app where act.server_id = sv.id and act.app_id = app.id and sv.id = 20 and app.id in (1,2,3,5,7,11,13);
if (is == null){;
select username into :username from users where pkey = :id;
create index ... concurrently;
create table month_value( eid int not null, month int, year int,  value int );
create view cm_absolute_month as select *, year * 12 + month as absolute_month from month_value;
then 'passed' else  'failed' end;
select concat( -- the test name -- the case statement case when = ( select count(distinct absolute_month) from cm_absolute_month) then 'passed' else 'failed' end;
select concat( 'sufficient and sufficiently varied month_value test data: ', case when and ( select count(distinct year) from month_value) > 3 and ... more tests then 'passed' else 'failed' end );
select concat( '(absolute_month)s are consecutive: ', case when ( select count(*) from cm_absolute_month a join cm_absolute_month b or (a.month = 12 and b.month = 1 and a.year + 1 = b.year) ) where a.absolute_month + 1 <> b.absolute_month ) = 0 then 'passed' else 'failed' end );
case when ( select count(*) from cm_abs_month a join cm_abs_month b where a.am + 1 <> b.am ) = 0;
from sqlalchemy.sql import compiler from psycopg2.extensions import adapt as sqlescape if isinstance(v, unicode):;
from sqlalchemy.sql import compiler from mysqldb.converters import conversions, escape if isinstance(v, unicode):;
parameters, context, executemany):;
select sometable.text from sometable;
from sqlalchemy import column, integer, string from sqlalchemy.ext.declarative import declarative_base;
from sqlalchemy.sql import select;
from sqlalchemy.dialects import postgresql;
from sqlalchemy.dialects import sqlite;
select field_1, field_2 from table where id=%s;
select field_1, field_2 from table where id=:id_1;
from sqlalchemy.dialects import postgresql dialect=postgresql.dialect(), compile_kwargs={"literal_binds": true} ) str(compiled_query), compiled_query.params );
select 'i like' || type_column || ' with' ect....;
concat( concat( concat( concat('i like ', t.type_desc_column), ' cake with '), t.icing_desc_column), ' and a '), t.fruit_desc_column);
select phone, contact, (addr1 ||  '-' || addr2 || '-' || addr3) as address from customer_details where code='341';
select 'i like ' || type_column_name || ' cake with ' || as cake_column from your_table_name;
select 'i like ' || type_column_name || ' cake with ' || as cake from table;
select avg( price ) select *, cume_dist() over ( order by price desc ) from web_price_scan where listing_type = 'aarm' and u_kbalikepartnumbers_id = 1000307 and ( extract( day from ( now() - dateended ) ) ) * 24 < 48 and coalesce( price, 0 ) > ( select avg( coalesce( price, 0 ) )* 0.50 from ( select *, cume_dist() over ( order by price desc ) from web_price_scan where listing_type='aarm' and u_kbalikepartnumbers_id = 1000307 and ( extract( day from ( now() - dateended ) ) ) * 24 < 48 where cume_dist < 0.50 ) and coalesce( price, 0 ) < ( select avg( coalesce( price, 0 ) ) *2 from web_price_scan where listing_type='aarm' and u_kbalikepartnumbers_id = 1000307 and ( extract( day from ( now() - dateended ) ) ) * 24 < 48 where cume_dist < 0.50) having count(*) > 5;
select avg( price ) select *, cume_dist() over ( order by price desc ) from web_price_scan where listing_type = 'aarm' and u_kbalikepartnumbers_id = 1000307 and ( extract( day from ( now() - dateended ) ) ) * 24 < 48 and ifnull( price, 0 ) > ( select avg( ifnull( price, 0 ) )* 0.50 from ( select *, cume_dist() over ( order by price desc ) from web_price_scan where listing_type='aarm' and u_kbalikepartnumbers_id = 1000307 and ( extract( day from ( now() - dateended ) ) ) * 24 < 48 where cume_dist < 0.50 ) and ifnull( price, 0 ) < ( select avg( ifnull( price, 0 ) ) *2 from web_price_scan where listing_type='aarm' and u_kbalikepartnumbers_id = 1000307 and ( extract( day from ( now() - dateended ) ) ) * 24 < 48 where cume_dist < 0.50) having count(*) > 5;
select avg( price ) select *, cume_dist() over ( order by price desc ) from web_price_scan where listing_type = 'aarm' and u_kbalikepartnumbers_id = 1000307 and ( extract( day from ( now() - dateended ) ) ) * 24 < 48 and coalesce( price, 0 ) > ( select avg( coalesce( price, 0 ) )* 0.50 from ( select *, cume_dist() over ( order by price desc ) from web_price_scan where listing_type='aarm' and u_kbalikepartnumbers_id = 1000307 and ( extract( day from ( now() - dateended ) ) ) * 24 < 48 where cume_dist < 0.50 ) and coalesce( price, 0 ) < ( select avg( coalesce( price, 0 ) ) *2 from web_price_scan where listing_type='aarm' and u_kbalikepartnumbers_id = 1000307 and ( extract( day from ( now() - dateended ) ) ) * 24 < 48 where cume_dist < 0.50) having count(*) > 5;
select a.pid from catalog as a left join catalog as b using( pid ) where a.sid != b.sid;
select c2.pid                  -- of pids from catalog as c2             -- from catalog where c2.pid = c1.pid having count(c2.sid) >= 2);
select * from a, b where ...;
select * from a where ...;
select * from table_a a, table_b b where a.id = b.id;
select * from table_a a join table_b b on b.id = a.id;
values ('aa'),('bb'),('cc') select @str = concat(@str+',',store_id) from @store select @str;
select name, class, color, productnumber, coalesce(class, color, productnumber) as firstnotnull from production.product;
select * from person where coalesce(addressid, contactid) is null.;
create login <login name> with password = '<password>' ; go;
create user user_name;
create login newadminname with password = 'abcd';
if not exists (select * from sys.database_principals where name = n'newadminname') create user [newadminname] for login [newadminname] exec sp_addrolemember n'db_owner', n'newadminname';
create login mynewadminuser check_policy     = off, check_expiration = off;
exec sp_addsrvrolemember @rolename = n'sysadmin';
set @defaultdatabasename = 'data1';
set @username = 'domain\username';
set @logincreationscript ='create login [{username}] from windows set @usercreationscript =' create user [{username}] for login [{username}];
exec sp_addrolemember ''db_datareader'', ''{username}'';
exec sp_addrolemember ''db_datawriter'', ''{username}'';
set @logincreationscript=replace(replace(@logincreationscript, '{username}', @username), '{databasename}', @defaultdatabasename) set @usercreationscript =replace(@usercreationscript, '{username}', @username) set @tempusercreationscript =replace(@usercreationscript, '{databasename}', @defaultdatabasename) set @tempusercreationscript =replace(@usercreationscript, '{databasename}', 'db2') set @tempusercreationscript =replace(@usercreationscript, '{databasename}', 'db3');
create login adminlogin with password = 'pass' if not exists (select * from sys.database_principals where name = n'adminlogin') create user [adminlogin] for login [adminlogin] exec sp_addrolemember n'db_owner', n'adminlogin' exec master..sp_addsrvrolemember @loginame = n'adminlogin', @rolename = n'sysadmin';
select security from the left pane.;
exec sp_configure 'show advanced options', 1 exec sp_configure 'ad hoc distributed queries', 1;
select a.* from openrowset('sqlncli', 'server=seattle1;trusted_connection=yes;', 'select groupname, name, departmentid from adventureworks2012.humanresources.department;
exec sp_configure 'show advanced options', 1 exec sp_configure 'ad hoc distributed queries', 1;
select id, datecreated from products where pname = iname;
select id, datecreated from products where pname = iname;
select p.id, p.datecreated into id, datecreated from products p where pname = iname;
select id, datecreated from products into iid, dcreate;
select id, datecreated from products where pname = iname;
select phone_number x from hr.employees select x, x, null from cte0 union all select xstr, case when instr(xrest,'.') = 0 then null else substr(xrest,instr(xrest,'.')+1) end, case when instr(xrest,'.') = 0 then xrest else substr(xrest,1,instr(xrest,'.') - 1) end from cte1 where xrest is not null ) select xstr, xremoved from cte1 where xremoved is not null;
2    id          number generated always as identity, 3    text        varchar2(100) table created.;
2         trim(column_value) text 4    xmltable(('"';
4            select id, 5                      text as orig_str , 6                   ',' 9                   1                                             as start_pos , 10                   length(text)                                   as end_pos , 11                   (length(text) - length(replace(text, ','))) + 1 as element_count , 12                   0                                             as element_no , 13                   rownum                                        as rn 16              trim(substr(mod_str, start_pos, end_pos-start_pos)) text 18                     select * 25                     end_pos[iteration_number+1] = instr(cv(mod_str), ',', 1, cv(element_no) + 1) ) 29           element_no;
select trim(regexp_substr('err1, err2, err3', '[^,]+', 1, level)) str_2_tab from dual;
list   => rec.val, tablen => l_tablen, tab    => l_tab);
select 108 name, 'test' project, 'err1,err2,err3' error from dual union all select 109, 'test2', 'err1' from dual ) select name from mytable ) from all_objects ) select x.name,x.project from x, iter where iter.pos < = (length(x.error) - length(replace(x.error, ','))) - 1;
create or replace type typ_str2tbl_nst as table of varchar2(30);
create or replace function str2tbl ( p_string    varchar2, p_delimiter char default ',' ) as l_tmp varchar2(32000) := p_string || p_delimiter;
select name, project, trim(column_value) error from t, table(str2tbl(error));
create or replace type typ_str2tbl_stats as object ( dummy number,   p_stats     out sys.odcitabfuncstats, p_args      in  sys.odciargdesclist, p_string    in  varchar2, p_delimiter in  char default ',' ) create or replace type body typ_str2tbl_stats as static function odcigetinterfaces ( p_interfaces out sys.odciobjectlist ) as begin end odcigetinterfaces;
p_stats     out sys.odcitabfuncstats, p_args      in  sys.odciargdesclist, p_string    in  varchar2, p_delimiter in  char default ',' ) as begin end odcistatstablefunction;
select xmltab.txt from xmltable( 'for $text in tokenize("a,b,c", ",") return $text';
select xmltab.txt from ( select 'a;b;c' inpt from dual union all select 'd;e;f' from dual 'for $text in tokenize($input, ";") return $text';
( select 108 name, 'test' project, 'err1, err2, err3' error  from dual union all select 109, 'test2', 'err1' from dual ) select distinct t.name, t.project, trim(regexp_substr(t.error, '[^,]+', 1, levels.column_value))  as error from temp t, table(cast(multiset(select level from dual connect by  level <= length (regexp_replace(t.error, '[^,]+'))  + 1) as sys.odcinumberlist)) levels;
select level from dual connect by level <= (...);
select level, length (regexp_replace('err1, err2, err3', '[^,]+'))  + 1 as max from dual connect by level <= length (regexp_replace('err1, err2, err3', '[^,]+'))  + 1;
select * from table(cast(multiset(select level from dual connect by  level <= length (regexp_replace(t.error, '[^,]+'))  + 1) as sys.odcinumberlist)) levels;
create table tab(name, project, error) as select 108,'test' ,'err1, err2, err3' from dual union select 109,'test2','err1'             from dual;
select * from tab t from json_table(replace(json_array(t.error), ',', '","'), '$[*]' columns (p varchar2(4000) path '$'))) s;
select 108 name, 'test' project, 'err1, err2, err3' error  from dual union all select 109, 'test2', 'err1' from dual ) select distinct name, project, trim(regexp_substr(str, '[^,]+', 1, level)) str from (select name, project, error str from temp) t;
select trim(regexp_substr('err1, err2, err3', '[^,]+', 1, level)) str_2_tab from dual select trim(regexp_substr('err1, err2, err3', '[^,]+', 1, level)) str_2_tab from dual;
create table table_name ( name, project, error ) as select 108, 'test',  'err1, err2, err3' from dual union all select 109, 'test2', 'err1'             from dual;
select name, project, error, 1, instr( error, ', ', 1 ) from   table_name union all select name, project, error, end_pos + 2, instr( error, ', ', end_pos + 2 ) from   table_name_error_bounds where  end_pos > 0 ) select name, project, case end_pos then substr( error, start_pos ) else substr( error, start_pos, end_pos - start_pos ) end as error from   table_name_error_bounds;
select q.name, q.project, s.column_value as error from mytable q, apex_string.split(q.error, ',') s;
alter database yourdatabasename set offline with rollback immediate;
alter database yourdatabasename set online;
select quote from quotes order by rand();
select * from table;
select * from dbo.foo order by newid();
set @randomid = cast(((@maxvalue + 1) - @minvalue) * rand() + @minvalue as tinyint);
select top 1 * from table_name order by rand();
select * from table_name order by rand() limit 1;
select  * from    sys.objects where   type in (n'fn', n'if', n'tf', n'fs', n'ft') ;
from http://msdn.microsoft.com/en-us/library/ms177596.aspx: if sql_inline_table_valued_function;
select * from sys.objects where (type='tf' or type='fn');
create view my_sys_functions_equivalent as select * from sys.objects where type in ('fn', 'if', 'tf')  -- scalar, inline table-valued, table-valued;
select * from information_schema.routines where routine_type = 'function';
select * from sysobjects where type in ('fn', 'if', 'tf');
select * from dbo.sysobjects where type in ('fn', 'if', 'tf');
select * from sys.objects where type_desc = 'sql_scalar_function';
select * from sys.objects where type_desc like '%fun%';
select o.name as 'function name', m.definition as 'definition', o.object_id from sys.objects as o inner join sys.sql_modules as m where type in ('fn', 'if', 'tf')  -- scalar, inline table-valued, table-valued;
select f.name, s.name as owner, t.name as datatype, p.max_length, p.precision, p.scale, m.definition from sys.objects f join sys.schemas s on s.schema_id = f.schema_id join sys.parameters p on p.object_id = f.object_id and p.parameter_id = 0 join sys.types t on t.system_type_id = p.system_type_id join sys.sql_modules as m on m.object_id = f.object_id where type='fn';
select [user], activity, stuff( (select distinct ',' + pageurl from tablename where [user] = a.[user] and activity = a.activity from tablename as a;
( id int, users varchar(10), activity varchar(10), pageurl varchar(10) ) values  (1, 'me', 'act1', 'ab'), (2, 'me', 'act1', 'cd'), (3, 'you', 'act2', 'xy'), (4, 'you', 'act2', 'st') select t1.users, t1.activity, stuff( ( select ',' + t2.pageurl from @table t2 where t1.users = t2.users from @table t1;
select * from your_table;
select * from dbo.your_table;
create role <abc>;
select 'grant execute on ['+name+'] to [username]  ' from sys.objects where type ='p' and is_ms_shipped = 0;
set @username='[username] ' set @strsql='' select @strsql+=char(13)+'grant execute on ['+ s.name+'].['+obj.name+'] to'+@username+';' from sys.all_objects as obj sys.schemas s on obj.schema_id = s.schema_id where obj.type in ('p','v','fk') and s.name not in ('sys','information_schema') exec sp_executesql @strsql;
if  exists (select * from sys.database_principals where name = n'asp_net') drop user asp_net if  exists (select * from sys.database_principals where name = n'db_execproc' and type = 'r') drop role [db_execproc] create role [db_execproc] authorization [dbo] create user asp_net exec sp_addrolemember n'db_execproc', 'asp_net';
exec sp_addrolemember n'db_datareader', 'asp_net';
exec sp_addrolemember n'db_datawriter', 'asp_net';
from p in db.obj select p;
where s.data == scandata select s.id).firstordefault();
from row in ds.invchead where row.company == session.companyid select row;
from myapp.invcheadrow row in ds.invchead where row.company == session.companyid select row;
select @sql1 = ( select ' drop table dbo.[' + name + ']' from sys.sysobjects as sobjects where (xtype = 'u') and (name like 'group_base_new_work_%') 1, 1, '');
drop table if exists b,c,a;
set foreign_key_checks = 0;
drop table if exists a,b,c;
set foreign_key_checks = 1;
create type testtabletype as table (objectid int);
create procedure [dbo].[util_scripttable] as begin try if not exists (select * from sys.types where name = 'tabletype') create type tabletype as table (objectid int)--drop type tabletype select @tablename = name from sysobjects where id = object_id(@tablename) set @sql= select distinct db_name() from (select schema_id,object_id,name from sys.views union all select schema_id,object_id,name from sys.tables)t join sys.schemas s on t.schema_id=s.schema_id join sys.columns c on  t.object_id=c.object_id --and s.schema_id=c.schema_id join information_schema.columns inf on t.name=inf.table_name and s.name=inf.table_schema and c.name=inf.column_name where inf.table_name = @tablename and inf.table_schema=@schema exec sp_executesql @sql, n'@tablename varchar(50),@schema varchar(50)', @tablename=@tablename,@schema=@schema select @dbname--db_name() from information_schema.columns c join sys.columns sc on  c.table_name = object_name(sc.object_id) and c.column_name = sc.name join sys.types st on coalesce(c.domain_name,c.data_type) = st.name where c.table_name = @tablename select top 1 @tableschema = tableowner from @showfields select   char(10) + fieldname + ' ' + case when domainname is not null and @usesystemdatatypes = 0 then domainname + case when isnullable = 1 then ' null ' else ' not null ' end else case when iscomputed is null then case when ischarcolumn = 1 then '(' + cast(maxlength as varchar(10)) + ')' else case when datatype = 'numeric' then '(' + cast(numericprecision as varchar(10))+','+ cast(numericscale as varchar(10)) + ')' else case when datatype = 'decimal' then '(' + cast(numericprecision as varchar(10))+','+ cast(numericscale as varchar(10)) + ')' else '' end end end + case when identitycolumn = 1 then ' identity(' + cast(identityseed as varchar(5))+ ',' + cast(identityincrement as varchar(5)) + ')' else '' end + case when isnullable = 1 then ' null ' else ' not null ' end + case when columndefaultname is not null and @includeconstraints = 1 then 'constraint [' + replace(columndefaultname,@tablename,@newtablename) + '] default' + upper(columndefaultvalue) else '' end else ' as '+iscomputed+' ' end end + case when fieldid = (select max(fieldid) from @showfields) then '' else ',' end  from    @showfields if @includeconstraints = 1 set @sql= select  distinct  '',constraint ['' + @newtablename+''_''+replace(name,@tablename,'''') + ''] foreign key ('' + parentcolumns + '') references ['' + referencedobject + '']('' + referencedcolumns + '')'' from ( select   referencedobject = object_name(fk.referenced_object_id), parentobject = object_name(parent_object_id),fk.name from   sys.foreign_key_columns fkc join sys.columns cp on fkc.parent_object_id = cp.object_id and fkc.parent_column_id = cp.column_id where fkc.constraint_object_id = fk.object_id   for xml path('''')   )), 2, 8000)) parentcolumns, reverse(substring(reverse((   select cr.name + '','' from   sys.foreign_key_columns fkc join sys.columns cr on fkc.referenced_object_id = cr.object_id and fkc.referenced_column_id = cr.column_id where fkc.constraint_object_id = fk.object_id   for xml path('''')   )), 2, 8000)) referencedcolumns from sys.foreign_keys fk where parentobject = @tablename exec sp_executesql @sql, n'@tablename varchar(50),@newtablename varchar(50),@schema varchar(50)', @tablename=@tablename,@newtablename=@newtablename,@schema=@schema select    ',constraint [' + name + '] foreign key (' + parentcolumns + ') references [' + referencedobject + '](' + referencedcolumns + ')' from ( select   referencedobject = object_name(fk.referenced_object_id), parentobject = object_name(parent_object_id),fk.name from   sys.foreign_key_columns fkc join sys.columns cp on fkc.parent_object_id = cp.object_id and fkc.parent_column_id = cp.column_id where fkc.constraint_object_id = fk.object_id   for xml path('')   )), 2, 8000)) parentcolumns, reverse(substring(reverse((   select cr.name + ',' from   sys.foreign_key_columns fkc join sys.columns cr on fkc.referenced_object_id = cr.object_id and fkc.referenced_column_id = cr.column_id where fkc.constraint_object_id = fk.object_id   for xml path('')   )), 2, 8000)) referencedcolumns from sys.foreign_keys fk    ) a where parentobject = @tablename set @sql= select distinct '',constraint ['' + @newtablename+''_''+replace(c.name,@tablename,'''') + ''] check '' + definition from sys.check_constraints c join sys.schemas s on c.schema_id=s.schema_id and s.name=@schema where object_name(parent_object_id) = @tablename exec sp_executesql @sql, n'@tablename varchar(50),@newtablename varchar(50),@schema varchar(50)', @tablename=@tablename,@newtablename=@newtablename,@schema=@schema select ',constraint [' + name + '] check ' + definition from sys.check_constraints where object_name(parent_object_id) = @tablename set @sql= select distinct  pkobject = cco.object_id from    sys.key_constraints cco join sys.index_columns cc on cco.parent_object_id = cc.object_id and cco.unique_index_id = cc.index_id join sys.indexes i on cc.object_id = i.object_id and cc.index_id = i.index_id join sys.schemas s on cco.schema_id=s.schema_id and s.name=@schema where    object_name(parent_object_id) = @tablename    and  i.type = 1 and    is_primary_key = 1 exec sp_executesql @sql, n'@tablename varchar(50),@schema varchar(50)', @tablename=@tablename,@schema=@schema select distinct  pkobject = cco.object_id from    sys.key_constraints cco join sys.index_columns cc on cco.parent_object_id = cc.object_id and cco.unique_index_id = cc.index_id join sys.indexes i on cc.object_id = i.object_id and cc.index_id = i.index_id where    object_name(parent_object_id) = @tablename    and  i.type = 1 and    is_primary_key = 1 set @sql= select distinct    pkobject = cco.object_id from    sys.key_constraints cco join sys.index_columns cc on cco.parent_object_id = cc.object_id and cco.unique_index_id = cc.index_id join sys.indexes i on cc.object_id = i.object_id and cc.index_id = i.index_id join sys.schemas s on cco.schema_id=s.schema_id and s.name=@schema where    object_name(parent_object_id) = @tablename and  i.type = 2 and    is_primary_key = 0 and    is_unique_constraint = 1 exec sp_executesql @sql, n'@tablename varchar(50),@schema varchar(50)', @tablename=@tablename,@schema=@schema select distinct    pkobject = cco.object_id from    sys.key_constraints cco join sys.index_columns cc on cco.parent_object_id = cc.object_id and cco.unique_index_id = cc.index_id join sys.indexes i on cc.object_id = i.object_id and cc.index_id = i.index_id where    object_name(parent_object_id) = @tablename and  i.type = 2 and    is_primary_key = 0 and    is_unique_constraint = 1 set @clusteredpk = case when @@rowcount > 0 then 1 else 0 end set @sql= select distinct '',constraint '' + @newtablename+''_''+replace(cco.name,@tablename,'''') + case type when ''pk'' then '' primary key '' + case when pk.objectid is null then '' nonclustered '' else '' clustered '' end  when ''uq'' then '' unique '' end + case when u.objectid is not null then '' nonclustered '' else '''' end from   sys.key_constraints ccok where i.object_id = ccok.parent_object_id and   ccok.object_id = cco.object_id from sys.key_constraints cco where    object_name(cco.parent_object_id) = @tablename exec sp_executesql @sql, n'@tablename varchar(50),@newtablename varchar(50),@schema varchar(50),@t tabletype readonly,@u tabletype readonly', @tablename=@tablename,@newtablename=@newtablename,@schema=@schema,@t=@t,@u=@u select ',constraint ' + name + case type when 'pk' then ' primary key ' + case when pk.objectid is null then ' nonclustered ' else ' clustered ' end  when 'uq' then ' unique ' end + case when u.objectid is not null then ' nonclustered ' else '' end from   sys.key_constraints ccok where i.object_id = ccok.parent_object_id and   ccok.object_id = cco.object_id    for xml path(''))), 2, 8000)) + ')' from sys.key_constraints cco where    object_name(cco.parent_object_id) = @tablename end  set @sql= select '' on '' + d.name + ''([''+c.name+''])'' from sys.tables t join sys.indexes i on(i.object_id = t.object_id and i.index_id < 2) join sys.index_columns ic on(ic.partition_ordinal > 0 and ic.index_id = i.index_id and ic.object_id = t.object_id) join sys.columns c on(c.object_id = ic.object_id and c.column_id = ic.column_id) join sys.schemas s on t.schema_id=s.schema_id join sys.data_spaces d on i.data_space_id=d.data_space_id where t.name=@tablename and s.name=@schema exec sp_executesql @sql, n'@tablename varchar(50),@schema varchar(50)', @tablename=@tablename,@schema=@schema if @includeindexes = 1 set @sql= select distinct '' create '' + i.type_desc + '' index ['' + replace(i.name collate sql_latin1_general_cp1_ci_as,@tablename,@newtablename) + ''] on '+@dbname+'.'+@newtableschema+'.'+@newtablename+' ('' from  sys.index_columns sc join sys.columns c on sc.object_id = c.object_id and sc.column_id = c.column_id where  t.name=@tablename and  sc.object_id = i.object_id and  sc.index_id = i.index_id and is_included_column=0 from  sys.index_columns sc join sys.columns c on sc.object_id = c.object_id and sc.column_id = c.column_id where  t.name=@tablename and  sc.object_id = i.object_id and  sc.index_id = i.index_id and is_included_column=1 from sys.indexes i join sys.tables t on i.object_id=t.object_id join sys.schemas s on t.schema_id=s.schema_id and case when @clusteredpk = 1 and is_primary_key = 1 and i.type = 1 then 0 else 1 end = 1   and is_unique_constraint = 0   and is_primary_key = 0 where t.name=@tablename and s.name=@schema exec sp_executesql @sql, n'@tablename varchar(50),@newtablename varchar(50),@schema varchar(50), @clusteredpk bit', @tablename=@tablename,@newtablename=@newtablename,@schema=@schema,@clusteredpk=@clusteredpk end  select   'create ' + type_desc + ' index [' + [name] collate sql_latin1_general_cp1_ci_as + '] on [' +  object_name(object_id) + '] (' +   reverse(substring(reverse((   select name + case when sc.is_descending_key = 1 then ' desc' else ' asc' end + ',' from  sys.index_columns sc join sys.columns c on sc.object_id = c.object_id and sc.column_id = c.column_id where  object_name(sc.object_id) = @tablename and  sc.object_id = i.object_id and  sc.index_id = i.index_id from sys.indexes i where   object_name(object_id) = @tablename and case when @clusteredpk = 1 and is_primary_key = 1 and type = 1 then 0 else 1 end = 1   and is_unique_constraint = 0   and is_primary_key = 0 select fieldvalue from @definition set @script='use '+@dbname+' '+(select fieldvalue+'' from @maindefinition for xml path('')) end try end set @script='' end catch;
exec [util_scripttable]   'db','schema_source','table_source',1,1,'schema_dest','tab_dest',0,@s output select @s;
set @uuid = 'a89b1acd95016ae6b9c8aabb07da2010' select  cast( substring(@uuid, 1, 8) + '-' + substring(@uuid, 9, 4) + '-' + substring(@uuid, 13, 4) + '-' + as uniqueidentifier);
select convert(uniqueidentifier,left(c, 8);
select convert(uniqueidentifier,'a89b1acd95016ae6b9c8aabb07da2010') end try end catch;
create function str2uniq(@s varchar(50)) returns uniqueidentifier as begin set @s = replace(replace(@s,'0x',''),'-','') set @s = stuff(stuff(stuff(stuff(@s,21,0,'-'),17,0,'-'),13,0,'-'),9,0,'-') end;
select convert(uniqueidentifier,stuff(stuff(stuff(stuff('b33d42a3ac5a4d4c81dd72f3d5c49025',9,0,'-'),14,0,'-'),19,0,'-'),24,0,'-'));
select convert(uniqueidentifier, hashbytes('md5','~a89b1acd95016ae6b9c8aabb07da2010'));
from django.db.models import lookup;
from django.db.models import q;
select size, color from sizes cross join colors;
select hour, minute from hours cross join minutes;
select specid, month from reports cross join months;
create table "hr"."bl_grp_01" set define off;
create table "hr"."bl_grp_02" set define off;
create table "hr"."rh_val_01" set define off;
select distinct  a.gr_1 || b.gr_1 || c.rh_val as bl_grp from bl_grp_01 a, bl_grp_02 b, rh_val_01 c;
select c.* from companies as c join users as u using(companyid) join jobs as j using(userid) join useraccounts as us using(userid) where j.jobid = 123;
select foo.baz from foo;
select foo.baz from foo, bar where foo.a *= bar.a;
where to.iduser=tbu.iduser and to.idoffice=1;
where to.idoffice=1;
from t1 cross join t2;
set @actualweightdims= @actual_dims_lenght + 'x' +;
set @actualweightdims= cast(@actual_dims_lenght as varchar(3)) + 'x' +;
set @actualweightdims = @actualweight;
set @actualweightdims = cast(@actualweight as varchar(50));
select  @actualweightdims = cast(@actual_dims_lenght as varchar(10));
select  @actualweightdims = str(@actual_dims_lenght);
set @actualweightdims =;
set @actualweightdims = cast(@actual_dims_lenght as varchar(8)) +;
select row_number() over (order by repairid) as'rn', [repairproductid] from [ws_repairlist] ) update cte set [repairproductid]= isnull([repairproductid]+convert(nvarchar(10),rn),0) from cte;
set @actualweightdims = concat(@actual_dims_lenght, 'x', @actual_dims_width, 'x';
set @actualweightdims = str(@actual_dims_width); or select str(@actual_dims_width) + str(@actual_dims_width);
select 'abcd' + ltrim(str(1)) + ltrim(str(2));
update `table` set `field` = replace(`field`, 'string', 'anothervalue');
update table_name set field_name = replace(field_name,'search','replace') where field_name like '%some_value%';
update table set field = replace(field, 'string', 'anothervalue') where field like '%string%';
update table_name set column_name = replace(column_name, 'string%', 'string') where column_name like '%string%';
select count(*) as aggregate from (select * from `abc` group by `col1`) as a;
where `to_id` = ".auth::id()." and `isseen` = 0;
'something', db::raw('sum( qty ) as qty'), 'foo', 'bar';
select * from (select * from t1 where col1 = ?) join t2 on col1 = col2 and col3 = ? where t2.col4 = ?;
select count(*) as aggregate from (select * from `abc` group by `col1`) as `a`;
select now() - interval '1 day';
select 'yesterday'::timestamp, 'tomorrow'::timestamp, 'allballs'::time;
select org_id, count(accounts) as count, ((date_at) - interval '1 day') as dateat from sourcetable where date_at <= now() - interval '130 days' org_id, dateat;
select date_trunc('month', current_date) + interval '1 month - 1 day';
select make_interval(days => 10 + 2);
select make_interval(days => 1, hours => 2);
select make_interval(0, 1, 0, 5, 0, 0, 0.0);
set define <1_character>;
select cast(replace(cast(myntext as nvarchar(max)),'find','replace') as ntext) from myntexttable;
update [cms_db_test].[dbo].[cms_htmltext] set content = cast(replace(cast(content as nvarchar(4000)),'abc','def') as ntext) where content like '%abc%';
update [cms_db_test].[dbo].[cms_htmltext] set content = cast(replace(cast(content as nvarchar(max)),'abc','def') as ntext) where content like '%abc%';
select chargeid, chargetype, max(servicemonth) as "mostrecentservicemonth" from invoice;
select chargeid, chargetype, max(servicemonth) as servicemonth from invoice;
select t.chargeid, t.chargetype, t.servicemonth from( select chargeid,max(servicemonth) as servicemonth from invoice join invoice t on x.chargeid =t.chargeid and x.servicemonth = t.servicemonth;
select to.chargeid,t0.po,i.chargetype from invoice i (select chargeid,max(servicemonth)po from invoice;
select a.chargeid, a.chargetype, a.servicemonth from invoice a where b.chargeid is null;
set @currentdate=isnull(@currentdate,getdate());
set @currentdate = coalesce(@currentdate , getdate());
alter procedure [dbo].[my_sp] as if @currentdate is null set @currentdate = getdate();
set @counter = 1;
set @counter = @counter + 1;
end  set @starttime = getdate() ( select id, name, row_number() over (partition by id order by name) as namenumber, count(*) over (partition by id) as namecount from @yourtable concatenated as ( select id, cast(name as nvarchar) as fullname, name, namenumber, namecount from partitioned where namenumber = 1 union all  select p.id, cast(c.fullname + ', ' + p.name as nvarchar), p.name, p.namenumber, p.namecount from partitioned as p ) select id, fullname from concatenated where namenumber = namecount set @endtime = getdate();
select datediff(millisecond,@starttime, @endtime);
set @counter = 1;
set @counter = @counter + 1;
end  set @starttime = getdate();
set nocount off select t1.headervalue (select from @yourtable t2 where t1.headervalue=t2.headervalue from @yourtable t1 set @endtime = getdate();
select datediff(millisecond,@starttime, @endtime);
( select id, name, row_number() over (partition by id order by name) as namenumber, count(*) over (partition by id) as namecount from dbo.sourcetable concatenated as ( select id, cast(name as nvarchar) as fullname, name, namenumber, namecount from partitioned where namenumber = 1 union all  select p.id, cast(c.fullname + ', ' + p.name as nvarchar), p.name, p.namenumber, p.namecount from partitioned as p and p.namenumber = c.namenumber + 1 ) select id, fullname from concatenated where namenumber = namecount;
values (1, 'matt'), (1, 'rocks'), (2, 'stylus'), (3, 'foo'), (3, 'bar'), (3, 'baz');
create table #t (id int, name varchar(20)) values (1, 'matt'), (1, 'rocks'), (2, 'stylus') select  id from #t xt where xt.id = t.id from #t t;
set @test = '' select @test += name from names;
select id from demo;
select id, string_agg(name, ', ') as names from some_table;
id                 int select   id from    raw_values_table;
select   sv.id from    @structured_values sv where   valuenumber = 1 union all  select   sv.id from    @structured_values sv join    cte and sv.valuenumber = cte.valuenumber + 1 ) select   id from    cte where   valuenumber = valuecount;
create nonclustered index myindex;
select id, name, address from mytable where id > 1000;
select tab.*, row_number() over () as rnum from tab;
select sql_calc_found_rows employeename, phonenumber from employee where employeename like 'a%' limit 10;
select found_rows();
select found_rows();
select * from ( select * from tbl where /* something */ limit ?;
select t.*, pgc.reltuples as total_count from tbl as t where /* something */ limit ?;
select (select count(*) from table) as count, (select json_agg(t.*) from ( select * from table where /* whatever */ limit ?;
select *, <b>count(*) over() as full_count</b> from   tbl where  /* whatever */ limit  ?;
select * from   tbl where  /* whatever */ ) select * from  ( table  cte limit  ?;
create table table1 ( id int not null identity(1, 1) primary key , name varchar(50) ) create table table2 ( id int not null identity(1, 1) primary key , id_table1 int not null );
select * from table1, table2;
select * from table1 table2;
select * from [mydatabaseondb1].[dbo].[mytable] tab1;
select * from openquery([db2], 'select * from [mydatabaseondb2].[dbo].[myothertable]') select * from [mydatabaseondb1].[dbo].[mytable] tab1;
select tab2.column_name from  [db1.mdf].[dbo].[table_name_1] tab1 inner join [db2.mdf].[dbo].[table_name_2]  tab2;
select        timetrackemployee.staffid from            dbo.tblgbstimecard as gbstimecard inner join;
select customer1.id,customer1.name,customer1.city,custadd.phone,custadd.country from customer1;
select a.id,a.type,b.name,b.city from databasename.dbo.tablename a left join databasename.dbo.tablename b on a.id=b.id;
if ($mysqli1->connect_error) { if ($mysqli2->connect_error) {;
if (mysqli_multi_query($mysqli1, $sql)) {;
select sum(mycol::int) from <table name>;
select count(mycol or null) from mytable;
select count(x < 7 or null) from generate_series(0,10) t(x);
select sum(case when x < 7 then 1 else 0 end) from generate_series(0,10) t(x);
select count(*) filter (where mycol) from tbl;
select count(*), -- all from tbl;
select count(*), sum(othercol) filter (where mycol) from tbl;
select count(mycol) from mytable;
select count(*),sum(mycol::int);
select count(nullif(mycol = false, true)),  -- count true values;
select count(nullif(mycol, true)),  -- count false values;
select f1, case when f1 = 't' then count(*) end as counts, (select count(*) from mytable) as total_counts from mytable;
select sum(case when f1 = 't' then 1 end) as t, sum(case when f1 = 'f' then 1 end) as f, sum(case when f1 not in ('t','f') or f1 is null then 1 end) as others, sum(case when f1 is not null or f1 is null then 1 else 0 end) as total_count from mytable;
select count(*)         -- or count(mycol) from   <table name>     -- replace <table name> with your table where  mycol = true;
select distinct *, count(*) over(partition by mycol) from   <table name>;
select coalesce(sum(case when mycol then 1 else 0 end),0) from <table name>;
select count(case when mycol then 1 end) from <table name>;
select count(*) as total from yourtable;
select count(*) as total from yourtable;
select count(*) as total from yourtable;
select * from product_sales where not (from_date > @rangetill or to_date < @rangefrom);
select * from product_sales where from_date between '2013-01-03' and '2013-01-09';
select * from product_sales where ( from_date >= '2013-08-19' and to_date <= '2013-08-23' ) or ( to_date >= '2013-08-19' and from_date <= '2013-08-23' );
select * from product_sales where from_date >= '03-jan-2013' and to_date <= '09-jan-2013';
select  * from    product_sales where   from_date >= '2013-01-03' and;
select * from product_sales where from_date >= '2013-01-01' and to_date <= '2013-01-20';
select * from product_sales where from_date between '2013-01-03' and '2013-01-09';
select @frmdt='2013-01-03', @todt='2013-01-09' select * from product_sales where (@frmdt between from_date and to_date) or;
select * from xxxx where datepart(yyyy,create_date)>=2013 and datepart(yyyy,create_date)<=2014;
select * from tbl_reservedrooms where not ('@checkindate' not between fromdate and todate and '@checkoutdate'  not between fromdate and todate);
select * from product_sales where;
select start_date, end_date, case when start_date <= '2015-08-31' then 'true' else 'false' end as started_before_end_of_month, case when not end_date <= '2015-08-01' then 'true' else 'false' end as did_not_end_before_begining_of_month from   product_sales where  start_date <= '2015-08-31' and end_date >= '2015-08-01';
select null from   hrmtable hm(nolock) where  hm.employeeid = 123 and ( ( cast(@fromdate as date) between cast(hm.fromdate as date) and cast(hm.todate as date) ) or ( cast(@todate as date) between cast(hm.fromdate as date) and cast(hm.todate as date) ) ) );
select * from table where ( (table.enddate > '2013-01-05') and (table.startdate < '2013-01-07' )  );
select  * from  product_sales where  from_date  >= '2013-01-03' and game_date  <= '2013-01-09';
select * from product_sales where from_date<='2018-04-11' and to_date>='2018-04-11';
@yearfrom int=null, @monthto int=null, @yearto int=null, @firstdate date=null, @lastdate date=null select @firstdate=dateadd(month,@monthfrom-1,dateadd(year,@yearfrom-1900,0)) /*setting first date using from month & year*/ select @lastdate= dateadd(day,-1,dateadd(month,@monthto,dateadd(year,@yearto-1900,0)))/*setting last date using from month & year*/ select *  from tbl_record where  (dateadd(yy, year - 1900, dateadd(m, month - 1, 1 - 1)) between convert(datetime, @firstdate, 102) and;
select * from product_sales where (from_date <= '2013-01-09' and to_date >= '2013-01-01');
select * from tabblename where (datecolumn between '2018-04-01' and '2018-04-5');
create or replace function diff_elements_text ( text[], text[] ) select array_agg(distinct new_arr.elem) from unnest($1) as new_arr(elem) where old_arr.elem is null create operator - ( procedure = diff_elements_text, leftarg = text[], rightarg = text[];
select array_agg(x)-array[''] from (   select 'y' x union all select null union all select 'n' union all select '';
create or replace function strip_nulls( in array_in anyarray ) select array_agg(a) from unnest(array_in) a where a is not null;
select array_remove(array['abc', ''], ''::text);
select array_remove(array['abc', ''], '');
select id, (select array_agg(a) from unnest(canonical_users) a where a is not null) canonical_users, (select array_agg(a) from unnest(non_canonical_users) a where a is not null) non_canonical_users from ( select g.id, array_agg(case when g.canonical = 'y' then g.users else null end) canonical_users, array_agg(case when g.canonical = 'n' then g.users else null end) non_canonical_users from groups g;
select g.id, array_to_string( array_agg(case when g.canonical = 'y' then g.users else null end) array_to_string( array_agg(case when g.canonical = 'n' then g.users else null end) from groups g;
select  coalesce(y.id, n.id) id, y.users, n.users from    (   select  g.id, array_agg(g.users) as users from    groups g where   g.canonical = 'y' from    groups g where   g.canonical = 'n';
select g.id, array_remove(array_agg(case when g.canonical = 'y' then g.users else null end), null) canonical_users, array_remove(array_agg(case when g.canonical = 'n' then g.users else null end), null) non_canonical_users from groups g;
select g.id, array_agg(g.users) filter (where g.canonical = 'y') canonical_users, array_agg(g.users) filter (where g.canonical = 'n') non_canonical_users from groups g;
select array_agg(u) from ( select unnest( array_agg(v) from x where u is not null;
create or replace function fn_array_agg_notnull ( a anyarray as $$ if b is not null then end if;
create aggregate array_agg_notnull(anyelement) ( sfunc = fn_array_agg_notnull, stype = anyarray, initcond = '{}';
create table product ( product_id serial primary key  -- implicit primary key constraint create table bill ( bill_id  serial primary key create table bill_product ( bill_id    int references bill (bill_id) on update cascade on delete cascade;
unique not null;
where x_field in ('f', 'p', 'i', 'a') ... case x_field else 5 --needed only is no in clause above. eg when = 'b';
case x_field else 5 end;
select tt.id, tt.x_field from target_table as tt (values ('f', 1), ('p', 2), ('i', 3), ('a', 4)) as order_table (x_field, order_num) order_table.order_num, -- here we order values by our custom order.;
case when grade = 'a' then 0 else 2 end;
select col1 from tbl_bill where col1 = 0 case when tbl_bill.isgen = 0 then 0 else 2 end;
select col1 from tbl_bill where col1 = 0 case when tbl_bill.isgen = 0 then 0 else 2 end, col1, col2;
select * from mytable where age( mydate, now() ) > '1 year';
select * from mytable where mydate > now()::date - 365;
select * from mytable where mydate > now() - interval '1 year';
select now() - interval '1 year';
select rand()*(@upper-@lower)+@lower;
select rand()*(6-3)+3;
select rand()*3+3;
select @min+floor((@max-@min+1)*rand(convert(varbinary,newid()))); --and then this t-sql snippet generates an integer between minimum and maximum integer values.;
select floor(rand()*(b-a)+a);
select floor(rand()*(25-10)+10);
select rand()*(b-a)+a;
select rand()*(25-10)+10;
set @lower = 3 ---- the lowest random number set @upper = 7 ---- one more than the highest random number select @random = round(((@upper - @lower -1) * rand() + @lower), 0) select @random;
select round((6 - 3 * rand()), 0);
create function dbo.randbetween(@minval tinyint, @maxval tinyint, @random numeric(18,10)) as begin end go;
select @min + round(rand() * (@max - @min), 0);
create view [dbo].[vw_randomseed] as select        rand() as seed;
create function udf_randomnumberbetween ( @min int, @max int ) as begin end;
select abs(checksum(newid()) % 10);
select abs(checksum(newid()) % 6) + 1;
select abs(checksum(newid()) % 4) + 3;
select abs(checksum(newid()) % (@max - @min - 1)) + @min;
select 3 + crypt_gen_random(1) % 4 /*random number between 3 and 6*/ from ...;
select @maxval=24,@minval=5 select cast(((@maxval + 1) - @minval) *;
update categories set code = concat(code, '_standard') where id = 1;
update test set image = concat('https://my-site.com/images/',image) where image is not null;
update [yourtable] set word=upper(left(word,1))+lower(substring(word,2,len(word)));
select upper(left(word,1))+lower(substring(word,2,len(word))) from [yourtable];
create function [dbo].[capitalizefirstletter] ( --string need to format ) as  @resultstring varchar(200)--result string size should equal to the @string variable size set @index = 1 set @resultstring = '' if (@index = 1)--first letter of the string set @resultstring = set @index = @index+ 1--increase the index end  else if ((substring(@string, @index-1, 1) =' 'or substring(@string, @index-1, 1) ='-' or substring(@string, @index+1, 1) ='-') and @index+1 <> len(@string)) set @resultstring = @resultstring + upper(substring(@string,@index, 1)) set @index = @index +1--increase the index end else-- all others set @resultstring = @resultstring + lower(substring(@string,@index, 1)) set @index = @index +1--incerase the index end end--end of the loop if (@@error set @resultstring = @string end -- if no error found return the new string end;
update [yourtable] set word=dbo.capitalizefirstletter([string to go here]);
select replace(wm_concat(new),',','-') exp_res from (select distinct initcap(substr(name,decode(level,1,1,instr(name,'-',1,level-1)+1),decode(level,(length(name)-length(replace(name,'-','')))+1,9999,instr(name,'-',1,level)-1-decode(level,1,0,instr(name,'-',1,level-1))))) new from table;
alter function initialcap(@string varchar(8000)) as begin select @string   = stuff(lower(@string),1,1,upper(left(@string,1))) collate latin1_general_bin, @position = patindex('%[^a-za-z''][a-z]%',@string collate latin1_general_bin);
select @string   = stuff(@string,@position,2,upper(substring(@string,@position,2))) collate latin1_general_bin, @position = patindex('%[^a-za-z''][a-z]%',@string collate latin1_general_bin);
select dbo.initialcap(columnname) from yourtable;
select ( select upper(t.n.value('.', 'char(1)'))+ from x.insxml.nodes('/n') as t(n) from ( select cast('<n>'+replace( replace( insurance, ' ', '</n><n>'), '-', '-</n><n>')+'</n>' as xml) as insxml from @t;
select 7, articleid, 1.50 from article where name like 'abc%';
select 7, articleid, 1.50 from article where name like 'abc%';
select 7, articleid, 1.50 from article where name like 'abc%';
group, id, price ) select 7, articleid, 1.50 from article where name like 'abc%';
select 7, articleid, 1.50 from article where name like 'abc%';
select t.col1, t.col2, ('test' + t.col3) as test_col3 from table t;
select max(acc_num) from accounts where acc_num between 1001000 and 1001999;
select max(acc_num) from accounts where acc_num between '1001000' and '1001999';
create table fund_account2 as select * from fund_account;
delete from fund_account;
alter table fund_account modify (office_id  number);
create table telephone_number (tel_number number);
select whatever from t_old where whatever;
select all_fields_except_active from t_new where active=1;
select some_other_field, field from tbl limit 1;
select min(`field`) from `tbl`;
select -1073741824 * 2;
select (-1073741824) * 2;
select @i1 = -100, @i2 = -100, @i3 = 10;
select @i1/@i2*@i3      [a], -100/(-100)*10   [b], -100/-100*10     [c], -100/-(100*10)   [d], -(100/-(100*10)) [e];
:adapter => 'mysql2', :host => 'host', :database => 'siteconfig_development', :username => 'username', :password => 'password' end;
[2, "title_2", "body_2"], ... {"id" => 2, "title" => "title_2", "body" => "body_2"}, ... end;
select * from tablename;
select * from cars_new where status = '1' and car_hide !='1' and cname in ('executive car','saloon','mpv+','mpv5') order by field(cname, 'executive car', 'saloon','mpv+','mpv5');
select * from table order by column `name`+0 asc;
select * from your_table;
select id, name, priority from table a;
select id, name, priority from mytable;
select * from your_table priority;
select * from your_table priority;
select id, name, priority from mytable;
select id, name, priority from mytable;
select id, name, priority from mytable;
create table server(name varchar(50),ipaddress varchar(15),id init);
create table client(name varchar(50),ipaddress varchar(15),id init);
update table set field = replace( field, 'c:\afolder\', 'c:\anewfolder\' ) where field like 'c:\afolder\%';
update table set field = replace( field, 'c:\afolder\', 'c:\anewfolder\');
select fielda, replace(field, 'c:\afolder\', 'c:\anewfolder\'), fieldb from table;
select s.id, s.name, s.city from stuff s join stuff p on ( s.name = p.city or s.city = p.name );
select id, name, city from [stuff] s where 1 < (select count(*) from [stuff] i where i.city = s.city and i.name = s.name);
select s.id, t.* from [stuff] s join ( select name, city, count(*) as qty from [stuff] having count(*) > 1;
select name, city, count(*) as qty from stuff;
select count(*) from staging.dbo.stage s ltrim(rtrim(s.transactiondate)) having count(*) > 1;
select t.* from ( select s.* from stuff s where t.qty > 1;
create table stuff( id   integer  not null;
select t.* from ( select s.* from stuff s where t.qty > 1;
select s1.id from stuff s1 where s1.id <> s2.id and s1.name = s2.name and s1.city = s2.city;
select ... from ... where date > dateadd(year,-1,getdate());
set @start = dbo.getdatewithouttime(dateadd(year, -1, getdate())) -- cut time (hours, minutes, ect.) --  getdatewithouttime() function doesn't exist in ms sql -- you have to write one select column1, column2, ..., columnn from table where date >= @start;
select ... from ... where year(date) = year(getdate()) - 1;
select ... from ... where year(date) = year(getdate()) - 1 and date > '05/05/2007';
select * from table where date >;
set @imonth = 0 set @syear = year(dateadd(month,@imonth,getdate())) set @smonth = right('0'+cast(month(dateadd(month,@imonth,getdate())) as varchar(2)),2) select @syear + @smonth set @imonth = @imonth - 1 end;
select .... from .... where year(*your date column*) = year(dateadd(year,-1,getdate()));
select .... from .... where year(date) > year(dateadd(year, -2, getdate()));
select ... from ....where;
select ... from ... where date between curdate() - interval 1 year and curdate();
create user 'readonly_user'@'localhost' identified by 'some_strong_password';
all privileges- this would allow a mysql user all access to a designated database (or if no database is selected, across the system);
select distinct on (usr_id) lives_remaining, usr_id, trans_id from lives;
select distinct on (location) location, time, report from weather_reports;
select t.* from (select row_number() over(partition by usr_id order by time_stamp desc) as r from lives) as t where t.r = 1;
select  l.* from    ( select distinct usr_id from   lives where   l.ctid = ( select ctid from   lives li where  li.usr_id = lo.usr_id time_stamp desc, trans_id desc limit 1 );
select l1.* from lives l1 left outer join lives l2 or (l1.time_stamp = l2.time_stamp and l1.trans_id < l2.trans_id))) where l2.usr_id is null;
select l1.* from lives as l1 select usr_id, max(time_stamp) as time_stamp_max from lives usr_id select usr_id, time_stamp, max(trans_id) as trans_max from lives usr_id, time_stamp;
--  by far the least i/o intensive operation even in case of great scarcity select l1.* from lives as l1 select usr_id, max(array[extract(epoch from time_stamp),trans_id]) as compound_time_stamp from lives usr_id;
select distinct on (usr_id) last_value(lives_remaining) over wnd, usr_id, last_value(trans_id) over wnd from lives partition by usr_id order by time_stamp, trans_id;
select (array_agg(tree.id order by tree_size.size)))[1] from tree join forest on (tree.forest = forest.id);
select * from lives outer where (usr_id, time_stamp, trans_id) in ( select usr_id, time_stamp, trans_id from lives sq where sq.usr_id = outer.usr_id limit 1 );
where (a, b, c) in (subquery);
select * from db1.dbo.clients c join db2.dbo.messages m on c.clientid = m.clientid;
select * from cte1 c1;
where date in table_2;
select generate_series('2012-06-29', '2012-07-03', '1 day'::interval) as date ) select generate_series('2012-06-30', '2012-07-13', '1 day'::interval) as date ) select * from table_1 t1 table_2 t2;
select * from table_1 t1 where t1.date in (select date from table_2);
select * from table_1 t1 where exists (select * from table_2 t2 where t2.date = t1.date);
tab2 as ( select ... from tab1 where your filter), tab3 as ( select ... from tab2 where your filter) select * from tab3;
update mytable set col1=@col1, col2=@col2 where id=@id if @@rowcount = 0;
set transaction isolation level serializable update mytable set col1=@col1, col2=@col2 where id=@id if @@rowcount = 0 end commit transaction upsert;
update t with (serializable) set hitcount = hitcount + 1 where pk = @id if @@rowcount = 0 values (@id,1) end commit tran;
set transaction isolation level serializable update mytable set    col1 = @col1, col2 = @col2 where  id = @id if @@rowcount = 0 col1, col2) values      (@id, @col1, @col2) end  if @@error > 0 col1, col2) values      (@id, @col1, @col2) end ;
select name from db1.table1 as a join db2.table2 as b where a.age = b.age;
select * from db1.sometable a db2.sometable b on b.somecolumn = a.somecolumn;
vacancies.where( vacancy.project_id_column.eq(project.id_column) );
select name, event_type, sport_type, level from vnn_sport;
where lastedit + interval '5 minute' < now() ";
select monthname(t.summarydatetime) as month, year(t.summarydatetime) as year from trading_summary t;
select onday, id, sum(pxlow)/count(*),sum(pxlow),count(`*`), concat(year(onday),"-",month(onday)) as sdate from ... where stockparent_id =16120 group by sdate order by onday;
select monthname(t.summarydatetime) as month, year(t.summarydatetime) as year from trading_summary t;
select year(t.summarydatetime) as yr, group_concat(monthname(t.summarydatetime)) as month from trading_summary t group by yr;
select  sum(amnt) `value`,date_format(dtrg,'%m-%y') as label from rentpay group by year(dtrg) desc, month(dtrg) desc limit 12;
select extract(year_month from summarydatetime) summary_year_month from trading_summary;
select extract(year_month from summarydatetime) summary_year_month from trading_summary;
select string_agg(prod, '|') within group (order by product) from ...;
select string_agg(prod,' | ') from;
select string_agg(product,' | ' order by product) from "tblproducts";
select getdate() - 1;
select datediff ( day, datediff(day, @createddate, -1), getdate());
select datediff(day,  dateadd(day, -1, '2013-03-13 00:00:00.000'), getdate());
select datediff(day,  dateadd(day, -1, @createddate), getdate());
select datediff(day, dateadd(day,-1,'2013-03-13 00:00:00.000') , getdate());
select date_sub(orderdate,interval 1 day) as subtractdate from orders;
select dateadd(day,-1,'2013-04-01 16:25:00.250');
select dateadd(day,-1,@createddate);
select dateadd(day,-1,getdate());
select convert(nvarchar(max), getdate(), 112);
select convert(nvarchar(max), getdate(), 112) - 1;
select convert(nvarchar (max),orderdate,112)-1 as subtractdate from orders;
select dateadd(day, -1, convert(date, getdate()));
table = "table";
if not script in script_cache:;
select field1, field2, field3, field4 from table where condition1 = 1 and condition2 = 2;
', '.join(fields));
select field1, field2, field3, field4 from table where condition1=1 and condition2=2;
select * from frobozz where zorkmids > 10;
select * from table;
select field1, field2, field3, field4 from table""" if debug:;
drop procedure if exists example;
create procedure example() select 2+222+2222+222+222+2222+2222 as this_is_a_really_long_string_test;
where condition1=1 and condition2=2';
from inspect import cleandoc select field1, field2, field3, field4 from table where condition1=1 and condition2=2;
select field1, field2, field3, field4 from table where condition1=1 and condition2=2 select field1, field2, field3, field4 from table where condition1=1 and condition2=2;
select * from foo;
select * from bar;
select field1, field2, field3, field4 from table where condition1 = 1 and condition2 = 2;
( select 1 as id,newid() as val union all select id + 1,newid() from    list where   id + 1 < 10 ) select id,val from list;
select substring(convert(varchar(40), newid()),0,9);
select substring(replace(newid(),'-',''),cast(rand()*(31-@desiredlength) as int),@desiredlength);
set @ipoffset=null set @offsetasciiup1=1 set @offsetasciidown1=-1 set @asciihibound=126 --> up to and not including set @asciilobound=31 --> up from and not including set @inpstring = '{"config":"some string value", "boolattr": true}' set @length = len(@inpstring) set @position = 1 set @maskedstring = '' select @maskedstring = @maskedstring + case when ascii(substring(@inpstring,@position,1))>@asciilobound and ascii(substring(@inpstring,@position,1))<@asciihibound then char(ascii(substring(@inpstring,@position,1))+ case when ascii(substring(@inpstring,@position,1))%2=0 then @offsetasciiup1 else @offsetasciidown1 end else @ipoffset end)) then '('+convert(varchar,ascii(substring(@inpstring,@position,1))+1000)+')' --> wrap for decode then '('+convert(varchar,ascii(substring(@inpstring,@position,1))+1000)+')' --> wrap for decode end ,'') select @position = @position + 1 end  select @maskedstring set @inpstring = @maskedstring set @length = len(@inpstring) set @position = 1 set @maskedstring = '' select @maskedstring = @maskedstring + case when ascii(substring(@inpstring,@position,1))>@asciilobound and ascii(substring(@inpstring,@position,1))<@asciihibound then char(ascii(substring(@inpstring,@position,1))+ case when ascii(substring(@inpstring,@position,1))%2=1 then @offsetasciidown1 else @offsetasciiup1 end else @ipoffset*(-1) end)) else '' end ,'') select @position = @position + 1 end  select @maskedstring;
set @binarydata=crypt_gen_random (@length) set @characterdata=cast('' as xml).value('xs:base64binary(sql:variable("@binarydata"))', 'varchar(max)');
select left(newid(),5);
create procedure [dbo].[spgeneraterandomstring] @randomstring varchar(50) output as begin set nocount on set @counter = 1 set @randomstring =  select @nextchar = char(48 + convert(int, (122-48+1)*rand())) if ascii(@nextchar) not in (58,59,60,61,62,63,64,91,92,93,94,95,96) select @randomstring = @randomstring + @nextchar set @counter = @counter + 1 end end end;
create view dbo.vwcodecharrandom as select top 100 percent from dbo.tblcharacter newid() select top 1 codechar from dbo.vwcodecharrandom;
select top 1 randomchar from tblrandomcharacters order by newid();
select @randomstring = convert(varchar(255), newid());
set @length = rand() * 5 + 8 set @charpool = set @poollength = len(@charpool) set @loopcount = 0 set @randomstring = '' select @randomstring = @randomstring + select @loopcount = @loopcount + 1 end;
alter procedure usp_generateidentifier as begin set nocount on;
select @alpha = 'qwertyuiopasdfghjklzxcvbnm' select @first = @alpha + '_@';
set  @seed = (rand((@seed+@step)%2147483647)*2147483647);
select @length = @minlen + rand(@seed) * (@maxlen-@minlen) select @dice = rand(@seed) * len(@first), @seed = (rand((@seed+@step)%2147483647)*2147483647);
select @string = substring(@first, @dice, 1);
select @dice = rand(@seed) * 100 if (@dice < 10) -- 10% special chars select @dice = rand(@seed) * len(@specials)+1 select @string = @string + substring(@specials, @dice, 1);
end else if (@dice < 10+10) -- 10% digits select @dice = rand(@seed) * len(@digit)+1 select @string = @string + substring(@digit, @dice, 1);
end else -- rest 80% alpha select @dice = rand(@seed) * len(@alpha)+1 select @string = @string + substring(@alpha, @dice, 1);
end  select @length = @length - 1;
select @seed = 1234; -- saved start seed exec usp_generateidentifier exec usp_generateidentifier exec usp_generateidentifier;
alter table my_table add my_column char(20) not null default dbo.generatetoken(crypt_gen_random(20));
create function generatetoken(@randombytes varbinary(max)) set @allowedchars = 'abcdefghijklmnopqrstuvwxyz012345';
set @token = '';
set @index = @index + 1;
select @onebyte = convert(tinyint, substring(@randombytes, @index, 1));
select @onechar = substring(@allowedchars, 1 + (@onebyte % 32), 1); -- 32 is the number of @allowedchars select @token = @token + @onechar;
if exists (select * from sys.objects where type = 'p' and object_id = object_id(n'generatearandomstring')) drop procedure generatearandomstring create procedure generatearandomstring ( @desiredlength         integer = 100, @numbers               varchar(50) @alphabet              varchar(100) @specials              varchar(50) @randomstring          varchar(8000)   out ) as  set @selector  = cast(abs(checksum(newid())) % 3 as integer);   -- always three 1 number , 2 alphabet , 3 special;
if @selector = 0 set @selector = 3 select @swap = case when @selector = 1 then @numbers when @selector = 2 then @alphabet else @specials end;
set @selector  = cast(abs(checksum(newid())) % len(@swap) as integer);
if @selector = 0 set @selector = len(@swap) set @randomstring = isnull(@randomstring,'') + substring(@swap,@selector,1);
set @currentlenght = len(@randomstring);
exec generatearandomstring @randomstring = @randomstring out select @randomstring;
select abs( cast( newid() as binary( 6)) %1000) + 1 as randomint;
if exists (select * from sys.objects where type = 'p' and object_id = object_id(n'usp_generateidentifier')) drop procedure usp_generateidentifier create procedure usp_generateidentifier as begin set nocount on;
select @alpha = 'qwertyuiopasdfghjklzxcvbnm' select @first = @alpha + '_@';
set  @seed = (rand(@seed)*2147483647);
select @length = @minlen + rand() * (@maxlen-@minlen);
select @dice = rand() * len(@first);
select @string = substring(@first, @dice, 1);
select @dice = rand() * 100;
if (@dice < 10) -- 10% special chars select @dice = rand() * len(@specials)+1;
select @string = @string + substring(@specials, @dice, 1);
end else if (@dice < 10+10) -- 10% digits select @dice = rand() * len(@digit)+1;
select @string = @string + substring(@digit, @dice, 1);
end else -- rest 80% alpha select @dice = rand() * len(@alpha)+1;
select @string = @string + substring(@alpha, @dice, 1);
end  select @length = @length - 1;
select char((rand()*25 + 65))+char((rand()*25 + 65));
create view [dbo].[vwgetnewid] as select        newid() as id as begin set @string = 'abcdefghijklmnopqrstuvwxyz' + --lower letters select @result = ( select top (@length) from master..spt_values where number < datalength(@string) and type = 'p' ( select top 1 id from dbo.vwgetnewid;
value nvarchar(510) ) * so we'll have to make multiple calls depending on length. select substring(replace(newid(), '-', ''), 1, @length * 2) end  set @i = 0 while @i < @iterations begin set @i = @i + 1 update @random set value = substring(value + replace(newid(), '-', ''), 1, @length * 2) end  set @i = 0 while @i < @length begin set @i = @i + 1 update @random set value = * and convert them to a single charset value. we can do this end  select value from @random;
select substring('abcdefghijklmnopqrstuvwxyz', (abs(checksum(newid())) % 26)+1, 1);
select textlen.textlen select  cast(newid() as varbinary(max)) + cast(newid() as varbinary(max)) where   textlen.textlen is not null /*force evaluation for each outer query row*/ from ( values (2),(4),(48) ) as textlen(textlen)    --define lengths here;
create view [dbo].[vw_crypt_gen_random_8] as select crypt_gen_random(8) as [value];
create function [dbo].[fn_generaterandomstring] ( @length int, @excludedcharacters varchar(200) --comma delimited string of excluded characters ) set @excludedcharacters = concat(@excludedcharacters,',^,*,(,),-,_,=,+,[,{,],},\,|,;,:,'',",<,.,>,/,`,~');
select ascii(trim(value)) from string_split(@excludedcharacters, ',') where len(trim(value)) = 1;
set @asciivalue = (select top 1 (abs(convert(int, [value])) % 94) + 33 from [dbo].[vw_crypt_gen_random_8]);
from @excludedcharacterstable where [asciivalue] = @asciivalue)) set @returnvalue = @returnvalue + char(@asciivalue);
select [dbo].[fn_generaterandomstring](8,'!,@,#,$,%,&,?');
select left(convert(varchar(36),newid()),4)+right(convert(varchar(36),newid()),4);
select right(replace(convert(varchar(36),newid()),'-',''),8);
select lower(replace(newid(),'-','')) + convert(varchar, @userid);
select cast( convert(nvarchar(max), convert(varbinary(8), newid()) as xml).value('xs:base64binary(xs:hexbinary(.))', 'varchar(max)') as stringvalue;
select u.username from users u select cast( convert(nvarchar(max), convert(varbinary(8), newid()) as xml).value('xs:base64binary(xs:hexbinary(.))', 'varchar(max)') as stringvalue;
select r from openjson((select crypt_gen_random(36) r for json path));
select * from invoice inv, invoiceline inv_l where select * from invoice inv, invoiceline inv_l where select * from invoice inv, invoiceline inv_l where select * from invoice inv, invoiceline inv_l where;
select * from invoice left join invoicelines on inv_id = invl_inv_id;
select * from invoices natural join invoice_lines select * from invoices join invoice_lines using (invoice_id);
select * from invoices join invoice_lines;
select invoice.invoiceid, lines.invoiceline, customer.orgname from invoices invoice join invoicelines lines on lines.invoiceid = invoice.invoiceid join customers customer on customer.customerid = invoice.customerid;
select * from customer as c;
select invoices.id from invoices;
select t1.field1, t2.field2, t3.field3 from table1 t1 join table2 t2 on t1.id = t2.table1id join table3 t3 on t1.id = t3.table2id;
select t1.field1, t2.field2, t3.field3 from table1 t1 join table2 t2 on t1.id = t2.table1id join table3 t3 on t2.id = t3.table2id;
select employee.*, email.address from employees as employee left join emails as email on employee.emailid = email.emailid -- i would sure like it to just have the email.id here.... but oh well;
create function [dbo].[fnconvert_titlecase] (@inputstring varchar(4000) ) as begin set @outputstring = lower(@inputstring) set @index = 2 set @outputstring = stuff(@outputstring, 1, 1,upper(substring(@inputstring,1,1))) set @char = substring(@inputstring, @index, 1) if @char in (' ', ';', ':', '!', '?', ',', '.', '_', '-', '/', '&','''','(') if @index + 1 <= len(@inputstring) if @char != '''' or upper(substring(@inputstring, @index + 1, 1)) != 's' set @outputstring = end set @index = @index + 1 end  end;
update titles set title =;
create function [dbo].[fntopropercase]( @name nvarchar(500) ) as begin if (@name <> '')--or @name = lower(@name) collate sql_latin1_general_cp1_cs_as or @name = upper(@name) collate sql_latin1_general_cp1_cs_as) set @name = lower(rtrim(@name)) set @name = stuff(@name, @pos, 1, upper(substring(@name, @pos, 1))) set @pos2 = patindex('%[- ''.)(]%', substring(@name, @pos, 500)) set @pos += @pos2 if (isnull(@pos2, 0) = 0 or @pos > len(@name)) end end  end go;
select upper('put your o'so oddly cased mcweird-name von righthere here');
select id from sometable;
select jobtitle, concat(upper(left(jobtitle,1)), substring(jobtitle,2,len(jobtitle))) as propercase from [humanresources].[employee];
select statename = 'north carolina' union all select 'texas' ( select upper(left(value, 1)) + from   #states op ) select string_agg(value, ' ') from ctedata c;
update tablename set columnname =;
create function propercase(@text as varchar(8000)) as begin if @text is null select @reset = 1, @i = 1, @ret = '';
select @c = substring(@text, @i, 1), @d = substring(@text, @i+1, 1), @ret = @ret + case when @reset = 1 or (@reset=-1 and @c!='s') or (@reset=-1 and @c='s' and @d!=' ') then upper(@c) else lower(@c) end, @reset = case when @c like '[a-za-z]' then 0 when @c='''' then -1 else 1 end, @i = @i + 1 end;
create function propercase(@text as nvarchar(max)) as begin select @return = coalesce(@return + ' ', '') + word from ( select case else case when len(value) = 1 then upper(value) else upper(left(value, 1)) + (lower(right(value, len(value) - 1))) end end as word from string_split(@text, ' ') end;
select 'goofyear tire and rubber company' as n union all select 'the happy bear' as n union all select 'monk house sales' as n union all select 'forum communications' as n ) select n, ( select ' ' + ( upper(left(value, 1)) ) from ( select value from string_split(t.n, ' ') from t;
create function string.initcap( @string nvarchar(4000) ) returns nvarchar(4000) as select @initcap = stuff( @initcap, n, 1, upper( substring( @initcap, n, 1 ) ) ) from ( select (1 + n1.n + n10.n + n100.n + n1000.n) as n from       (select 0 as n union select    1 union select    2 union select    3 union select    4 union select    5 union select    6 union select    7 union select    8 union select    9) as    n1 where n between 1 and len( @initcap ) and substring( @initcap, n, 1 ) like '[a-z]'                 /* this character is a letter */ and ( n = 1                                                    /* this character is the first `character` */ or substring( @initcap, n-1, 1 ) like '[^a-z]'           /* the previous character is not a letter */ ) and ( n < 3                                                    /* only test the 3rd or greater characters for this exception */ or substring( @initcap, n-2, 3 ) not like '[a-z]''[a-z]' /* exception: the pattern <letter>'<letter> should not capatolize the letter following the apostrophy */ ) end;
create function propercase ( --the string to be converted to proper case ) as begin if @input is null end  set @ctr = 1 set @len = len(@input) set @output = '' set @lower_case_a = 97 set @lower_case_z = 122 set @delimiter = ' ,-' set @upper_case_a = 65 set @upper_case_z = 90 set @output = @output + substring(@input,@ctr,1) set @ctr = @ctr + 1 end  if ascii(substring(@input,@ctr,1)) between @lower_case_a and @lower_case_z set @output = @output + upper(substring(@input,@ctr,1)) end else begin set @output = @output + substring(@input,@ctr,1) end  set @ctr = @ctr + 1 if ascii(substring(@input,@ctr,1)) between @upper_case_a and @upper_case_z set @output = @output + lower(substring(@input,@ctr,1)) end else begin set @output = @output + substring(@input,@ctr,1) end set @ctr = @ctr + 1 end  end return @output end  set quoted_identifier off set ansi_nulls on;
create function propercase(@text as varchar(8000)) as begin if @text is null select @reset = 1, @i = 1, @ret = '';
select @c = substring(@text, @i, 1), @ret = @ret + case when @reset = 1 then upper(@c) else lower(@c) end, @reset = case when @c like '[a-za-z]' then 0 else 1 end, @i = @i + 1 end;
create function topropercase(@string varchar(255)) returns varchar(255) as begin set @w = '[' + char(13) + char(10) + char(9) + char(160) + ' ' + ']' set @i = 1 set @l = len(@string) set @f = 1 set @o = '' set @c = substring(@string, @i, 1) if @f = 1 set @o = @o + @c set @f = 0 end else begin set @o = @o + lower(@c) end  if @c like @w set @f = 1 set @i = @i + 1 end  end;
all upper case and      some lower      cc ;
if object_id('dbo.propercase') is not null drop function dbo.propercase create function dbo.propercase ( @str varchar(8000)) as begin set @str = ' ' + @str set @str = replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace( @str, ' a', ' a'), ' b', ' b'), ' c', ' c'), ' d', ' d'), ' e', ' e'), ' f', ' f'), ' g', ' g'), ' h', ' h'), ' i', ' i'), ' j', ' j'), ' k', ' k'), ' l', ' l'), ' m', ' m'), ' n', ' n'), ' o', ' o'), ' p', ' p'), ' q', ' q'), ' r', ' r'), ' s', ' s'), ' t', ' t'), ' u', ' u'), ' v', ' v'), ' w', ' w'), ' x', ' x'), ' y', ' y'), ' z', ' z') end go;
@c  char(1), @sql    varchar(8000) set @x = 0 set @sql = '@str' -- actual variable/column you want to replace set @c = char(ascii('a') + @x) set @sql = 'replace(' + @sql + ', '' ' + @c+  ''', '' ' + upper(@c) + ''')' set @x = @x + 1 end print @sql;
@c  char(1), @sql    varchar(8000), @count  int set @x = 0 set @count = 0 set @sql = '@str' -- actual variable you want to replace set @c = char(@x) if @x = ascii(lower(@c)) and @x != ascii(upper(@c)) set @sql = 'replace(' + @sql + ', '' ' + @c+  ''', '' ' + upper(@c) + ''')' set @count = @count + 1 end set @x = @x + 1 end print @sql;
if object_id('dbo.propercase') is not null drop function dbo.propercase create function dbo.propercase ( @str varchar(8000)) as begin set @str = ' ' + @str set @str =     replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(@str, ' a', ' a'), ' b', ' b'), ' c', ' c'), ' d', ' d'), ' e', ' e'), ' f', ' f'), ' g', ' g'), ' h', ' h'), ' i', ' i'), ' j', ' j'), ' k', ' k'), ' l', ' l'), ' m', ' m'), ' n', ' n'), ' o', ' o'), ' p', ' p'), ' q', ' q'), ' r', ' r'), ' s', ' s'), ' t', ' t'), ' u', ' u'), ' v', ' v'), ' w', ' w'), ' x', ' x'), ' y', ' y'), ' z', ' z'), ' ', ' '), ' ', ' '), ' ', ' '), ' ', ' '), ' ', ' '), ' ', ' '), ' ', ' '), ' ', ' '), ' ', ' '), ' ', ' '), ' ', ' '), ' ', ' '), ' ', ' '), ' ', ' '), ' ', ' '), ' ', ' '), ' ', ' '), ' ', ' '), ' ', ' '), ' ', ' '), ' ', ' '), ' ', ' '), ' ', ' '), ' ', ' '), ' ', ' '), ' ', ' '), ' ', ' '), ' ', ' '), ' ', ' '), ' ', ' '), ' ', ' '), ' ', ' '), ' ', ' '), ' ', ' ') end go;
set @floor = 50 set @resultlimit = 10 set @total = @floor + @resultlimit --table body ) --table body ) select top @total --what to select (the where, from, etc) select top @floor * from @tmp0 select * from @tmp0 select * from @tmp1;
select [keycol1], [keycol2], [col3] from (select top 5 [keycol1], [keycol2], [col3] from [dbo].[table_name];
select * from (select row_number() over (order by createddate) as row, * from locations where userid = 12345) as subquery where row > 1 -- or 2, or 5, or 34;
@count int set @bottom = 1000 set @count = (select count(*) from employee) select * from employee emp where emp.employeeid not in ( select top (@count-@bottom) employee.employeeid from employee );
select top 1 * --(or 2, or 5, or 34) from   (select row_number() over (order by  (select null) ) as rowindex, * from mytable) as subquery;
select top 10*from table1 order by id desc;
select count(1) from cohort; --number of results to expect select * from cohort;
select columns from ( select top 200 from my_table a_column desc a_column asc;
set @numberofrows = (select count(*) from thetable);
select col1, col2,... from ( select col1, col2,..., row_number() over (order by col1) as introw from thetable where introw > @numberofrows - 20;
select * from split('apple,orange,banana,apple,lime',',');
select * into #mytemptable from split('apple,orange,banana,apple,lime',',') alter table #mytemptable add tempid int identity select top 2 * from #mytemptable order by tempid desc drop table #mytemptable;
select * into #mytemptable from split('apple,orange,banana,apple,lime',',') alter table #mytemptable add tempid int identity delete from #mytemptable where tempid <= ((select count(*) from #mytemptable) - 2) alter table #mytemptable drop column tempid select * from #mytemptable drop table #mytemptable;
select * from sys.sysprocesses where open_tran = 1;
select trans.session_id as [session id], eses.host_name as [host name],login_name as [login name], trans.transaction_id as [transaction id], tas.name as [transaction name],tas.transaction_begin_time as [transaction tds.database_id as [database id],dbs.name as [database name] from sys.dm_tran_active_transactions tas join sys.dm_tran_session_transactions trans where eses.session_id is not null;
exec sp_addrolemember n'db_datareader', n'your-user-name';
exec sp_addrolemember n'db_datawriter', n'your-user-name';
exec sp_addrolemember 'db_owner', 'username';
exec sp_addrolemember n'db_owner', n'username';
select  * from    [yourtable] with (index(0)) where   ...;
select  * from    [yourtable] with (index(1)) where   ...;
select * from table where attribute = 'value';
select name from table where name = 'boris';
select * from table where name = 'boris';
select * from table with(index(index_name));
select * from table1 use index (col1_index,col2_index) where col1=1 and col2=2 and col3=3;
select * from table1 ignore index (col3_index) where col1=1 and col2=2 and col3=3;
select * from t1 use index (i1) ignore index (i2) use index (i2);
( select  * from    mytable where   parentid is null -- this condition defines the ultimate ancestors in your chain, change it as appropriate union all select  m.* from    mytable m join    q ) select  * from    q;
( select  m.*, cast(row_number() over (order by m.personid) as varchar(max)) collate latin1_general_bin as bc from    mytable m where   parentid is null union all select  m.*,  q.bc + '.' + cast(row_number() over (partition by m.parentid order by m.personid) as varchar(max)) collate latin1_general_bin from    mytable m join    q ) select  * from    q bc;
personid int, initials varchar(20), parentid int ) select @personid = 1 select * from    @table where   personid = @personid union all select  t.* from    @table t inner join ) select  * from    selects;
create function udfpersonandchildren ( @personid int ) as begin select * from people p where personid=@personid select p.* from people p where o2.personid is null end  end;
@enddate datetime set @startdate = '11/10/2011' set @enddate = '03/25/2012' select year(@startdate) as 'yr', month(@startdate) as 'mm', datename(mm, @startdate) as 'mon', datepart(d,@startdate) as 'dd', @startdate 'new_date' union all select year(new_date) as 'yr', month(new_date) as 'mm', datename(mm, new_date) as 'mon', datepart(d,@startdate) as 'dd', dateadd(d,1,new_date) 'new_date' from cte where new_date < @enddate ) select yr as 'year', mon as 'month', count(dd) as 'days' from cte;
end  end  end  end;
name: 'jane', courses: [ { course: 'chem101', mark: 89 } name: 'biology 101', description: 'introduction to biology';
name: 'jane', courses: ['bio101', 'bio102']   // <= ids of the courses name: 'biology 101', description: 'introduction to biology';
addresses : [ { street: '123 avenue q', city: 'new york', cc: 'usa' };
name : 'goofy.example.com', ipaddr : '127.66.66.66' message : 'cpu is on fire!', host: objectid('aaab')       // reference to the host document;
name: 'jane', courses: [ mark: 85, id:bio101 ];
select * from ( select a.*, rownum r__ from ( select * from orders where customerid like 'a%' where rownum < ((pagenumber * pagesize) + 1 ) ) where r__ >= (((pagenumber-1) * pagesize) + 1);
select * from ( select /*+ first_rows(25) */ row_number() over from all_objects ) where rn between :n and :m;
select * from (select fielda, fieldb, fieldc, row_number() over (order by fieldc) r from table_name where fielda = 10 ) where r >= 10 and r   <= 15;
select * from v$version;
select * from user;
select * from user;
select id  from tb1 where yearweek (date) = yearweek( current_date -interval 1 week );
set @startdate = getdate() - 7 /* seven days earlier */ set @enddate = getdate() /* now */ select id from   mytable where  date between @startdate and @enddate;
set @startdate = getdate() - 8 /* eight days earlier */ set @enddate = getdate() - 1  /* yesterday */;
@startdate datetime, @enddate datetime set @daytype = datename(dw, getdate()) if @daytype= 'monday' set @startdate = getdate()-7 set @enddate = getdate()-1 end  else if @daytype = 'tuesday' set @startdate = getdate()-8 set @enddate = getdate()-2 end else if @daytype = 'wednesday' set @startdate = getdate()-9 set @enddate = getdate()-3 end else if @daytype = 'thursday' set @startdate = getdate()-10 set @enddate = getdate()-4 end  else if @daytype = 'friday' set @startdate = getdate()-11 set @enddate = getdate()-5 end  else if @daytype = 'saturday' set @startdate = getdate()-12 set @enddate = getdate()-6 end  else if @daytype = 'sunday' set @startdate = getdate()-13 set @enddate = getdate()-7 end  select @startdate,@enddate;
select id from table where date >= current_date - 7;
select id from table1 where yearweek(date) = yearweek(now() - interval 1 week);
select * from table where date between (now() - interval 7 day) and now();
where yourdatecolumn > dateadd(day, -7, getdate()) ;
where cast( yourdatecolumn as date ) > dateadd( day, -7, cast( getdate() as date );
select * from   inventory where  yearweek(`modify`, 1) = yearweek(curdate(), 1);
select id from tbl where week (date) = week( current_date ) - 1 and year( date) = year( current_date );
select id from tbl where week (date) = week( current_date ) - 2 and year( date) = year( current_date );
select id from tbname where date between date_sub(now(),interval 1 week) and now();
select id from table where date >= "$sunday-date" + interval 7 day;
select id from tbl where date >= curdate() - interval dayofweek(curdate())+6 day and date < curdate() - interval dayofweek(curdate())-1 day;
select id from `mytable` where mydate between "2011-05-15" and "2011-05-21";
select id from tbl where date >= curdate() - interval dayofweek(curdate())+5 day and date < curdate() - interval dayofweek(curdate())-2 day;
where week(yourdate) = week(now()) - 1;
where week(yourdate, 3) = week(now(), 3) - 1;
select name, created_at from employees where yearweek(`created_at`, 1) = yearweek( curdate() - interval 1 week, 1);
select username, inserttime from tblaccounts where week(inserttime) = week(now()) - 1;
select username, inserttime from tblaccounts where month(inserttime) = month(now()) - 1;
select username, inserttime from tblaccounts where year(inserttime) = year(now()) - 1;
select date from table_name where date(date) >= curdate() - interval 7 day;
select array_to_string(array(select column_name from table_name where id=5), ', ');
select array_agg(id, ',') from table;
select array( select id from table );
select array_to_string( array( select id from table ), ',' );
select string_agg(id::text, ',') from table;
select * from information_schema.tables where lower(table_name) like lower('%%');
select name from dbname.sys.tables where name like '%xxx%' and is_ms_shipped = 0; -- << comment out if you really want to see them;
select  * from    dbname.sys.tables where   name like '%xxx%';
@tablename nvarchar(200) = 'somestring';
if not exists (select 1 from master.sys.databases where name = @dbname) from    ' + quotename(@dbname) + '.sys.tables where   name like ''%'' + @table + ''%''';
select * from information_schema.tables where table_name like '%%';
select 'select ''' + name + ''' as tablename, * from ' + name as selecttable, 'delete from ' + name as deletetable from sys.tables where name like '%xxxx%' and is_ms_shipped = 0;
create extension unaccent;
select * from   users where  unaccent(name) = unaccent('joo');
create or replace function public.immutable_unaccent(regdictionary, text) create or replace function public.f_unaccent(text) select public.immutable_unaccent(regdictionary 'public.unaccent', $1);
set search_path = public, pg_temp;
create or replace function public.f_unaccent(text) select public.unaccent('public.unaccent', $1)  -- schema-qualify function and dictionary;
create index users_unaccent_name_idx on users(public.f_unaccent(name));
select * from users where  f_unaccent(name) = f_unaccent('joo');
select unaccent('    ');
select unaccent('    ');
create index users_unaccent_name_trgm_idx on users;
select * from users where  f_unaccent(name) like ('%' || f_unaccent('joo') || '%');
create extension unaccent;
create text search configuration mydict ( copy = simple );
alter text search configuration mydict alter mapping for hword, hword_part, word;
create table mytable ( mycol ) as values ('f bar baz'),('qux quz');
create index on mytable;
select * from mytable where to_tsvector('mydict', mycol) @@ 'foo & bar';
select `column`, `column2` from `table`;
select [column], [column 2] from [table];
select [date], [time], [any_other_to_be_escaped_column] from [table];
select [column], [column2] from [table];
select `column`, `column2` from `table`;
select "column", "column2" from "table";
select dbms_metadata.get_granted_ddl( 'system_grant', :username ) from dual;
select dbms_metadata.get_granted_ddl( 'object_grant', :username ) from dual;
select dbms_metadata.get_granted_ddl( 'role_grant', :username ) from dual;
select * from all_tab_privs_recd where grantee = 'your user';
select privilege from sys.dba_sys_privs where grantee = <theuser> union select privilege from dba_role_privs rp join role_sys_privs rsp on (rp.granted_role = rsp.role) where rp.grantee = <theuser>;
select owner, table_name, select_priv, insert_priv, delete_priv, update_priv, references_priv, alter_priv, index_priv from table_privileges where grantee = <theuser>;
select distinct owner, table_name, privilege from dba_role_privs rp join role_tab_privs rtp on (rp.granted_role = rtp.role) where rp.grantee = <theuser>;
select distinct 'grant '||privilege||' on '||owner||'.'||table_name||' to '||rp.grantee from dba_role_privs rp join role_tab_privs rtp where (owner in ('your user') --change user name or rp.grantee in ('your user')) --change user name and rp.grantee not in ('sys', 'system');
select tpm.name privilege, decode(mod(oa.option$,2), 1, 'yes', 'no') grantable, ue.name grantee, ur.name grantor, u.name owner, decode(o.type#, 0, 'next object', 1, 'index', 2, 'table', 3, 'cluster', 4, 'view', 5, 'synonym', 6, 'sequence', 7, 'procedure', 8, 'function', 9, 'package', 11, 'package body', 12, 'trigger', 13, 'type', 14, 'type body', 19, 'table partition', 20, 'index partition', 21, 'lob', 22, 'library', 23, 'directory', 24, 'queue', 28, 'java source', 29, 'java class', 30, 'java resource', 32, 'indextype', 33, 'operator', 34, 'table subpartition', 35, 'index subpartition', 40, 'lob partition', 41, 'lob subpartition', 42, 'materialized view', 43, 'dimension', 44, 'context', 46, 'rule set', 47, 'resource plan', 66, 'job', 67, 'program', 74, 'schedule', 48, 'consumer group', 51, 'subscription', 52, 'location', 55, 'xml schema', 56, 'java data', 57, 'edition', 59, 'rule', 62, 'evaluation context', 'undefined') object_type, o.name object_name, '' column_name from sys.objauth$ oa, sys.obj$ o, sys.user$ u, sys.user$ ur, sys.user$ ue, table_privilege_map tpm where oa.obj# = o.obj# and oa.grantor# = ur.user# and oa.grantee# = ue.user# and oa.col# is null and oa.privilege# = tpm.privilege and u.user# = o.owner# and o.type# in (2, 4, 6, 9, 7, 8, 42, 23, 22, 13, 33, 32, 66, 67, 74, 57) and ue.name = 'your user' and bitand (o.flags, 128) = 0 union all -- column level grants select tpm.name privilege, decode(mod(oa.option$,2), 1, 'yes', 'no') grantable, ue.name grantee, ur.name grantor, u.name owner, decode(o.type#, 2, 'table', 4, 'view', 42, 'materialized view') object_type, o.name object_name, c.name column_name from sys.objauth$ oa, sys.obj$ o, sys.user$ u, sys.user$ ur, sys.user$ ue, sys.col$ c, table_privilege_map tpm where oa.obj# = o.obj# and oa.grantor# = ur.user# and oa.grantee# = ue.user# and oa.obj# = c.obj# and oa.col# = c.col# and bitand(c.property, 32) = 0 /* not hidden column */ and oa.col# is not null and oa.privilege# = tpm.privilege and u.user# = o.owner# and o.type# in (2, 4, 42) and ue.name = 'your user' and bitand (o.flags, 128) = 0;
select * from dba_tab_privs where grantee = 'your user';
select coalesce(array_length(id, 1), 0) as size from example;
select array_length(id, 1) from example;
select cardinality(id) from example;
select * from db.table having count(somefield) > 1;
select t1.* from db.table t1 where exists from db.table t2 where t1.pk != t2.pk and t1.somefield = t2.somefield);
select t1.* from db.table t1 join db.table t2 on t1.somefield = t2.somefield and t1.pk != t2.pk;
select username, numb from( select username, count(username) as numb from customers group by username ) as my_table where numb > 3;
select t1.* from db.table t1 join db.table t2 on t1.somefield = t2.somefield and t1.pk != t2.pk;
select * from db.table having count(somefield) > 1;
select cn.name,ct.name,count(ct.id) totalcity from city ct left join country cn on ct.countryid = cn.id having totalcity > 2;
select field1, count(field1) from table1 having count(field1) > 1;
select (random() * 9)::integer + 1;
select cast(rand()*(b-a)+a as int);
create table [dbo].[searchindex]( [id] [int] identity(1,1) not null, [cursor] [nvarchar](255) null);
create table [dbo].[id]( [idn] [int] identity(1,1) not null, [id] [int] null);
create procedure [dbo].[randnumbers] as exec sp_executesql @randnosscript;
exec randnumbers;
select random() * 9 + 1;
select random() * 9 + 1 as i from generate_series(1,1000000);
select trunc(random() * 9 + 1);
select trunc(random() * 9 + 1) as i from generate_series(1,1000000);
select floor(random() * 10);
select floor(random() * (10 + 1));
select ceil(random() * 10);
select min(i), max(i) from (select floor(random() * 10) as i from generate_series(0, 100000)) q;
select min(i), max(i) from (select floor(random() * (10 + 1)) as i from generate_series(0, 100000)) q;
select min(i), max(i) from (select ceil(random() * 10) as i from generate_series(0, 100000)) q;
select (random() * 10) + 1;
union (select id from design where accountid = 1 and rendered = 'true');
select tbl_names.id, tbl_names.name, tbl_names.section from tbl_names, tbl_section where tbl_names.id = tbl_section.id;
select a.id, b.id, name, section from tbl_names as a;
select customers.id, name, amount, date from customers.orders;
select tbl_names.id, name, section from tbl_names;
select tbl_section.id, name, section from tbl_names;
select tbl_names.id as id, name, section from tbl_names, tbl_section where tbl_names.id = tbl_section.id;
select tbl_names.id, tbl_section.id, name, section from tbl_names join tbl_section on tbl_section.id = tbl_names.id;
select n.id, s.id, n.name, s.section from tbl_names n join tbl_section s on s.id = n.id;
select id, name, section from tbl_names join tbl_section using (id);
select id, name, section from tbl_names;
alter trigger [dbo].[tr_schedule_modified] as begin set nocount on;
if (update(qtytorepair)) update schedule set modified = getdate() from schedule s where s.qtytorepair <> i.qtytorepair end end;
alter trigger [dbo].[tr_schedule_modified] as begin set nocount on;
if update (qtytorepair) update schedule set modified = getdate() from schedule s inner join inserted i where s.qtytorepair <> i.qtytorepair end end;
alter trigger [dbo].[tr_schedule_modified] as begin set nocount on;
if update (qtytorepair) update schedule set modified = getdate() from schedule s inner join inserted i where s.qtytorepair <> i.qtytorepair end end;
alter trigger [dbo].[tr_schedule_modified] as begin set nocount on;
update schedule set modified = getdate() from schedule s where s.qtytorepair <> i.qtytorepair and d.qtytorepair <> i.qtytorepair end;
if update (qtytorepair) select s.orderno, s.partnumber, getdate(), suser_name(), host_name(), d.qtytorepair, i.qtytorepair from schedule s where i.qtytorepair <> d.qtytorepair end;
alter trigger [dbo].[updatephydate] as begin set nocount on;
select @dt1ky = dt1ky from deleted update m_contractdt1 set phydate=getdate() where dt1ky=  @dt1ky end  end;
from ( select cname,address, rn=row_number() over (partition by cname order by cname) from customeraddresses where rn = 1) order by cname;
select * from ( select * from mytable where row = 1;
select cname, min(addressline) from mytable cname;
select m.cname, m.addressline, from ( select cname, min(inserted) as first from mytable cname join mytable m on foo.cname = m.cname and foo.first = m.inserted;
select cname, addressline, rank() over (partition by cname order by addressline) as [r] from mytable ) select cname, addressline from cte where [r] = 1;
select * from mytable where row_number() over(partition by name order by addressline) = 1;
if upper(@@version) not like '%azure%';
select serverproperty('collation');
create table test ( ci_str varchar(15) collate latin1_general_ci_as -- case-insensitive;
select serverproperty('collation');
select databasepropertyex('databasename', 'collation') sqlcollation;
create database exampledatabase;
create table exampletable ( examplecolumn varchar(10) collate sql_latin1_general_cp1_ci_as null );
alter table exampletable alter column examplecolumn varchar(10) collate sql_latin1_general_cp1_ci_as null;
select column1 collate sql_latin1_general_cp1_ci_as as column1 from table1;
create table dbo.foo(bar varchar(32) collate latin1_general_cs_as);
select bar from dbo.foo where bar like 'j%';
select bar from dbo.foo where bar collate latin1_general_ci_as like 'j%';
drop table dbo.foo;
create table dbo.foo(bar varchar(32) collate latin1_general_ci_as);
select bar from dbo.foo where bar like 'j%';
select bar from dbo.foo where bar collate latin1_general_cs_as like 'j%';
drop table dbo.foo;
select * from information_schema.tables where 'abc' collate sql_latin1_general_cp1_ci_as like 'abc' collate sql_latin1_general_cp1_cs_as;
select * from information_schema.tables where 'abc' like 'abc' collate sql_latin1_general_cp1_cs_as;
select aname         as authorname, avg(quantity) as authorrating from book;
create temporary table abc ( column1 varchar(255) select ... or otherwise values ('text', 5.5), ('text2', 0815.8);
select * from abc inner join users on ...;
select * from ( select * from table;
select * from emps where id < 20 union all select * from emps where sex = 'f';
select aname, avg(quantity) from authorrating;
select col1 from ( select 'value1' as col1 union select 'value2' as col1 union select 'value3' as col1 where mytable.mycol is null;
select * from (select lstname, salary, row_number() over( order by salary desc) as rn from employee) tmp where rn = 2;
select * from employee e1 where 1 = (select count(distinct salary) from employee e2 where e2.salary > e1.salary );
select salary from where id = nth);
set @n = $n select a.* from ( select a.* , @rn = @rn+1  from employee order by a.empsalary desc ) as a  where rn = @n;
select min(column_name) from   ( select distinct top 3     column_name from   table_name column_name        desc;
select empsalary from salary_table;
select top 1 salary from ( select top 3 salary from employees;
select empname,salary from ( select empname,salary ,row_number() over(order by salary desc) as rowid from emptbl) as a where rowid=3;
from salary select top 1 salary from cte from salary s left join employee e select name,salary from cte where sal_rank=3;
select min(empsalary) from ( select empsalary from employee order by empsalary desc limit 3;
select top 1 salary as '3rd highest salary' from (select distinct top 3 salary from employee order by salary desc) a order by salary asc;
select *  from tablename t1 where (n-1) = (select count(distinct(t2.salary)) from tablename t2 where t2.salary > t1.salary);
( select salary from table ) select * from cte where rnk = @yourvariable;
select top 1 * from ( select distinct top(@yourvariable)  salary from employees select * from employees;
create table employee([eid] [float] null,[ename] [nvarchar](255) null,[basic_sal] [float] null);
select * from employee order by basic_sal desc;
select ename,basic_sal select ename,basic_sal,row_number() over (order by basic_sal desc) as rowid from employee where rowid=2;
select  a.grn_name from grn_hdr a,grn_hdr b where a.grn_name<=b.grn_name having count(a.grn_name)=3;
select top 3 @maxnthsal=grn_name from grn_hdr   order by grn_name desc;
select top(1) export_no from dc_hdr;
select min(empsalary) from salary where empsalary in(select top n empsalary from salary order by empsalary desc);
select min(empsalary) from salary where empsalary in(select top 3 empsalary from salary order by empsalary desc);
select max(empsalary) from salary where empsalary in(select top n empsalary from salary order by empsalary asc);
select max(empsalary) from salary where empsalary in(select top 3 empsalary from salary order by empsalary asc);
select * from sales.salesperson;
set @grade = 10;
select min(bonus) from (select top (@grade) bonus from (select distinct(bonus) from sales.salesperson) as a order by bonus desc) as g;
select distinct salary from emp e where from emp where e.salary <= salary);
select * /*this is the outer query part */ from employee emp1 where (n-1) = ( /* subquery starts here */ select count(distinct(emp2.salary)) from employee emp2 where emp2.salary > emp1.salary);
select min(salary) from (select salary from(select salary from employee order by salary desc)where rownum<=n);
select *  from emp x where &no=(select count(*) from emp y where y.sal>=x.sal);
select salary,empname from ( select salary,empname,dense_rank() over(order by salary desc) rno from employee where rno=3;
select salary from salary;
select distinct salary from emp e where from emp where e.salary <= salary);
select max(sal) from emp where sal > ( select max(sal) from emp where sal > (select max(sal) from emp);
select a.jid,a.entrydate,refunddate,comments,refund, actionby from ( (select jid, max(entrydate) as entrydate from refundrequested group by jid) a;
select salary from employee;
select distinct * from emp order by sal desc limit (n-1),1;
set @nhighestsalary = 3 select top 1 salary from ( select top @nhighestsalary salary from employees;
select top (1)* from ( select top (1)* from student_info order by classid desc;
( select empid, empname, empsalary, rn = row_number() over (order by empsalary desc) from dbo.salary ) select empid, empname, empsalary from cte where rn = @nthrow;
select top 1 salary from ( select top 3 salary from employees;
select * from employee emp1 where (n-1) = ( select count(distinct(emp2.salary)) from employee emp2 where emp2.salary > emp1.salary);
( select empid ,rn = row_number() over (order by empsalary desc) from salary ) select empid from rankedsalaries where rn = @n;
select salary,empname from ( select salary,empname,row_number() over(order by salary) as rownum from employee where a.rownum in (2,3);
select * from employee emp1 where (n-1) = ( select count(distinct(emp2.salary)) from employee emp2 where emp2.salary > emp1.salary );
select top 1 salary from ( select distinct top n salary from employee;
select top 1 salary from ( select top 3 salary from employees;
select top 1 salary from ( select top n salary from employees order by salary desc group by salary ) as emp order by salary asc;
select min(salary) from (select salary from employee where rownum < n+1;
select distinct salary from employee order by salary desc limit nth, 1;
select min(salary) from ( select salary from employees order by salary desc) t where rownum<=3;
select max(salary) from employee where salary not in (select * from employee orderby salary desc limit n-1);
select * from emp where sal=;
select distinct sal from emp order by sal desc limit 3,1;
select empname,empsalary from salary;
select min(customerid) from (select distinct customerid from customers order by customerid desc limit 4) as a;
select min(country) from (select distinct country from customers order by country desc limit 3);
select  *from business order by id desc limit 3,1;
select  *from business order by id asc limit 3,1;
select * from tablename order by columnname desc limit 2, 1;
select * from one one1 where ( n ) = ( select count( one2.salary ) from one one2 where one2.salary >= one1.salary );
select linkorder from u_links select max(linkorder) from u_links select max(linkorder) from u_links where linkorder < (select max(linkorder) from u_links) select top 1 linkorder from ( select distinct top 2 linkorder from u_links order by linkorder desc) tmp;
select linkorder ,dense_rank() over ( order by linkorder desc ) as  danserank from u_links ) select top 1 linkorder from result where danserank = 5;
1 as id from employee union all select first_value(emp.esal) over(order by emp.esal desc) as esal, id from employee emp, (select esal, id+1 as id from cte_nth_sal) cte_nth_sal where emp.esal<cte_nth_sal.esal and cte_nth_sal.id<=5 ) select distinct esal from cte_nth_sal where id=5;
select top 1 salary from   employee where  salary in (select distinct top 3 salary from   employee;
select empsalary from dbo.salary empsalary desc;
select * from employee order by salary desc;
select distinct salary from employee e1 where (n) = (select count( distinct(salary) ) from employee e2 where e1.salary<=e2.salary);
and (email != "" or email is not null);
select `userid` from `users` where `userid` from `users_indvsettings` where `indvsettingid`=5 and `optionid`='.$time.') and `email` != "" and `email` is not null;
select table_name from information_schema.columns where column_name = 'your_column_name';
select c.relname from pg_class as c where a.attname = <column name> and c.relkind = 'r';
select t.table_schema, t.table_name from information_schema.tables t and c.table_schema = t.table_schema where c.column_name like '%string%' and t.table_schema not in ('information_schema', 'pg_catalog') and t.table_type = 'base table';
select t.table_schema, t.table_name from information_schema.tables t and c.table_schema = t.table_schema where c.column_name = 'name_colum' and t.table_schema not in ('information_schema', 'pg_catalog') and t.table_type = 'base table';
select n.nspname as schema ,c.relname from pg_class as c where a.attname = 'id_number' and c.relkind = 'r';
select substring_index(user(), '@', -1) select substring_index(user(), '@', 1);
select @@hostname;
select host from information_schema.processlist;
set datefirst 4     /* or use any other weird value to test it */ set @d = getdate() select @d thatdate, dateadd(dd, 0 - (@@datefirst + 5 + datepart(dw, @d)) % 7, @d) monday, dateadd(dd, 6 - (@@datefirst + 5 + datepart(dw, @d)) % 7, @d) sunday;
select dob from profile_info where day(dob) between and day((current_date()+(7 - (select dayofweek(current_date())) ) )) and month(dob)=month(current_date());
select sum(numberofbrides) as [wedding count], datepart( wk, weddingdate) as [week number], datepart( year, weddingdate) as [year], dateadd(day, 1 - datepart(weekday, dateadd(wk, datepart( wk, weddingdate)-1,  dateadd(yy,datepart( year, weddingdate)-1900,0))), dateadd(wk, datepart( wk, weddingdate)-1, dateadd(yy,datepart( year, weddingdate)-1900,0))) as [week start] from  memberweddingdates;
select dateadd(day, datediff(day, 0, weddingdate) /7*7, 0) as weekstart, dateadd(day, datediff(day, 6, weddingdate-1) /7*7 + 7, 6) as weekend;
set @mondaydatefirstvalue = 7 - @mondaydatefirstvalue - 1 set @fridaydatefirstvalue = 7 - @fridaydatefirstvalue - 1 set datefirst 6 -- notice this is saturday select dateadd(day, 0 - (@@datefirst + @mondaydatefirstvalue + datepart(dw,@testdate)) % 7, @testdate)  as mondaystartofweek set datefirst 2 --notice this is tuesday select dateadd(day, 0 - (@@datefirst + @mondaydatefirstvalue + datepart(dw,@testdate)) % 7, @testdate)  as mondaystartofweek;
select sum(numberofbrides) as [wedding count], datepart( wk, weddingdate) as [week number], datepart( year, weddingdate) as [year], max(case when datepart(week, weddingdate) = 1 then cast(dateadd(year, datediff(year, 0, weddingdate), 0) as date) else dateadd(day, 7 * datepart(week, weddingdate), dateadd(day, -(datepart(weekday, dateadd(year, datediff(year, 0, weddingdate), 0)) + 6), dateadd(year, datediff(year, 0, weddingdate), 0))) end) as weekstart, max(case when datepart(week, weddingdate) = datepart(week, dateadd(day, -1, dateadd(year, datediff(year, 0, weddingdate) + 1, 0))) then dateadd(day, -1, dateadd(year, datediff(year, 0, weddingdate) + 1, 0)) else dateadd(day, 7 * datepart(week, weddingdate) + 6, dateadd(day, -(datepart(weekday, dateadd(year, datediff(year, 0, weddingdate), 0)) + 6), dateadd(year, datediff(year, 0, weddingdate), 0))) end) as weekend from  memberweddingdates;
select    @mydate, datename(weekday,@mydate), dateadd(dd,-(choose(datepart(dw, @mydate), 1,2,3,4,5,6,0)),@mydate) as weekstartdate, dateadd(dd,7-choose(datepart(dw, @mydate), 2,3,4,5,6,7,1),@mydate) as weekenddate;
select cast('20001225' as datetime) union all select cast('20001226' as datetime) union all select cast('20001227' as datetime) union all select cast('20001228' as datetime) union all select cast('20001229' as datetime) union all select cast('20001230' as datetime) union all select cast('20001231' as datetime) union all select cast('20010101' as datetime) union all select cast('20010102' as datetime) union all select cast('20010103' as datetime) union all select cast('20010104' as datetime) union all select cast('20010105' as datetime) union all select cast('20010106' as datetime) union all select cast('20010107' as datetime) union all select cast('20010108' as datetime) union all select cast('20010109' as datetime) union all select cast('20010110' as datetime) union all select cast('20010111' as datetime) union all select cast('20010112' as datetime) union all select cast('20010113' as datetime) union all select cast('20010114' as datetime) select somedate, (@@datefirst + datepart(dw, somedate) - 1 - 1) % 7 + 1 as dow from testdata ) select format(somedate,                            'ddd yyyy-mm-dd') as somedate, format(dateadd(dd, -dow + 1, somedate),     'ddd yyyy-mm-dd') as [monday], format(dateadd(dd, -dow + 1 + 6, somedate), 'ddd yyyy-mm-dd') as [sunday] from testdataplusdow;
select dateadd(wk, -1, dateadd(day, 1-datepart(weekday, getdate()), datediff(dd, 0, getdate()))) --first day previous week select dateadd(wk, 0, dateadd(day, 1-datepart(weekday, getdate()), datediff(dd, 0, getdate()))) --first day current week select dateadd(wk, 1, dateadd(day, 1-datepart(weekday, getdate()), datediff(dd, 0, getdate()))) --first day next week select dateadd(wk, 0, dateadd(day, 0-datepart(weekday, getdate()), datediff(dd, 0, getdate()))) --last day previous week select dateadd(wk, 1, dateadd(day, 0-datepart(weekday, getdate()), datediff(dd, 0, getdate()))) --last day current week select dateadd(wk, 2, dateadd(day, 0-datepart(weekday, getdate()), datediff(dd, 0, getdate()))) --last day next week;
select dateadd(day,case when datepart(weekday, @date)=1 then -6 else 2 - datepart(weekday, @date) end, cast(@date as date)) [week_start_date];
select dateadd(week, @week_number, @start_weekday), dateadd(week, @week_number, @end_weekday);
select datediff(week, 0, @wedding_date) as week_number;
select dateadd(d, -(datepart(weekday, @currentdate) - 1), @currentdate) select dateadd(d, (7 - datepart(weekday, @currentdate)), @currentdate);
if ( hasmoreresultsets ) { else { // if ddl/dml/... if ( queryresult == -1 ) { // no more queries processed;
select s.stud_id, s.name from   student s, student_club x, student_club y where  x.club_id = 30 and    s.stud_id = x.stud_id and    y.club_id = 50 and    s.stud_id = y.stud_id;
select * from student where id in (select student_id from student_club where club_id = 30) and id in (select student_id from student_club where club_id = 50);
select * from   student where  id in (select student_id from   student_club where  club_id = 30 select student_id from   student_club where  club_id = 50);
select s.id, s.name from   student s join student_club sc where  sc.club_id in ( 30, 50 ) s.name having count(distinct sc.club_id) = 2;
select s.* from student s where sc_baseball.club_id = 50 and;
select s.id, s.name from student s join ( select student_id from student_club where club_id in (30, 50) having count(*) > 1;
select s.id, s.name from student s where exists (select 1 from student_club where  student_id = s.student_id and club_id = 30) and exists (select 1 from student_club where  student_id = s.student_id and club_id = 50);
alter table student add constraint student_pkey primary key(stud_id );
alter table student_club add constraint sc_pkey primary key(stud_id, club_id);
alter table club       add constraint club_pkey primary key(club_id );
create index sc_club_id_idx on student_club (club_id);
select s.stud_id, s.name from   student s join   student_club sc using (stud_id) where  sc.club_id in (30, 50) having count(*) > 1;
select s.stud_id, s.name from   student s join   ( select stud_id from   student_club where  club_id in (30, 50) having count(*) > 1;
select s.stud_id, s.name from   student s where  student_id in ( select student_id from   student_club where  club_id = 30 select stud_id from   student_club where  club_id = 50);
select s.stud_id,  s.name from   student s where  s.stud_id in (select stud_id from student_club where club_id = 30) and    s.stud_id in (select stud_id from student_club where club_id = 50);
select s.stud_id,  s.name from   student s where  exists (select * from student_club where  stud_id = s.stud_id and club_id = 30) and    exists (select * from student_club where  stud_id = s.stud_id and club_id = 50);
select s.stud_id, s.name from   student s join   student_club x on s.stud_id = x.stud_id join   student_club y on s.stud_id = y.stud_id where  x.club_id = 30 and    y.club_id = 50;
select s.stud_id,  s.name from   student as s where  not exists ( select * from   club as c where  c.club_id in (30, 50) and    not exists ( select * from   student_club as sc where  sc.stud_id = s.stud_id and    sc.club_id = c.club_id );
select s.stud_id,  s.name from   student as s where  not exists ( select * from  ( select 30 as club_id union  all select 50 where not exists ( select * from   student_club as sc where  sc.stud_id = s.stud_id and    sc.club_id = c.club_id );
select 1::int as level from   student_club sc1 where  sc1.club_id = 30 union select two.level + 1 as level from   student_club sc2 join   two using (stud_id) where  sc2.club_id = 50 and    two.level = 1 ) select s.stud_id, s.student from   student s join   two using (studid) where  two.level > 1;
select stud_id from   student_club where  club_id in (30,50) having count(*) > 1 ) select s.* from   student s join   sc using (stud_id);
select s.stud_id, s.student from   student s join   student_club sc using (stud_id) where  sc.club_id = 10                 -- member in 1st club ... and    not exists ( select * from  (select 14 as club_id) as c  -- can't be excluded for missing the 2nd where  not exists ( select * from   student_club as d where  d.stud_id = sc.stud_id and    d.club_id = c.club_id ) );
select s.* from   student s join   student_club x using (stud_id) where  sc.club_id = 10                 -- member in 1st club ... and    exists (                        -- ... and membership in 2nd exists select * from   student_club as y where  y.stud_id = s.stud_id and    y.club_id = 14 );
select s.* from   student as s where  exists ( select * from   student_club as x join   student_club as y using (stud_id) where  x.stud_id = s.stud_id and    x.club_id = 14 and    y.club_id = 10 );
select student_id from student_club where club_id in ( 30, 50 ) having count( student_id ) = 2;
select student_id, name from student s where exists( select * from student_club sc where s.student_id = sc.student_id and club_id in ( 30, 50 ) having count( sc.student_id ) = 2 );
select student_id, name from student s where exists( select * from student_club sc where s.student_id = sc.student_id and exists( select * from club_selection cs where sc.club_id = cs.club_id ) having count( sc.student_id ) = ( select count( * ) from club_selection ) );
select s.* from student as s where not exists from club as c where c.id in (30, 50) and not exists from student_club as sc where sc.student_id = s.id and sc.club_id = c.id ) );
select s.* from student as s where not exists from ( select 30 as club_id union all select 50 where not exists from student_club as sc where sc.student_id = s.id and sc.club_id = c.club_id ) );
select s.* from student_club as sc join student as s where sc.club_id = 50                      --- one option here and not exists from ( select 30 as club_id           --- all the rest in here where not exists from student_club as scc where scc.student_id = sc.id and scc.club_id = c.club_id ) );
select s.stud_id from   student s select stud_id from ( select s.stud_id, c.club_id from student s select stud_id, club_id from student_club where club_id in (30, 50)   -- optional. not needed but may affect performance;
from tmp.student_club sc0 where sc0.club_id = 30 union select 1+two.level as level from tmp.student_club sc1 join two on (two.student_id = sc1.student_id) where sc1.club_id = 50 and two.level=1 ) select st.* from tmp.student st join two on (two.student_id=st.id) where two.level> 1;
select student_id from tmp.student_club where club_id in (30,50) having count(*) > 1 ) select st.* from tmp.student st join two on (two.student_id=st.id);
drop schema tmp cascade;
create schema tmp;
create table tmp.student create table tmp.club create table tmp.student_club select generate_series(1,1000) select generate_series(1,100) select st.id  , cl.id from tmp.student st, tmp.club cl delete from tmp.student_club where random() < 0.8 update tmp.student set sname = 'student#' || id::text ;
update tmp.club set cname = 'soccer' where id = 30;
update tmp.club set cname = 'baseball' where id = 50;
alter table tmp.student_club add primary key (student_id,club_id);
select a.* from   ef.adr a join ( select adr_id from   ef.adratt where  att_id in (10,14) having count(*) > 1) t using (adr_id);
index cond: (att_id = any ('{10,14}'::integer[]));
select adr_id from   ef.adratt where  att_id in (10,14) having count(*) > 1 ) select a.* from   ef.adr a join   two using (adr_id);
index cond: (att_id = any ('{10,14}'::integer[]));
select c0.student_id from tmp.student_club c0 where c0.student_id = c1.student_id and c0.club_id = 30 and c1.club_id = 50 ) select st.* from tmp.student st join two on (two.student_id=st.id);
index cond: (club_id = 50) index cond: (club_id = 30);
select s.stud_id, s.name from   student s, ( select x.stud_id from join   student_club y on x.stud_id = y.stud_id where  x.club_id = 30 and    y.club_id = 50 where tmp_tbl.stud_id = s.stud_id;
create table dupnulls ( pk int identity(1,1) primary key, x  int null, nullbuster as (case when x is null then pk else 0 end), constraint dupnulls_uqx unique (x,nullbuster) );
create table the_entity_incorrect ( id integer, uniqnull integer null, /* we want this to be "unique and nullable" */;
create table the_entity ( id integer, primary key(id) create table the_relation ( the_entity_id integer not null, uniqnull integer not null,  unique(uniqnull), /* primary key can be both or either of the_entity_id or uniqnull */ foreign key (the_entity_id) references the_entity(id);
select id, uniqnull from the_entity left outer join the_relation;
update table1 set field1 = (select sum(t2.field2) from table2 t2 where t2.field3 = field2);
update t1 set t1.field1 = t2.field2sum from table1 t1 from table2;
update table1 set field1 = (select sum(field2) from table2 as t2 where t2.field3 = t1.field3) from table1 as t1;
update t1 set t1.field1 = t2.field2sum from table1 t1;
update table1 t1 set t1.field1 = t2.field2sum from (...) as t2 where t2.field3 = t1.field3;
select field3, sum(field2) as field2 from table2 ) update table1 set table1.field1 = t2.field2 from table1;
update t1 set t1.field1 = t2.field2sum from table1 t1 from table2 t2 where t2.field3 = t1.field3) as t2;
select case <variable> else <returndefaultcase> end from <table>;
if ((select count(*) from table1 where project = 1) > 0) select product, price from table1 where project = 1 else if ((select count(*) from table1 where project = 2) > 0) select product, price from table1 where project = 2 else if ((select count(*) from table1 where project = 3) > 0) select product, price from table1 where project = 3;
select product, price from table1 where project = 1 if @@rowcount = 0 select product, price from table1 where customer = 2 if @@rowcount = 0 select product, price from table1 where company = 3 end;
select product from table1 t1;
select top 1 price from table1 where (project=1 or customer=2 or company=3) and;
select product,price,1 a from table1 where project=1   union all select product,price,2 a from table1 where customer=2  union all select product,price,3 a from table1 where company=3 ) select top 1 with ties product,price from cte order by a;
select top 1 with ties product,price from table1 where project=1 or customer=2 or company=3;
drop table table1 create table table1 (project int, customer int, company int, product int, price money) select top 1 with ties product else 'no match' end as source from ( select product, price, 1 as wherefound from table1 where project = 11 union all select product, price, 2 from table1 where customer = 0 union all select product, price, 3 from table1 where company = 30;
(select count(closed) from ticket where assigned_to = c.user_id and closed is not null  (select count(closed) from ticket where assigned_to = c.user_id and closed is null;
set ansi_warnings off;
select count(closed) from   ticket where  assigned_to = c.user_id and closed is null;
select count(isnull(closed, 0)) from   ticket where  assigned_to = c.user_id and closed is null;
select city, count(emp_id) as emp_count from emp_db;
select city, count(emp_id) as emp_count from emp_db where emp_id is not null;
select convert(varchar(1000), varbinary_value, 1);
select convert(varchar(1000), varbinary_value, 2);
set @b2 = 0x54006800690073002000690073002000610020007400650073007400 select convert(nvarchar(1000), @b2, 0);
select convert(varchar(5000), yourvarbincolumn, 0);
set @b = 0x5468697320697320612074657374 select cast(@b as varchar(max)) /*returns "this is a test"*/;
select @@servername;
select @@servername;
select @@servername;
select left(ltrim(rtrim(@@servername)), charindex('\', ltrim(rtrim(@@servername))) -1);
select serverproperty('machinename');
create procedure sp_get_ip_address (@ip varchar(40) out) as begin set nocount on set @ip = null create table #temp (ipline varchar(200)) select @ipline = ipline from #temp where upper (ipline) like '%ip address%' if (isnull (@ipline,'***') != '***') set @pos = charindex (':',@ipline,1);
set @ip = rtrim(ltrim(substring (@ipline , @pos + 1 , len (@ipline) - @pos))) end drop table #temp set nocount off end go exec sp_get_ip_address @ip out;
select serverproperty('machinename');
select dec.local_net_address from sys.dm_exec_connections as dec where dec.session_id = @@spid;
select serverproperty(n'machinename');
select connectionproperty('net_transport') as net_transport, connectionproperty('protocol_type') as protocol_type, connectionproperty('auth_scheme') as auth_scheme, connectionproperty('local_net_address') as local_net_address, connectionproperty('local_tcp_port') as local_tcp_port, connectionproperty('client_net_address') as client_net_address;
select c.local_net_address from sys.dm_exec_connections as c where c.session_id = @@spid;
select top(1) c.local_net_address from sys.dm_exec_connections as c where c.local_net_address is not null;
set @connectionstring = n'server=tcp:' + @@servername + ';trusted_connection=yes;' set @parm_definition  = n'@ip_address_out varchar(15) output set @command          = n'select  @ip_address_out = a.local_net_address, @tcp_port_out   = a.local_tcp_port from openrowset(''sqlncli'' from sys.dm_exec_connections where session_id = @@spid exec sp_executesql @command select @ip_address, @tcp_port;
exec xp_cmdshell 'ipconfig';
select serverproperty('computernamephysicalnetbios')  as 'is_current_owner' else @@servername +' \ ' + @@servicename end as '@@servername \ servicename', connectionproperty('net_transport') as net_transport, connectionproperty('local_tcp_port') as local_tcp_port, dec.local_tcp_port, connectionproperty('local_net_address') as local_net_address, dec.local_net_address as 'dec.local_net_address' from sys.dm_exec_connections as dec where dec.session_id = @@spid;
select host_name();
set @l_sql = @l_sql + case when 1=1 then end ;
select datalength(@a5000 + @a5000), datalength(concat(@a5000,@a5000));
set @a+= replicate('a',5000) + replicate('a',5000) set @b = @b + replicate('a',5000) + replicate('a',5000) select datalength(@a), datalength(@b);`;
set @sql = 'foo' + 'bar' + ...;
set @sql = @sql + n'foo' + n'bar';
select @sql as [processing-instruction(x)] for xml path;
create procedure executemyhugequery as begin select @len = len(@sql) if (@len > 8000) 16, 1);
end  @chunk2 varchar(2000), @chunk3 varchar(2000), @chunk4 varchar(2000) select @chunk1 = '', @chunk2 = '', @chunk3 = '', @chunk4 = '' if (@len > 2000) select @chunk1 = substring(@sql, 1, 2000) if (@len > 4000) select @chunk2 = substring(@sql, 2001, 2000) if (@len > 6000) select @chunk3 = substring(@sql, 4001, 2000) select @chunk4 = substring(@sql, 6001, (@len - 6001)) end else begin select @chunk3 = substring(@sql, 4001, (@len - 4001)) end end else begin select @chunk2 = substring(@sql, 2001, (@len - 2001)) end end  exec (@chunk1 + @chunk2 + @chunk3 + @chunk4) end;
set @sql = n'somemassivestring > 4000 chars...';
set @p = 0x select   @p = @p + 0x3b + convert(varbinary(100), email) from tbcarslist where email <> '' set @p = substring(@p, 2, 100000) select datalength(col) as collen, col from @local;
create table accounts( account_id int not null auto_increment, customer_id int( 4 ) not null , account_type enum( 'savings', 'credit' ) not null, balance float( 9 ) not null, primary key ( account_id ), foreign key (customer_id) references customers(customer_id);
alter table `accounts` add constraint `fk_mykey` foreign key (`customer_id`) references `customers` (`customer_id`) on delete cascade on update cascade;
select a, b from table1 left join table2 using (common_field);
create table accounts( account_id int not null auto_increment, customer_id int( 4 ) not null , account_type enum( 'savings', 'credit' ) not null, balance float( 9 ) not null, primary key (account_id) create table customers( customer_id int not null auto_increment, name varchar(20) not null, address varchar(20) not null, city varchar(20) not null, state varchar(20) not null, primary key ( account_id ), foreign key (customer_id) references customers(customer_id);
create table accounts( account_id int not null auto_increment, customer_id int( 4 ) not null , account_type enum( 'savings', 'credit' ) not null, balance float( 9 ) not null, primary key ( account_id ) ) and  create table customers( customer_id int not null auto_increment, name varchar(20) not null, address varchar(20) not null, city varchar(20) not null, state varchar(20) not null, );
create table customers( customer_id int not null auto_increment, name varchar(20) not null, address varchar(20) not null, city varchar(20) not null, state varchar(20) not null, account_type enum( 'savings', 'credit' ) not null, balance float( 9 ) not null, );
create table customersaccounts( customer_id int not null, account_id int not null, primary key (customer_id, account_id) foreign key account_id  references accounts  (account_id) on delete cascade;
select a.* from customersaccounts ca and ca.customer_id=mycustomerid;
create view customeraccounts as select a.*, c.* from customersaccounts ca;
create table departement( dep_id      int primary key auto_increment, dep_name    varchar(100) not null, dep_descriptin      text, dep_photo       varchar(100) not null, dep_video       varchar(300) not null create table newsfeeds( news_id         int primary key auto_increment, news_title      varchar(200) not null, news_description    text, news_photo          varchar(300) , news_date           varchar(30) not null, news_video          varchar(300), news_comment        varchar(200), news_departement    int foreign key(dep_id) references departement(dep_id);
"jdbc:postgresql://127.0.0.1/"+dbname,user,pass);
select * from pg_stat_activity;
select count(*) from pg_stat_activity;
select min_val, max_val from pg_settings where name='max_connections';
select convert( varchar(24), getdate(), 113);
set @formatted_datetime = convert(char(23), getdate(), 121);
select format(getdate(), 'yyyy-mm-dd hh:mm:ss.fff');
select  cast(datediff(s, '1970-01-01 00:00:00.000', '2016-12-09 16:22:17.897' ) as bigint);
select  cast(datediff(s, '1970-01-01 00:00:00.000', '2016-12-09 16:22:17.897' ) as bigint)  * 1000;
create function fn_retornafecha (@i_fecha datetime) as begin @w_anio  varchar(4), @w_mes   varchar(2), @w_dia   varchar(2), @w_hh    varchar(2), @w_nn    varchar(2), @w_ss    varchar(2), @w_sss   varchar(3) select @w_fecha = null if ltrim(rtrim(@i_fecha)) is not null select @w_anio = replicate('0',4-char_length( convert(varchar(4), year(@i_fecha)) )) + convert(varchar(4), year(@i_fecha)), @w_mes  = replicate('0',2-char_length( convert(varchar(2),month(@i_fecha)) )) + convert(varchar(2),month(@i_fecha)), @w_dia  = replicate('0',2-char_length( convert(varchar(2),  day(@i_fecha)) )) + convert(varchar(2),  day(@i_fecha))  , @w_hh   = replicate('0',2-char_length( convert(varchar(2),datepart( hh, @i_fecha ) ) )) + convert(varchar(2),datepart( hh, @i_fecha ) ), @w_nn   = replicate('0',2-char_length( convert(varchar(2),datepart( mi, @i_fecha ) ) )) + convert(varchar(2),datepart( mi, @i_fecha ) ), @w_ss   = replicate('0',2-char_length( convert(varchar(2),datepart( ss, @i_fecha ) ) )) + convert(varchar(2),datepart( ss, @i_fecha ) ), @w_sss  = convert(varchar(3),datepart( ms, @i_fecha ) ) + replicate('0',3-datalength( convert(varchar(3),datepart( ms, @i_fecha ) )  )) select @w_fecha = @w_anio + '-' + @w_mes + '-' + @w_dia + ' ' + @w_hh + ':' + @w_nn + ':' + @w_ss + '.' + @w_sss end  end go;
select fn_retornafecha(getdate());
select user.email, user.name, document.name, documents_permissions.readallowed, documents_permissions.writeallowed from user, document, documents_permissions where user.email = "user@email.com";
user, document, documentspermissions user.email == document.author document.name == documentspermissions.document user.email == "user@email.com";
select 'all the columns' from user join document on document.author_id = user.id and document.author == user.email join document_permissions on document_permissions.document_id = document.id and document_permissions.document = document.name;
user document documentspermissions user.email == "user@email.com";
user.email, user.name, document.name, documentspermissions.readallowed, documentspermissions.writeallowed, );
user, document, documentpermissions, ).filter( user.email == document.author, ).filter( document.name == documentpermissions.document, ).filter( user.email == 'someemail', ).all();
alter table dbo.table add constraint ck_table_frequency check (frequency in ('daily', 'weekly', 'monthly', 'yearly'));
check constraint;
create table sometable ( id int not null, frequency varchar(200), constraint chk_frequency check (frequency in ('daily', 'weekly', 'monthly', 'yearly')) );
from flask import flask from flask_sqlalchemy import sqlalchemy;
from user where user.id = ?;
from user where user.id = ? limit ? offset ?;
select substring(columnname, patindex('%[^0]%',columnname), 10);
select case then '0' else substring(columnname, patindex('%[^0]%',columnname), 10) end;
select replace(ltrim(replace(columnname,'0',' ')),' ','0');
select substring(substring('b10000n0z', patindex('%[0]%','b10000n0z'), 20), patindex('%[^0]%',substring('b10000n0z', patindex('%[0]%','b10000n0z'), 20)), 20);
select replace(left(convert(nvarchar,getdate(),101),2),'0','')+right(convert(nvarchar,getdate(),101),8);
select ltrim('000045', '0') from dual;
select case when left(column,1) = '0' then right(column, (len(column)-1)) else column end;
select replace(ltrim(replace('000010a', '0', ' ')),' ', '0');
select case then '' else substring(mtrl_nbr, patindex('%[^0]%',mtrl_nbr), 18) end;
select replace(columnname,'0','') from table;
set @leadingzeros = case when patindex('%-0', @leadingzeros) = 1   then else cast(cast(@leadingzeros as int) as varchar(10)) end  select @leadingzeros;
select replace(replace(rtrim(replace(replace(replace(replace(ltrim(replace(replace([column],' ','[ltrim]'),[ltrim],' ')),' ',[ltrim]),'[ltrim]',' '),' ','[rtrim]'),[rtrim],' ')),' ',[rtrim]),'[rtrim]',' ') as result;
set ansi_nulls on set quoted_identifier on create function dbo.funremoveleadingzeros ( -- add the parameters for the function here ) as begin set @result = @input set @result = substring(@result, 2, len(@result) - 1) end  end go;
select isnull(stuff(columnname );
select t.id, coalesce(d.field, 'default') from test t detail d on t.id = d.item;
select iar.description, ifnull(iai.quantity,0) as quantity, ifnull(iai.quantity * rpl.regularprice,0) as 'retail', iar.compliance from inventoryadjustmentreason iar where iar.storeuse = 'yes';
select iar.description, isnull(iai.quantity,0) as quantity, isnull(iai.quantity * rpl.regularprice,0) as 'retail', iar.compliance from inventoryadjustmentreason iar where iar.storeuse = 'yes';
if not whatever set noexec on;
end  alter table dbo.employee add column emp_is_admin bit not null update dbo.employee set emp_is_admin = whatever set noexec off;
if col_length('employees','emp_is_admin') is null --column does not exist alter table dbo.employees add emp_is_admin bit end  update employees set emp_is_admin = 0 end end;
if 1=1 set @statementno = 1 exec sp_executesql add column emp_is_admin bit not null' set @statementno = 2 exec sp_executesql set emp_is_admin = 1' set @statementno = 3 exec sp_executesql set emp_is_admin = 1x' end end try end catch if @@trancount > 0;
if whatever alter table dbo.employee add column emp_is_admin bit not null;
exec ('update dbo.employee set emp_is_admin = whatever') end;
end go if whatever;
if not whatever begin end  alter table dbo.employee add column emp_is_admin bit not null update dbo.employee set emp_is_admin = whatever;
if exists( select... ) end ;
select a.column, b.column from table1 a table2 b;
select mt.id, mt.parentid, ot.masterid from dbo.maintable as mt union all select mt.id, mt.parentid, ot.masterid from dbo.othertable as ot;
select  * from    maintable m join    othertable o union select  * from    maintable m join    othertable o;
select  * from    tablea a tablexref x and a.id = 1 tableb b;
select  * from    tablea a tablexref x tableb b where   a.id = 1;
'key2' => 'val2', 'key3' => [ 'subkey2' => 'subval2', 'subkey3' => [ 'subsubkey2' => 'subsubval2', ], ], ];
if (is_array($v)) {;
if (!$trimmed_line || $trimmed_line === '(' || $trimmed_line === ')' || $trimmed_line === 'array') { if (substr_compare($trimmed_line, '=>', -2) === 0) {;
select grantee, privilege_type from information_schema.role_table_grants where table_name='mytable';
select grantee from information_schema.role_table_grants where grantee != 'postgres';
select format ( 'grant %s on table %i.%i to %i%s;', string_agg(tg.privilege_type, ', '), tg.table_schema, tg.table_name, tg.grantee, case when tg.is_grantable = 'yes' then ' with grant option' else '' end ) from information_schema.role_table_grants tg join pg_tables t on t.schemaname = tg.table_schema and t.tablename = tg.table_name where tg.table_schema = 'myschema' and;
select a.schemaname, a.tablename, b.usename, has_table_privilege(usename, quote_ident(schemaname) || '.' || quote_ident(tablename), 'select') as has_select, has_table_privilege(usename, quote_ident(schemaname) || '.' || quote_ident(tablename), 'insert') as has_insert, has_table_privilege(usename, quote_ident(schemaname) || '.' || quote_ident(tablename), 'update') as has_update, has_table_privilege(usename, quote_ident(schemaname) || '.' || quote_ident(tablename), 'delete') as has_delete, has_table_privilege(usename, quote_ident(schemaname) || '.' || quote_ident(tablename), 'references') as has_references from pg_tables a, pg_user b where a.schemaname = 'your_schema_name' and a.tablename='your_table_name';
select grantee, string_agg(privilege_type, ', ') as privileges from information_schema.role_table_grants where table_name='mytable';
select a.tablename, b.usename, has_table_privilege(usename,tablename, 'select') as select, has_table_privilege(usename,tablename, 'insert') as insert, has_table_privilege(usename,tablename, 'update') as update, has_table_privilege(usename,tablename, 'delete') as delete, has_table_privilege(usename,tablename, 'references') as references from pg_tables a, pg_user b where schemaname='your_schema_name' and b.usename='your_user_name';
select text, getdate(), * from sys.dm_exec_requests;
in above ^m is not (shift + 6)m instead it is (ctrl + v)(ctrl + m);
from django.db.models import count;
literal.objects.values('name') );
from django.contrib.postgres.aggregates import arrayagg from django.db.models import func, value;
select unnest(array_agg("app_literal"."id")) as "ids" from "app_literal" having array_length(array_agg("app_literal"."id"), 1) > 1;
if ($res = $mysqli->store_result()) {;
if (!mysqli_stmt_prepare($stmt, $sql)) if (!mysqli_stmt_execute($stmt)) if (!mysqli_stmt_fetch($stmt)) {;
if (isset($_get['get']) && !empty($_get['get']) ) if (check_method('get') && isset($_get['delete']) ) if (check_method('get') && isset($_get['get']) ) if (!$result) {;
if ($stmt->error) printf("error 1 : %s\n", $stmt->error);
if ($stmt->error) printf("error 2 : %s\n", $stmt->error);
if ($stmt->error) printf("error 3 : %s\n", $stmt->error);
if ($stmt->error) printf("error 4 : %s\n", $stmt->error);
if ($stmt->error) printf("error 5 : %s\n", $stmt->error);
select student.name as name, (select array(select mark from grade where grade.student_id = student.id)) as arrayofmarks from student;
select p.p_name, string_agg(grade.mark, ',' order by grade.mark) as marks from student;
select p.p_name, array_to_string(array_agg(grade.mark),';') as marks from student;
select s.name,  array_agg(g.mark) as marks from student s;
create table grade values (1, 'a'), (2, 'b'), (2, 'b+'), (3, 'c'), (3, 'a');
create table student values (1, 'john'), (2, 'david'), (3, 'will');
select directory, array_agg(file_name) from table where type = 'zip';
values ('127.0.0.1', 1);
update (+ insert if update fails);
update visits set hits = hits + 1 where ip like $ip;
select round(<maxnumber>*rand());
between <min> and <max> inclusive.;
create function myrandom( pmin integer, pmax integer );
select myrandom(100,300);
select name, address, floor(rand() * 401) + 100 as `random_number` from users;
where randnum not in (select * from temptable);
select name, address, round(100.0 + 400.0 * rand()) as random_number from users;
if (it.hasnext()) {;
if (res.length() != 0) {;
if (values==null || values.isempty()) return "";
collectionofstrings.toarray() );
if (ret.length() > 0) ret.append(",");
if (values == null || values.isempty()) {;
select day(eomonth(getdate()));
select day(eomonth ( @date )) as 'this month';
select day(eomonth ( @date, 1 )) as 'next month';
@year int=1989 set @date=cast(cast(@year as nvarchar) + '-' + cast(@month as nvarchar) + '-' + '1' as datetime);
set @noofdays = datepart(month,@date ) set @countfordate = 28 + (@noofdays + floor(@noofdays/8)) % 2 + 2 %    @noofdays + 2 * floor(1/@noofdays) set @noofdays= @countfordate + case when @countfordate = 28 and datepart(year,@date)%4 =0 then 1 else 0 end;
select day( dateadd(day,-1,dateadd(month, 1, convert(date,'2019-03-01')))) select day(eomonth(getdate()));
select add_months(trunc(sysdate,'mm'),1) -  trunc(sysdate,'mm') from dual;
set     @m = 2 select @m as [month], datediff(day, dateadd(day, 0, dateadd(m, +@m -1, 0)), dateadd(day, 0, dateadd(m,+ @m, 0));
select day(dateadd(month, 12 * year(date) + month(date) - 22800, -1));
set @adate = getdate() select day(eomonth(@adate)) as daysinmonth;
select  datediff(day, dateadd(day, 0, dateadd(month, ((2013 - 1900) * 12) + 3 - 1, 0)), dateadd(day, 0, dateadd(month, ((2013  - 1900) * 12) + 3, 0)) );
select datediff(day,@date,dateadd(month,1,@date));
select day(dateadd(dd,-1,dateadd(mm,datediff(mm,-1,'1/31/2009'),0)));
select day(dateadd(dd,-1,dateadd(mm,datediff(mm,-1,'2404-feb-15'),0)));
select day(dateadd(dd,-1,dateadd(mm,datediff(mm,-1,'2011-12-22'),0)));
set @date ='2012-02-09 00:00:00' select datediff(day,cast(replace(cast(year(@date) as char)+'-'+cast(month(@date) as char)+'-01',' ','')+' 00:00:00' as datetime),dateadd(month,1,cast(replace(cast(year(@date) as char)+'-'+cast(month(@date) as char)+'-01',' ','')+' 00:00:00' as datetime)));
create function [dbo].[get_days](@date datetime) as begin set @date = dateadd(month, 1, @date) end;
select datediff(dd,getdate(),dateadd(mm,1,getdate())) as datas;
set @monthnumber = datepart(month,@date ) set @daycount = 28 + (@monthnumber + floor(@monthnumber/8)) % 2 + 2 %    @monthnumber + 2 * floor(1/@monthnumber) select @daycount + case when @daycount = 28 and datepart(year,@date)%4 =0 then 1 else 0 end -- leap year adjustment;
alter function dbo.[daysinm] ( @dates nvarchar(12) ) as begin select @dates2 = (select day(eomonth(convert(datetime,@dates,103)))) set @days = convert(int,@dates2) end return @days end ;
select day(eomonth(convert(datetime,'08/12/2016',103)));
select day(eomonth(convert(datetime,getdate(),103)));
dateadd(month, 1, dateadd(day, 1-day(@date), @date)));
create function [dbo].[ufn_getdaysinmonth] ( @pdate    datetime ) as begin set @pdate = convert(varchar(10), @pdate, 101) set @pdate = @pdate - day(@pdate) + 1 end ;
select datepart(day, dateadd(s,-1,dateadd(mm, datediff(m,0,getdate()),0))) select datepart(day, dateadd(s,-1,dateadd(mm, datediff(m,0,getdate())+1,0))) select datepart(day, dateadd(s,-1,dateadd(mm, datediff(m,0,getdate())+2,0)));
create function dbo.isleapyear ( @testyear int ) as begin set @result = case when ((@testyear % 4 = 0) and (@testyear % 100 != 0)) or (@testyear % 400 = 0) then 1 else 0 end as bit ) end go create function dbo.getdaysinmonth ( @testdt datetime ) as begin set @monthno = datepart(m,@testdt) set @result = case @monthno case when dbo.isleapyear(datepart(yyyy,@testdt)) = 0 then 28 else 29 end when  3 then 31 end  end go;
set @testdt = '2404-feb-15';
select dbo.getdaysinmonth(@testdt);
select day(dateadd(day, -day(dateadd(month, 1, getdate())), dateadd(month, 1, getdate())));
select @firstdayofmonth;
select @lastdayofmonth;
select datediff(day, (convert(datetime,convert(varchar(2),month(getdate()))+'/01/'+convert(varchar(4),year(getdate())))), (convert(datetime,convert(varchar(2),month(getdate())+1)+'/01/'+convert(varchar(4),year(getdate()))))) as [no.of days in a month];
select day(subdate(adddate(concat(year(now()), '-', month(now()), '-1'), interval 1 month), interval 1 day));
set     @dt = getdate() select @dt as [datetime], day(dateadd(mm, datediff(mm, -1, @dt), -1)) as [days in month];
set     @y = 2012 set     @m = 2 select @y as [year], @m as [month], datediff(day, dateadd(day, 0, dateadd(m, ((@y - 1900) * 12) + @m - 1, 0)), dateadd(day, 0, dateadd(m, ((@y - 1900) * 12) + @m, 0));
from [northwnd].[dbo].[employees] """;
from sqlalchemy import create_engine r'driver=odbc driver 13 for sql server;';
select * from ( select `timestamp`, `fromemail`, `subject` from `incomingemails`;
select cur.textid, cur.fromemail, cur.subject, cur.timestamp, cur.read from incomingemails cur and cur.timestamp < next.timestamp where next.timestamp is null and cur.touserid = '$userid';
and cur.id < next.id;
select incomingemails.* from ( select fromemail, max(timestamp) `timestamp` from incomingemails join incomingemails using (fromemail, timestamp);
select t.* from (select * from table order by time desc) t group by t.from;
select count(*), concat(year(`datetime_added`), '-', lpad(month(`datetime_added`), 2, '0')) as date from `person` where (email = '' or email is null);
select * from s natural join sp;
select * from s join sp on s.sno = sp.sno;
select distinct;
select * from table_expression;
select * from product join component;
alter table news add fulltext(headline, story);
create fulltext catalog fulltextcatalog as default select * from sys.fulltext_catalogs;
create fulltext index on production.productdescription(description);
select id, productname from [productsdb].[dbo].[products] where [productsdb].[dbo].[products].productname like '%q%';
alter table news add fulltext(headline, story);
select * from chartofaccounts where accountname like '%tax%';
select * from table where contains([column], '"a00*"');
where [column] like 'a00%';
where dbo.property == true select dbo.color.name).distinct();
where dbo.property select dbo.color.name).distinct();
where dbo.property == true select dbo.color.name).distinct().orderby(name=>name);
select distinct ...;
select ... ( select listagg(v.column_value,',') within group (order by v.column_value) from table(columns_tab) v ... from ( select ... ... );
create or replace type tab_typ as table of varchar2(100);
select col1, listagg(case rn2 when 1 then col2 end, ',') within group (order by col2) as col2_list, listagg(case rn3 when 1 then col3 end, ',') within group (order by col3) as col3_list, sum(col4) as col4 from ( select col1, col2, row_number() over (partition by col1, col2 order by null) as rn2, row_number() over (partition by col1, col3 order by null) as rn3 from foo );
select col1, listaggr(col2,',') within group(order by col2) from table group by col1;
select col1, listaggr(col2,',') within group(order by col2),listaggr(col3,',') within group(order by col3) from table group by col1;
select col1, listagg(col2, ',') within group (order by col2) as col2_list, listagg(col3, ',') within group (order by col3) as col3_list, sum(col4) as col4 from ( select col1, decode(row_number() over (partition by col1, col2 order by null),1,col2) as col2, decode(row_number() over (partition by col1, col3 order by null),1,col3) as col3 from foo );
select pid, listagg(desc, ' ' on overflow truncate) within group (order by seq) as desc from b group by pid;
create type listagg_distinct_params as object (elemento varchar2(2000), separatore varchar2(10));
create type t_lista_elementi as table of varchar2(2000);
create type t_listagg_distinct as object (  separatore varchar2(10),   value in                    listagg_distinct_params )  return_value out    varchar2, flags        in     number      )  ctx2                 in         t_listagg_distinct    ) create or replace type body t_listagg_distinct is if value.elemento is not null then end if;
if self.lista_elementi.exists(1) then -- se esiste almeno un elemento nella lista select cast(multiset(select * from table(lista_output) order by 1 ) as t_lista_elementi ) into lista_output from dual;
if length(stringa_output) > lunghezza_max then else return_value:=stringa_output;
else -- se non esiste nessun elemento, restituisci null end if;
create function listagg_distinct (input listagg_distinct_params) return varchar2 select listagg_distinct(listagg_distinct_params(owner, ', ')) as lista_owner from sys.all_objects;
(value, ', ') within group( order by value)), '([^ ]+)(, \1)+','\1'),', ');
select col1, stragg(distinct col2) from table;
create or replace function distinct_listagg delimiter_in varchar2) as hold_result varchar2(4000);
select rtrim( regexp_replace( (listagg_in) from dual;
select distinct_listagg( listagg(myfield,', ') within group (order by 1), ', ' ) from mytable;
( select 1 as col1, 2 as col2, 3 as col3, 'smith' as created_by from dual union all select 1 as col1, 2 as col2, 3 as col3,'john'  as created_by from dual union all select 1 as col1, 3 as col2, 4 as col3,'ajay'  as created_by from dual union all select 1 as col1, 4 as col2, 4 as col3,'ram'   as created_by from dual union all select 1 as col1, 5 as col2, 6 as col3,'jack'  as created_by from dual ) ( select  distinct col1, listagg(col2,',') within group (order by col2)  over (partition by col1) as col2list from ( select distinct col1,col2 from tab) ) ( select  distinct col1, listagg(col3,',') within group (order by col3)  over (partition by col1) as col3list from ( select distinct col1,col3 from tab) ) select col1,col2list,col3list from getcol2 join getcol3;
( select 1 as col1, 2 as col2, 'smith' as created_by from dual union select 1, 2, 'john' from dual union select 1, 3, 'ajay' from dual union select 1, 4, 'ram' from dual union select 1, 5, 'jack' from dual union select 2, 5, 'smith' from dual union select 2, 6, 'john' from dual union select 2, 6, 'ajay' from dual union select 2, 6, 'ram' from dual union select 2, 7, 'jack' from dual ) select col1  , listagg(col2 , ',') within group (order by col2 asc) as orig_value, listagg(case when rwn=1 then col2 end , ',') within group (order by col2 asc) as distinct_value from ( select row_number() over (partition by col1,col2 order by 1) as rwn, a.* from test_data a;
select distinct t.app_svc_id, listagg(rtrim(t.access_mode), ',') within group(order by t.access_mode) over(partition by t.app_svc_id) as access_mode from app_svc_access_cntl t;
select a,b,listagg(c,',') within group(order by c) c, avg(d) from (select a,b,c,avg(d) from   table;
( select 'a' as col1, 't_a1' as col2, '123' as col3 from dual union select 'a', 't_a1', '456' from dual union select 'a', 't_a1', '789' from dual union select 'a', 't_a2', '123' from dual union select 'a', 't_a2', '456' from dual union select 'a', 't_a2', '111' from dual union select 'a', 't_a3', '999' from dual union select 'b', 't_a1', '123' from dual union select 'b', 't_b1', '740' from dual union select 'b', 't_b1', '846' from dual ) select col1 from ( select col1 from test_data;
select col1, dbms_lob.substr(ltrim(regexp_replace(replace( replace( xmlagg( xmlelement("a",col2) '<a>','-'), '</a>',''),'([^-]*)(-\1)+($|-)', '\1\3'),'-'), 4000,1) as platform_mix from table;
( select 1 as col1, 2 as col2, 'smith' as created_by from dual union all select 1 as col1, 2 as col2, 'john'  as created_by from dual union all select 1 as col1, 3 as col2, 'ajay'  as created_by from dual union all select 1 as col1, 4 as col2, 'ram'   as created_by from dual union all select 1 as col1, 5 as col2, 'jack'  as created_by from dual ) select col1 else col2 end as col2_with_nulls from tab;
( select 1 as col1, 2 as col2, 'smith' as created_by from dual union all select 1 as col1, 2 as col2, 'john'  as created_by from dual union all select 1 as col1, 3 as col2, 'ajay'  as created_by from dual union all select 1 as col1, 4 as col2, 'ram'   as created_by from dual union all select 1 as col1, 5 as col2, 'jack'  as created_by from dual ) select listagg(col2_with_nulls, ',') within group (order by col2_with_nulls) col2_list from ( select col1 from tab );
( select 1 as col1, 2 as col2, 'smith' as created_by from dual union all select 1 as col1, 2 as col2, 'john'  as created_by from dual union all select 1 as col1, 3 as col2, 'ajay'  as created_by from dual union all select 1 as col1, 4 as col2, 'ram'   as created_by from dual union all select 1 as col1, 5 as col2, 'jack'  as created_by from dual ) select listagg(col1_with_nulls, ',') within group (order by col1_with_nulls) col1_list from ( select case when lag(col1) over (order by col1) = col1 then null else col1 end as col1_with_nulls from tab );
create or replace function listagg_distinct (t in str_t, sep in varchar2 default ',') as l_rc varchar2(4096) := '';
select listagg(val, sep) within group (order by 1) from (select distinct column_value val from table(t));
select col1, listagg_distinct(cast(collect(col_2) as str_t ), ', ') from your_table;
select ptc.pmid as pmid, ptc.pmc_id, ptc.pub_title as pubtitle, ptc.author_list as authorlist, ptc.pub_date as pubdate, regexp_replace( listagg ( ppcc.admin_phs_org_code || '(^|,)(.+)(,\2)+', '\1\2') as projectnum from publication_total_citations ptc join proj_paper_citation_counts ppcc and ppcc.citation_year = 2013 join user_appls ua and ppcc.serial_num = ua.serial_num and ua.login_id = 'evansf';
create or replace package list_const_p end list_const_p;
create type listagg_clob_t as object( v_liststring varchar2(32767), v_clob clob, v_templob number,  sctx in out listagg_clob_t member function odciaggregateiterate( self in out listagg_clob_t, value in varchar2 member function odciaggregateterminate( self in out listagg_clob_t, returnvalue out clob, flags in number member function odciaggregatemerge( self in out listagg_clob_t, ctx2 in out listagg_clob_t create or replace type body listagg_clob_t is self in out listagg_clob_t, value in varchar2 if nvl(lengthb(v_liststring),0) + nvl(lengthb(value),0) <= 4000 then else if self.v_templob = 0 then end if;
self in out listagg_clob_t, returnvalue out clob, flags in number if self.v_templob != 0 then else self.v_clob := substr(self.v_liststring, 1, length(self.v_liststring) - 1);
if ctx2.v_templob != 0 then if self.v_templob != 0 then else self.v_clob := ctx2.v_clob;
if nvl(lengthb(self.v_liststring),0) + nvl(lengthb(ctx2.v_liststring),0) <= 4000 then else if self.v_templob = 0 then end if;
create or replace function listagg_clob (input varchar2) return clob;
select col1, wm_concat(distinct col2) col2_list from tab1;
select * from (select listagg(enroll_status, ',') within group(order by enroll_status) "enrollment status" from (select distinct enroll_status from students) t)          t2, (select listagg(gender, ',') within group(order by gender) "legal gender code" from (select distinct gender from students) t)                               t3, (select listagg(city, ',') within group(order by city) "city" from (select distinct city from students) t)                                                  t4, (select listagg(entrycode, ',') within group(order by entrycode) "entry code" from (select distinct entrycode from students) t)                             t5, (select listagg(exitcode, ',') within group(order by exitcode) "exit code" from (select distinct exitcode from students) t)                                 t6, (select listagg(lunchstatus, ',') within group(order by lunchstatus) "lunch status" from (select distinct lunchstatus from students) t)                     t7, (select listagg(ethnicity, ',') within group(order by ethnicity) "race code" from (select distinct ethnicity from students) t)                              t8, (select listagg(classof, ',') within group(order by classof) "expected graduation year" from (select distinct classof from students) t)                     t9, (select listagg(track, ',') within group(order by track) "track code" from (select distinct track from students) t)                                         t10, (select listagg(gradreqsetid, ',') within group(order by gradreqsetid) "graduation id" from (select distinct gradreqsetid from students) t)                 t11, (select listagg(enrollment_schoolid, ',') within group(order by enrollment_schoolid) "school key" from (select distinct enrollment_schoolid from students) t)       t12, (select listagg(fedethnicity, ',') within group(order by fedethnicity) "federal race code" from (select distinct fedethnicity from students) t)                         t13, (select listagg(summerschoolid, ',') within group(order by summerschoolid) "summer school key" from (select distinct summerschoolid from students) t)                               t14, (select listagg(fedracedecline, ',') within group(order by fedracedecline) "student decl to prov race code" from (select distinct fedracedecline from students) t)          t15;
select regexp_replace( '2,2,2.1,3,3,3,3,4,4' from dual;
select col1,  listagg( col2 , ',') within group (order by col2)  -- sorted from tablex where rn = 1;
select col1,  case when count(col2) < 100 then listagg(col2, ',') within group (order by col2) else 'too many entries to list...' end  from sometable where rn = 1;
select col1  , dbms_xmlgen.convert(  -- html decode replace( xmlagg( xmlelement("a",col2 ) '<a>',','), '</a>',''),'([^,]+)(,\1)*(,|$)', '\1\3'), ','), -- remove leading xml commas ltrim as col2 from sometable where rn = 1;
select regexp_replace('2,2,2.1,3,3,4,4','([^,]+)(,\1)*(,|$)', '\1\3') , ---> 2,2.1,3,4 works --> 2.1,1 works from dual;
select listagg(distinct the_column, ',') within group (order by the_column) from the_table;
select listagg(the_column, ',') within group (order by the_column) from ( select distinct the_column from the_table;
select col1, listagg(col2, ',') within group (order by col2) from ( select col1, col2, row_number() over (partition by col1, col2 order by col1) as rn from foo ) where rn = 1;
select question_id, listagg(element_id, ',') within group (order by element_id) from (select distinct question_id, element_id from your_table);
set constraint pk_tab1 deferred;
database    not deferrable  deferrable           deferrable;
create table example( row integer not null, col integer not null, unique (row, col) deferrable initially immediate update example set row = row + 1, col = col + 1;
select * from example;
select table1.id as parent_id, table2.id as child_id;
select name, address, amount from employees join payroll using (employee_id);
select * from `users`;
select * from sometable with (nolock);
set transaction isolation level read uncommitted;
select ... like :username;
select ... like :username%;
select ... like %:username;
select ... like %:username%;
select year(a.timestamp), month(a.timestamp), hour(a.timestamp), minute(a.timestamp) div 5, name, count(b.name) from time a, id b where a.user = b.user and a.id = b.id and b.name = 'john' and a.timestamp between '2010-11-16 10:30:00' and '2010-11-16 11:00:00' month(a.timestamp), hour(a.timestamp), minute(a.timestamp) div 12;
select concat(year(a.timestamp), "-", month(a.timestamp), "-" ,day(a.timestamp), " " , lpad(hour(a.timestamp),2,'0'), ":", lpad((minute(a.timestamp) div 5) * 5, 2, '0'));
select timestamp with time zone 'epoch' + name, count(b.name) from time a, id where  round(extract('epoch' from timestamp) / 300), name;
select timestamp,  -- not sure about that count(b.name) from time a, id where  unix_timestamp(timestamp) div 300, name;
select date_format( min(timestamp), '%d/%m/%y %h:%i:00' name, count(id) as cnt from table group by round(unix_timestamp(timestamp) / 300), name;
select substring( from_unixtime( ceiling( timestamp /300 ) *300, '%y-%m-%d %h:%i:%s' ) , 1, 19 ) as ts_ceiling, sum(value) from group_interval '%y-%m-%d %h:%i:%s' ) , 1, 19 ) '%y-%m-%d %h:%i:%s' ) , 1, 19 ) desc;
select from_unixtime( 300 * round( unix_timestamp( r.dt ) /300 ) ) as 5datetime, ( select r.c from astro_transit1 ra where ra.dt = r.dt limit 1 limit 0 , 30;
select name, sum(count), date_trunc('minute',timestamp) as timestamp from table where xxx;
select from_unixtime(unix_timestamp(timestamp) - unix_timestamp(timestamp) mod 300) as ts, sum(value) from group_interval;
select concat(cast(createdate as date),' ',datepart(hour,createdate),':',round(cast((cast((cast(datepart(minute,createdate) as decimal (18,4)))/5 as int)) as decimal (18,4))/12*60,2)) as '5mindate' from table;
select count(*) cnt, to_timestamp(floor((extract('epoch' from timestamp_column) / 300 )) * 300) from table_name group by interval_alias;
select generate_series(min(date_trunc('hour',timestamp_column)), max(date_trunc('minute',timestamp_column)),'5m') as interval_alias from;
select series.minute as interval,  coalesce(cnt.amnt,0) as count from ( select count(*) amnt, to_timestamp(floor((extract('epoch' from timestamp_column) / 300 )) * 300) from table_name  group by interval_alias ( select generate_series(min(date_trunc('hour',timestamp_column)), max(date_trunc('minute',timestamp_column)),'5m') as minute from table_name;
select from_unixtime(floor((unix_timestamp(timestamp))/300)*300) as t,timestamp,count(1) as c from users group by t order by t;
like 'express edition%';
set @edition = cast((select serverproperty ('edition')) as varchar) if @edition like 'express edition%' set @isexpress = 1;
else set @isexpress = 0;
set @isexpress = case when left(@edition, 15) = 'express edition' then 1 else 0 end;
set @isexpress = iif(left(@edition, 15) = 'express edition', 1, 0);
set @isexpress = iif(charindex('express edition', @edition) = 1, 1, 0);
set @isexpress = (charindex('express edition', @edition) = 1);
set @isexpress = (charindex('express edition', @edition) >= 1);
delete from table where id not in ( 2 );
delete from table where id <> 2;
delete from table where id not in ( 2 );
delete from table where id <>  2;
delete * from table where not(id = 2);
delete from table where id <> 2;
select * from foo where      test-1 and      test-2 and (    test-3 or test-4 );
select * from foo where not(          test-1 and      test-2 and (    test-3 or test-4 ) );
select * from foo where        not test-1 or         not test-2 or   (     not test-3 and not test-4 );
delete from table where id <> 2;
delete from table where id <> 2 or id is null;
and (isdelete is null or isdelete = 0);
create table db2.table like db1.table;
create table db_name.table1 like dbname.table2;
create table new ( like old;
create table new_table_name ( like old_table_name including all);
create table sample_table_copy as (select * from sample_table where 1 = 2);
create table films2 as table films;
if (@something = 'foo') end commit;
if (@something = 'foo') end commit;
end try end catch;
if @@trancount > 0 rollback transaction;
create procedure [usp_my_procedure_name] as begin set nocount on;
set @trancount = @@trancount;
if @trancount = 0 else save transaction usp_my_procedure_name;
if @trancount = 0 end try select @error = error_number(), @message = error_message(), @xstate = xact_state();
if @xstate = -1 if @xstate = 1 and @trancount = 0 if @xstate = 1 and @trancount > 0 end catch end go;
set xact_abort on set nocount on end try end catch;
select rownum = row_number() over (order by columns_to_order_by), value from table ) select curr.value - prev.value from cte cur;
select t2.col from ( select col,max(id) id from ( select row_number() over(partition by col order by col) id ,col from testtab t1) as t1;
select value - lag(value) over (order by id) from table;
select t1.value - t2.value from table t1, table t2 where t1.primarykey = t2.primarykey - 1;
select  rank() over (order by id) as 'rank', value into temp1 from t select t1.value - t2.value from temp1 t1, temp1 t2 where t1.rank = t2.rank - 1 drop table temp1;
select  value - ( select  top 1 value from    mytable m2 where   m2.col1 < m1.col1 or (m2.col1 = m1.col1 and m2.pk < m1.pk) col1, pk ) from mytable m1 col1, pk;
select t1.value - t2.value from @temp  t1 join @temp  t2;
where group by having;
where having group by;
select                        ###  just from tblinvoiceitems as ii    ###  purposes. join tblhosting as h on ii.relid = h.id join tblinvoices as i on ii.invoiceid = i.id where ii.amount <> h.amount   ### show only updatable rows;
select * from nicetable where somthing=1;
update nicetable set nicefield='value' where somthing=1;
select * from nicetable where somthing=1; #check select * from nicetable where somthing=1; #should be the old value;
else $mysqlconnection->query('rollback;');
set @v1 := update myguests set lastname='doe' where id=2;
update wp_history set history_by="admin" where history_ip like '123%';
select * from where history_ip like '123%';
set autocommit=0;
update foo set bar = 42 where col1 = 1 and col2 = 'foobar';
select * from foo where col1 = 1 and col2 = 'foobar';
update users set id=0 where name='jan';
select * from users where name='jan';
select a, b, c from foobar where x=3;
select empno,ename,dno,job from emp where job='clerk';
update yourtable set columnb = columna where columnb is null and columna is not null;
update yourtable set columnb=columna where columnb is null and columna is not null;
update your_table set b = a where b is null;
update some_table set null_column = not_null_column where null_column is null;
update yourtable set b = coalesce(b, a);
select * from customers;
select * from customers join orders on customers.id = orders.customerid;
create procedure updatetables as begin set nocount on;
update table1 set column = 0 where column is null select @rowcount1 = @@rowcount update table2 set column = 0 where column is null select @rowcount2 = @@rowcount update table3 set column = 0 where column is null select @rowcount3 = @@rowcount update table4 set column = 0 where column is null select @rowcount4 = @@rowcount select @rowcount1 as table1, @rowcount2 as table2, @rowcount3 as table3, @rowcount4 as table4 end;
name varchar(32) ) update @fish set name = 'lurpackfish' where name = 'butterfish' select @@rowcount  --gives 1 update @fish set name = 'dinner' select @@rowcount -- gives 3;
create table [dbo].[test_table]( [lockid] [int] identity(1,1) not null, [starttime] [datetime] null, [endtime] [datetime] null, primary key clustered ( [lockid] asc update test_table set starttime = '2011 jul 01' where starttime > '2009 jul 09';
[lockid] [int], [starttime] [datetime] null, [endtime] [datetime] null ) update test_table set starttime = '2011 jul 01' where starttime > '2009 jul 09' select count(*) from @temp;
set heading off select 'alter table ' || from user_constraints;
from user_constraints c, user_tables t where c.table_name = t.table_name and c.status = 'enabled' and not (t.iot_type is not null and c.constraint_type = 'p') end loop;
from user_constraints c, user_tables t where c.table_name = t.table_name and c.status = 'disabled' end loop;
if c1.table_name = c2.table_name and c1.status = 'enabled' then end if;
set serveroutput on from user_constraints c,user_tables t where c.table_name=t.table_name and c.status='enabled' ) c1.constraint_name child_constraint from user_constraints p join user_constraints c1 on(p.constraint_name=c1.r_constraint_name) or p.constraint_type='u') and c1.constraint_type='r' and p.table_name=upper(c.table_name) ) end loop;
select 'alter table '||substr(c.table_name,1,35)|| from user_constraints c, user_tables u where c.table_name = u.table_name;
from (select a.table_name child_tname from user_cons_columns a where a.constraint_name = b.constraint_name and b.constraint_type = 'r' from user_cons_columns a where a.constraint_name = b.constraint_name and b.constraint_type in ('p', 'u') where child.parent_cons_name = parent.parent_cons_name and (parent.parent_tname like 'v2_%' or child.child_tname like 'v2_%')) select distinct disable_pk from qry0 union select distinct disable_fk from qry0;
where table_name = 'd' and owner = 'tranee') end loop;
select distinct(city) from station where substr(lower(city), length(city), 1) in ('a', 'e', 'i', 'o', 'u') and substr(lower(city), 1, 1) in ('a', 'e', 'i', 'o', 'u');
select substr(description,-3) from student.course;
select right('abcdeffff',4);
select right( '1234567890', 4 ); -- returns '7890';
select right(column, 4) from ...;
if exists (select 1 from sys.all_objects where type='u' and name='_original') drop table _original create table #original (rowid int identity, monthyear varchar(max), salesrepid int, sale money) select (select cast(floor(rand()*(@endyear-@startyear)+@startyear) as varchar(4))+'-'+ cast(floor(rand()*(13-1)+1) as varchar(2)) ),  @salesrepid , @income set  @salesrepid  = cast(floor(rand()*(9100-9000)+9000) as varchar(4)) set @income = cast((select round(rand()*(5000-4990)+4990 , 2)) as money) set @iterator=@iterator+1 end update #original set monthyear=replace(monthyear, '-', '-0') where  len(monthyear)=6 select * into _original from #original;
create type columnnames as table;
create proc delete_dupes (@tablename varchar(max), @columns columnnames readonly) as begin if exists (select 1 from @columns)  begin select 1, columnnames from @columns set @partitionby = (select distinct from @columns1 t1 where t1.iterator = t2.iterator from @columns1 t2 ) end  select 1, a.name, is_identity from sys.all_columns a join sys.all_objects b on a.object_id=b.object_id where b.name = @tablename select          distinct case when @iterator=1 then 'order by' else 'over (partition by' end , substring((select ', '+t1.name from @table t1 where t1.iterator = t2.iterator and is_identity=@iterator from @table t2 set @iterator=@iterator-1 end  if @partitionby is null begin select @originalpartition  = replace(b.value+','+a.type+a.value ,'over (partition by','')  from @tablepartition a cross join @tablepartition b where a.idx=2 and b.idx=1 select @partitionby = a.type+a.value+' '+b.type+a.value+','+b.value+') rownum' from @tablepartition a cross join @tablepartition b where a.idx=2 and b.idx=1 end else begin select @originalpartition=b.value +','+ @partitionby from @tablepartition a cross join @tablepartition b where a.idx=2 and b.idx=1 set @partitionby = (select 'over (partition by'+ @partitionby  + ' order by'+ @partitionby + ','+b.value +') rownum' from @tablepartition a cross join @tablepartition b where a.idx=2 and b.idx=1) end  'delete a from _original a where b.rownum is null') drop table ##temp end;
exec delete_dupes '_original';
values ('salesrepid'),('sale') exec delete_dupes '_original' , @table1;
create table #properolvchangecodes( id int not null, name nvarchar(max) not null ) select  top 1 @newid = id from    sales_orderlineversionchangereasoncode where   name = @name update sales_orderlineversion set changereasoncodeid = @newid where changereasoncodeid = @id delete from sales_orderlineversionchangereasoncode where id = @id end else begin end  drop table #properolvchangecodes;
('anil'),('dipak'),('dipak'),('anil') select * from @employee;
delete  aliasname from ( select  *, row_number() over (partition by employeename order by employeename) as rownumber from    @employee) aliasname where   rownumber > 1 select * from @employee;
delete from employee where rowid not in (select max(rowid) from employee;
delete from person where id not in ( select t.id from;
delete from mytable where id not in ( select max(id) from mytable;
as ( select firstname, lastname, row_number() over (partitionby firstname, lastname orderby firstname) as duplicaterecordcount from dbo.users ) delete from tempusers where duplicaterecordcount > 1;
delete t1 from mytable t1, mytable t2 where t1.dupfield = t2.dupfield and t1.uniquefield > t2.uniquefield;
delete from employee where id not in ( select min(id) from employee;
delete from guidemployees where cast(id as binary(16)) not in ( select min(cast(id as binary(16))) from guidemployees;
delete x from ( select *, rn=row_number() over (partition by employeename order by empid) from employee where rn > 1;
select * from ( select *, rn=row_number() over (partition by employeename order by empid) from employee where rn > 1;
( select employeename, row_number() over(partition by employeename order by employeename) as r from employee_table ) delete cte where r > 1;
('2006-04-05', 'buy', 'msft', 1000, 72.00), ('2006-04-06', 'sell', 'ibm', 500, 53.00), ];
seminar, paid) );
set @sql = 'select top 1 * from sys.tables';
set @sql = 'select top 1 * from sys.tables';
set @sql = n'select top 1 * from sys.tables';
select new count = g.count();
where n.sent == false select new { id = g.key,  count = g.count()};
select [n].[appuserid], count(*) as [count] from [notifications] as [n] where [n].[sent] = 0;
select * from cols where column_name = 'id';
select distinct c1.table_name from cols c1 cols c2 cols c3 cols c4 tab t where t.tabtype = 'table' --could be 'view' if you wanted and upper(c1.column_name) like upper('%id%') and upper(c2.column_name) like upper('%fname%') and upper(c3.column_name) like upper('%lname%') and upper(c4.column_name) like upper('%address%');
select * from schema1.cols where column_name like '%id%';
select distinct 'schema1' as schema_name from schema1.cols where column_name like '%id%' union select distinct 'schema2' as schema_name from schema2.cols where column_name like '%id%';
select owner, table_name from all_tab_columns where column_name = 'id';
select owner, table_name, column_name from all_tab_columns where column_name in ('id', 'fname', 'lname', 'address');
select owner, table_name from all_tab_columns where column_name in ('id', 'fname', 'lname', 'address') having count(*) = 4;
set verify off set wrap off select distinct table_name, column_name, data_type || ' (' || 'blob',null,'clob',null,'number', decode(data_precision,null,to_char(data_length), data_precision||','||data_scale from all_tab_columns where column_name like ('%' || upper('&colnam') || '%');
select owner,table_name from all_tab_columns where upper(column_name) =upper('keyword');
select owner,table_name from all_tab_columns where upper(column_name) like upper('%keyword%');
select 'hello world' from dual;
select 'hello world';
select (select count(*) from votesonposts where votetypename = 'upmod' and userid = @userid and posttypeid = 2) as totalupvotes, (select count(*) from answers where userid = @userid) as totalanswers;
select 'hello world';
select 'hello world' from dual;
select 'hello world';
select distinct 'hello world' as new_value from anytablewithoneormorerows where 1 = 1;
select 'howdy' from <table_name>;
select " where 1 = 1;
select 'your text';
select 'hello world' from (select name='nothing') n where 1=1;
select *  from (values ('hello world')) t1 (col1) where 1 = 1;
select *  from (values ('hello world'),('hello world'),('hello world')) t1 (col1) where 1 = 1;
create table notable ( nocolumn              integer;
select 'hello world' as name;
select "hello world" from rdb$database;
union all values(2,'goodbye world');
values ('hello world');
values (1, 'a'), (2, 'b'), (3, 'c');
select 1       from dual;
select 1 + 1   from dual;
select sqrt(2) from dual;
select 1 from system.one;
if object_id('tempdb..##clients_keyword') is not null drop table ##clients_keyword create table ##clients_keyword(client_id int) end else create table ##clients_keyword(client_id int) if object_id('tempdb..##temp_clients_keyword') is not null drop table ##temp_clients_keyword create table ##temp_clients_keyword(client_id int) end else create table ##temp_clients_keyword(client_id int);
if object_id('tempdb..##clients_keyword') is not null drop table ##clients_keyword create table ##clients_keyword(client_id int) if object_id('tempdb..##temp_clients_keyword') is not null drop table ##temp_clients_keyword create table ##temp_clients_keyword(client_id int);
drop table if exists ##clients_keyword;
if object_id('tempdb..##clients_keyword', 'u') is not null drop table ##clients_keyword create table ##clients_keyword ( client_id int );
if object_id('tempdb..##clients_keyword', 'u') is not null else create table ##clients_keyword ( client_id int );
if object_id('tempdb..##clients_keyword') is not null drop table ##clients_keyword;
select * from table where column between str_to_date('29/01/15', '%d/%m/%y') and str_to_date('07/10/15', '%d/%m/%y');
select * from table where str_to_date(column, '%d/%m/%y') between str_to_date('29/01/15', '%d/%m/%y') and str_to_date('07/10/15', '%d/%m/%y');
select date_format(date(starttime),'%y-%m-%d') from data where date(starttime) >= date '2012-11-02';
select * from players where date(us_reg_date) between '2000-07-05' and '2011-11-10';
select * from players where us_reg_date >= '2000-07-05' and us_reg_date < '2011-11-10' + interval 1 day;
select * from players where us_reg_date between '2000-07-05' and date_add('2011-11-10',interval 1 day);
select chr(13) & chr(10) select char(13) + char(10);
create table t1 (id int not null, col1 int);
alter table t1 add constraint pk_t1 primary key nonclustered (id);
create clustered index ix_t1_col1 on t1 (col1);
create table t2 (id int not null, col1 int);
alter table t2 add constraint pk_t2 primary key nonclustered (id);
create table your_table ( your_pk int primary key nonclustered;
create table your_table ( your_pk int primary key, your_clustered_key int not null unique clustered;
create clustered index ...;
select * from users where username='administrator'; -- and password='';
update accounts set password = 'xyzzy' where account_id = account_id;
employeedetails.class);
create or replace procedure count_comments ( postid in number, commentcount out number ) as begin select count(*) into commentcount from post_comment where post_id = postid;
parametermode.in) parametermode.out);
create or replace procedure post_comments ( postid in number, postcomments out sys_refcursor ) as begin select * from post_comment where post_id = postid;
parametermode.in) parametermode.ref_cursor);
create or replace function fn_count_comments ( postid in number ) select count(*) into commentcount from post_comment where post_id = postid;
"select fn_count_comments(:postid) from dual" );
set @sql ='select * from #td1' if (@ismonday+@istuesday !='') set @sql= @sql+' where pickupday in ('''+@ismonday+''','''+@istuesday+''' )' end exec( @sql);
select "pg_attribute".attname                                                    as "column", pg_catalog.format_type("pg_attribute".atttypid, "pg_attribute".atttypmod) as "datatype",  from pg_catalog.pg_attribute "pg_attribute" where "pg_attribute".attnum > 0 and not "pg_attribute".attisdropped and "pg_attribute".attrelid = ( select "pg_class".oid from pg_catalog.pg_class "pg_class" where "pg_namespace".nspname = 'schema' and "pg_class".relname = 'table';
select column_name, data_type from information_schema.columns where table_name = 'your_table_name' and table_schema = 'your_schema_name';
select distinct row_number () over (order by pgc.relname , a.attnum) as rowid , pgc.relname as table_name , a.attnum as attr, a.attname as name, format_type(a.atttypid, a.atttypmod) as typ, a.attnotnull as notnull, com.description as comment, coalesce(i.indisprimary,false) as primary_key, def.adsrc as default from pg_attribute a join pg_class pgc on pgc.oid = a.attrelid where 1=1 and pgc.relkind in ('r','') and n.nspname <> 'pg_catalog' and n.nspname <> 'information_schema' and n.nspname !~ '^pg_toast' and a.attnum > 0 and pgc.oid = a.attrelid and pg_table_is_visible(pgc.oid) and not a.attisdropped;
select column_name,data_type from information_schema.columns where table_name = 'your_table_name' and table_catalog = 'your_database_name' and table_schema = 'your_schema_name';
drop table if exists abc;
create temporary table abc as select * from foo select column_name, data_type from information_schema.columns where table_name = 'abc';
drop if exists abc;
select pg_attribute.attname as column_name, pg_catalog.format_type(pg_attribute.atttypid, pg_attribute.atttypmod) as data_type from pg_catalog.pg_attribute pg_catalog.pg_class on pg_class.oid = pg_attribute.attrelid pg_catalog.pg_namespace on pg_namespace.oid = pg_class.relnamespace where pg_attribute.attnum > 0 and not pg_attribute.attisdropped and pg_namespace.nspname = 'my_schema' and pg_class.relname = 'my_table' attnum asc;
select column_name,data_type from information_schema.columns where table_name = 'table_name';
select a.attname as "column", pg_catalog.format_type(a.atttypid, a.atttypmod) as "datatype" from pg_catalog.pg_attribute a where a.attnum > 0 and not a.attisdropped and a.attrelid = ( select c.oid from pg_catalog.pg_class c where c.relname ~ '^(hello world)$' and pg_catalog.pg_table_is_visible(c.oid);
select * into database.dbo.backuptable from sourcedatabase.dbo.sourcetable;
select * into mytable_backup from mytable;
select * into  [dbo].[tbl_newtable] from [dbo].[tbl_oldtable];
where t : idbdataadapter, idisposable, new();
if (con.state == connectionstate.closed) { if (cmdtext == commandtype.storedprocedure) //type : stored procedure if (p.length > 0) // if any parameter is there means, we need to add. if (cmdtext == commandtype.text) // type : text if (cmdtext == commandtype.tabledirect) //type: table direct;
select [groupby1].[a1] as [c1] from ( select from [dbo].[persons] as [extent1];
select [groupby1].[a1] as [c1] from ( select from ( select case when ([project1].[c1] is null) then 0 else [project1].[age] end as [a1] from   ( select 1 as x ) as [singlerowtable1] cast(1 as tinyint) as [c1] from [dbo].[persons] as [extent1]) as [project1] on 1 = 1;
create global temporary table today_sales(order_id number);
create private temporary table ora$ptt_today_sales as select * from orders where order_date = sysdate;
create global temporary table table_name enddate date, class char(20));
create table table_temp_list_objects as select o.owner, o.object_name from sys.all_objects o where o.object_type ='table';
select b.name, max(b.value) as maxvalue, max(b.anothercolumn) as anothercolumn from out_pumptabl max(value) as maxvalue from out_pumptabl;
select * from out_pumptabl c where pk in from out_pumptabl b max(value) as maxvalue from out_pumptabl;
select name, max(value) from out_pumptable;
select distinct (t1.prodid), t1.quantity from dummy t1 inner join and t1.quantity = t2.maxquantity;
select name, value, anothercolumn from out_pumptable where value = ( select max(value) from out_pumptable as f where f.name=out_pumptable.name );
select * from (select * from table order by value desc limit 999999999) v group by v.name;
select name, value from out_pumptable ) as a where rn = 1;
select cities.* from cities left outer join photos on photos.city_id = city.id where photos.id is null;
select cities.id as t0_r0, cities.attr1 as t0_r1, cities.attr2 as t0_r2, cities.created_at as t0_r3, cities.updated_at as t0_r4, photos.id as t1_r0, photos.city_id as t1_r1, photos.attr1 as t1_r2, photos.attr2 as t1_r3, photos.created_at as t1_r4, photos.updated_at as t1_r5 from cities left outer join photos on photos.city_id = cities.id where photos.id is null;
create table checkconstraint ( id tinyint, name varchar(50), recordstatus tinyint ) create function checkactivecount( @id int select @ret = count(*) from checkconstraint where id = @id and recordstatus = 1;
alter table checkconstraint add constraint checkactivecountconstraint check (not (dbo.checkactivecount(id) > 1 and recordstatus = 1));
select * from checkconstraint;
alter table checkconstraint drop constraint checkactivecountconstraint;
drop function checkactivecount;
drop table checkconstraint;
create <b>unique</b> index myindex;
select  sum(transaction) from    customers join    accounts;
select  sum(transaction) from    customers join    accounts where   customer_last_name = 'stellphlug';
create database [$database$] exec sp_dbcmptlevel [$database$], $compatabilitylevel$ if '1'!='$integratedsecurity$' create login [$login$] with password=n'$password$', default_database=[$database$] create user [$user$] for login [$login$] exec sp_addrolemember n'db_owner', n'$user$' end go;
select @nextid = thekey from @temptable;
create table testtable(key uniqueidentifier, id varchar(100), name varchar(100), value tinyint);
select @uniqueidentifier = key from @tmptable;
drop table testtable;
create table dbo.guidtest ( guidcolumn uniqueidentifier not null default newsequentialid(), intcolumn int not null );
set @id  = newid() values (@id) select @id;
create table dbo.guidpk ( colguid uniqueidentifier not null default newsequentialid(), col2    int              not null ) colguid uniqueidentifier ) col2 ) values (1) select * from @op select * from dbo.guidpk;
cte2 as (select * from cdr.location) select * from cte1 union select * from cte2;
cte2 as (select * from cdr.location) select * from cte1 union select * from cte2;
cte2 as (select * from cte1 where val1 = val2) select * from cte1 union select * from cte2;
alter table tablename add newcolumn type not null constraint df_tmp_tablename_newcolumn default -9999 update tablename set newcolumn = oldcolumn alter table tablename drop constraint df_tmp_tablename_newcolumn;
alter table [widget] add [code] char(5) not null default(substring(convert(char(36), newid()), 1, 5)) alter table [dbo].[widget] with check add constraint [uq_widget_code] unique ([code]);
alter table dbo.tablename add newcolumn as (oldcolumn) persisted;
alter table dbo.tablename add newcolumn as (oldcolumn * 1.5) persisted;
set identity_insert <tablename> off;
set identity_insert <tablename> on;
create trigger tablename_on_insert on tablename as insert into tablename (oldcolumn, newcolumn) select oldcolumn, isnull(newcolumn, oldcolumn) from inserted;
alter table tablename add newcolumn type not null default (0) update tablename set newcolumn = oldcolumn where newcolumn = 0;
create trigger tablex_afterinsert_trg as update tablex as t set t.newcolumn = t.oldcolumn from inserted as i where t.pk = i.pk ;              -- where pk is the primary key of the table;
select * from table limit 10000 offset floor(rand() * 190000);
create table randomkeys (randomkey int) create table randomkeysattempt (randomkey int) -- with luck (and m much less than n), this won't be necessary if not exists (select * from randomkeys where randomkey = nextattempt) select * from randomkeys r join table t on r.randomkey = t.uniquekey;
where rand() < 0.1;
where rand() < 0.01;
select * from table where rand() <= .3;
select * from table_name where _id in (4, 1, 2, 5, 3);
select * from sales.salesorderdetail where 0.01 >= rand();
select * from sales.salesorderdetail where 0.01 >= cast(checksum(newid(), salesorderid) & 0x7fffffff as float) / cast (0x7fffffff as int);
select ... where id in (<subarray>);
select id from mytable;
) select id from ids order by mt_random() limit 3000;
select top 10000 * from table order by newid();
select distinct top 10000 customer_id from nielsen.dbo.customer tablesample (20000 rows) repeatable (123);
create [temporary] table tmp_ids (`id` int not null,primary key (`id`));
select id, name, price from products where id in (select id from tmp_ids);
where id between 300 and 3000;
where id between 300 and 3000 and id not between 742 and 836;
`id` int not null , `text` varchar(45) null , primary key (`id`) )");
if ($c>0) $values .= ",";
if ($r<$selected) { if ($selvalues!="(") $selvalues .= ",";
if (($c==100)||(($i==$nrows-1)&&($c>0))) {;
select * from `shirts` where `colors` regexp '\b1\b';
select * from shirts where find_in_set('1',colors) > 0;
select * from shirt, color where color.color_name = 'red' and shirt.shirt_id = shirtcolor.shirt_id and color.color_id = shirtcolor.color_id;
select * from shirts where concat(',', colors, ',') like '%,1,%';
select * from shirts where find_in_set('1',colors) <> 0;
select * from shirts where find_in_set(1,colors);
-> ticketnumber int, -> colors varchar(30) -> (32424,'1,5,12,15,30'), -> (32425,'2,5,11,15,28'), -> (32426,'1,2,7,12,15'), -> (32427,'2,4,8,12,15');
select * from shirts where 1 in (colors);
select * from shirts where find_in_set('1',colors) <> 0;
create function `total_occurance`(`commastring` text, `findme`     varchar(255)) returns int(11) ( length(commastring);
select find_in_set(5, columnname) as result from table;
select * from tablename f where 'searchvalue' = any (string_to_array(columnname, ','));
select * from customer f where '11' = any (string_to_array(customerids, ','));
select lpad(zip, 5, '0') as zipcode from table;
alter table `table` change `zip` `zip` char(5); #changes type update table set `zip`=lpad(`zip`, 5, '0'); #pads everything;
update mytable set zipcode = lpad( zipcode, 5, '0' );
alter table mytable change `zipcode` `zipcode`;
create table xxx ( zipcode int(5) zerofill unsigned, ... );
select lpad(cast(zipcode_int as char), 5, '0') as zipcode from table;
set sql_safe_updates = 0;
delete from instructor where salary between 13000 and 15000;
set sql_safe_updates = 1;
delete from t where ... (select ... from t ...);
update t ... where col = (select ... from t ...);
update t ... where col = (select * from (select ... from t...) as _t ...);
delete from instructor where id in ( select temp.id from ( select id from instructor where salary between 13000 and 15000;
delete from tbl where id <> 0;
select * into < new_table > from < existing_table > where < clause >;
select * from tableold where [conditions];
select col1, col2, ..., coln from tbl2 where ...;
select * from sourcetable where ...;
select column1, column2 from table1 where [conditions];
create login [contoso\patk] from windows;   alter server role;
create login templogin with password = '************';   alter;
alter login sa with password = '************';   warning;
create login [<<domain\username>>] from windows;
exec sys.sp_addsrvrolemember @loginame = n'<<domain\username>>', @rolename = n'sysadmin';
alter server role [sysadmin] add member [<<domain\username>>];
alter server role [sysadmin] add member [<<domain\username>>];
select @@servicename;
set sqlresult=n/a if .%1 == . (set /p sqlinstance=enter sql instance name, or default to sqlexpress: ) else (set sqlinstance=%1) if .%sqlinstance% == . (set sqlinstance=sqlexpress) if /i %sqlinstance% == mssqlserver (set sqlservice=mssqlserver) else (set sqlservice=mssql$%sqlinstance%) if .%2 == . (set sqllogin="%userdomain%\%username%") else (set sqllogin=%2) set srvstate=0 if .%srvstate% == .0 goto existerror if not .%2 == . goto continue set srvstarted=0 set srvstate=0 if .%srvstate% == .0 goto queryerror if .%srvstate% == .1 goto startm set srvstarted=1 if errorlevel 1 goto stoperror if errorlevel 1 goto startmerror set srvstate=0 if .%srvstate% == .0 goto queryerror if .%srvstate% == .1 goto startmerror if not .%srvstate% == .4 goto checkstate1 if errorlevel 1 goto stoperror if .%srvstarted% == .0 goto exit if errorlevel 1 goto starterror if .%sqlresult% == .0 (@echo '%sqllogin%' was successfully added to the 'sysadmin' role.) else (@echo '%sqllogin%' was not added to the 'sysadmin' role: sql return code is %sqlresult%.);
delete tablename;
exec sp_msforeachtable @command1="truncate table ?";
delete from table_name;
drop table table_name;
drop table tablename;
delete from <tablename>;
delete from student;
update tobeupdated set tobeupdated.id = original.id;
update tobeupdated set tobeupdated.id = original.id;
content( `status`, content_category, content_type, content_id, user_id, title, description, content_file, content_url, tags, create_date, edit_date, runs ) select `status`, content_category, content_type, content_id, user_id, title, description, content_file, content_url, tags, create_date, edit_date, runs from content_images;
set @db:='id_new';
select @max_id:=max(auto_increment) from information_schema.tables;
select concat('update ',table_name,' set ', column_name,' = ',column_name,'+',@max_id,' ; ') from information_schema.columns where table_schema=@db and column_name like '%id' into outfile 'update_ids.sql';
create table merged as select * from table 1 union select * from table 2;
select count(*), pk from merged group by pk having count(*) > 1;
select  * from    second_table s update s.column1 = do_what_ever_must_be_done_on_key_clash(f.column1);
select all_columns_except_pk from table2;
select * from table_2;
select * from table_2;
select create_date from sys.tables where name='yourtablename';
select [name] from sys.tables;
select [name] as [tablename], [create_date] as [createddate] from sys.tables;
select so.[name] as [tablename], so.[crdate] as [createddate] from information_schema.tables as it, sysobjects as so where it.[table_name] = so.[name];
select   su.name,so.name,so.crdate,* from     sysobjects so join sysusers su where    xtype='u';
select concat(ic.table_schema, '.', st.name) as tablename from sys.tables st join information_schema.columns ic on ic.table_name = st.name;
select t.name as table_name, s.name as schema_name, t.create_date, t.modify_date from sys.tables t join sys.schemas s;
select t.name as table_name, s.name as schema_name, t.create_date, t.modify_date from sys.tables t join sys.schemas s where s.name = 'schemaname';
delete from table where id in (1, 4, 6, 7);
delete from t where id in (1, 4, 6, 7);
where x.someprop == "abc" select x.bar;
select x.bar from [sometable] x where x.someprop = @p1;
select * from table_name and select 1 from table_name.;
select 1 from table_name;
select count(1) from <table name>;
select count(*)  from <table name>;
select count(*);
select count(col_name) from <table name>;
select count(1) from random_table;
select count(*) from random_table;
create table test1( id number, name varchar2(20) select * from test1;
select count(*) from test1;
select count(1) from test1;
select count(all 1) from test1;
select count(distinct 1) from test1;
select table.cost, (table.cost + const.more) as newcost from table, const where table.name = const.name;
create temp table _variables(name text primary key, realvalue real, integervalue integer, blobvalue blob, textvalue text);
update _variables set integervalue = ... where name = 'variablename';
drop table _variables;
create table foo( thing1 integer primary key autoincrement not null create table bar( thing2 integer primary key autoincrement not null, foreign key(thing2) references foo(thing1) create temp table _variables(key text, value integer);
drop table _variables;
end transaction;
create temp table if not exists variables (name text primary key, value text);
select value from variables where name = 'varstr' union all select value from variables where name = 'varint' union all select value from variables where name = 'varblob';
create constraint;
create assertion;
(select users.username as posted_by, users.id as posted_by_id from users where users.id = posts.posted_by);
select topics.id, topics.name, topics.post_count, topics.view_count, posts.posted_by (select users.username as posted_by_username from users where users.id = posts.posted_by);
select topics.id, topics.name, topics.post_count, topics.view_count, count( posts.solved_post ) as solved_post, users.username as posted_by, users.id as posted_by_id from topics where topics.cat_id = :cat;
join joined_table on (joined_table.column = table.column, joined_table.column2 = table.column2);
set totalvalue = (ifnull(i.subtotal,0) + ifnull(i.tax,0),0);
where product_id = (1,2,3);
set v_filter_value = 100;
select f_id, f_sale_value from t_seller where f_id = 5 and (v_filter_value <> 0, f_sale_value = v_filter_value, true);
users.id as posted_by_id from users where users.id = posts.posted_by);
select (p.column1, p.colum2, p.column3) from table1 p where p.column1 = 1;
select p.column1, p.colum2, p.column3 from table1 p where p.column1 = 1;
select user.id from user where id in (:ids); # do not put brackets around list argument;
select user.id from user where id in :ids; # no brackets is correct;
select  count(made_only_recharge) as made_only_recharge from ( select distinct (identifiant) as made_only_recharge from cdr_data where callednumber = '0130' select distinct (identifiant) as made_only_recharge from cdr_data where callednumber != '0130';
"select foo from bar where baz = @baz", yoursqlconnection;
end using end function;
end try end function end try end sub end sub end class;
if runscalar = true then end if end try if dbcon.state = connectionstate.open then dbcon.close() end sub end sub end class;
if (clientsparsed["objects"] is jarray clients) if (item["thisparameter"] as jtoken itemtoken);
if ((obj).type == jtokentype.array) else return new jarray(); // this will return an empty jarray;
if (token != null);
select max(len(description))from table_name;
select description from table_name group by description having max(len(description)) >27;
select max(len(columnname)) from table_name;
select max(datalength(columnname)) from table_name;
select max(length(desc)) from table_name;
select top 1 column_name, len(column_name) as lenght from table_name order by len(column_name) desc;
select id, [description], len([description]) as descriptionlength from [database1].[dbo].[table1] where len([description]) = from [database1].[dbo].[table1];
select max(datalength(desc)) from table_name;
select max(length(desc)) from table_name;
select max(length(desc)) from table_name;
select max(len(desc)) from table_name;
select max(len(desc)) as maxlen from table;
( select salesorderid, orderdate, row_number() over (order by orderdate) as 'rownumber' from sales.salesorderheader ) select * from orderedorders where rownumber between 51 and 60; --between is inclusive;
select a,b,c from from table) t0 where to.row_number between 1000 and 1100;
select * from sales.salesorderheader;
select * from [table-name] order by [column-name];
select * from personals order by id;
select customer.[customer id], customer.[full name] ...;
select "business name","other name" from your_table;
select [business name],[other name] from your_table;
select "business name","other name" from your_table;
select `business name` from annoying_table;
values  (current_timestamp);
values (to_timestamp(:ts_val, 'yyyy-mm-dd hh24:mi:ss'));
values (current_timestamp);
create table table1 ( id int identity(1, 1) not null, somecolmn varchar (5), lastchanged [timestamp] not null);
values (timestamp '2019-02-15 13:22:11.871+02:00');
values (timestamp '2017-10-12 21:22:23');
values ('dd-mm-yyyy hh-mm-ss am');
values (sysdate);
create trigger dbo.mytabletrigger on dbo.mytable, after insert, update as begin if not exists(select pk from otherdb.dbo.tablename where pk in (select fk from inserted) begin end  end;
create function dbo.fn_db2_schema2_tb_a as begin if exists ( select top 1 1 from db2.schema2.tb_a where column_key_1 =  @column1 set @exists = 1 end go alter table db1.schema1.tb_s add constraint chk_s_key_col1_in_db2_schema2_tb_a;
select * from sample_table order by rowid asc limit 1;
alter table [tablename] drop constraint [constraintname];
alter table table1 add constraint [constraintname] foreign key (column) references table2 (column) on update cascade on delete cascade;
alter table table add constraint [primary key] primary key(column1,column2,.....);
alter table your_table drop constraint activeprog_fkey1;
alter table your_table add constraint activeprog_fkey1 foreign key(activeprogcode) references program(activeprogcode);
set @columnlist = 'customerid, contactname, city' set @city = '''london''' set @sqlcommand = 'select ' + @columnlist + ' from customers where city = ' + @city exec (@sqlcommand);
set @columnlist = 'customerid, contactname, city' set @city = 'london' set @sqlcommand = 'select ' + @columnlist + ' from customers where city = @city';
set @thedate = '2010-01-01';
and ( tblwo.orderdate > dateadd(millisecond, -1, @thedate) and tblwo.orderdate < dateadd(day, 1, @thedate) );
set @thedate = '''2010-01-01'' and ''2010-08-31 23:59:59''' set @sql = 'select administratorcode, sum(total) as thetotal, sum(wod.quantity) as theqty, avg(total) as avgtotal, (select sum(tblwod.amount) from tblwod join tblwo on tblwod.orderid = tblwo.id where tblwo.approved = ''1'' and tblwo.administratorcode = tblwo.administratorcode and tblwo.orderdate between '+ @thedate +')';
exec sp_executesql;
alter table [dbo].[deductions]  with nocheck add  constraint [fk_deductions_employees_ce] foreign key([id], [fk_tid]) not for replication alter table [dbo].[deductions] nocheck constraint [fk_600_workcomments_employees_ce] alter table [dbo].[deductions]  with nocheck add  constraint [fk_deductions_employees_sn] foreign key([id], [fk_tid]) not for replication alter table [dbo].[deductions] nocheck constraint [fk_600_workcomments_employees_sn];
table 1 fruit table 2 meat table 3 entity's table 4 basket (table using fk_s);
select ... from table join ( select x.value(n'.',n'uniqueidentifier') as guid from @values.nodes(n'/guids/guid') t(x)) as guids;
select [hash], [d] from @original having count(*) > 1 delete o from @original o join @temp t on t.[hash] = o.[hash] and t.[d] = o.[d] select [hash], [d] from @temp select * from @original;
delete   from yourtable where    rowid not in ( select  min(rowid) from    yourtable hash );
create table tmp ... drop table t;
alter table tmp rename to t;
delete from table where something not in from      table as s;
create or replace function remove_duplicates(text, text) returns void as $$;
delete from table using table alias where table.field1 = alias.field1 and table.field2 = alias.field2 and;
delete from user_accounts using user_accounts ua2 where user_accounts.email = ua2.email and user_account.id < ua2.id;
create table ... as select distinct ... from ... ;
select remove_duplicates('mytable');
delete from table where ctid not in from table s;
create table test ( a text, b text );
select oid, a, b from test;
select o.oid, o.a, o.b from test o where exists ( select 'x' from test i where     i.a = o.a and i.b = o.b and i.oid < o.oid;
delete from test where exists ( select 'x' from test i where     i.a = test.a and i.b = test.b and i.oid < test.oid;
select pg_size_pretty(pg_relation_size('tbl'));
set temp_buffers = 200mb;   -- example value create temp table t_tmp as  -- retains temp for duration of session select distinct * from tbl  -- distinct folds duplicates select * from t_tmp;        -- retains order (implementation detail);
delete from tbl;
select distinct * from del;
delete from tablename where id in (select id from (select id, row_number() over (partition by column1, column2, column3 order by id) as rnum from tablename) t where t.rnum > 1);
create index othertable_idx on othertable( colname );
create table newtable as select distinct on (colname) col1,colname,col2 from othertable;
create temporary table t_tmp as select distinct * from tbl;
create table test (col text);
('2'), ('2'), ('3'), ('4'), ('4'), ('5'), ('6'), ('6');
delete from test where ctid in ( select t.ctid from ( select row_number() over ( partition by col ctid from test where t.rnum >1);
delete from mytable where ctid=(select ctid from mytable where [] limit 1);
delete from table_name where ctid not in ( select max(ctid) from table_name;
delete from tablename where id in (select id from (select id,row_number() over (partition by column1, column2, column3 order by id) as rnum from tablename) t where t.rnum > 1);
select id, rnum from num_of_rows where rnum > 1 num_of_rows as ( select id, row_number() over (partition by column1, column2, column3 order by id) as rnum from tablename ) delete from tablename where id in (select id from duplicate_ids);
where str.startswith("a") select str;
if (checkvalues.contains(myvalue));
where list.contains(row.value1) select row;
select * from table where fieldname in ('val1', 'val2');
select * from table where fieldname not in (1, 2);
where validvalues.contains(item.fieldname) select item;
where !validvalues.contains(item.fieldname) select item;
from item in items where list.contains(item) select item).toarray().;
case 1: case 2: case 3:;
if (thisstring.equals(val, stringcomparison.invariantcultureignorecase));
if (items == null) if (myvalue.in(1, 2, 3)) if (ds.in("andy", "joel", "matt"));
if (new[] {1,2,3,99}.contains(x));
from v in list where i.name.startswith(v) select i;
select salary from ( select  salary, row_number() over (order by salary desc) rn from employee;
( select employee_id, rownum = row_number() over (order by employee_id) from v_employee ) select  employee_id from    mycte where   rownum > 0;
select * from ( select row_number() over ( order by id) as 'row_number', * from tbl_contact_us where tbl.row_number = 5;
select  employee_id from    ( select  employee_id, row_number() over (order by employee_id) as rn from    v_employee where   rn > 0 employee_id;
( select   employee_id, rownum = row_number() over ( order by employee_id ) from     v_employee ) select  employee_id from    mycte where   rownum > 0;
select employee_id from  (select employee_id, row_number() from v_employee) tableexpressionsmusthaveanaliasfordumbreasons where rownumber > 0;
select t.employee_id, row_number() over ( order by t.employee_id ) 'rownum' from v_employee t) select er.employee_id from employee_rows er where er.rownum > 1;
select er.employee_id from (select t.employee_id, row_number() over ( order by t.employee_id ) 'rownum' from v_employee t) er where er.rownum > 1;
select object_id, row_number() over ( order by object_id) rn from sys.objects) select object_id from object_rows where rn > 1 select object_id from (select object_id, row_number() over ( order by object_id) rn from sys.objects) t where rn > 1;
set nocount on set nocount off set @pagenumber=3 set @pagesize=5 set @sortby=1 select rowid,value1,value2,value3 end as rownumber from @yourtable ) select rowid,value1,value2,value3,rownumber from paginatedyourtable where rownumber>=(@pagenumber-1)*@pagesize and rownumber<=(@pagenumber*@pagesize)-1 select rowid,value1,value2,value3 ( order by case @sortby end asc end desc from @yourtable ) select rowid,value1,value2,value3,rownumber from paginatedyourtable where rownumber>=(@pagenumber-1)*@pagesize and rownumber<=(@pagenumber*@pagesize)-1 case @sortby end asc end desc;
select col.* from   sys.columns col where  col.[object_id] = object_id(n'dbo.tablename') and    col.[collation_name] is not null;
select * from   sys.fn_helpcollations() col where  col.[name] like n'{currentcollationminus"_bin"}[_]ci[_]%';
select * from   sys.fn_helpcollations() col where  col.[name] like n'japanese_xjis_100[_]ci[_]%';
select * from mytable where lcase(myfield) like lcase('someval');
select * from mytable where myfield = 'someval' collate sql_latin1_general_cp1_ci_as;
select balance from people where email = 'billg@microsoft.com';
select * from mytable where convert(varbinary, myfield) = convert(varbinary, 'someval');
select 'currently, ' from v$license vl;
select 'currently, ' from v$parameter vp where vp.name = 'sessions';
select name, value from v$parameter where name = 'sessions';
select count(*) from v$session;
select count(*),sum(decode(status, 'active',1,0)) from v$session where type= 'user';
select current_utilization, limit_value from v$resource_limit where resource_name='sessions';
select resource_name, current_utilization, max_utilization, limit_value from v$resource_limit where resource_name in ('sessions', 'processes');
select v.*, row_number() over (partition by id order by elem) rn from unnest(string_to_array(elements, ',')) as elem from mytable) v;
select id, elem, row_number() over (partition by id) as nr from ( select id, unnest(string_to_array(elements, ',')) as elem from mytable;
select t.id, a.elem, <b>a.nr</b> from   tbl as t;
select t.id, a.elem, a.nr from   tbl t, unnest(string_to_array(t.elements, ',')) with ordinality a(elem, nr);
select t.id, a.elem, a.nr from   tbl t, unnest(t.arr) with ordinality a(elem, nr);
select id, a, ordinality from   tbl, unnest(arr) with ordinality a;
select *, row_number() over (partition by id) as nr from  (select id, regexp_split_to_table(elements, ',') as elem from tbl) t;
select id, arr[nr] as elem, nr from  ( select *, generate_subscripts(arr, 1) as nr from  (select id, string_to_array(elements, ' ') as arr from tbl) t;
select id, arr[nr] as elem, nr from  (select *, generate_subscripts(<b>arr</b>, 1) as nr from tbl) t;
create function f_unnest_ord(anyarray, out val anyelement, out ordinality integer) from   generate_series(array_lower($1,1), array_upper($1,1)) i';
create function f_unnest_ord_idx(anyarray, out val anyelement, out ordinality int, out idx int) from   generate_series(array_lower($1,1), array_upper($1,1)) i';
select id, arr, (rec).* from  ( select *, f_unnest_ord_idx(arr) as rec from  (values (1, '{a,b,c}'::text[])  --  short for: '[1:3]={a,b,c}';
create function unnest2(anyarray) select $1[i], i from   generate_series(array_lower($1,1), array_upper($1,1)) i;
select id from ( select from ( select from mytable;
select id from ( select from mytable;
select wpoi.order_id as no_commande from  wp_woocommerce_order_items as wpoi and wpp.meta_key = '_shipping_first_name' where  wpoi.order_id =2198;
select wp_woocommerce_order_items.order_id as no_commande from  wp_woocommerce_order_items ( select meta_value as prenom, post_id  -- <----- this from wp_postmeta where meta_key = '_shipping_first_name' where  wp_woocommerce_order_items.order_id =2198;
create table t( id int identity(1,1) primary key, number int, name8000 varchar(8000), name500 varchar(500)) select number, name, name /*<--same contents in both cols*/ from master..spt_values select id,name500 from t;
select id,name8000 from t;
if ( $this->connection === null );
if (empty($this->db));
create table test1(id serial, x integer);
create index test1_x on test1 (x);
create table test2(id serial, x integer);
create index test2_x on test2 (x);
create table #t1 ( id int not null, val1 varchar(10) null ) create table #t2 ( id int not null, val1 varchar(10) null ) select * from #t1 t1 inner join #t2 t2 on t1.id = t2.id and t1.val1 = t2.val1;
select * from #t1 t1 inner join #t2 t2 on t1.id = t2.id and (t1.val1 = t2.val1 or t1.val1 is null and t2.val1 is null);
set ansi_nulls off;
set ansi_nulls off select * from sys.tables where principal_id = null;
set ansi_nulls on select * from sys.tables where principal_id = null;
set @tempvariable = null set ansi_nulls on select 'no rows if set ansi_nulls on' where    @tempvariable = null set ansi_nulls off select 'there will be a row if ansi_nulls off' where    @tempvariable =null;
create table #temptable (sn int, ename varchar(50)) values (1, 'manoj'), (2, 'pankaj'), (3, null), (4, 'lokesh'), (5, 'gopal');
select * from #temptable where ename is null -- (1 row(s) affected) select * from #temptable where ename = null -- (0 row(s) affected) select * from #temptable where ename is not null -- (4 row(s) affected) select * from #temptable where ename <> null -- (0 row(s) affected);
select * from #temptable where ename is null -- (1 row(s) affected) select * from #temptable where ename = null -- (1 row(s) affected) select * from #temptable where ename is not null -- (4 row(s) affected) select * from #temptable where ename <> null -- (4 row(s) affected);
feedentry.table_name, feedentry.column_name_nullable, values);
feedreaderdbhelper.feedentry.table_name, values, selection, selectionargs);
exists = (cursor.getcount() > 0);
exists = (cursor.getcount() > 0);
cursor.getstring(cursor.getcolumnindex(dbhelper.cart_dish_id)), cursor.getstring(cursor.getcolumnindex(dbhelper.cart_dish_name)), cursor.getstring(cursor.getcolumnindex(dbhelper.cart_dish_qty)), integer.parseint(cursor.getstring(cursor.getcolumnindex(dbhelper.cart_dish_price))) if (totalamount == 0.0) else return "" + totalamount;
if (cursor.getcount() > 0) {;
update [your table] set [your column]=value;
update foo set bar=125;
delete from articles where id in from (select id from articles where user_id = :userid and user_id = :userid;
select  @thresholdid = userpasswordhistoryid from ( select row_number() from userpasswordhistory where userid = @userid where   (rownum = 10) -- keep this many records. delete  userpasswordhistory where   (userid = @userid) and (userpasswordhistoryid < @thresholdid);
delete from tablename where id < (select * from (select (max(id)-10) from tablename ) as a);
select * from table del;
delete from `test_sandbox` where id <= ( select id from ( select id from `test_sandbox` limit 1 offset 42 -- keep this many records );
delete from table where access_time >= ( select access_time from ( select access_time from table );
delete from table_name order by id limit 10;
select @rows_to_delete := count(*) - nnn from `thetable`;
select @rows_to_delete := if(@rows_to_delete<0,0,@rows_to_delete);
delete from `table` where id not in ( select id from ( select id from `table` limit 42 -- keep this many records;
delete from table where id not in;
delete  i1.* from    items i1 ( select  id from    items ii id desc limit 20 where   i2.id is null;
delete from table where id < (select max(id) from table)-n;
delete from table where id not in ( select id from table order by id, desc limit 0, 10 );
delete from mytable where id not in (select max(id) from mytable);
delete from mytable where id not in;
select id from mytable order by id desc limit n;
delete from mytable where id not in ( ...comma-separated string... );
delete from `table` where id not in ( select id from ( select id from `table` limit 42 -- keep this many records;
delete from table order by id desc limit 1, 123456789;
delete from [table] select [id] from ( select [id] from [table] limit n;
select * from ( select  2 as rtype,v.id as vtype, date_format(entdt, ''%d-%m-%y'')  as entdt,v.name as vouchertype,voucherno,round(if((dr_cr)>0,(dr_cr),0),0) as dr ,round(if((dr_cr)<0,(dr_cr)*-1,0),2) as cr ,round((dr_cr),2) as balamt, if(d.narr is null or d.narr='''',t.narration,d.narr) as narration from trans_m as t join trans_dtl as d on(t.id=d.transid) join acc_head l on(d.acc_id=l.id) join vouchertype_m as v on(t.vouchertype=v.id) where t.cmpid=',companyid,' and  d.acc_id=',ledgerid ,' and t.entdt>=''',fromdate ,''' and t.entdt<=''',todate ,''' ',vtype,';
create function ifempty(s text, defaultvalue text);
select ifempty(field1, 'empty') as field1 from tablename;
select if(ifnull(field1, '') = '', 'empty', field1) as field1 from tablename;
select ifnull(nullif(field1,''),'empty') as field1 from tablename;
select if(field1 is null or field1 = '', 'empty', field1) as field1 from tablename;
select case when field1 is null or field1 = '' then 'empty' else field1 end as field1 from tablename;
select case when field1 is null or field1 = '' then 'empty' else field1 end as field1 from tablename.;
if ('' !== $ertom['yourrowname']) {;
select col5,col6,col7,col8 from db1.table2;
create table todatabasename.totablename as select * from fromdatabasename.fromtablename;
column1 ) select column1 from [mydb2].dbo.mytable2 --where any condition select * from opendatasource ( 'sqlncli';
exec sp_addlinkedsrvlogin 'nameoflinkedserver', 'false', null, 'remoteusername', 'remoteuserpassword';
select * from sys.servers;
exec sp_testlinkedserver n'nameoflinkedserver';
select * into newtable from [linkedserver\instance].remotedatabase.remoteschema.remotetable;
select  * from    localtable;
select  * from    [linkedserver\instance].remotedatabase.remoteschema.remotetable;
create table database1.employees as select * from database2.employees;
select field1, field2, field3 from sourcedatabase.dbo.sourcetable where (some condition);
select  * from    mytable;
select * from table1 where columnname like 'a%' collate utf8_bin;
select @@servername;
select @@servicename;
@key = 'software\microsoft\microsoft sql server', @value_name = 'installedinstances';
select convert(sysname, serverproperty('servername'));
@key='software\microsoft\microsoft sql server\instance names\sql', @value_name='mssqlserver';
select serverproperty ('instancename');
select @@servername;
select @@servicename;
select * from sys.servers;
select * from sys.databases;
select serverproperty('servername') as servername, serverproperty('machinename') as machinename, case when  serverproperty('instancename') is null then '' else serverproperty('instancename') end as instancename, '' as port, --need to update to strip from servername. note: assumes registered server is named with port serverproperty('productversion') as productversion, serverproperty('productlevel') as productlevel, serverproperty('productmajorversion') as productmajorversion, serverproperty('productminorversion') as productminorversion, serverproperty('productbuild') as productbuild, serverproperty('edition') as edition, case serverproperty('engineedition') end as engineedition, case serverproperty('ishadrenabled') else 'not applicable' end as hadrenabled, case serverproperty('hadrmanagerstatus') else 'not applicable' end as hadrmanagerstatus, case serverproperty('issingleuser') when 0 then 'no' else 'yes' end as insingleusermode, case serverproperty('isclustered') else 'not applicable' end as isclustered, '' as serverenvironment, '' as serverstatus, '' as comments;
( select 'rm1' as rm, 'adr1' as adr union all select 'rm1' as rm, 'adr1' as adr union all select 'rm2' as rm, 'adr1' as adr union all select 'rm2' as rm, 'adr2' as adr union all select 'rm2' as rm, 'adr2' as adr union all select 'rm2' as rm, 'adr3' as adr union all select 'rm3' as rm, 'adr1' as adr union all select 'rm2' as rm, 'adr1' as adr union all select 'rm3' as rm, 'adr1' as adr union all select 'rm3' as rm, 'adr2' as adr ) ( select rm, adr, dense_rank() over(partition by rm order by adr) as dr from basetable ) select rm from cte;
-- which only happens if there were rows where [include] <> 'y' partition by [mth] ) partition by [mth] );
select  datekey, coalesce(runningtotal, 0) as runningtotal, coalesce(runningcount, 0) as runningcount, coalesce(runningdistinctcount, 0) as runningdistinctcount from    document count(1) as runningcount, count(distinct d2.datekey) as runningdistinctcount from    document d2 where   d2.datekey <= document.datekey;
select  datekey, sum(amount) over(order by datekey) as runningtotal from    document;
select t1.* from table1 t1 join ( select category, max(date) as maxdate from table1 and t1.date = t2.maxdate;
select distinct first_value("id") over (partition by "category" order by "date" desc) from table1;
select id from ( select id, row_number() over (partition by "category" order by "date" desc) as rownum from table1 where rownum = 1;
select distinct on (category) from   tbl;
select suppliers.* from suppliers join orders;
select suppliers.* from suppliers join orders using supplier_id;
where id in (25,26,27) -- and so on;
where exists (select * from orders where suppliers.supplier_id = orders.supplier_id);
select s.* from suppliers s where exists (select 1/0 from orders o where o.supplier_id = s.supplier_id);
select s.supplier_id from suppliers s select s.supplier_id from suppliers s where exists (select * from orders o where o.supplier_id = s.supplier_id) select s.supplier_id from suppliers s where s.supplier_id in (select o.supplier_id from orders o) select s.supplier_id from suppliers s select o.supplier_id from orders o;
select student_grade.student_id from student_grade where student_grade.grade = 10 and student_grade.student_id;
select id, first_name, last_name from student where exists ( select 1 from student_grade where student_grade.student_id = student.id and );
( column1 int, column2 int, someint int, somevarchar nvarchar(50) select column1, column2, someint, somevarchar from table2 where table2.id = 7;
select * from t;
select date_add( '2009-01-01', interval @num := @num+1 day) as date_sequence, your_table.* from your_table where your_table.other_column is not null having date_add('2009-01-01', interval @num day) <= '2009-01-13';
create table all_dates ( dt date primary key;
create table num (i int);
select adddate('2009-01-01', numlist.id) as `date` from from num n1 cross join num as n10 cross join num as n100) as numlist where adddate('2009-01-01', numlist.id) <= '2009-01-13';
select * from time_intervals select * from time_intervals create procedure make_intervals(startdate timestamp, enddate timestamp, intval integer, unitval varchar(10)) set thisdate = startdate;
drop temporary table if exists time_intervals;
create temporary table if not exists time_intervals ( interval_start timestamp, interval_end timestamp select case unitval end into nextdate;
set thisdate = nextdate;
select * from ( select dateadd(d, number - 1, '2009-01-01') as dt from numbers where number between 1 and datediff(d, '2009-01-01', '2009-01-13') + 1;
set @datefrom = '2010-08-10' set @dateto = '2010-09-11' @holder values (@datefrom) select @datefrom = dateadd(d, 1, @datefrom) values (@datefrom) end  select date from @holder;
select cast(dayname(daydate) as char) as dayname,daydate from (select cast((date_add('20110101', interval h.i*100 + t.i*10 + u.i day) )as date) as daydate from erp_integers as h join erp_integers as t join erp_integers as u where date_add('20110101', interval h.i*100 + t.i*10 + u.i day ) <= '20110228';
set @tempdate=date('2011-07-01') - interval 1 day;
select date(@tempdate := (date(@tempdate) + interval 1 day)) as thedate from mytable x,mytable y having thedate <= '2011-07-31';
select time_day_ref.greg_dt from temprundates, time_day_ref where time_day_ref.greg_dt>=temprundates.fromdate and greg_dt<=temprundates.todate;
set @startdate = '2011-01-01' set @enddate = '2011-01-31';
( select @startdate as date union all select dateadd(d,1,[date]) from dates where date < @enddate ) select date from dates;
create procedure dates_between (in from_date datetime, in to_date datetime) begin ( select from_date as date union all select date_add(date, interval 1 day) from dates where date < to_date ) select date(date) from dates;
create function [dbo].[_dates] ( @startdate datetime, @enddate datetime ) date1 datetime ) as begin select @startdate select @startdate = dateadd(d,1,@startdate) end return end;
set @d := '2011-09-01';
select @d as d, cast( @d := date_add( @d , interval 1 day ) as date ) as new_d from [yourtable] where @d <= '2012-05-01';
select * from table_name where col_date between '2011/02/25' and dateadd(s,-1,dateadd(d,1,'2011/02/27'));
create procedure popula_calendario_controle() set first_day_of_year = concat(date_format(curdate(),'%y'),'-01-01');
if dayofweek(adddate(first_day_of_year,a)) <> 1 then end if;
if a=365 then end if;
end loop one_by_one;
create procedure `get_amount_subscription_per_month`() select @startdate := min(date_format(a.startdate, "%y-%m-01")), @enddate := max(date_format(a.enddate, "%y-%m-01")) + interval 1 month from subscription a;
drop table if exists tmp_months;
create temporary table tmp_months ( year_month date, primary key (year_month) set @tempdate=@startdate;  #- interval 1 month;
set @tempdate = (date(@tempdate) + interval 1 month);
select year_month from tmp_months;
select mnd.year_month, sum(subscription.amount) as subscription_amount from tmp_months mnd end;
select '2019-01-01' as dt union select date_add(t.dt, interval 1 day) from t where date_add(t.dt, interval 1 day) <= '2019-04-30' ) select * from t;
select cast(cal.date_list as date) day_year from ( select subdate('2019-01-01', interval 1 year) + interval xc day as date_list from ( select @xi:=@xi+1 as xc from (select 1 union select 2 union select 3 union select 4) xc2, (select 1 union select 2 union select 3 union select 4) xc3, (select 1 union select 2 union select 3 union select 4) xc4, (select 1 union select 2 union select 3 union select 4) xc5, (select @xi:=-1) xc0 where cal.date_list between '2019-01-01' and '2019-12-31';
select * from primarytable p where not exists (select * from secondarytable s where p.pkcol = s.fkcol);
select p.* from primary_table p left join second s on p.id = s.id where s.id is null;
select p.* from primary_table p where s.p_id is null;
select id, fname from firsttable select id, sname from secondtable;
select <select_list> from table_a a where b.key is null;
select * from table1 where id not in (select id from table2);
update table1 set column1 = ( select column2 from table2 where table2.id = table1.id;
update tblindiantime set countryname = contacts.businesscountry from contacts where tblindiantime.contact_id = contacts.id;
update tblindiantime set tblindiantime.countryname = contacts.businesscountry from tblindiantime join contacts;
select businesscountry from contacts;
update tblindiantime t set countryname = (select c.businesscountry from contacts c where c.key = t.key );
update table_name set column1 = column2;
update table_name1 set column1 = ( select column2 from table_name2 where table_name1.id = table_name2.id;
select contacts.businesscountry from contacts c where c.key = t.key;
update tblindiantime t set countryname=resultvalue.businesscountry where t.key=resultvalue.key;
exec sp_configure 'clr enabled' ,1 exec sp_configure 'clr enabled'   -- make sure it took exec sp_changedbowner 'sa' alter database <database> set trustworthy on;
select name, case when value = 1 then 'yes' else 'no' end as 'enabled' from sys.configurations where name = 'clr enabled';
select * from sys.configurations where name = 'clr enabled';
select * from sys.configurations where name = 'clr enabled';
if not exists( select value from sys.configurations where name = 'clr enabled' and value = 1 ) exec sp_configure @configname=clr_enabled, @configvalue=1 end;
select reportid, email = from your_table b where b.reportid = a.reportid from your_table a;
select  [reportid], substring(d.emaillist,1, len(d.emaillist) - 1) emaillist from ( select distinct [reportid] from table1 ( select [email] + ', ' from table1 as b where a.[reportid] = b.[reportid];
if (reader != null);
if (reader != null);
select * from test order by len(field);
select * from test order by length(description) desc;
select * from test order by char_length(description) desc;
select * from test order by char_length(description);
select @id = min(id) from @ids exec p_myinnerprocedure @id delete from @ids where id = @id end;
where id > @id) select @id = min(id) from @ids where id > @id exec p_myinnerprocedure @id end;
select 4 union select 7 union select 12 union select 22 union select 19 select @i = min(idx) - 1, @cnt = max(idx) from @ids select @i = @i + 1 exec p_myinnerprocedure @id end;
set @comma_delimited_list = '4,7,12,22,19' set @cursor = cursor static for select convert(int, value) as id from dbo.split(@comma_delimited_list) a if @@fetch_status <> 0 break end -- not strictly necessary w/ cursor variables since they will go out of scope like a normal var;
id int identity(1,1) ) select parameter from some_table where some_condition -- here you populate your parameters select @i = min(id), @n = max(id) from @calls select @myid = parameter from @calls where id = @i set @i = @i+1 end;
select @i=0, @list ='4,7,12,22,19,' select  @item = substring(@list,  @i,charindex(',',@list,@i)-@i) select @item exec p_myinnerprocedure @item set @i = charindex(',',@list,@i)+1 end;
create table #listofids (idvalue int) set @ids = @originallistofids + ',' set @id = substring(@ids, 0, charindex(',', @ids));
set @ids = replace(',' + @ids, ',' + @id + ',', '') end  select * from #listofids;
exec p_myinnerprocedure {};
select * from tablea union select * from tableb select * from tablea select * from tableb;
set ansi_nulls on set quoted_identifier on create procedure [dbo].[ps_tablegap] as begin set nocount on;
if @fld2 = '' set @fld2 = @fld1 set @fldtmp = @fldtmp + (select substring(@fld2,1,charindex(',',@fld2)-1) + ' as _' + substring(@fld2,1,charindex(',',@fld2)-1) + ',') set @fld2 = (select ltrim(right(@fld2,len(@fld2)-charindex(',',@fld2)))) end set @fldtmp = @fldtmp + @fld2 + ' as _' + @fld2 set @fld2 = @fldtmp set @nloop = 1 set @sql = 'declare crsr cursor for select column_name from information_schema.key_column_usage where table_name = ''' if @nloop = 1 set @pk = 's.' + @strtmp + ' = b._' + @strtmp set @pk1 = @strtmp set @nloop = @nloop + 1 end else set @pk = @pk + ' and s.' + @strtmp + ' = b._' + @strtmp end close crsr set @sql = 'select case when s.' + @pk1 + ' is null then ''del'' when b._' + @pk1 + ' is null then ''add'' else ''gap'' end as typerr, ''' set @sql = @sql + @tbl1 +''' as tbl1, s.*, ''' + @tbl2 +''' as tbl2 ,b.* from (select ' + @fld1 + ' from ' + @tbl1 set @sql = @sql + ' except select ' + @fld2 + ' from ' + @tbl2 + ')s full join (select ' + @fld2 + ' from ' + @tbl2 set @sql = @sql + ' except select ' + @fld1 + ' from ' + @tbl1 +')b on '+ @pk end;
select t1.id, t1.id from t1 inner join t2 using (id) where concat(t1.c, t1.d, ...)<>concat(t2.c, t2.d, ...);
select * from tablea select * from tableb;
select col1, col2, col3 from (select * from tablea union all select * from tableb) data having count(*)!=2;
( select 'intablea_nomatchintableb' as msg, * from tablea select 'intablea_nomatchintableb' , * from tableb ) union all ( select 'intableb_nomatchintablea' as msg, * from tableb select 'intableb_nnomatchintablea' ,* from tablea );
if (object_id('tempdb..#col') is not null) drop table #col select  identity(int, 1, 1) rownum , c.name from    sys.objects o join sys.columns c on o.object_id = c.object_id where   o.name = @table1 and not c.name in ('list','columns','youwanttoignore') set @colname = (select name from #col where rownum= @counter) exec ('select  t1.identifier from    '+@table1+' t1 where   t1.'+@colname+' <> t2.'+@colname) set @counter = @counter - 1 end;
set nocount on select  left(@tablea_threepartname,charindex('.',@tablea_threepartname) - 1)) select  right(@tablea_threepartname,len(@tablea_threepartname) - charindex('.',@tablea_threepartname,len(@database_a) + 2))) select  replace(replace(@tablea_threepartname,@database_a + '.',''),'.' + @table_a,'')) select  left(@tableb_threepartname,charindex('.',@tableb_threepartname) - 1)) select  right(@tableb_threepartname,len(@tableb_threepartname) - charindex('.',@tableb_threepartname,len(@database_b) + 2))) select  replace(replace(@tableb_threepartname,@database_b + '.',''),'.' + @table_b,'')) select  column_name from  information_schema.columns where  table_name = ''' + @table_a + ''' and  table_schema = ''' + @schema_a + ''' create table #table_a_details ( columnname nvarchar(max) ) exec (@gettableadetails) select  column_name from  information_schema.columns where  table_name = ''' + @table_b + ''' and  table_schema = ''' + @schema_b + ''' create table #table_b_details ( columnname nvarchar(max) ) exec (@gettablebdetails) select  row_number() over (order by from  #table_a_details a where  a.columnname is null or  b.columnname is null or  a.datatype <> b.datatype drop table  #table_a_details drop table  #table_b_details select  coalesce(a_columnname,b_columnname) as columnname from  #fieldlist create table #datavariances ( tablekey            nvarchar(max) ) delete from #fieldlist where a_datatype in ('varbinary','image') or b_datatype in ('varbinary','image') set @testsql = ' select  coalesce(a.[' + @keyname + '],b.[' + @keyname + ']) as tablekey from  [' + @database_a + '].[' + @schema_a + '].[' + @table_a + '] a where  ltrim(rtrim(a.[' + @thisfield + '])) <> ltrim(rtrim(b.[' + @thisfield + '])) or (a.[' + @thisfield + '] is null and  b.[' + @thisfield + '] is not null) or (a.[' + @thisfield + '] is not null and  b.[' + @thisfield + '] is null) exec (@testsql) set @rownumber = @rownumber + 1 set @thisfield = (select coalesce(a_columnname,b_columnname) from #fieldlist a where rowkey = @rownumber) end  drop table #fieldlist;
set @sql = select ''' + @table1 + ''' as table_name,* from ( select * from ' + @table1 + ' select * from ' + @table2 + ' union  select ''' + @table2 + ''' as table_name,* from ( select * from ' + @table2 + ' select * from ' + @table1 + ' exec sp_executesql @stmt = @sql;
select * from ( select * from tablea select * from tableb ) union all select * from ( select * from tableb select * from tablea );
select c.id from clients c where exists(select c2.id from clients2 c2 where c2.id = c.id);
select unnest(array[1,2,2,3,3]) select unnest(array[1,1,2,3,3]) union select unnest(array[1,1,2,3,3]) select unnest(array[1,2,2,3,3]);
( select unnest(array[1,2,2,3]) select unnest(array[2,1,2,3]) ) union ( select unnest(array[2,1,2,3]) select unnest(array[1,2,2,3]) );
select * from a where a.field1!=b.field1 or a.field2!=b.field2 or a.field3!=b.field3 or a.field4!=b.field4;
select t1.col1,t1.col3,t1.col5 from s.t1;
select t2.col1,t2.col3,t2.col5 from s.t1;
select t1.col1,t1.col3,t1.col5 from s.t1 select t2.col1,t2.col3,t2.col5 from s.t1;
select * from table a where not exists (select 'x' from  table b where b.keyfield1 = a.keyfield1 and   b.keyfield2 = a.keyfield2 and   b.keyfield3 = a.keyfield3);
select * from ( select column1, column2, ..., count(*) as the_count from tablea select column1, column2, ..., count(*) as the_count from tableb ) union all ( select column1, column2, ..., count(*) as the_count from tableb select column1, column2, ..., count(*) as the_count from tablea );
select t1.*, t2.* from t1 full outer join t2 on t1.pk=t2.pk where t1.pk is null or t2.pk is null;
select t1.pk, 'a' as columnname, t1.a as leftvalue, t2.a as rightvalue from t1 join t2 on t1.pk=t2.pk where coalesce(t1.a,0) != coalesce(t2.a,0) union all select t1.pk, 'b' as columnname, t1.b as leftvalue, t2.b as rightvalue from t1 join t2 on t1.pk=t2.pk where coalesce(t1.b,0) != coalesce(t2.b,0);
select concat('select t1.pk, ''', column_name, ''' as columnname, t1.', column_name, ' as leftvalue, t2.', column_name, ' as rightvalue from t1 join t2 on t1.pk=t2.pk where coalesce(t1.',column_name, ',0)!=coalesce(t2.', column_name, ',0)') from information_schema.columns where table_name='t1' and data_type in ('nvarchar','varchar');
select t1.*, t2.*, case when t1 is null or t2 is null then 'not equal' else 'equal' end from t1;
select * from (select 't1' as t1, t1.* from t1) t1 where t1 is null or t2 is null -- show differences;
select date(my_date);
select date(somedate);
select date_format(your_date, '%y-%m-%d');
select now()::timestamp(0);
select cast (now() as timestamp(0));
create table t ( x int primary key, y int, z char(8000) ) create nonclustered index narrowindex on t(y) if exists (select * from t);
select col1 from mytable where exists (select * from table2 where mytable.col1=table2.col2);
select primary_key;
select other_not_null_column;
select not null col;
set showplan_text on;
select count(1) from master..spt_values;
select @v=1 where exists (select 1 from ##t) option(recompile);
create user blat without login;
create table dbo.t ( x int primary key, y int, z char(8000) ) select 1 where  exists (select 1 from   t);
drop user blat drop table t;
select some_not_null_col;
select whatever from yourtable where exists( select 1/0 from someothertable where a_valid_clause );
select * from table_name order by unique_column desc limit 1;
select whatever,columns,you,want from mytable where mykey=(select max(mykey) from mytable);
select top 1 * from table_name order by unique_column desc;
select top 1 column_name from table_name order by column_name desc;
select top 1 column_name from table_name;
select last(column_name) from table;
select last(id) from status;
select * from employees where [employee id] = all (select max([employee id]) from employees);
set tkt = addzone &'-'& customer_code &'-'& sn where sn in (select max(sn) from compalints );
select * from  table where id = (select max(id)  from table);
select ident_current('tablename');
select * from table where id = (select max(id) from table);
select max(workflowstatestatusid) from workflowstatestatus;
set @i=1 select workflowstatestatusid from workflow.workflowstatestatus where workflowstatestatusid not in (select top ( (select count(*) from workflow.workflowstatestatus) - @i ) workflowstatestatusid from .workflowstatestatus);
select top 1 sys.fn_physlocformatter(%%physloc%%) as [file:page:slot], t.* from mytable as t;
select * from table where id not in (select top (select count(1)-1 from table) from table);
select id from comission_fees order by id desc limit 1;
select last_value(column) over (partition by column order by column)...;
select distinct t.contractid, last_value(t.price)over(partition by t.contractid order by created rows between current row and unbounded following) from [dbo].[tick] as t where t.ticktype=4;
select * from table_name;
alter table your_table modify column registration_no int;
replicate(' ', len(lb5low) - len(lb2low)) + convert(nvarchar(4), lb2low) + '" to ' + convert(nvarchar(4), lb2high) + '"' as l2text, replicate(' ', len(lb5low) - len(lb3low)) + convert(nvarchar(4), lb3low) + '" to ' + convert(nvarchar(4), lb3high) + '"' as l3text, replicate(' ', len(lb5low) - len(lb4low)) + convert(nvarchar(4), lb4low) + '" to ' + convert(nvarchar(4), lb4high) + '"' as l4text, convert(nvarchar(4), lb5low) + '" and over' as l5text;
select @source.stdistance(@target);
set @orig_lat=53.381538 set @orig_lng=-1.463526 select *, @orig.stdistance(geography::point(dest.latitude, dest.longitude, 4326)) as distance from #orig dest;
create function [dbo].[distancekm] ( @lat1 float(18), @lat2 float(18), @long1 float(18), @long2 float(18) ) as begin set @r =  6367.45 set @dlat = radians(@lat2 - @lat1);
set @dlon = radians(@long2 - @long1);
set @a = sin(@dlat / 2) set @c = 2 * asin(min(sqrt(@a)));
set @d = @r * @c;
create function [dbo].[fncalcdistancemiles] (@lat1 decimal(8,4), @long1 decimal(8,4), @lat2 decimal(8,4), @long2 decimal(8,4)) set @lat1 = @lat1 / 57.2958 set @long1 = @long1 / 57.2958 set @lat2 = @lat2 / 57.2958 set @long2 = @long2 / 57.2958 set @d = (sin(@lat1) * sin(@lat2)) + (cos(@lat1) * cos(@lat2) * cos(@long2 - @long1)) if @d <> 0 set @d = 3958.75 * atan(sqrt(1 - power(@d, 2)) / @d);
end return @d end;
create function dbo.fncalcdistancekm(@lat1 float, @lat2 float, @lon1 float, @lon2 float) as begin end;
set @g = geography::stgeomfromtext('linestring(-122.360 47.656, -122.343 47.656)', 4326);
set @h = geography::stgeomfromtext('point(-122.34900 47.65100)', 4326);
select @g.stdistance(@h);
select [dbo].[fncalcdistancekm](13.077085,80.262675,13.065701,80.258916);
create function get_distance ( @la1 float , @lo1 float , @la2 float, @lo2 float ) as return select geography::point(@la1, @lo1, 4326).stdistance(geography::point(@la2, @lo2, 4326)) as distance;
select distance from place p1, place p2, outer apply dbo.get_distance(p1.latitude, p1.longitude, p2.latitude, p2.longitude);
select geography::point(latitude_1, longitude_1, 4326).stdistance(geography::point(latitude_2, longitude_2, 4326));
select geography::point(53.429108, -2.500953, 4326).stdistance(geography::point(c.latitude, c.longitude, 4326)) from coordinates c;
update yourtable set column1 = replace(column1,'a','b') where column1 like '%a%';
update table_name set column_name=replace(column_name,'text_to_find','replace_with_this');
set title=replace(title,'script','a'); commit transaction;
update yourtable set column1 = replace(cast(column1 as nvarchar(max)),'a','b') where column1 like '%a%';
select name from master.dbo.sysdatabases where name not in ('master','model','msdb','tempdb')  -- exclude these databases set nocount on set @searchstr = 'search string' set @replacestr = 'replace string' set @searchstr2 = quotename('%' + @searchstr + '%','''') set  @tablename = '' set @columnname = '' set @sql = 'use ' + @databasename + ' select @result = min(quotename(table_schema) + ''.'' + quotename(table_name)) from    [' + @databasename + '].information_schema.tables where       table_type = ''base table'' and table_catalog = ''' + @databasename + ''' and quotename(table_schema) + ''.'' + quotename(table_name) > ''' + @tablename + ''' and objectproperty( object_id( quotename(table_schema) + ''.'' + quotename(table_name) exec master..sp_executesql @sql, n'@result nvarchar(256) out', @result out set @tablename = @result set @sql = ' select @columnresult = min(quotename(column_name)) from    [' + @databasename + '].information_schema.columns where       table_schema    = parsename(''[' + @databasename + '].' + @tablename + ''', 2) and table_name  = parsename(''[' + @databasename + '].' + @tablename + ''', 1) and data_type in (''char'', ''varchar'', ''nchar'', ''nvarchar'') and table_catalog = ''' + @databasename + ''' and quotename(column_name) > ''' + @columnname + '''' exec master..sp_executesql @sql, n'@columnresult nvarchar(256) out', @columnresult out set @columnname = @columnresult if @columnname is not null exec ( 'use ' + @databasename + ' select ''' + @tablename + ''',''' + @columnname + ''',''' + @tablename + '.' + @columnname + ''', left(' + @columnname + ', 3630) from ' + @tablename + ' (nolock) ' + ) end end end  select tablename, realcolumnname from @results group by tablename, realcolumnname set @mycursor = cursor for select tablename, realcolumnname from @time_to_update group by tablename, realcolumnname set @sqlcommand = ' update [' + @databasename + '].' + @t + ' set ' + @c + ' = replace(' + @c + ', ''' + @searchstr + ''', ''' + @replacestr + ''') where ' + @c + ' like ''' + @searchstr2 + '''' exec (@sqlcommand) end try end catch delete from @time_to_update delete from @results end ;
create function dbo.getsitepermissions(@regionid int, @optpersonid int, optsiteid int) as return select distinct siteid, personid from dbo.siteviewpermissions where (@optpersonid is null or @optpersonid = personid) and (@optsiteid is null or @optsiteid = siteid) and @regionid = regionid;
select * from dbo.getsitepermissions(@regionid) where siteid = 1;
select function_name(field1) from table;
select * from dbo.tvfverylargeresultset1(@myvar1) tvf1;
select * from table where cast(column as nvarchar(max)) like '%test%';
select * from where [xmldatastring] like '%test%';
select * from webpagecontent where data.value('(/pagecontent/text)[1]', 'varchar(100)') like 'xyz%';
select substring(data.value('(/pagecontent/text)[1]', 'varchar(100)'),patindex('%north%',data.value('(/pagecontent/text)[1]', 'varchar(100)')) - 20,999) from webpagecontent where coalesce(patindex('%north%',data.value('(/pagecontent/text)[1]', 'varchar(100)')),0) > 0;
select distinct column 1, column 2, ... from table_name;
select item, min(data) from  table;
select distinct a, table.* from table;
create temporary table dupes(word text, num int, id int);
values ('aaa', 100, 1);
select distinct word, num from    dupes;
select  word, num, min(id), max(id), count(*) from    dupes;
where not in (subquery);
select  distinct d2.id from    dupes d1 where d2.id > d1.id select  * from    dupes where   id not in ( select  d2.id from    dupes d1 where d2.id > d1.id );
select  * from    dupes ) select  word, num, id from    cte where   row_num = 1;
select a.* from yourtable a (select yourcolumn, min(id) as id from yourtable and a.id = b.id;
select array( select column_name::text from information_schema.columns where table_name='aean' );
select array_agg(column_name::text) from information.schema.columns where table_name = 'aean';
select array( select column_name from information.schema.columns where table_name = 'aean');
select column_name from information.schema.columns where table_name='aean';
select * from pg_stat_activity where datname = 'my_great_database';
select * from pg_stat_activity;
select usesysid, usename from pg_stat_activity;
select next value for <seq>, <other columns> from <table>;
consider using a covering index, limit in your transact-sql code, may need;
select distinct step1.dealer_nbr from step1 where dlr_qlty is not null or dlr_risky is not null;
select id, (coalesce(value1 ,0) + coalesce(value2 ,0) as total from tablename;
select tblexportvertexcompliance.totaldaysonincivek + tblexportvertexcompliance.incivekdaysothersource as [total days on incivek];
select  id, sum(value1), sum(value2) from    tablename;
select  id, value1 + value2 from    tablename;
select  id, sum(value1 + value2) from    tablename;
select *, (fielda + fieldb) as sum from table;
select (convert(int, col1)+convert(int, col2)) as summed from tbl1;
select col1, col2, ..., coln from this_table where entry_date < '2011-01-01 00:00:00';
create table new_tbl select * from orig_tbl;
select * from pg_stat_all_indexes where schemaname <> 'pg_catalog';
select relname                                               as tablename, to_char(seq_scan, '999,999,999,999')                  as totalseqscan, to_char(idx_scan, '999,999,999,999')                  as totalindexscan, to_char(n_live_tup, '999,999,999,999')                as tablerows, pg_size_pretty(pg_relation_size(relname :: regclass)) as tablesize from pg_stat_all_tables where schemaname = 'public' and 50 * seq_scan > idx_scan -- more than 2% and n_live_tup > 10000 and pg_relation_size(relname :: regclass) > 5000000;
select pt.tablename as tablename from pg_tables as pt ( select pc.relname as tablename from pg_index as pi join pg_class as pc join pg_class as pc2 join pg_stat_all_indexes as psai where pt.schemaname='public';
create extension pgstattuple;
create table test(t int);
select * from pgstatindex('test_idx');
select * from pg_stat_user_indexes;
select * from pg_statio_user_indexes;
select top (1) [project1].[migrationid] as [migrationid], [project1].[model] as [model] from ( select [extent1].[model] as [model], 1 as [c1] from [dbo].[__migrationhistory] as [extent1];
set @year = 2002 set @month = 6 select [pch].* from [production].[productcosthistory]   pch where year([pch].[modifieddate]) = @year and month([pch].[modifieddate]) = @month;
select id from things where month(happened_at) = 1 and year(happened_at) = 2009;
select * from yourtable where datepart(month,field) = @month and datepart(year,field) = @year;
where datediff(m,@date,datefield) = 0;
select * from yourtable where '2009-01-01' <= datecolumn and datecolumn < '2009-02-01';
select ... from ... where datecolumn >= @startdate and datecolumn < dateadd(month, 1, @startdate);
create function date(@year int, @month int, @day int) as begin end go;
select ... from ... where datecolumn >= date(@year,@month,1) and datecolumn < dateadd(month, 1, date(@year,@month,1));
select dateadd(m, datediff(m, '1990-01-01t00:00:00.000', current_timestamp), '1990-01-01t00:00:00.000'), dateadd(m, datediff(m, '1990-01-01t00:00:00.000', current_timestamp), '1990-01-31t23:59:59.997');
select * from yourtable where yourtimestampfield like 'aaaa-mm%';
select * from information_schema.columns where table_name='<table name>';
set @tablename = n'members' -- change with table name select [column].*, columnproperty(object_id([column].[table_name]), [column].[column_name], 'isidentity') as [identity] from information_schema.columns [column] where [column].[table_name] = @tablename;
desc table_name;
select * from information_schema.columns where table_name = 'student';
exec sp_help 'dbo.table_name';
select s1.* from sensortable s1 ( select sensorid, max(timestamp) as mts from sensortable;
select sensorid, max(timestamp) "lastreading" from sensortable ) select s.sensorid,s.timestamp,s.sensorfield1,s.sensorfield2 from sensortable s;
select l.* from sensortable l where isnull (r.sensorid);
select sensorid,timestamp,sensorfield1,sensorfield2 from sensortable s1 where timestamp = (select max(timestamp) from sensortable s2 where s1.sensorid = s2.sensorid);
select distinct;
select distinct on (sensorid) from sensortable;
select sensorid,timestamp,sensorfield1,sensorfield2 from ( select sensorid,timestamp,sensorfield1,sensorfield2 partition by sensorid from sensortable s1 where rn = 1;
select idsensor,description,tvlastupdate,tvlastvalue from sensors;
select  closing_date = dateadd(month, datediff(month, 0, closing_date), 0), category, count(status) totalcount from    mytable where   closing_date >= '2012-02-01' and     closing_date <= '2012-12-31' and     defect_status1 is not null;
select  to_char(closing_date,'mm'), category, count(status) totalcount from    mytable where   closing_date >= '2012-02-01' and     closing_date <= '2012-12-31' and     defect_status1 is not null;
select format(closing_date, 'yyyy_mm') as closing_month from mytable where defect_status1 is not null and closing_date >= '2011-12-01' and closing_date < '2016-07-01';
select closing_date, category,  count(status)totalcount from   mytable where  closing_date >= '2012-02-01' and closing_date <= '2012-12-31' and    defect_status1 is not null;
select datepart(month, closing_date) as closing_month, count(status) as totalcount from t;
select  closing_date, category,  count(status)totalcount from  mytable where closing_date >= '2012-02-01' and closing_date <= '2012-12-31' and defect_status1 is not null;
select  closing_date = dateadd(month, datediff(month, 0, closing_date), 0), category, count(status) totalcount from    mytable where   closing_date >= '2012-02-01' and     closing_date <= '2012-12-31' and     defect_status1 is not null;
select  closing_year = datepart(year, closing_date), closing_month = datepart(month, closing_date), category, count(status) totalcount from    mytable where   closing_date >= '2012-02-01' and     closing_date <= '2012-12-31' and     defect_status1 is not null;
select  format(closing_date,'yyyy-mm') as closingmonth, category, count(status) totalcount from    mytable where   closing_date >= '2012-02-01' and     closing_date <= '2012-12-31' and     defect_status1 is not null;
select min(closing_date), date_part('month',closing_date) || '-' || date_part('year',closing_date) as month, category, count(status)totalcount from mytable where closing_date >= '2012-02-01' and closing_date <= '2012-12-31' and defect_status1 is not null order by 1;
select * from tbl_name where (id_field in ('value1', 'value2', 'value3') or id_field is null);
select * from   tbl_name where  other_condition = bar and    another_condition = foo and   <b>(</b>id_field in ('value1', 'value2', 'value3') <b>or</b> id_field is null<b>)</b>;
select * from (select case when id_field is null then 0 else id_field end as id_field from tbl_name) as tbl where tbl.id_field in ('value1', 'value2', 'value3', 0);
select * from table_a whara a = 3 or a = 4 or a = null;
select * from table_a whara a <> 3 and a <> 4 and a <> null;
select * from tbl_name where coalesce(id_field,'unik_null_value') in ('value1', 'value2', 'value3', 'unik_null_value');
create view as <br/>   select * from tbldata;
alter table tbl add column col varchar(20)  default "mydefault" not null;
alter table tbl add column col varchar(20)  default "mydefault" null;
alter table tbl add column col varchar(20) default 'mydefault';
update tbl set col = default;
update tbl set col = null;
create table t(id int primary key, col int default 10);
default on null;
create table t2(id int primary key, col int default on null 10);
set @row_number = 0;
select (@row_number:=@row_number + 1) as num, userid, points from ourtable;
select *, row_number() over(order by votes desc) as "rank" from "category_model" where ("model_type" = ? and "category_id" = ?);
select t,count(*) as position from t where name <= 'search string' order by name;
select @rank := @rank + 1 as ranking, t.avg, t.name from alumnos_materia join (select @rownum := 0) r;
select `id`, (select count(*) from `table` where `name` <= 'beta') as `position`, `name` from `table` where `name` = 'beta';
select * from tbl order by name asc limit 1;
select x.id, x.position, x.name from (select t.id, t.name, @rownum := @rownum + 1 as position from table t join (select @rownum := 0) r where x.name = 'beta';
select t.id, (select count(*) from table x where x.name <= t.name) as position, t.name from table t where t.name = 'beta';
select * from tbl where name = 'beta';
select count(1) from tbl where name >= 'beta';
select column_name from table_name where rtrim(isnull(column_name, '')) like '';
select column_name from table_name where rtrim(nvl(column_name, '')) like '';
select column_name from table_name where trim(column_name) is null;
select firstname from userdetails where trim(lastname) is null;
select firstname from userdetails where ltrim(rtrim(lastname)) is null;
select [column_name] from [table_name] where nullif([column_name], '') is null;
select [column_name] from [table_name] where [column_name] like '% %' or [column_name] is null;
select column_name from table_name where ifnull(column_name,'') not like '%_%';
select [column_name] from [table_name] where len(rtrim(isnull([column_name], ''))) > 0;
select column_name from table_name where isnull(column_name,'') <> '';
select * from `table_name` where not ((`column_name` is null) or (trim(`column_name`) like ''));
select * from <schema>."my_table";
set search_path to my_schema;
select * from information_schema.columns;
select * from parroquias_region select * from public.parroquias_region;
select * from map_update.sectores_point;
table "public.commondata_nwcg_agencies" column          |            type             | collation | nullable | default;
drop table if exists "commondata_nwcg_agencies";
create table "commondata_nwcg_agencies" ( ...;
select * from public."my_table";
select pg_catalog.set_config('search_path', '', false);
create table public."test" ( id serial not null, data text not null, updater character varying(50) not null, "updatedt" time with time zone not null, constraint test_pk primary key (id) ) alter table public."test";
create schema employees;
set search_path = employees, pg_catalog;
select ea_month, id, amount, ea_year, circle_id from   tbl;
select ea_month, id, amount, ea_year, circle_id from   (select *, to_date(ea_year || ea_month, 'yyyymonth') as mon from tbl);
if (object_id('tempdb..#raiserrors') is null) create table #raiserrors (errornumber int, errormessage varchar(400), errorseverity int, errorstate int, errorline int, errorprocedure varchar(128));
set @tc = @@trancount;
if (@tc = 0) else save transaction mytransaction;
set @return_value = '0';
@errormessage as varchar(400), @errorseverity as int, @errorstate as int, @errorline as int, @errorprocedure as varchar(128);
exec @return_value = [dbo].[assumethisfails] if (@return_value <> 0) if (@tc = 0) end try select @errornumber = error_number(), @errormessage = error_message(), @errorseverity = error_severity(), @errorstate = error_state(), @errorline = error_line(), @errorprocedure = error_procedure();
values (@errornumber, @errormessage, @errorseverity, @errorstate, @errorline, @errorprocedure);
if (@tc = 0) if (xact_state() <> 0) select * from #raiserrors;
select * from #raiserrors;
values (@errornumber, @errormessage, @errorseverity, @errorstate, @errorline, @errorprocedure);
end end -- if i didn't start the transaction if (xact_state() = 1) if (object_id('tempdb..#raiserrors') is not null) values (@errornumber, @errormessage, @errorseverity, @errorstate, @errorline, @errorprocedure);
else raiserror(@errormessage, @errorseverity, @errorstate);
end else if (xact_state() = -1) if (object_id('tempdb..#raiserrors') is not null) values (@errornumber, @errormessage, @errorseverity, @errorstate, @errorline, @errorprocedure);
else raiserror(@errormessage, @errorseverity, @errorstate);
end end catch end;
set status = '1' where id in ( select id from ( select c2.id from clusters as c2 where c2.assign_to_user_id is not null and c2.id not in ( select c1.id from clusters as c1 where ft.slug = 'closed' ) or is there something we can improve on my query above?;
select group_concat(id) as csv_result from your_table where whatever = 'test' ...;
delete t from target as t;
delete th from term_hierarchy as th;
create table term_hierarchy_backup (tid int(10)); <- check data type select distinct(th1.tid) from term_hierarchy as th1 where th1.parent = 1015;
delete from term_hierarchy as th where th.parent = 1015 and th.tid in (select tid from term_hierarchy_backup);
delete th from term_hierarchy as th where th.parent = 1015 and th.tid in ( select distinct(th1.tid) from term_hierarchy as th1 where th1.parent = 1015;
delete e.* from tablee e where id in (select id from tablee where arg = 1 and foo = 'bar');
delete e.* from tablee e where id in (select id from (select id from tablee where arg = 1 and foo = 'bar') x);
delete from `secure_links` where `secure_links`.`link_id` in ( select `sl1`.`link_id` from ( select  from `secure_links` as `sl2` where  );
delete  th.* from term_hierarchy th where th.parent = 1015;
select convert(varchar(4),getdate(),100)  + convert(varchar(4),year(getdate()));
select convert(char(4), date_of_birth, 100) + convert(char(4), date_of_birth, 120) from customers;
select datepart(month,getdate()) -- integer (1,2,3...);
select datename(mm, article.created) as month, datename(yyyy, article.created) as year, count(*) as total from articles as article datename(mm, article.created), datename(yyyy, article.created);
select datename(yyyy, date) as year from income;
select datename( month, getdate() ) + ' ' + datename( year, getdate() );
select datepart(mm,getdate())  --to get month value select datename(mm,getdate())  --to get name of month;
set @date = '19000101' set @date = dateadd(day,1,@date) end  select count(*) total_records from @mytable select dateadd(month,datediff(month,0,mydate),0) first_of_the_month, count(*) cnt from @mytable;
create table users ( userid int,date_of_birth date ) select datediff(year,date_of_birth, getdate()) - (case when (dateadd(year, datediff(year,date_of_birth, getdate()),date_of_birth)) > getdate() then 1 else 0 end) as years, month(getdate() - (dateadd(year, datediff(year, date_of_birth, getdate()), date_of_birth))) - 1 as months, day(getdate() - (dateadd(year, datediff(year,date_of_birth, getdate()), date_of_birth))) - 1 as days, from users;
select format(@date, 'yyyymm');
select convert (varchar(7), getdate(),20);
set @pyear  = right(convert(char(10), getdate(), 101), 4) set @pmonth = left(convert(char(10), getdate(), 101), 2) set @pday   = substring(convert(char(10), getdate(), 101), 4,2) select @pyear,@pmonth,@pday;
alter table your_table_name add column id serial not null primary key;
alter table users;
alter table users add id int not null auto_increment primary key;
alter table `users` modify column id int not null;
alter table `users` drop primary key, add primary key(id);
alter table `users` modify column id int not null auto_increment;
alter table `users` add `id` int not null auto_increment;
alter table users change id int( 30 ) not null auto_increment;
add the new column like that;
alter table users add id int not null auto_increment primary key first;
alter table nametable drop primary key;
alter table nametable add id int not null auto_increment primary key;
alter table table1 drop constraint pk_table1_col1;
alter table `mytable` add column `id` int auto_increment unique first;
alter table users add id int not null auto_increment;
alter table users modify id int not null auto_increment;
alter table `table` add `id` int not null auto_increment unique;
alter table users add id int not null auto_increment primary key;
alter table users modify id int not null auto_increment primary key;
alter table `tablename` drop primary key;
alter table `tablename` add `column_name` int primary key auto_increment;
alter table `tablename` modify column `column_name` int not null auto_increment primary key;
delete ps from posts ps inner join distinct id from posts having count(id) > 1 ) dubids on dubids.id = ps.id;
delete from posts where id in ( select * from ( select id from posts group by id having ( count(id) > 1 ) );
delete p1 from posts as p1 select id from posts group by id having count(id) > 1;
delete posts from posts select id from posts having count(id) = 1 union  select id from posts having count(id) != 1 where duplicate.id is null;
select cast(123.4567 as decimal(9,6));
select cast( cast( (round( 35.457514 , 2) *100) as int) as float ) /100;
set @mynum = 700000 select cast(parsename(convert(numeric(15,2),@mynum/10000),2) as varchar(10));
select format(cast(15.12     as decimal(9,6)), 'g18')  -- '15.12' select format(cast(0.0001575 as decimal(9,6)), 'g10')  -- '0.000158' select format(cast(2.0       as decimal(9,6)), 'g15')  -- '2';
select format(cast(15.12 as float), 'g17')         -- '15.119999999999999' select format(cast(0.9 as real), 'g8')             -- '0.89999998' select format(cast(0.9 as real), 'g7')             -- '0.9';
case when left(replace(ltrim(rtrim(replace(str(xxx, 38, 10), '0',  ' '))), ' ', '0'), 1) = '.' then '0' else '' end + case when right(replace(ltrim(rtrim(replace(str(xxx, 38, 10), '0',  ' '))), ' ', '0'), 1) = '.' then '0' else '' end;
select replace(trim(replace(20.5500, "0", " ")), " ", "0");
select parsename(2.5500,2);
set @thistext = replace(rtrim(replace(@thisdata, '0', ' ')), ' ', '0') if substring(@thistext, len(@thistext), 1) = '.' end;
select replace(rtrim(ltrim(replace(accno,'0',' '))),' ','0') accno from @bankaccount;
select reverse(round(reverse(2.5500),1));
select replace(rtrim(replace( replace(rtrim(replace(cast(@value as varchar(40)), '0', ' ')), ' ', '0');
select left(code,len(code)+1 - patindex('%[1-z]%',reverse(code))) from tablename;
select isnull(cast(floor(replace(rtrim(ltrim('999,999.0000')),',','')) as int),0);
select convert(double precision, [columnname]);
select parsename(@num,2) + replace(rtrim(ltrim(replace(@num-parsename(@num,2),'0',' '))),' ','0') set @num = 0.0123450000 select parsename(@num,2) + replace(rtrim(ltrim(replace(@num-parsename(@num,2),'0',' '))),' ','0');
create function [dbo].[fn_converttostring] ( @value sql_variant ) as begin set @x= reverse(replace(ltrim(reverse(replace(convert(varchar(max) , @value),'0',' '))),' ',0)) set @x = replace(rtrim(replace(@x,'.',' ')),' ' ,'.') end;
set @value = 1.2000 select @value original_val, substring(  cast( @value as varchar(100)), 0, patindex('%.%',cast(@value as varchar(100))) ) reverse( substring( cast(@value as varchar(100)), patindex('%.%',cast(@value as varchar(100)))+1, len(cast(@value as varchar(100))) ) ) patindex('%.%',cast(@value as varchar(100)))+1, len(cast(@value as varchar(100))) ) else '' end  as modified_val;
select cast(123.456700 as float),cast(cast(123.4567 as decimal(9,6)) as float);
select @n select format(@n, '0.######');
create proc [dbo].[sp_delete_multi_row] as  set nocount on set transaction isolation level read uncommitted delete tb_sampletest where code in( select item.value('.', 'varchar(20)') from  @code.nodes('recordlist/id') as x(item) ) if @@rowcount = 0 set @errflag = 200 set nocount off;
delete from `table` where id >=163 and id<= 265;
delete id from table where id in (select id from table);
delete from table where id between 163 and 265;
delete from your_table where id in (value1, value2, ...);
delete from your_table where id in (select acolumn from ...);
delete from your_table where id between bottom_value and top_value;
delete from your_table where id >= a_value and id <= another_value;
select concat(`subject`,'_', `year`) as subject_year from `table_name`;
select topic, concat_ws( " ", subject, year ) as subject_year from table;
select concat(`name`, ' ', `email`) as password_email from `table`;
select filed1 as category,filed2 as item, group_concat(cast(filed2 as char)) as item_name from `table` group by filed1;
select concat(`subject`, ' ', `year`) from `table`;
select concat(`subject`,'-',`year`,'-',lpad(@rn := @rn+1,3,'0')) from `table`;
set @weight= 47 / 638; print @weight;
set @weight= 47.000000000 / 638.000000000; print @weight;
set @weight= cast(@set1 as float) / cast(@set2 as float);
set @weight= @set1 / @set2 *1.00000;
set @weird_number_float=22/7 select @weird_number_float set @weird_number_decimal=22/7 select @weird_number_decimal set @weird_number_numeric=22/7 select @weird_number_numeric set @weird_number=cast(22 as float)/cast(7 as float) select @weird_number;
@qsql       nvarchar(max) = '';
set @qsql = ' select * from openquery(teraserver,'' select distinct case when ' + cast(@dayofwk as nchar(1)) + ' = 2 then ''''monday'''' else ''''not monday'''' end '');';
exec sp_executesql @qsql;
select * from openquery(khssqlodsprd,'select * from abc.dbo.claim a with (nolock) where a.dos >= (select max(date) from khsdasql01.da_main.[dbo].[allfilenames]) ');
set @p_id = '40381' set     columnname1 = null, columnname2 = null, columnname3 = null, columnname4 = null where   personid = '+ @p_id +'; end;') at [linked_server_name];
set @sfid = (select t.id from (select id,  contact_id_sql__c  from openquery([tr-sf-prod], 'select id,  contact_id_sql__c from contact') where contact_id_sql__c = @contactid) t);
create table #selected_store ( code varchar(250), id int ) select @code = code from #selected_store select @code drop table #selected_store;
exec master.dbo.sp_serveroption @optname = n'remote proc transaction promotion', @optvalue = n'false';
select * from openquery([nameoflinkedserver], 'select * from tablename where field1=''your search value''') t1 inner join mysqlserver.database.dbo.tablename t2 on t1.pk = t2.pk;
set @sql = 'select * from tbl where field1 < ''someval'' and field2 in '+ @valuelist set @sql = 'select * from openquery(svrname, ''' + replace(@sql, '''', '''''') + ''')';
select * from mysqlserver.database.dbo.tablename t2 on t1.pk = t2.pk where t1.field1 = @someparameter;
select  @var = 'ca' select  @tsql = 'select * from openquery(mylinkedserver,''select * from pubs.dbo.authors where state = ''''' + @var + ''''''')' exec (@tsql);
set @linkedserver = 'mylinkedserver' set @openquery = 'select * from openquery('+ @linkedserver + ',''' set @tsql = 'select au_lname, au_id from pubs..authors'')' exec (@openquery+@tsql);
select  @var = 'ca' exec mylinkedserver.master.dbo.sp_executesql n'@state char(2)', @var;
in this example i wanted to pass in the name of a global temporary table dynamically.  i have 1 procedure dropping in the name of our pickup table as a parameter for openquery. if ( object_id('tempdb..##contextspecificglobal__temp' , 'u') is null ) exec ('select * into ##contextspecificglobal__temp from openquery(loopback, ''select *,''''' +  @guid +''''' as tempid from ' + @tablesrc + ''')') else exec ('insert ##contextspecificglobal__temp select * from openquery(loopback, ''select *,''''' +  @guid +''''' as tempid from ' + @tablesrc + ''')') select * into #tablesrc from ##contextspecificglobal__temp where tempid = @guid if ( object_id('tempdb..##contextspecificglobal__temp' , 'u') is not null ) if (select count(*) from ##contextspecificglobal__temp) = 0 drop table ##contextspecificglobal__temp end commit tran t1;
set @username = 'username' set @openselect = '(select @output = cast((cast(pwdlastset as bigint) / 864000000000) as numeric(18,4)) from openquery (adsi,''select pwdlastset from  ''''ldap://domain.net.intra/dc=domain,dc=net,dc=intra'''' where objectclass =  ''''user'''' and samaccountname = ''''' + @username + ''''' exec sp_executesql @openselect, n'@output numeric(18,4) out', @output out select @output as outputs;
select field1 from openquery 'select field1 from tablename') where field1=@someparameter t1;
if object_id('tempdb..##temp') is not null drop table ##temp end declare @dept as nvarchar(20) ='''47''' set @openquery = 'select ' + @dept + ' as dept,  * into ##temp from openquery(sql_awsprod01,''' set @parmdef = n'@dept varchar(20)' exec sp_executesql @sql,@parmdef, @dept select * from ##temp;
select * from db1.sys.procedures p where p.name not in;
select definition from [residazemaster].[sys].[procedures] p set @sql = replace(@sql,'''','''''') set @sql = 'use [' + @name + ']; exec(''' + @sql + ''')' end ;
if (-not (test-path $outdir)) { if ($o -ne $null) { if ($o.schema -ne $null -and $o.schema -ne "") {;
select * from sys.procedures;
select cast(dev_cost as decimal) / sell_cost from software ;
select dev_cost::decimal / sell_cost from software ;
select ceil(dev_cost::decimal / sell_cost) from software ;
select round(dev_cost ::decimal / sell_cost + 0.5);
select 16000::numeric / 7500 col;
select ceil(dev_cost::numeric/sell_cost) from software;
select (dev_cost::numeric/sell_cost::numeric);
select trunc((dev_cost::numeric/sell_cost::numeric),2);
select e1.emp_id as 'emp_id' from employee e1 right join employee e2 on e1.emp_id = e2.emp_id;
select e1.emp_id as 'emp_id' from employee e1 left join employee e2 and e1.emp_name = e2.emp_name and e1.every_other_matching_column = e2.every_other_matching_column;
select users.user_id, users.user_name, managers.user_id as manager_id, managers.user_name as manager_name inner join users as manager on users.manager_id=manager.user_id;
select e.name, m.name from employees e left outer join employees m;
table (employee): varchar name, int manager_id;
select e1.name, e2.name as managername from employee e1, employee e2 where where e1.manager_id = e2.id;
select child.id, child.name, child.phonenumber, father.name, father.phonenumber from mytableofpersons as child where child.city = 'chicago'  -- or some other condition or none;
select c1.name , c2.name as boss from emp1 c1;
select name from employee e1, employee e2 where e1.intialdesignationid = e2.currentdesignationid;
select a.id from my_bookings a, my_bookings b where a.name = b.name and a.date = b.date and a.id != b.id;
select a.customername as customername1, b.customername as customername2, a.city from customers a, customers b where a.customerid <> b.customerid and a.city = b.city;
select * from tablename where datetime >= '12/04/2011 12:00:00 am' and datetime <= '25/05/2011 3:53:04 am';
select * from tablename where datetime >= '2011-04-12t00:00:00.000' and;
select * from tablename where datetime between '04/12/2011 12:00:00 am' and '05/25/2011 3:53:04 am';
select * from tablename where [datetime] >= '2011-04-12 12:00:00 am' and [datetime] <= '2011-05-25 3:35:04 am';
select getdate() select convert(varchar(30),getdate(),131) >= '12/04/2011 12:00:00 am';
select * from table where fieldname > {ts '2013-02-01 15:00:00.001'} and fieldname < {ts '2013-08-05 00:00:00.000'};
select time from [tablename] where datepart(yyyy,[time])='2018' and datepart(mm,[time])='06' and datepart(dd,[time])='14;
url: "jdbc:log4jdbc:oracle:thin:@(description =(address_list = (address = (protocol = tcp)(host = xxxxx.xx>xxx)(port = 1521))) (connect_data = (sid = xxxx)(server =dedicated)))", ....;
create session create table;
3     id int not null, 4     text varchar2(1000), 5     primary key (id);
create table "johny"."johny_table" "text" varchar2(1000), primary key ("id");
create unique index "johny"."sys_c0013353" on "johny"."johny_table" ("id");
create user auto_exchange identified by 123456;
create user lctest identified by lctest;
create procedure usp_execute_sql_within_transaction ( @sql nvarchar(max) ) as  set nocount on end try select @errormessage = n'error number: ' + convert(nvarchar(5), error_number()) + n'. ' + error_message() + ' line ' + convert(nvarchar(5), error_line()), @errorseverity = error_severity(), @errorstate = error_state() end catch exec usp_execute_sql_within_transaction @sql = 'select 1; select 2' exec usp_execute_sql_within_transaction @sql = 'select 1/0; select 2' exec usp_execute_sql_within_transaction @sql = 'exec usp_another_sp';
end try select error_number() end catch;
end try end catch;
end try if @@trancount > 0 rollback transaction;
end try select @errormessage = error_message() + ' line ' + cast(error_line() as nvarchar(5)), @errorseverity = error_severity(), @errorstate = error_state();
if @@trancount > 0 rollback transaction;
@errornumber int = error_number(), @errorseverity int = error_severity(), @errorstate int = error_state(), @errorline int = error_line(), @errorprocedure nvarchar(200) = isnull(error_procedure(), '-');
select @errormessage = n'error %d, level %d, state %d, procedure %s, line %d, ' + 'message: ' + @errormessage;
values (2,'netvibes', 'http://www.netvibes.com/subscribe.php?type=rss' || chr(38) || 'amp;url=');
select 'one'||'&'||'two' from dual;
select 'free &' || ' clear' from dual;
delete from sqlite_master where type in ('view', 'table', 'index', 'trigger');
if (table.startswith("sqlite_")) {;
select 'drop table ' || name || ';' from sqlite_master where type = 'table';
if (!tablename.equals("android_metadata") &&;
delete from sqlite_sequence;
select 'drop table ' || name || ';' from sqlite_master where type = 'table';
and name glob 'pax_*';
delete from sqlite_master where type in ('table', 'index', 'trigger');
delete from messages,usersmessages where messages.messsageid='1';
delete a.*, b.* from messages a where a.messageid = 1;
delete message.*, usersmessage.* from users, usersmessage where message.messageid=usersmessage.messageid and message.messageid='1';
delete from messages where messageid = '1';
delete from usersmessages where messageid = '1';
delete messages , usersmessages  from messages  inner join usersmessages where messages.messageid= usersmessages.messageid and messages.messageid = '1';
alter table usersmessages add constraint fk_usermessages_messageid;
delete from    usermessages where   messageid = 1 delete from    messages where   messageid = 1;
delete from messages where messageid = 1;
delete from usermessages where messageid = 1;
create table parent ( id int not null, primary key (id) create table child ( id int, parent_id int, foreign key (parent_id) references parent(id) on delete cascade;
delete m, um from messages m, usersmessages um where m.messageid = 1 and m.messageid = um.messageid;
delete a.*, b.* from table1 as a, table2 as b where a.id=[your value here] and b.id=[your value here];
delete project , create_test  from project inner join create_test where project.project_name='trail' and  create_test.project_name ='trail' and project.uid= create_test.uid = '1';
delete t1, t2 from table1 t1 left join table2 t2 on t1.id = t2.id where t1.id = some_id;
select @variable1 = col1, @variable2 = col2 from table1;
select @var = col1, @var2 = col2 from   table;
select cast ( ( select 1 ) as real );
select cast(field1 as float) / field2;
select something*1.0/total from somewhere;
update table_with_fields set real_field=cast(field_with_txt as real);
select city, max(length(city)) from customers;
select * from ( (select city, length(city) as maxlen from station union (select city, length(city) as minlen from station;
select name, length( name ) from my_table where length( name ) = ( select max( length( name ) ) from my_table );
select name, length(name) from users where id = ( select id from users limit 1;
select * from my_table where length( name ) = ( select max( length( name ) ) from my_table limit 1;
select mt.name from my_table mt having max(length(mt.name)) = 18;
select mt.name from my_table mt join (select max(length(x.name) as max_length from my_table x) y on y.max_length = length(mt.name);
select  name, length(name) as mlen from    mytable mlen desc limit 1;
select urcolumnname from urtablename where length(urcolumnname ) in;
update transactions t join account a on a.id = t.account_id join account ap on ap.id = a.pmt_act_id set  t.payee_id = a.pmt_act_id where t.payee_id = 0;
update reservations r join train t on (r.train = t.trainid) set t.capacity = t.capacity + r.noseats where r.reservationid = ?;
select @numrowschanged = @@rowcount, @errorcode = @@error;
select @numrowschanged = @numrowschanged  + @@rowcount, @errorcode = @@error;
set nocount off;
create table mynewone as select * from myoldone where ...;
create table films_recent as select * from films where date_prod >= '2002-01-01';
create table films_recent (like films including indexes);
select * from books where date_prod >= '2002-01-01';
delete from yourtable where <condition(s)>;
table "public.x1" column |  type   |                    modifiers;
table "public.x2" column |  type   |                    modifiers;
set set set set set set set set create table alter table alter table alter table;
table "public.x3" column |  type   |                    modifiers;
create table new_table (like original_table including all);
create table new ( like original including all);
select object_name(c.object_id) tablename, c.name columnname from sys.columns as c join sys.types as t on c.user_type_id=t.user_type_id where t.name = 'ntext';
select c.* from information_schema.columns c where c.data_type = 'int' and t.table_type = 'base table';
select table_name [table name], column_name [column name] from information_schema.columns where data_type = 'ntext';
select table_name from information_schema.tables t where t.table_catalog = 'mydatabase' and exists ( select * from information_schema.columns c where c.table_catalog = t.table_catalog and );
delete from table where id not in (select top 10 id from table);
delete article where id not in (select top 1000 id from article);
delete from table where id not in (select top 10 id from table);
create table #nuke(nukeid int) delete article where not exists (select 1 from nuke where nukeid = id) drop table #nuke;
delete a from table a inner join ( select top (select count(tableid) from table) - 10) from table order by tableid desc;
delete from table where id not in (select id from table order by id limit n);
set @n = select count(*) from dtable;
delete top (@n - 10 ) from dtable;
delete top 90 percent from dtable;
delete product from product ( select top 10 from product where topproducts.id is null;
( select  id from    dbo.tablename ) delete cte;
select max(temp.id) from (select top 10 id from table order by id asc) temp ) if @maxid is not null delete from table where id > @maxid;
select t.name as tablename, s.name as schemaname, p.rows as rowcounts, sum(a.total_pages) * 8 as totalspacekb, cast(round(((sum(a.total_pages) * 8) / 1024.00), 2) as numeric(36, 2)) as totalspacemb, sum(a.used_pages) * 8 as usedspacekb, cast(round(((sum(a.used_pages) * 8) / 1024.00), 2) as numeric(36, 2)) as usedspacemb, (sum(a.total_pages) - sum(a.used_pages)) * 8 as unusedspacekb, cast(round(((sum(a.total_pages) - sum(a.used_pages)) * 8) / 1024.00, 2) as numeric(36, 2)) as unusedspacemb from sys.tables t sys.indexes i on t.object_id = i.object_id sys.partitions p on i.object_id = p.object_id and i.index_id = p.index_id sys.allocation_units a on p.partition_id = a.container_id where t.name not like 'dt%' and t.is_ms_shipped = 0 and i.object_id > 255 t.name, s.name, p.rows t.name;
select top 20 obj.name, ltrim (str ( sz.in_row_data_page_count * 8, 15, 0) + ' kb') as size, * from sys.dm_db_partition_stats sz;
select table_schema, table_name, data_length, index_length from information_schema.tables;
select pg_size_pretty(pg_relation_size('tablename'));
select count(*) from your_table_name;
create table #tmptablesizes ( tablename varchar(100), numberofrows varchar(100), reservedsize varchar(50), datasize varchar(50), indexsize varchar(50), unusedsize varchar(50) ) exec sp_msforeachtable @command1="exec sp_spaceused '?'" select  * from #tmptablesizes;
select t.name as tablename, p.rows as rowcounts, convert(decimal,sum(a.total_pages)) * 8 / 1024 / 1024 as totalspacegb, sum(a.used_pages)  * 8 / 1024 / 1024 as usedspacegb , (sum(a.total_pages) - sum(a.used_pages)) * 8 / 1024 / 1024 as unusedspacegb from sys.tables t sys.indexes i on t.object_id = i.object_id sys.partitions p on i.object_id = p.object_id and i.index_id = p.index_id sys.allocation_units a on p.partition_id = a.container_id where t.name = 'yourtable' and t.is_ms_shipped = 0 and i.object_id > 255 t.name, s.name, p.rows usedspacegb desc, t.name;
select cast(add_date as char) as add_date;
select "-- tabla item_pedido";
create table item_pedido ( id integer auto_increment primary key, id_pedido integer, id_item_carta integer, observacion varchar(64), fecha_estimada timestamp, fecha_entrega timestamp null, // here is!!.. null = delivery date not set yet constraint fk_item_pedido_id_pedido foreign key (id_pedido);
select "++ insert item_pedido";
(02, 01, 02, 'ninguna', adddate(@hoy, interval 3 minute), null),...;
select * from information_schema.tables where table_type='base table';
select * from information_schema.columns;
select * from information_schema.columns where table_name='your_table_name';
select * from information_schema.columns;
select * from sysobjects where xtype='u';
select * from information_schema.columns where table_name = 'insert table name here';
select t.name as table_name , c.name as column_name , p.name as data_type , p.max_length as size , cast(p.precision as varchar) + '/' + cast(p.scale as varchar) as precision_scale from   sys.objects as t join sys.columns as c on t.object_id = c.object_id join sys.types as p on c.system_type_id = p.system_type_id where  t.type_desc = 'user_table';
select table_schema , table_name , column_name , ordinal_position , column_default , data_type , character_maximum_length , numeric_precision , numeric_precision_radix , numeric_scale , datetime_precision from   information_schema.columns;
select * from information_schema.columns where table_catalog like 'databasename';
select * from information_schema.columns where table_catalog like 'databasename' and table_name like 'tablename';
set @database = '' select cu.table_catalog,cu.view_schema, cu.view_name, cu.table_name, cu.column_name,c.data_type,c.character_maximum_length from information_schema.view_column_usage as cu join information_schema.columns as c and c.table_name = cu.table_name and c.column_name = cu.column_name where cu.table_catalog = @database;
select * from information_schema.columns;
select * from <dbname>.information_schema.columns;
select *from user_tab_columns;
set nocount on select t.name as tablename from sys.objects as t where t.type_desc = 'user_table' select left(c.name, 30) as columnname, left(isc.data_type, 10) as datatype, c.max_length as size, cast(p.precision as varchar(4)) + '/' + cast(p.scale as varchar(4)) as precscale, case when c.is_nullable = 1 then 'null' else 'no null' end as [nullable], left(isnull(isc.column_default, ' '), 5)  as [default], case when c.is_identity = 1 then 'identity' else '' end as [identity] from   sys.objects as t join sys.columns as c on t.object_id = c.object_id join sys.types as p on c.system_type_id = p.system_type_id join information_schema.columns as isc on t.name = isc.table_name and c.name = isc.column_name where  t.type_desc = 'user_table' and  t.name = @tablename end  set nocount off;
select * from information_schema.columns;
select table_name from information_schema.columns;
select * from information_schema.columns where table_schema = "<databasename>";
set @sql2  =' if (  db_name(db_id()) not in (''master'',''tempdb'',''model'',''msdb'',''ssisdb'')  ) select db_name() as db, ss.name as schemaname, so.name tablename, sc.name columnname, st.name type, case when st.name in (''nvarchar'', ''nchar'') then convert(varchar(10), ( sc.max_length / 2 )) then convert(varchar(10), sc.max_length) else null end as length, case when sc.is_nullable = 0 then ''no'' when sc.is_nullable = 1 then ''yes'' else null end as nullable, isnull(sc.column_id,0) as col_number from sys.objects                  so join sys.schemas                  ss join sys.columns             sc where so.is_ms_shipped = 0 end ' exec sp_msforeachdb @command1 = @sql2;
select name from table_1 a where exists( select * from table_2 b where (a.name=b.name));
set key = 'key', generation = 'generation' update key = 'key', generation = (generation + 1);
drop table % cascade;
drop table foo, bar, baz;
create or replace function footgun(in _schema text, in _parttionbase text) as $$ select table_schema, table_name from information_schema.tables where table_type = 'base table' and table_schema = _schema and table_name ilike (_parttionbase || '%') end loop;
select footgun('public', 'tablename');
select 'drop table '||n.nspname ||'.'|| c.relname||';' as "name" from pg_catalog.pg_class c where c.relkind in ('r','v','s','') and n.nspname <> 'pg_catalog' and n.nspname <> 'information_schema' and n.nspname !~ '^pg_toast' and pg_catalog.pg_table_is_visible(c.oid);
where c.relname ilike 'bubba%';
drop table public.a1;
drop table public.a2;
drop table ctrl+shift+v;
set @s='northwind' set @t = 'select * from ' + @s + '.[dbo].[customers]';
create table #variables ( varname varchar(20) primary key, value varchar(255) ) select value from #variables where varname = 'bob' drop table #variables;
select 'value1' as variable1, 'mydatabasename' as dbname into #tmp exec ('use ' + @dbname) drop table #tmp;
select * from [dbo].[refresh_indexes] select * from $(mydatabase).[dbo].[refresh_indexes];
exec dbo.myvariablesave @name = 'test', @value=@myvariable exec dbo.myvariableload 'test', @myvariable output;
exec dbo.myvariablelist       -- lists all variables in the temporary table. exec dbo.myvariabledeleteall  -- deletes all variables in the temporary table.;
exec dbo.myvariablelist;
create or alter procedure myvariablesave @value varchar(max) as begin set nocount on if not exists (select top 1 * from tempdb.sys.objects where name = '##variableloadsave') drop table if exists ##variableloadsave create table ##variableloadsave ( name varchar(255), value varchar(max) ) end update ##variableloadsave set value=@value where name=@name if @@rowcount = 0 end go create or alter procedure myvariableload @value varchar(max) out as begin if exists (select top 1 * from tempdb.sys.objects where name = '##variableloadsave') if not exists(select top 1 * from ##variableloadsave where name=@name) end  select @value=cast(value as varchar(max)) from ##variableloadsave where name=@name end else begin end end go create or alter procedure myvariablelist as begin if exists (select top 1 * from tempdb.sys.objects where name = '##variableloadsave') select * from ##variableloadsave end end go create or alter procedure myvariabledeleteall as begin drop table if exists ##variableloadsave create table ##variableloadsave ( name varchar(255), value varchar(max) ) end;
if col_length('stufftable', 'enablega') is not null set noexec on -- script will not do anything when column already exists alter table dbo.stufftable add enablega bit not null constraint df_stufftable_enablega default(0) alter table dbo.stufftable set (lock_escalation = table) update dbo.stufftable set enablega = 1 where stuffurl is not null set noexec off;
if (@procedureversion='1.0') set noexec off  --code execution on end else begin set noexec on  --code execution off end;
set noexec off -- execution is on;
if (@procedureversion='2.0') set noexec off  --code execution on end else begin set noexec on  --code execution off end;
set noexec off -- execution is on;
select colum from table limit 1;
select column from table limit 1;
select top 1 column from table;
select column, rand() as idx from table;
select column from where rownum = 1;
from  sqlalchemy.sql.expression import func, select;
from sqlalchemy.sql import func from sqlalchemy.orm import load_only func.floor( func.random() * );
from random import randint if rows_query.count() > 0:                       # make sure there's at least 1 row;
from sqlalchemy.sql.expression import func if not sample_num:;
in [24]: %%timeit in [25]: %timeit foo.tablesample(1).select().execute().fetchall() in [26]: %timeit foo.tablesample(func.bernoulli(1)).select().execute().fetchall();
set @variable1 =( select column_gonna_asign from dbo.your_db where non_primary_non_unique_key= @variable2;
select companyname from customers where customerid in ( select customerid from orders where year(orderdate) = '1997';
select companyname from customers where customerid = ( select customerid from orders where year(orderdate) = '1997';
where supplier_item.sku=orderdetails.sku and;
select orderdetails.sku, orderdetails.mf_item_number, orderdetails.qty, orderdetails.price, supplier.supplierid, supplier.suppliername, supplier.dropshipfees, supplier_item.price as cost from orderdetails join supplier on orderdetails.mfr_id = supplier.supplierid join group_master on group_master.sku = orderdetails.sku join supplier_item on where invoiceid='339740';
select od.sku, od.mf_item_number, od.qty, od.price, s.supplierid, s.suppliername, s.dropshipfees, si.price as cost from orderdetails od where od.invoiceid = '339740';
select * from ( select count(*) as c, supplier_item.sku from supplier_item where c > 1;
alter table your_table disable trigger [the_trigger_name] update    your_table set     gender = 'female' where     (gender = 'male') alter table your_table enable trigger [the_trigger_name];
select column from table where columns_name in ( select column from table where columns_name = 'value');
select floor(your_field) from your_table;
select floor(12345.7344);
select substr(12345.7344,1,locate('.', 12345.7344) - 1);
select floor(12345.7344);
select 25 * 9.54 + 0.5 -> 239.00 select floor(25 * 9.54 + 0.5) -> 238  (oops!) select substr((25*9.54+0.5),1,locate('.',(25*9.54+0.5)) - 1) -> 239;
select floor(desired_field_value) from table;
select round(desired_field_value-0.5) from table;
select floor(@num * 10000) / 10000;
select substring(convert(varchar, @num), 1, charindex('.', @num) + 4);
delete t from where t.rownumber > 1;
select (select count(i.au_id) from pubs..authors i where i.au_id >= o.au_id ) as rowid, au_fname + ' ' + au_lname as 'author name' from          pubs..authors o;
select row_number() over (order by rn_execution_date asc) as 'row number', rn_execution_date as 'execution date', count(*) as 'count' from td.run where rn_execution_date >= '2009-05-19';
select row_number() over (order by empid asc) as rowid, * from employee;
select row_number() over (order by getdate()) as rowid, * from employees;
update x -- cte is referenced by the alias. set ison=1, @id=x.id from cte as x select *, @id as 'random' from @x;
create table t(x int);
select %%physloc%% as [%%physloc%%], sys.fn_physlocformatter(%%physloc%%) as [file:page:slot] from t;
select * from t where %%physloc%% = 0x2926020001000100;
@pageid int = 338, @slot   int = 3 select cast(reverse(cast(@pageid as binary(4))) as binary(4)) +;
select distinct c1, c2 from t;
select c1, c2, count(*) from t;
select c1, count(*) from (select distinct c1, c2 from t) group by c1;
select count(*) from (select distinct c1, c2 from [tableentity]) te;
select ([distinct] col)+;
select (distinct a), b;
create sequence oracle_seq;
2. generation type. sequence, 3. generation type. identity;
select a, b, count(a) from tbl group by a, b;
select group,subgroup,count(*) from tablename group by group,subgroup;
select group, subgroup, count(*) from groups group, subgroup;
alter table dbo.product alter column status bit not null;
select isnull(cast( case status else 0 end as bit), 0) as hasstatus from dbo.product;
create table tracks (id serial, artists <b>jsonb</b>);
create index tracks_artists_gin_idx on tracks using gin (artists);
select * from tracks where artists @> '[{"name": "the dirty heads"}]';
create index tracks_artists_gin_idx on tracks;
create table tracks (id serial, <b>artistnames</b> jsonb);
create index tracks_artistnames_gin_idx on tracks using gin (artistnames);
select * from tracks where artistnames ? 'the dirty heads';
create index tracks_artistnames_gin_idx on tracks;
select * from tracks where artistnames @> '"the dirty heads"'::jsonb;
create or replace function json2arr(_j json, _key text);
create index tracks_artists_gin_idx on tracks;
select * from tracks where  '{"the dirty heads"}'::text[] <@ (json2arr(artists, 'name'));
select p.proname, p.provolatile from   pg_proc p join   pg_namespace n on n.oid = p.pronamespace where  n.nspname = 'pg_catalog' and    p.proname ~~* '%json%';
#my_temporary_table select * from er101_acct_order_dtl with (nolock) where er101_upd_date_iso > dateadd(month, -1, getdate()) create index idx_er101_upd_date_iso on #my_temporary_table(er101_upd_date_iso) select top 100 from #my_temporary_table er101_upd_date_iso desc;
select top 100 from er101_acct_order_dtl er101_upd_date_iso desc ) select er101_acct_order_dtl.* from recs join er101_acct_order_dtl er101_upd_date_iso desc;
set transaction isolation level read uncommitted;
select avg(current_tasks_count) as [avg task count], avg(runnable_tasks_count) as [avg runnable task count], avg(pending_disk_io_count) as [avg pending diskio count] from sys.dm_os_schedulers with (nolock) where scheduler_id < 255 option (recompile);
select *, sum(col3) from a group by  col2, col1;
select *, sum(col3) from a group by  col1, col2;
select spec_id, catid, spec_display_value, count(*) as cnt  from tbl_product_spec;
select spec_id, catid, spec_display_value, count(*) as cnt  from tbl_product_spec force index(idx_comp_spec_cnt);
select * from news where date < dateadd(day, -1, date);
select * from news where date > dateadd(d,-1,getdate());
select * from news where date > date_sub(now(), interval 24 hour);
select * from news where date >= now() - interval 1 day;
select [fields] from [table] where timediff(now(), my_datetime_field) < '24:00:00';
select * from new where date < date_add(now(),interval -1 day);
select * from [table_name] where date > (now() - interval 24 hour);
exec sp_rename @newname = 'new_constraint', @objtype = 'object';
exec sp_rename n'schema.myioldconstraint', n'mynewconstraint', n'object';
delete all the existing records;
select datediff (myunits, '2010-01-22 15:29:55.090', '2010-01-22 15:30:09.153');
select  datediff(day, '2010-01-22 15:29:55.090', '2010-01-22 15:30:09.153');
select datediff (m, '20100131', '20100201');
select datediff(mi, '2010-01-22 15:29:55.090' , '2010-01-22 15:30:09.153');
select date1, date2, date2 - date1 as differenceindays from mytable;
case when datediff(s, startdate, enddate) >= 359999 then cast(datediff(s, startdate, enddate) / 86400        as varchar(7)) + ':' else right('0' + cast(datediff(s, startdate, enddate)        / 3600 as varchar(2)), 2) + ':' end;
select cast((@dt2-@dt1) as time(0));
select datediff(day,'1997-10-07','2011-09-11');
select datediff(day,'1997-10-07', getdate() );
select dateadd(day,  45, getdate()) -- actual datetime adding 45 days select dateadd(  s,-638, getdate()) -- actual datetime subtracting 10 minutes and 38 seconds;
select convert(  char(8), getdate() ,   8) -- part hh:mm:ss of actual datetime select convert(  varchar, getdate() , 112) -- yyyymmdd select convert( char(10), getdate() ,  20) -- yyyy-mm-dd limited by 10 characters;
set @date1=dateadd(s,-638,getdate()) set @date2=getdate() select convert(char(8),dateadd(s,datediff(s,@date1,@date2),'1900-1-1'),8);
select distinct convert(char(8),dateadd(s,datediff(s, crdate , getdate() ),'1900-1-1'),8) from sysobjects order by 1;
if object_id('ufn_hourminutesecond') is not null drop function dbo.ufn_hourminutesecond 'create function dbo.ufn_hourminutesecond ( @startdatetime datetime, @enddatetime datetime as begin @minute int, @hour int, @elapsed varchar(10) select @seconds = abs(datediff(second ,@startdatetime,@enddatetime)) if @seconds >= 60 select @minute = @seconds/60 select @seconds = @seconds%60 if @minute >= 60 select @hour = @minute/60 select @minute = @minute%60 end  else goto final end  select @hour = isnull(@hour,0), @minute = isnull(@minute,0), @seconds =               isnull(@seconds,0) select @elapsed = cast(@hour as varchar) + '':'' + cast(@minute as varchar) + '':'' +     cast(@seconds as varchar) );
select convert(varchar(max), datediff(dd, '2019-08-14 03:16:51.360', '2019-08-15 05:45:37.610')) '2019-08-15 05:45:37.610'), '1900-1-1'), 8);
select datediff(second, '2010-01-22 15:29:55.090' , '2010-01-22 15:30:09.153');
select datediff(millisecond,'2010-01-22 15:29:55.090','2010-01-22 15:30:09.153') / 1000.0 as secs;
select datediff(yyyy, '2011/08/25', '2017/08/25') as datediff;
select datediff(millisecond,'2010-01-22 15:29:55.090', '2010-01-22 15:30:09.153')/1000.00;
select datediff(year,        '2005-12-31 23:59:59.9999999', '2006-01-01 00:00:00.0000000');
select datediff(quarter,     '2005-12-31 23:59:59.9999999', '2006-01-01 00:00:00.0000000');
select datediff(month,       '2005-12-31 23:59:59.9999999', '2006-01-01 00:00:00.0000000');
select datediff(dayofyear,   '2005-12-31 23:59:59.9999999', '2006-01-01 00:00:00.0000000');
select datediff(day,         '2005-12-31 23:59:59.9999999', '2006-01-01 00:00:00.0000000');
select datediff(week,        '2005-12-31 23:59:59.9999999', '2006-01-01 00:00:00.0000000');
select datediff(hour,        '2005-12-31 23:59:59.9999999', '2006-01-01 00:00:00.0000000');
select datediff(minute,      '2005-12-31 23:59:59.9999999', '2006-01-01 00:00:00.0000000');
select datediff(second,      '2005-12-31 23:59:59.9999999', '2006-01-01 00:00:00.0000000');
select datediff(millisecond, '2005-12-31 23:59:59.9999999', '2006-01-01 00:00:00.0000000');
set @fdate = dbo.getvdate(@fdate) set @tdate = dbo.getvdate(@tdate) set @ftime = datepart(hh,@fdate) set @ttime = datepart(hh,@tdate) if datediff(hour,@fdate, @tdate) <= 9 else --setting working hours set @nftime = dbo.getv00(convert(varchar(2),datepart(hh,@fdate))) + ':' +dbo.getv00(convert(varchar(2),datepart(mi,@fdate))) + ':'+  dbo.getv00(convert(varchar(2),datepart(ss,@fdate))) set @nttime = dbo.getv00(convert(varchar(2),datepart(hh,@tdate))) + ':' +dbo.getv00(convert(varchar(2),datepart(mi,@tdate))) + ':'+  dbo.getv00(convert(varchar(2),datepart(ss,@tdate))) if @ftime > 17 set @nftime = '17:00:00' end else begin if @ftime < 8 set @nftime = '08:00:00' end  if @ttime > 17 set @nttime = '17:00:00' end else begin if @ttime < 8 set @nttime = '08:00:00' end  set @nfdate = dateadd(day,1,@fdate) set @ntdate = @tdate set @nfdate = convert(varchar,datepart(yyyy,@nfdate)) + '-' + convert(varchar,datepart(mm,@nfdate)) + '-' + convert(varchar,datepart(dd,@nfdate)) set @ntdate = convert(varchar,datepart(yyyy,@ntdate)) + '-' + convert(varchar,datepart(mm,@ntdate)) + '-' + convert(varchar,datepart(dd,@ntdate)) set @cnt = 0 set @daydiff = 0 set @cntdate = @nfdate set @daydiffwk = convert(decimal(18,2),@ntdate-@nfdate) if (not datename(dw, @cntdate) = 'saturday') and (not datename(dw, @cntdate) = 'sunday') set @daydiff = @daydiff + 1 end set @cntdate = dateadd(day,1,@cntdate) set @cnt = @cnt + 1 end  set @fdate = convert(varchar,datepart(yyyy,@fdate)) + '-' + convert(varchar,datepart(mm,@fdate)) + '-' + convert(varchar,datepart(dd,@fdate)) + ' ' + @nftime set @tdate = convert(varchar,datepart(yyyy,@tdate)) + '-' + convert(varchar,datepart(mm,@tdate)) + '-' + convert(varchar,datepart(dd,@tdate)) + ' ' + @nttime set @markerfdate = convert(varchar,datepart(yyyy,@fdate)) + '-' + convert(varchar,datepart(mm,@fdate)) + '-' + convert(varchar,datepart(dd,@fdate)) + ' ' + '17:00:00' set @markertdate = convert(varchar,datepart(yyyy,@tdate)) + '-' + convert(varchar,datepart(mm,@tdate)) + '-' + convert(varchar,datepart(dd,@tdate)) + ' ' + '08:00:00' set @hrsdiff = convert(decimal(18,2),datediff(hh,@fdate,@markerfdate)) set @hrsdiff = @hrsdiff +  convert(int,datediff(hh,@markertdate,@tdate)) if convert(varchar,datepart(yyyy,@fdate)) + '-' + convert(varchar,datepart(mm,@fdate)) + '-' + convert(varchar,datepart(dd,@fdate)) = convert(varchar,datepart(yyyy,@tdate)) + '-' + convert(varchar,datepart(mm,@tdate)) + '-' + convert(varchar,datepart(dd,@tdate)) set @hrsdiff = datediff(hour,@fdate,@tdate) end  if (@hrsdiff / 9) > 0 set @daydiff = @daydiff + floor(@hrsdiff / 9) set @hrsdiff = @hrsdiff - floor(@hrsdiff / 9)*9 end ;
select starttime from [yourtable];
select starttime from [yourtable];
select datepart(hour,[endtime]-[starttime]) from [yourtable];
select emp_name, dept from employee where trunc(time_created) = date '2011-01-26';
select emp_name, dept from employee where trunc(time_created) = to_date('26/jan/2011','dd/mon/yyyy');
select emp_name, dept from employee where time_created >= to_date('26/jan/2011','dd/mon/yyyy') and time_created < to_date('26/jan/2011','dd/mon/yyyy') + 1;
select emp_name, dept from employee where trunc(time_created) = to_date('26/jan/2011','dd/mon/yyyy');
select emp_name, dept from employee where time_created between to_date('26/jan/2011','dd/mon/yyyy') and to_date('26/jan/2011','dd/mon/yyyy') + interval '86399' second;
select emp_name from employee where time_created >= to_date('26/jan/2011 00:00:00', 'dd/mon/yyyy hh24:mi:ss');
select date_format(colname, '%y-%m-%d') dateonly, date_format(colname,'%h:%i:%s') timeonly;
select date(`date_time_field`) as date_part, time(`date_time_field`) as time_part from `your_table`;
select date(datetimefield) as date, time(datetimefield) as time, col2, col3, from table1 ...;
alter table table1 disable trigger all;
alter table table2 disable trigger all;
delete from table1;
delete from table2;
alter table table1 enable trigger all;
alter table table2 enable trigger all;
delete from kontakty where id_osoby = 1;
delete from osoby where id_osoby = 1;
select pg_get_constraintdef(oid) as constraint_def from   pg_constraint where  conrelid = 'public.kontakty'::regclass  -- assuming pubic schema and    conname = 'kontakty_ibfk_1';
alter table kontakty drop constraint kontakty_ibfk_1;
alter constraint;
select * from sys.procedures where name like '%name_of_proc%';
select text from syscomments c where p.name like '%name_of_proc%';
select * from information_schema.routines where routine_name like '%name_of_proc%';
select '[' + s.name + '].[' + o.name + ']', o.type_desc from sys.objects o join sys.schemas s on s.schema_id = o.schema_id where o.name = 'createallthethings' -- if you are certain of the exact name or o.name like '%createallthe%' -- if you are not so certain;
select routine_catalog as databasename , routine_schema as schemaname, specific_name as spname , routine_definition as spbody , created as createddate, last_altered as lastmodificationdate from information_schema.routines where (routine_definition like '%%') and (routine_type='procedure') and (specific_name like '%assessmenttooldegreedel');
view > object explorer details;
select * from syscomments c where p.name like '%usp_connectionscount%';
select name from master.dbo.sysdatabases where status not like 48 and name not in ('master','model','msdb','tempdb','distribution') select @statement = 'select * from ['+@dbname+'].information_schema.routines  where [routine_name] like ''%name_of_proc%'''+';' exec sp_executesql @statement end close db_cursor;
where lastname like '%' + @lastname + '%';
where lastname like '%@lastname%';
set @lastname = 'ning' select employee where lastname like '%' + @lastname + '%';
where lastname like concat('%',@lastname,'%');
dbcommand command, dbcommandinterceptioncontext<int> interceptioncontext) dbcommand command, dbcommandinterceptioncontext<dbdatareader> interceptioncontext) dbcommand command, dbcommandinterceptioncontext<object> interceptioncontext) sqlparam.parametername, sqlparam.sqldbtype.tostring().tolower(), getsqldatatypesize(sqlparam));
if (param.size == 0) if (param.size == -1) dbcommand command, dbcommandinterceptioncontext<int> interceptioncontext) dbcommand command, dbcommandinterceptioncontext<dbdatareader> interceptioncontext) dbcommand command, dbcommandinterceptioncontext<object> interceptioncontext);
if (!isdbinterceptioninitialised);
entityconn,entityconn.connectiontimeout }, cultureinfo.invariantculture);
"producecommands", bindingflags.nonpublic | bindingflags.instance);
sqlparam.parametername, sqlparam.sqldbtype.tostring().tolower(), sqlparam.size > 0 ? "(" + sqlparam.size + ")" : ""));
"producecommands", bindingflags.nonpublic | bindingflags.instance);
sqlparam.parametername, sqlparam.sqldbtype.tostring().tolower(), sqlparam.size > 0 ? "(" + sqlparam.size + ")" : ""));
select distinct on (id) id, date, another_info from the_table;
select id, date, another_info from ( select id, date, another_info, row_number() over (partition by id order by date desc) as rn from the_table where rn = 1;
select  id, max(date), another_info from the_table;
select * from bar where (id,date) in (select id,max(date) from bar group by id);
case when field1>0 then field2/field1 else 0 end as field3;
select field1, field2, case when field1>0 then field2/field1 else 0 end as field3 from test;
select coalesce(nullif(y,''),x), coalesce(nullif(x,''),y), * from (     (select 'abc' as x, '' as y) union all (select 'def' as x, 'ghi' as y) union all (select '' as x, 'jkl' as y) union all (select null as x, 'mno' as y) union all (select 'pqr' as x, null as y);
select distinct id, customer_id, domain from config;
select distinct id, customer_id, 'www.example.com' from config;
select distinct id, customer_id, 'www.example.com' from config;
update config set domain = 'www.example.com';
select id, customer_id, domain from config;
select id, customer_id, 'www.example.com' from ( select distinct id, customer_id, domain from config where type = 'foo';
insert into sample(firstname,lastname) second_insert as ( insert into sample1( id ,adddetails) values ( (select id from first_insert), 'ss') ) values ( (select user_id from first_insert), 'ss');
insert into sample(firstname, lastname) values ('fai55', 'shaggk') ) insert into sample1 (sample_id, adddetails) select sample_id, 'ss' from ins1 ) select user_id, 'ss2' from ins2;
values                              -- provide data here ) insert into sample (firstname, lastname) select firstname, lastname          -- distinct? see below from   data ) insert into sample1 (sample_id, adddetails) select ins1.sample_id, d.adddetails from   data d join   ins1 using (firstname, lastname) ) select ins2.user_id, d.value from   data d join   ins1 using (firstname, lastname) join   ins2 using (sample_id);
select distinct firstname, lastname from data;
insert into sample(firstname, lastname) insert into sample1(id, adddetails) select id,'ss' from sample_ids ) select id, user_id, 'val' from sample1_ids;
select * from <table>;
somestring varchar(100), somevalue int;
somevalue int, somestring varchar(100);
select column1 from table;
select column2 from table;
alter table table_name modify field_name timestamp(6) not null;
3    "company code" varchar2(255), 4    "company name" varchar2(255), 5    "sector_code" varchar2(255), 6    "sector_name" varchar2(255), 7    "business_unit_code" varchar2(255), 8    "business_unit_name" varchar2(255), 9    "department_code" varchar2(255), 10    "department_name" varchar2(255), 11    "hr_org_id" varchar2(255), 12    "hr_org_name" varchar2(255), 13    "cost_center_number" varchar2(255), 14    " " varchar2(255) table created.;
where department_code = 'bah';
create table ps_tbl_department_details company_name varchar2(255), cost_center_number varchar2(255));
select * from ps_tbl_department_details;
select * from ps_tbl_department_details;
select * from ps_tbl_department_details where comapny_code = 'orcl' and cost_center_number = '0980';
select a.emplid, b.first_name, c.last_name from ps_person a where length(a.emplid) = 9 and length(b.last_name) > 5 and length(c.last_name) > 5 select a.emplid, b.first_name, c.last_name from ps_person a where b.emplid = a.emplid and c.emplid = a.emplid and length(a.emplid) = 9 and length(b.last_name) > 5 and length(c.last_name) > 5;
select a.emplid, b.first_name, c.last_name from ps_person a where b.emplid = a.emplid and length(a.emplid) = 9 and length(b.first_name) > 5 and length(c.last_name) > 5 select a.emplid, b.first_name, c.last_name from ps_person a where b.emplid = a.emplid and length(a.emplid) = 9 and length(b.first_name) > 5 and length(c.last_name) > 5;
select * from emp_table where emp_id=123;
select * from emp_table where emp_id='123';
select id,numbers_from,created_date,amount_numbers,sms_text from test_table where created_date <= '2013-12-04';
select id,numbers_from,created_date,amount_numbers,sms_text from test_table where convert(datetime, convert(varchar(10), created_date, 102))  <= convert(datetime,'2013-04-12');
select id,numbers_from,created_date,amount_numbers,sms_text from test_table where created_date <= convert(date,'2013-04-12',102);
select id,numbers_from,created_date,amount_numbers,sms_text from test_table where created_date <= #2013-04-12#;
select * from employeetable where departmentid=%departmentvalue%;
create database;
create database if not exists;
if (temp[temp.length - 1] == '$') {;
select * from [sheet1$];
select * from myrange;
select * from [sheet1$a1:b10];
select table1.field1 from table1 order by table1.field1 union select table2.field1 from table2 order by field1;
select field1 from table1 union select field1 from table2;
union select table2.field1 from table2) order by field1;
select [product id], [order date], [company name], [transaction], [quantity] from [product orders] union select [product id], [creation date], [company name], [transaction], [quantity] from [product purchases];
select supplier_id, supplier_name from suppliers where supplier_id > 2000 union select company_id, company_name from companies where company_id > 1000;
select table1column1 as col1,table1column2 as col2 from table1 union (    select table2column1 as col1, table1column2 as col2 from table2 );
select * from ( select table1.field1 from table1 order by table1.field1 union all  select * from ( select table2.field1 from table2 order by table2.field1;
select field1 from ( select field1 from table1 union select field1 from table2;
select name from folders order by name union select name from files order by name;
select name from ( select 1 as rank, name from folders union select 2 as rank, name from files) dt;
select * from where pointtype = 1 union all select * from where pointtype = 2;
select * from ( select table1.field1 from table1 order by table1.field1 union select table2.field1 from table2 order by table2.field1;
select top (100) percent field1, field2, field3, field4, field5 from union all select table2.field1, table2.field2, table2.field3, table2.field4, table2.field5 from  table2) as unitedtables order by field5 desc;
select 1 as type, field1 from table1 union select 2 as type, field1 from table2;
union (select field2 from table2 order by field2) union (select field3 from table3 order by field3) order by newfield;
select a from table1 union select a from table2;
select a from table1 order by field1 union select a from table2 order by field1;
select * from ( select table1.field1 from table1 order by table1.field1 union all  select * from ( select table2.field1 from table2 order by table2.field1;
select * from ( select top 100 percent table1.field1 from table1 order by table1.field1 union all  select * from ( select top 100 percent table2.field1 from table2 order by table2.field1;
select * from ( select table1.field1 from table1 order by table1.field1 ) as dummy_alias1 union all  select * from ( select table2.field1 from table2 order by table2.field1 ) as dummy_alias2;
where date(datetime_column) = ...;
from sqlalchemy import or_ user.lastname.like(searchvar)));
user.firstname.like(search_var1), user.lastname.like(search_var2) );
firstname.like(search_var1), lastname.like(search_var2) );
from sqlalchemy import and_, or_, not_ and_( user.firstname.like(search_var1), user.lastname.like(search_var2) ) );
if (isset($_get['pn'])) { // get pn from url vars if it is present if ($pn < 1) { // if it is less than 1 if ($pn == 1) { if ($lastpage != "1"){ if ($pn != 1) { if ($pn != $lastpage) {;
select count(*) from table ')->fetchcolumn();
'options' => array( 'default'   => 1, 'min_range' => 1, ), )));
select * from table order by name limit :limit if ($stmt->rowcount() > 0) {;
if (isset($_get['currentpage']) && is_numeric($_get['currentpage'])) { if ($currentpage > $totalpages) { if ($currentpage < 1) { if ($currentpage > 1) { if (($x > 0) && ($x <= $totalpages)) { if ($x == $currentpage) { if ($currentpage != $totalpages) {;
update [dbname].[dbo].[mytable] set mycolumn = 1 where ( select count(*) from [dbname].[dbo].[mytable] mt2 where mt2.id > [dbname].[dbo].[mytable].id and mt2.category = [dbname].[dbo].[mytable].category;
update accounts set (contact_first_name, contact_last_name) = where salesmen.id = accounts.sales_id);
update accounts set contact_first_name = first_name, contact_last_name = last_name from salesmen where salesmen.id = accounts.sales_id;
update tempdataview set (marks) = where tempdataview.name = tempdata.name);
update a set a.valuetochange = b.newvalue from ( select * from c where a.id = b.id;
update  a set     a.marks = b.marks from    tempdataview a;
update  tempdataview set     marks = ( select marks from tempdata b where tempdataview.name = b.name );
select * from    tempdataview a;
update  b set     b.marks = a.marks from    tempdataview a;
delete a from    tempdataview a;
update mytable set    mycolumn = upper(mycolumn) where  mycolumn != upper(mycolumn) collate latin1_general_cs_as;
select serverproperty('collation') select name, collation_name from sys.databases select column_name, collation_name from information_schema.columns where character_set_name is not null;
update mytable set mycolumn = upper(mycolumn);
select upper(mycolumn) as mycolumn from mytable;
alter table rename index;
alter table drop key oldkeyname, add key newkeyname (...);
set foreign_key_checks = 0;
alter table tbl drop index index_name;
alter table tbl add index new_index_name (indexed_column);
set foreign_key_checks = 1;
alter table tbl_name rename index old_index_name to new_index_name;
alter table tbl_name drop index old_index_name, add index new_index_name (...);
select id, case when col1 < col2 and col1 < col3 then col1 else col3 end as themin from   yourtablenamehere;
select case when col1 <= col2 and col1 <= col3 then col1 case when col2 <= col1 and col2 <= col3 then col2 case when col3 <= col1 and col3 <= col2 then col3 as 'themin' end  from table t;
select min(val) from tbl;
select *, case when column1 < columnl2 and column1 < column3 then column1 else column3 end as minvalue from   tbl_example;
select t.id, t.col1, t.col2, t.col3, a.themin from   yourtable t select a.id, min(a.col1) as themin from   ( select id, col1 from   yourtable union all  select id, col2 from   yourtable union all  select id, col3 from   yourtable;
as ( select   t.yourid , cast(( select   col1 as c01 , col2 as c02 , col3 as c03 , col4 as c04 , col5 as c05 from     yourtable as cols where    yourid = t.yourid elements from     yourtable as t ) select  yourid , colslist.query('for $c in //cols return min(data($c/*))').value('.', 'real') as yourmin , colslist.query('for $c in //cols return avg(data($c/*))').value('.', 'real') as youravg , colslist.query('for $c in //cols return max(data($c/*))').value('.', 'real') as yourmax from    res;
values (1, 3, 34, 76), (2, 32, 976, 24), (3, 7, 235, 3), (4, 245, 1, 792) select id, col1, col2, col3, ( select min(t.col) from ( select foo.col1 as col union all select foo.col2 as col union all select foo.col3 as col from @foo as foo;
create function f_min_int(@a as int, @b as int) as begin end;
select col1, col2, col3, dbo.f_min_int(dbo.f_min_int(col1,col2),col3);
select col1, col2, col3, col4, col5, dbo.f_min_int(dbo.f_min_int(dbo.f_min_int(dbo.f_min_int(col1,col2),col3),col4),col5);
select case when 0 in (page1status ,page2status ,page3status, page4status,page5status ,page6status) then 0 else 1 end from customers_forms;
select case else                                    col3 end as [min value] from [your table];
select case else                                                                      col5 end as [min value] from [your table];
select id, col1, col2, col3, minvalue from yourtable;
if object_id('tempdb..#temp1') is not null drop table #temp1 if object_id('tempdb..#temp2') is not null drop table #temp2 select r.recordid ,  r.referencenumber, i.inventiontitle, recorddate, i.receiveddate from record r join invention i on i.inventionid = r.recordid where r.recorddate > '2015-05-26' r.referencenumber, i.inventiontitle select recordid, recorddate [min date] from #temp1 update #temp2 set [min date] = receiveddate from #temp1 t1 join #temp2 t2 on t1.recordid = t2.recordid where t1.receiveddate < [min date] and  t1.receiveddate > '2001-01-01' update #temp2 set [min date] = t1.[min file upload] from #temp1 t1 join #temp2 t2 on t1.recordid = t2.recordid where t1.[min file upload] < [min date] and  t1.[min file upload] > '2001-01-01' update #temp2 set [min date] = t1.[min file correspondence] from #temp1 t1 join #temp2 t2 on t1.recordid = t2.recordid where t1.[min file correspondence] < [min date] and t1.[min file correspondence] > '2001-01-01' select t1.*, t2.[min date] [lowest date] from #temp1 t1 join #temp2 t2 on t1.recordid = t2.recordid;
select id, col1, col2, col3, (select min(col) from (values (col1), (col2), (col3)) as x(col)) as themin from table;
select least(col1, col2, col3) from yourtable;
select [id], ( select min([value].[minvalue]) from ( values ([col1]), ([col1]), ([col2]), ([col3]) from table;
create table #temptable (id int, columnname varchar(20), datavalue int) select id, 'col1', col1 from sourcetable where col1 is not null select id, 'col2', col2 from sourcetable where col2 is not null select id, 'col3', col3 from sourcetable where col3 is not null select id from #temptable;
create function <b>pg_temp.</b>f_inc(int) select <b>pg_temp.</b>f_inc(42);
create index foo_idx on tbl (pg_temp.f_inc(id));
update tbl t set set_name = $2 where tbl_id = $1;
create function pg_temp.testfunc() returns text as;
2         instr('abc_blahblahblah','_',1,1) position_underscore, 3         substr('abc_blahblahblah',1,instr('abc_blahblahblah','_',1,1)-1) result;
select nvl(substr('abc_blah', 0, instr('abc_blah', '_')-1), 'abc_blah') as output from dual;
select nvl(substr(t.column, 0, instr(t.column, '_')-1), t.column) as output from your_table t;
select regexp_substr('string_example','[^_]+',1,1)  from dual;
select regexp_substr('host.domain','[^.]+',1,1)  from dual;
select regexp_substr('host','[^.]+',1,1)  from dual;
select coalesce "string_column") as output from dual;
select regexp_substr('string_example','[^_]+',1,1) from dual;
select substr(string_value,instr(string_value,'ple'),length('ple')) from dual;
delete from tablea where entitynum in (...your select...);
delete from tablea where (...your select...);
delete from tablea where entitynum in ( select tablea.entitynum from tablea q where (length(q.memotext) not in (8,9,10) or q.memotext not like '%/%/%') and (u.fldformat = 'date') );
delete from tablea where (select q.entitynum from tablea q where (length(q.memotext) not in (8,9,10) or q.memotext not like '%/%/%') and (u.fldformat = 'date'));
delete from tablea where entitynum in (select q.entitynum from tablea q where (length(q.memotext) not in (8,9,10) or q.memotext not like '%/%/%') and (u.fldformat = 'date'));
delete from tablea where rowid in from tablea q where (length(q.memotext) not in (8,9,10) or q.memotext not like '%/%/%') and (u.fldformat = 'date'));
delete tablea from tablea where (length(tablea.memotext) not in (8,9,10) or tablea.memotext not like '%/%/%') and (u.fldformat = 'date');
delete q from tablea q where (length(q.memotext) not in (8,9,10) or q.memotext not like '%/%/%') and (u.fldformat = 'date');
create table exclusions(excl varchar(250));
values ('%timeline%'), ('%placeholders%'), ('%stages%'), ('%master_stage_1205x465%'), ('%accessories%'), ('%chosen-sprite.png'), ('%webresource.axd');
create view tobedeleted as select * from chunks where chunks.file_id in ( select distinct lf.file_id from largefiles lf where lf.file_id not in ( select distinct lf.file_id from largefiles lf where e.excl is null ) set nocount on;
delete top (10000) from tobedeleted;
set @r = @@rowcount end go;
select * from books where title similar to '^[0-9]*$';
select * from books where title similar to '^[0-9]%$';
select * from books where title ~ '^[0-9]*$';
select * from books where title similar to '[0-9]*';
select * from books where title ~ '^[0-9]+';
select * from books where price::text like '123%';
select * from books where price > 89999 and price < 90100;
select * from books where title ~ '^[0-9]';
select * from books where cast(price as text) like '123%';
select * from books where price between 123000 and 123999;
select * from books where title ~ '^\d+ ?';
select * from books where convert(char(32), book_id) like '7%';
where title >= '0' and title < ':';
select * from notification where `date` >= '2011-05-03' for update;
select * from notification where `date` = '2011-05-02' for update;
set session transaction isolation level read committed;
create table `t1` ( `id` int(11) not null auto_increment, `notid` int(11) default null, primary key (`id`);
select * from t1 where id=5 for update;
select * from t1 where id!=5 for update;
select * from t1 where id<5 for update;
select * from t1 where notid!=5 for update;
select * from t1 where notid<5 for update;
select * from t1 where id<=4 for update;
select * from t1 where id>5 for update;
select * from t1 where id=3 for update;
select * from t1 where id=4 for update;
select * from t1 where id=6 for update;
select * from t1 where id=7 for update;
select * from t1 where notid=5 for update;
select *, @x:=@x+id as counter from t1 cross join (select @x:=0) b having counter>5 limit 1 for update;
select * from t1 where id=2 for update;
select * from t1 where id=4 for update;
create database so1;
create table notification (`id` bigint(20), `date` date, `text` text) engine=innodb;
select * from notification where `date` >= '2011-05-03' for update;
select * from notification where `date` = '2011-05-02' for update;
select ... for update;
values ('auto dealer');
values ('auto dealer');
select n1.name, n1.author_id, cast(count_1 as numeric)/total_count from (select id, name, author_id, count(1) as count_1 from names from names) n2 where true;
create table items ( n integer not null, s text not null select (random()*1000000)::integer as n, md5(random()::text) as s from generate_series(1,1000000);
create index n_index on items(n);
select i.* from items i select count(1), n from items where i.n in (243477, 997947);
index cond: (n = any ('{243477,997947}'::integer[]));
select i.* from items i select count(1), n from items where n = i.n where i.n in (243477, 997947);
index cond: (n = any ('{243477,997947}'::integer[])) index cond: (n = i.n);
select name, author_id, count(*), t.total from names as n1 select count(*) as total from names as n2 where n2.id = n1.id and n2.author_id = n1.author_id n1.name, n1.author_id;
select n1.name, n1.author_id, count_1, total_count from (select id, name, author_id, count(1) as count_1 from names from names;
select n1.name, n1.author_id, cast(count_1 as numeric)/total_count from (select id, name, author_id, count(1) as count_1 from names from names;
select cast(getdate() as date);
select cast(getdate() as binary(8));
select dateadd(day, datediff(day, 0, getdate()), 0);
set identity_insert mytable on select admincolvalue from tableb;
set identity_insert mytable off;
select scope_identity();
select isnull(max(admidid), 0) + 1 from mytable;
alter table `schemaname`.`table1` add column `fk_column` bigint(20) not null, add constraint `fk_table2_column` foreign key (`fk_column`);
alter table `userdb`.`address_table` add column `user_id` bigint(20) not null after `phone_number`, add constraint `fk_customer_table_customer_id` foreign key (`user_id`);
alter table database.table add column columnname int default(1), add foreign key (fk_name) references reftable(refcolumn) on delete cascade;
alter table database.table add column columnname int default(1);
alter table database.table add foreign key (fk_name) references reftable(refcolumn) on delete cascade;
alter table database.table add column columnname int default(1), add foreign key fk_name(fk_column) references reftable(refcolumn) on delete cascade;
create table if not exists `task`( `id` int not null auto_increment primary key , `teaching_hours` decimal(5,2) default null, `isactive` boolean default false, `is_validated` boolean default false, ) engine=innodb default charset=utf8;
where c.idcatalog= :id and p.productname like :xxx");
create procedure dbo.uspbeafraidbeveryafraid ( @p1 varchar(64) ) as set nocount on set @sql = 'select * from ' + @p1;
exec dbo.mystoredproc 'dodgytext';
select  @parameterdefinition = '@date varchar(10)' set @sql='select cast(@date as datetime) date' exec sp_executesql @sql,@parameterdefinition,@date='04/15/2011';
case count(column_name) else count(column_name) end;
select column + (column = 0)::integer;
select concat("alter table `", table_name,"` default character set utf8 collate utf8_unicode_ci;") as    mysql from information_schema.tables where table_schema="myschema" and table_type="base table";
alter table tbl_name;
select * from information_schema.tables where table_schema="yourdatabasename" and table_type="base table";
select concat("alter table ", table_schema, '.', table_name," collate your_collation_name_here;") as    executethestring from information_schema.tables where table_schema="yourdatabasename" and table_type="base table";
set @my_schema = "";
select distinct concat("alter table ", table_name," convert to character set utf8mb4 collate utf8mb4_unicode_ci;") as queries from information_schema.tables where table_schema=@my_schema and table_type="base table" union  select distinct concat("alter table ", c.table_name, " change ", c.column_name, " ", c.column_name, " ", c.column_type, " character set utf8mb4 collate utf8mb4_unicode_ci;") as queries from information_schema.columns as c where c.collation_name is not null and c.table_schema=@my_schema and t.table_type="base table" union  select distinct concat("create or replace view ", v.table_name, " as ", v.view_definition, ";") as queries from information_schema.views as v where v.table_schema=@my_schema and t.table_type="view";
select concat('alter table `', table_name,'` convert to character set utf8 collate utf8_general_ci;') as    mysql from information_schema.tables where table_schema= "myschema" and table_type="base table";
set foreign_key_checks = 0;
set foreign_key_checks = 0;
alter table `table1` convert to character set utf8 collate utf8_unicode_ci;
alter table `table2` convert to character set utf8 collate utf8_unicode_ci;
alter table `tablexxx` convert to character set utf8 collate utf8_unicode_ci;
set foreign_key_checks = 1;
select group_concat("alter table ", table_schema, '.', table_name," convert to character set utf8mb4 collate utf8mb4_unicode_ci;" separator ' ') as    onesqlstring from information_schema.tables where table_schema="yourtableschemaname" and table_type="base table";
while read table; do );
while read table; do );
while read table; do );
if [[ "$tablename" != "table_name" ]] ; then;
delete table1 from table1 t1, table2 t2 where t1.id = t2.id;
delete table1 from table1 t1 inner join table2 t2 on t1.id = t2.id;
delete table1 from table1;
delete t1 from table1 t1 join table2 t2 on t1.id = t2.id;
delete from table1 where table1.id in (select table2.id from table2);
delete from table1 where exists( select 1 from table2 where table1.id = table2.id);
delete from table1 from tabel1 t1;
delete from table1 where exists ( select 1 from table2 where table1.id = table2.id );
delete table1 from t2 where table1.id=t2.id;
delete from table1 a,table2 b where a.id=b.id or  delete from table1 where table1.id in (select table2.id from table2) or  delete table1 from table1 t1 inner join table2 t2 on t1.id = t2.id;
delete deletingfromtable from deletingfromtable inner join criteriatable where criteriatable.criteria = "value";
delete subscribers, subscriptions from subscribers inner join subscriptions where subscribers.name='wes';
delete from trans where   yr = '16' and     tran_date = '01/22/2016' and     acct_type = 'r' and     tran_type = 'a' and     bill_no in and res_exempt != 'p');
delete table1 from table2 where table1.joincolumn = table2.joincolumn and table1.somestuff = 'somestuff';
delete from t1 where t1.id = t2.id;
select t2.id from table2 t2;
delete ... from;
delete from table1 as t1 where id_number not in;
set @myboolean = 0;
set @myboolean = @myboolean ^ 1;
select @myboolean;
set @myboolean = case @myboolean when 0 then 1 else 0 end;
set @myboolean = 0 set @myboolean = ~@myboolean select @myboolean;
set @trend = 0 select @trend, abs(@trend-1);
select ~convert(bit, 1);
set @t=1 select ~@t;
select substring_index( field1, ' ', 1 );
select substring_index( field1, ' ', -1 );
select substr(field1, 0, locate(' ', field1)) from your_table;
select if( locate(' ', field1), substr(field1, 0, locate(' ', field1)), field1;
select left(field1,locate(' ',field1) - 1);
select case when exists (select 1 from ....) then 1 else 0 end as 'minbit' from ... where ...;
select case when min(bitfield+0) = 1 then 'true' else 'false' end as mycolumn from mytable;
select min(convert(int, somebitfield));
select convert(bit, min(convert(int, somebitfield)));
select   ..., min(case when somebitfield=1 then 1 else 0 end), min(somebitfield+0)... from     ... where    ...;
select col from tbl;
select last_updated from your_table last_updated asc;
create index foo_idx on tbl (last_updated desc nulls last);
create table suppliers as (select * from companies where 1=2);
select * from employees where 1=2;
create table empl_demo as select * from employees where 1=2;
create table empl_demo as select * from employees limit 0;
create table empl_demo as select * from employees where 1=2; //just structure not data create table empl_demo as select * from employees where 1=1; //ststructure and data;
create table empl_demo as memployees with no data; //structure create table empl_demo as memployees with data; //structure and data;
set @now = getdate() set @thirtydaysago = dateadd(day,-30,@now) select @now, @thirtydaysago;
select dateadd(day, -30, getdate());
select date_add(now(), interval -30 day);
select getdate() - 30;
select (column name) from (table name) where (column name) < dateadd(day,-30,getdate());
select `name`, `phone`, `product` from `tbmmember` where `dateofservicw` < (day,-30,getdate());
select c.customer, c.state, e.entry from customer c and e.category='d';
select c.customer, c.state, e.entry from customer as c;
select c.customer, c.state, e.entry from customer c where e.category is null or e.category='d';
select * from table where table.foo=bar order by cola, colb;
select * from tbl where predictor order by col_a, col_b;
select * from users where active = 0;
select * from users where active = 1 /* all active users */;
select * from users where active = 0 /* all inactive users */;
select * from users where active = 'true' select * from users where active = 'false';
select * from users where active;
select * from users where active = 't';
select * from users where active = 1   -- does not work select * from users where active = '1' -- works;
where login like '12345678';
where login ='600009';
create table #temptester (id int, col1 varchar(20), value varchar(20)) values (1, 'this is #1', 'abcdefghij') values (2, 'this is #2', 'foob'), (3, 'this is #3', 'abdefghic'), (4, 'this is #4', 'other'), (5, 'this is #5', 'zyx'), (6, 'this is #6', 'zyx'), (7, 'this is #7', 'zyx'), (8, 'this is #8', 'klm'), (9, 'this is #9', 'klm'), (10, 'this is #10', 'zyx') create clustered index ixid on #temptester(id)create clustered index ixid on #temptester(id) create nonclustered index ixtesting on #temptester(value);
set showplan_xml on;
select * from #temptester where value like 'abc%' select * from #temptester where value = 'abcdefghij';
like '%something';
like 'something%';
select 'hello' from dual where 'hello  ' like 'hello';
select 'hello' from dual where 'hello  ' =  'hello';
create table newtable like oldtable;
create table tbl_new as select * from tbl_old;
create table copy select * from original;
create table new_table like old_table; insert new_table select * from old_table;
create table copy like original;
alter table copy disable keys;
alter table copy enable keys;
set unique_checks=0; set foreign_key_checks=0;
set unique_checks=1; set foreign_key_checks=1;
create table mynewtable (select * from myoldtable);
create table bar (unique (n)) select n from foo;
create table like;
create table select;
create table copy like original;
set @t=100 select top (@t) percent * from tableof;
select top ( select count(foo) from mytable where isnumeric (foo) = 1) * from bar with(nolock) where cast(foo as int) > 100 );
create view v_test as select name from sysobjects;
top 100 percent;
top 100 percent;
create view my_view as select i.item_id, i.item_description, it.item_type_description from items i join item_types it on it.item_type_id = i.item_type_id;
select t.item_id, t.item_description, t.item_type_description from my_view t;
select t.item_id, t.item_description, t.item_type_description from (select i.item_id, i.item_description, it.item_type_description from items i join item_types it on it.item_type_id = i.item_type_id;
select foo from mytable where isnumeric (foo) = 1 and cast(foo as int) > 100;
select foo from (select foo from mytable where isnumeric (foo) = 1) bar where cast(foo as int) > 100;
select foo from (select top 100 percent foo from mytable where isnumeric (foo) = 1 order by foo) bar where cast(foo as int) > 100;
select top 2000000000 ... order by...;
select dbms_xmlgen.getxml("select ....") xml from dual;
select dbms_xmlgen.getxml('select .. where something='red'..') xml from dual;
select dbms_xmlgen.getxml('select .. where something=''red''..') xml from dual;
alter table foo add bar varchar(100) constraint df_foo_bar default ('bicycle') alter table foo add bar varchar(100) default ('bicycle');
constraint constraint_name;
alter table tablename add constraint df_foo_bar default 'bicycle' for fieldname;
select * from table order by cast(mid(name, 6, length(c) -5) as unsigned);
select names from your_table order by games + 0 asc;
create function dbo.udf_naturalsortformat( @string nvarchar(4000), @numberlength int = 10, @sameorderchars char(50) = '' ) as begin @numstartindex int, @numendindex int, @padlength int, @totalpadlength int, @i int, @sameordercharslen int;
select @totalpadlength = 0, @string = rtrim(ltrim(@string)), @sortstring = @string, @numstartindex = patindex('%[0-9]%', @string), @numendindex = 0, @i = 1, @sameordercharslen = len(@sameorderchars);
set @sortstring = replace(@sortstring, substring(@sameorderchars, @i, 1), ' ');
set @i = @i + 1;
end  set @numstartindex = @numstartindex + @numendindex;
set @numendindex = @numstartindex;
set @numendindex = @numendindex + 1;
end  set @numendindex = @numendindex - 1;
set @padlength = @numberlength - (@numendindex + 1 - @numstartindex);
if @padlength < 0 set @padlength = 0;
end  set @sortstring = stuff( @sortstring, @numstartindex + @totalpadlength, 0, replicate('0', @padlength) set @totalpadlength = @totalpadlength + @padlength;
set @numstartindex = patindex('%[0-9]%', right(@string, len(@string) - @numendindex));
select alphanumeric, integer from sorting_test;
drop function if exists `udf_firstnumberpos`;
create function `udf_firstnumberpos` (`instring` varchar(4000)) set position = 5000;
set tmp_position = locate('0', instring); if (tmp_position > 0 and tmp_position < position) then set position = tmp_position; end if;
set tmp_position = locate('1', instring); if (tmp_position > 0 and tmp_position < position) then set position = tmp_position; end if;
set tmp_position = locate('2', instring); if (tmp_position > 0 and tmp_position < position) then set position = tmp_position; end if;
set tmp_position = locate('3', instring); if (tmp_position > 0 and tmp_position < position) then set position = tmp_position; end if;
set tmp_position = locate('4', instring); if (tmp_position > 0 and tmp_position < position) then set position = tmp_position; end if;
set tmp_position = locate('5', instring); if (tmp_position > 0 and tmp_position < position) then set position = tmp_position; end if;
set tmp_position = locate('6', instring); if (tmp_position > 0 and tmp_position < position) then set position = tmp_position; end if;
set tmp_position = locate('7', instring); if (tmp_position > 0 and tmp_position < position) then set position = tmp_position; end if;
set tmp_position = locate('8', instring); if (tmp_position > 0 and tmp_position < position) then set position = tmp_position; end if;
set tmp_position = locate('9', instring); if (tmp_position > 0 and tmp_position < position) then set position = tmp_position; end if;
if (position = 5000) then return 0; end if;
drop function if exists `udf_naturalsortformat`;
create function `udf_naturalsortformat` (`instring` varchar(4000), `numberlength` int, `sameorderchars` char(50)) set totalpadlength = 0;
set instring = trim(instring);
set sortstring = instring;
set numstartindex = udf_firstnumberpos(instring);
set numendindex = 0;
set sameordercharslen = char_length(sameorderchars);
set sortstring = replace(sortstring, substring(sameorderchars, i, 1), ' ');
set numstartindex = numstartindex + numendindex;
set numendindex = numstartindex;
set numendindex = numendindex + 1;
set numendindex = numendindex - 1;
set padlength = numberlength - (numendindex + 1 - numstartindex);
if padlength < 0 then set padlength = 0;
set sortstring = insert(sortstring, numstartindex + totalpadlength, 0, repeat('0', padlength));
set totalpadlength = totalpadlength + padlength;
set numstartindex = udf_firstnumberpos(right(instring, char_length(instring) - numendindex));
select name from products order by udf_naturalsortformat(name, 10, ".");
select * from `table` order by greatest( locate('1', name), locate('2', name), locate('3', name), locate('4', name), locate('5', name), locate('6', name), locate('7', name), locate('8', name), locate('9', name) name;
select name, (name = '-') booldash, (name = '0') boolzero, (name+0 > 0) boolnum from table;
drop function if exists `udf_naturalsortformat`;
create function `udf_naturalsortformat` (`instring` varchar(4000), `numberlength` int, `sameorderchars` char(50)) set totalpadlength = 0;
set instring = trim(instring);
set sortstring = instring;
set numstartindex = udf_firstnumberpos(instring);
set numendindex = 0;
set sameordercharslen = char_length(sameorderchars);
set sortstring = replace(sortstring, substring(sameorderchars, i, 1), ' ');
set numstartindex = numstartindex + numendindex;
set numendindex = numstartindex;
set numendindex = numendindex + 1;
set numendindex = numendindex - 1;
set padlength = numberlength - (numendindex + 1 - numstartindex);
if padlength < 0 then set padlength = 0;
set sortstring = insert(sortstring, numstartindex + totalpadlength, 0, repeat('0', padlength));
set totalpadlength = totalpadlength + padlength;
set numstartindex = udf_firstnumberpos(right(instring, char_length(instring) - numendindex));
select name, least( ifnull(nullif(locate('0', name), 0), ~0), ifnull(nullif(locate('1', name), 0), ~0), ifnull(nullif(locate('2', name), 0), ~0), ifnull(nullif(locate('3', name), 0), ~0), ifnull(nullif(locate('4', name), 0), ~0), ifnull(nullif(locate('5', name), 0), ~0), ifnull(nullif(locate('6', name), 0), ~0), ifnull(nullif(locate('7', name), 0), ~0), ifnull(nullif(locate('8', name), 0), ~0), ifnull(nullif(locate('9', name), 0), ~0) from table substr(name, 1, first_int - 1), lpad(cast(substr(name, first_int) as unsigned), length(~0), '0'), substr(name, first_int + length(cast(substr(name, first_int) as unsigned)));
select test_column from test_table order by length(test_column) desc, test_column desc;
select mystring from mytable order by natsortkey(mystring,0);  ### 0 means process all numbers - resulting sort key might be quite long for certain inputs;
select mystring from mytable order by mystringnsk;
create table mytable ( ... mystringnsk varchar(150) as (natsortkey(mystring,10)) stored, ... ...);
create definer=current_user function natsortkey (s varchar(100), n int) returns varchar(350) deterministic then there is a single suffix that consists of a ' ' or '+' character, followed by a pair base-36 digits for each number component in the sequence. if using a charset that maps these characters to multiple bytes (such as, e.g. utf16 or utf32), you must replace all instances of length() in the function definition with char_length() if you do not require the total-ordering property, you could edit the code to use suffixes of 1 character (space or plus) only; this would reduce the maximum output length for any given n. if changing the input length, the output length must be modified according to the above formula.  the declare statements for x,y,r, and suf must also be modified, as the code comments indicate. if n<=0 then set n := -1; end if;   # n<=0 means "process all numbers" set i := regexp_instr(s,'\\d');   # find position of next digit if i=0 or n=0 then return concat(r,s); end if;   # no more numbers to process -> we're done set n := n-1, suf := ' ';
if i>1 then if substring(s,i-1,1)='.' and (i=2 or substring(s,i-2,1) rlike '[^.\\p{l}\\p{n}\\p{m}\\x{608}\\x{200c}\\x{200d}\\x{2100}-\\x{214f}\\x{24b6}-\\x{24e9}\\x{1f130}-\\x{1f149}\\x{1f150}-\\x{1f169}\\x{1f170}-\\x{1f189}]') and (substring(s,i) not rlike '^\\d++\\.\\d') then set i:=i-1; end if;   # allow decimal number (but not version string) to begin with a '.', provided preceding char is neither another '.', nor a member of the unicode character classes: "alphabetic", "letter", "block=letterlike symbols" "number", "mark", "join_control" if i>1 and substring(s,i-1,1)='+' then set suf := '+', j := i-1; else set j := i; end if;   # move any preceding '+' into the suffix, so equal numbers with and without preceding "+" signs sort together set r := concat(r,substring(s,1,j-1)); set s = substring(s,i);   # add everything before the number to r and strip it from the start of s; preceding '+' is dropped (not included in either r or s) end if;
set x := regexp_substr(s,if(substring(s,1,1) in ('0','.') or (substring(r,-1)=',' and suf=' '),'^\\d*+(?:\\.\\d++)*','^(?:[1-9]\\d{0,2}(?:,\\d{3}(?!\\d))++|\\d++)(?:\\.\\d++)*+'));   # capture the number + following decimals (including multiple consecutive '.<digits>' sequences) set s := substring(s,length(x)+1);   # note: length() can be safely used instead of char_length() here & below provided we're using a charset that represents digits, ',' and '.' characters using single bytes (e.g. latin1, utf8) set i := instr(x,'.');
if i=0 then set y := ''; else set y := substring(x,i); set x := substring(x,1,i-1); end if;   # move any following decimals into y set i := length(x);
set x := replace(x,',','');
set j := length(x);
set x := trim(leading '0' from x);   # strip leading zeros set k := length(x);
set suf := concat(suf,lpad(conv(least((j-k)*2,1294) + if(i=j,0,1),10,36),2,'0'));   # (j-k)*2 + if(i=j,0,1) = (count of leading zeros)*2 + (1 if there are thousands-separators, 0 otherwise)  note the first term is bounded to <= base-36 'zy' as it must fit within 2 characters set i := locate('.',y,2);
if i=0 then set r := concat(r,lpad(conv(least(k,359),10,36),2,'0'),x,y,suf);   # k = count of digits in number, bounded to be <= '9z' base-36 else   # encode a version number (like 3.12.707, etc) set r := concat(r,lpad(conv(least(k,359),10,36),2,'0'),x);   # k = count of digits in number, bounded to be <= '9z' base-36 if i=0 then set x := substring(y,2); set y := ''; else set x := substring(y,2,i-2); set y := substring(y,i); set i := locate('.',y,2); end if;
set j := length(x);
set x := trim(leading '0' from x);   # strip leading zeros set k := length(x);
set r := concat(r,lpad(conv(least(k,359),10,36),2,'0'),x);   # k = count of digits in number, bounded to be <= '9z' base-36 set suf := concat(suf,lpad(conv(least((j-k)*2,1294),10,36),2,'0'));   # (j-k)*2 = (count of leading zeros)*2, bounded to fit within 2 base-36 digits set n := n-1;
set r := concat(r,y,suf);
create table titles(title);
('final fantasy #03'), ('final fantasy #11'), ('final fantasy #10'), ('final fantasy #2'), ('bond 007 ##2'), ('final fantasy #01'), ('bond 007'), ('final fantasy #11}');
select regexp_replace(title, "#([0-9]+)", "\\1") as title from titles cast(regexp_replace(title, ".*#([0-9]+).*", "\\1") as int);
constraint `server_id_refs_id_34554433` foriegn key (`server_id`) references `server` (`id`);
alter table `alarm` drop foreign key `server_id_refs_id_34554433`;
alter table `alarm` drop `server_id`;
alter table `table_name` drop foreign key `id_name_fk`;
alter table `table_name` drop index `id_name_fk`;
set startdate = convert(datetime,'2015-03-11t23:59:59.000',126) where custid = 'f24';
update table set enddate = '2009-05-25 00:00:00.000' where id = 1;
update table set enddate = cast('2009-05-25' as datetime) where id = 1;
create table t1 (id int, enddate datetime);
update t1 set enddate = '20100525' where id = 1 -- yyyymmdd is language agnostic;
set language us_english update t1 set enddate = '2010-05-25' where id = 1;
set language british update t1 set enddate = '2010-05-25' where id = 1;
update table set enddate = cast('2017-12-31' as date) where id = '123';
if err != nil { if err := rows.scan(&user.id, &user.username, &user.email); err != nil {;
if err != nil {;
if err != nil {;
if err != nil { if err != nil {;
"database/sql" ) val interface{} ) if row, err = m.getrow(); err == nil { if val, err = m.scanrowtype(row, (*usertb)(nil)); err == nil { id:         u.id, score:      u.score, };
select * from a, b where a.column = b.column(+);
select * from a, b where b.column(+) = a.column;
select employee_id, manager_id from employees where employees.manager_id(+) = employees.employee_id;
select e1.employee_id, e1.manager_id, e2.employee_id from employees e1, employees e2 where e1.manager_id(+) = e2.employee_id;
select * from a, b where a.column = b.column(+);
select * from a, b where b.column(+) = a.column;
select * from a, b where a.column = b.column(+);
select * from a;
select * from a, b where a.column = b.column(+);
select * from a, b where b.column(+) = a.column;
from tab_a a, tab_b b, where a.col_1 + = b.col_1;
from tab_a a left outer join;
select sources.id, count(metrics.id) from "sources" where (ports.auto_delete = 't') having (count(metrics.id) = 0);
end  end end end  end end ;
student_enrollments: {student_id: some_user.id, id: nil}, active: true );
student_enrollments: {student_id: some_user.id, id: nil}, active: true ) end .... end;
student_enrollments: {student_id: some_user.id, id: nil}, active: true );
end  if column.is_a? array end elsif column.is_a? hash end else assoc = this.reflect_on_association(column) end collection end  arel::nodes::outerjoin).on(source[assoc.foreign_key].eq( assoc.klass.arel_table[pk])).join_sources end end;
select choose(@imonth,'january','february','march','april','may','june','july','august','september','october','november','december');
select left(datename(month,dateadd(month, -1, getdate())),3) union all select left(datename(month,(dateadd(month, -2, getdate()))),3) union all select left(datename(month,(dateadd(month, -3, getdate()))),3);
select monthname( `col1` ) from `table_name`;
( select 0 as monthnumber union all  select monthnumber+1 from cte_sample1 where monthnumber+1<12 ) select datename( month , dateadd( month , monthnumber ,0 ) ) from cte_sample1;
select datename(month, s0.orderdatetime);
select convert(char(3), s0.orderdatetime, 0);
select convert(varchar(3),datename(month, s0.orderdatetime));
select left(datename(month,getdate()),3);
where orders.orderstatus = 'shipped' and orders.shipdate >  convert(datetime, (round(convert(float, getdate()-6.5),0)));
select convert(datetime, datediff(day, 0, getdate()));
select convert(datetime, datediff(day, 0, getdate()) + @dayoffset);
select convert(datetime, datediff(day, 0, getdate() + .5));
select getdate();
select convert(datetime,convert(bigint, getdate()));
where orders.orderstatus = 'shipped' and orders.shipdate >= convert(date, getdate());
select getdate() as now, convert(datetime, datediff(day, 0, getdate())) as midnighttoday, convert(datetime, datediff(day, -1, getdate())) as midnightnextday, convert(datetime, datediff(day, 1, getdate())) as midnightyesterday;
select * from mytable where convert(varchar, mytable.datefield, 101) = convert(varchar, getdate(), 101);
select * from mytable where cast(mytable.datefield as date) = cast(getdate() as date);
where orders.orderstatus = 'shipped' and orders.shipdate >= (cast(getdate()-6 as date));
where orders.orderstatus = 'shipped' and orders.shipdate >= dateadd(day, datediff(day,0, getdate() -6), 0);
select * from yourtable where datefield >= cast(getdate() - 6 as date) and datefield <  cast(getdate() + 1 as date);
select * from yourtable where datefield >= dateadd(day, datediff(day, 0, getdate()) - 6, 0) and datefield <  dateadd(day, datediff(day, 0, getdate()) + 1, 0);
select * from mytab t where;
select * from mytab t where date_add(t.runtime, interval 20 minute) < now();
select * from mytab t where unix_timestamp() - t.runtime > 20*60;
select top 1 [extracteddate] from [onsitev4].[dbo].[sqlpendingindex] order by extracteddate desc );
select max(extracteddate) from [onsitev4].[dbo].[sqlpendingindex] );
select top 1 @lastextractdate=[extracteddate] from [onsitev4].[dbo].[sqlpendingindex] order by extracteddate desc;
set  @extracteddate = (select    top 1 extracteddate from      [onsitev4].[dbo].[sqlpendingindex];
select @lastextractdate=max([extracteddate]) from [onsitev4].[dbo].[sqlpendingindex];
values (test truncation warnings);
alter database scoped configuration set verbose_truncation_warnings = on;
alter function [dbo].[testing1](@price int) as select ta.item, ta.warehouse, ta.price from   stock ta where  ta.price >= @price;
item       nvarchar(25)  null, -- 25 or equal size of your item column );
descr varchar(10), mybit1 bit, mybit2 bit ) select mybit1, count(mybit1) from @t group by mybit1 select mybit2, count(mybit1) from @t group by mybit2;
select pt.partner_name, count(case when pd.product_name = 'product a' then 1 end) producta, count(case when pd.product_name = 'product b' then 1 end) productb, count(case when pd.product_name = 'product c' then 1 end) productc, count(case when pd.product_name = 'product d' then 1 end) productd, count(case when pd.product_name = 'product e' then 1 end) producte from partners pt;
set @sql = null;
select group_concat(distinct 'count(case when product_name = ''', product_name, ''' then 1 end) as ', replace(product_name, ' ', '') ) from products;
set @sql = concat('select pt.partner_name, ', @sql, ' from partners pt;
set @@group_concat_max_len = 32000;
delete from table where date > convert(varchar, getdate(), 101);
select convert(datetime, convert(varchar(10), getdate(), 101));
delete from table where date > cast(getdate() as date);
delete from table where date > datediff(d, 0, getdate());
"select id, timestamp, user " + new sqlparameter("till", till)), .tolistasync();
set @id = 78 select * from mytable where id = @var; <-- remove this character to avoid the error message select * from anothertable where mytableid = @var;
select month, sum(weight) as weight, sum(amount) as amount from sometable as e where year = @year and type = 'm';
set @sql = n'declare @rt int; set @rt = ' + @rowto;
set @sql = n'declare @rt int; set @rt = ' + convert(varchar(12), @rowto);
set @sql = n'select ' + convert(varchar(12), @rowto) + ' * 5';
exec sys.sp_executesql @sql;
set @sql = @sql + ' where rownum between ';
set @sql = @sql + ' where rownum between @rowfrom and @rowto;';
exec sys.sp_executesql @sql, n'@rowfrom int, @rowto int', @rowfrom, @rowto;
set @sql = @sql + ' where rownum between @rowfrom and @rowto;';
set @sql = @***s***ql;
drop table [table_name];
delete from [table_name] where [condition];
delete from [table_name];
create table bookmark1 as select * from bookmark;
create table bookmark1 as select * from bookmark;
create table newtable as select * from oldtable where 1 <> 1;
select now();     -- you will get 2010-12-09 17:10:18 select curdate(); -- you will get 2010-12-09;
set global local_infile = 1;
drop table fdata;
create table fdata (fid int, name varchar(64), lastname varchar(64), email varchar(128), gender varchar(12), ipaddress varchar(40));
create user 'required'@'%' identified by 'password';
alter user 'required'@'%' identified with mysql_native_password by 'password';
select * from fdata limit 10;
host=host, user=settings_db.db_config['user'], port=port, passwd=settings_db.db_config['password'], db=settings_db.db_config['name'], local_infile=true);
set global local_infile = 1;
like '%' + @param + '%';
"select * from compliance_corner"_;
select id, name, blah, blah from tableb tb where ta.id is null;
select * from   b where (select count(*)  from   a where  a.id = b.id) < 1;
select * from   b where  not exists (select 1 from   a where  a.id = b.id);
select * from tableb as b where not exists ( select * from tablea as a where b.id = a.id );
select * from tableb where id not in ( select id from tablea;
select .... where id = 5 union select .... where not id = 5;
select id,name from friends;
select id,name from friends;
select id,name from friends;
select id,name from friends;
select ... order by id != 5, id;
select id,name from friends union select id,name from friends;
select id,name, (id=5) as is_five from friends union select id,name, (id=5) as is_five from friends;
select 1 id, 'zeta' order_col union all select 2 id, 'alpha' order_col union all select 3 id, 'gamma' order_col union all select 4 id, 'phi' order_col union all select 5 id, 'delta' order_col union all select 6 id, 'delta' order_col union all select 7 id, 'alpha' order_col union all select 8 id, 'gamma' order_col union all select 9 id, 'zeta' order_col union all select 10 id, 'phi' order_col;
select id,name from friends order by field(id,5,id);
alter table `dbo.table_1` row_format = default ;
create table `dbo.table_1` (textt varchar(255));
select * from `dbo.table_1` order by textt;
select id, max(signin) as most_recent_signin from tbl;
select tbl.id, signin, signout from tbl select id, max(signin) as maxsign from tbl group by id where tbl.id=1;
select * from   tbl where  id = 1 limit  1;
select [insert your fields here] from tablename where signin = (select max(signin) from tablename where id = 1);
select * from (select * from tb1 order by signin desc) group by id;
select id, signin, signout from dtable select id, max(signin) as signin from dtable;
select * from `page_contents_translations` limit 1;
select * from table where id=1 order by signin desc;
select top(1) * from table where id=1 order by signin desc;
select status, case status else 'active' end as statustext from   stage.tst;
select case substr(status,1,1) -- you're only interested in the first character. end as statustext from stage.tst;
create table statuses ( -- not a good table name :-) ) create table tst ( id number );
select a.status, b.description from tst a;
select status, case when status in('a1','a2','a3') then 'active' then 'inactive' then 'terminated' end as statustext from status;
where x.p_nbr =to_number(substr(y.k_str,11,5)) and x.q_nbr = else 1 end );
select status, decode ( status, 'a1','active', 'a2','active', 'a3','active', 'i','inactive', 't','terminated', 'default')statustext from status;
select status, case when status in('a1','a2','a3') then 'active' then 'inactive' then 'terminated'  else null end as statustext from stage.tst;
case to_char(meta.rhcontratosfolha.contrato) end contrato, ;
case when grade = 'a' then dbms_output.put_line('excellent');
else dbms_output.put_line('no such grade');
case grade else dbms_output.put_line('no such grade');
select t.name from table where num =t.num) cnt from table t;
select name, count(*) as num from tbl group by name;
select `num`, count(*) as `count` from yourtable;
select `num`, count(*) as `count` from yourtable where `num`=1;
select count(1) from your_table where num = 1;
select num, count(1) from your_table group by num;
select sum(num) where num = 1;
select num, count(1) as count from tbl where num = 1;
select count(num) as 'result' from table1 num having num = 1;
select sum(if(your_column=3,1,0)) from your_table where your_where_contion='something';
select sum(if(num=1,1,0)) from your_table_name;
update my_table set price = 2;
update current_timestamp;
create trigger update_user_password if old.password <> new.password then set new.password_changed_on = now();
default current_timestamp;
alter table whatevertable default current_timestamp;
update whatevertable set something = 'newvalue', whatevercolumn = whatevercolumn where someindex = 'indexvalue';
create procedure show_current_orders as declare @sql nvarchar(4000) select @sql = select id_num, searchstring from searchorders where  + exec (@sql);
create procedure getuser as declare @sql as nvarchar(512) set @sql = 'select usrid, usruname, usrfullname, usrroleid '+;
select usrid, usruname, usrfullname, usrroleid from users where usruname = 'admin' and usrpass = 'any' or 1=1 --';
alter procedure getuser as select usrid, usruname, usrfullname, usrroleid from users where usruname = @name and usrpass = @pass;
column properties;
values ((select max(pk)+1 from table1), 123, 456);
select (select max(id) from role) + row_number() over (order by name) from ( values ('content coordinator', getdate());
create table sample( [id]     [int]  identity(1,1) not null, [status] [smallint] not null,  constraint [pk_sample] primary key clustered ( [id] asc ) );
select iif( length( a ) > 4 , a , ' ') as b from foo;
select case when length(a) > 4 then a else '' end as b from foo;
select case when length(a)>4 then a else ' ' end from foo;
select cast(notes as nvarchar(4000)) + 'sometext' from notestable a;
select cast(notes as nvarchar(max)) + 'sometext' from notestable a;
select isnull(cast(notes as nvarchar(4000)),'') + 'sometext' from notestable a;
select concat(mytable.textcolumn, 'text') from mytable;
select 'ani received' where not exists (select 1 from eventtype where eventtypename = 'ani received');
create table if not exists tblusers (userid integer primary key, username varchar(100), contactname varchar(100),password varchar(100));
create function [dbo].[fnescapesinglequote] as begin select @result = replace(@stringtocheck, char(39), char(39) + char(39)) end;
exec sp_executesql...;
end return rval.reverse end;
as base64: b8trs7h4tj2vt43dp85v2a as uuid  : 6fcb514b-b878-4c9d-95b7-8dc3a7ce6fd8;
set autocommit = 0;
set autocommit = 0;
set autocommit = 0;
set autocommit = off;
set autocommit = 1;
set autocommit = on;
set autocommit = 0;
set autocommit = 0;
set autocommit = 0;
set autocommit = 0;
set autocommit = 1;
set autocommit = 0;
set autocommit = 1; /* commit statement instead would not restore autocommit to 1 */;
set autocommit=0;
union (select * from de_music where `genre` = 'punk');
select * from us_music, de_music where `us_music.genre` = 'punk' and `de_music.genre` = 'punk';
alter table t_person modify mobile_no bigint;
alter table table_name auto_increment=100 -- change 100 to the desired number;
alter table table_name auto_increment=101;
select `auto_increment` from  information_schema.tables where table_schema = 'databasename' and   table_name   = 'tablename';
alter table `table` change `cust_fax` `cust_fax` varchar(60) null default null;
select * into public."newtable" from public."existingtable";
create table mycopy as select * from mytable;
create table mycopy (like mytable including all);
select * from mytable;
select col1, col2 from mytable;
select price_per_sqft, (price_per_sqft/2) as col1, (select col1 + 1) as col2 from items;
select invoices.invoiceno, invoices.clientid, invoices.date, invoices.paid, invoiceswithsubtotal.subtotal, round( cast( subtotal * invoices.vatrate as decimal( 10, 4 )), 2 ) as vat, (select vat + subtotal) as total from invoices ( select sum( invoiceitems.charge ) as subtotal, invoices.invoiceno from invoices;
set @total_sales = 0;
select @total_sale := s.f1 + s.f2 as total_sale, s.f1 / @total_sale as f1_percent from sales s;
select @total_sale := s.f1 + s.f2 as total_sale, s.f1 / @total_sale as f1_percent from sales s;
select tbl1.total_sale, tbl1.f1/tbl1.total_sale as f1_percent from (select s.f1+s.f2 as total_sale, s.f1 from sales s) as tbl1;
select h.total_sale, s.f1 / h.total_sale as f1_percent from sales s, (select id, f1 + f2 as total_sale from sales) h where s.id = h.id;
select x.total_sale, x.f1 / x.total_sale as f1_percent from (select s.f1, s.f1 + s.f2 as total_sale, from sales s) x;
select s.f1 + s.f2 as total_sale, s.f1 / (select total_sale) as f1_percent from sales s;
create table destination_old as select * from destination;
drop table destination;
create table destination as select from destination_old d left join source s;
create table destination as select from destination_old d left join source s;
update table1 set name=(select t2.name from table2 t2 where t2.id=table1.id);
select customer, count(*) as pets from table_name;
select count(customer) as count, pets from table;
select count(distinct column_name) from table_name;
select count(*) column_name from (select distinct column_name);
select distinct...;
select count(customer) as num_customers, pets from customer_pets group by pets;
set curid = pid;
select parentid from test where id=curid limit 1 into curid;
set depth = depth + 1;
if curid is null then set depth = -1;
select * from test where childdepth(1, id) <> -1;
create procedure chainreaction ( in inputno int ) select col3 from table1 where col1 = inputno;
select * from results;
drop table if exists results;
create procedure get_tree(in id int) set prev_id = id;
select col3 into child_id from table1 where col1=id ;
create temporary  table if not exists temp_table as (select * from table1 where 1=0);
set prev_id = child_id;
select col3 into child_id from table1 where col1=prev_id;
select * from temp_table;
select col1, col2, @pv := col3 as 'col3' from table1 join (select @pv := 1) tmp where col1 = @pv;
select t.item_id as item, @pv:=t.parent as parent from (select * from item_tree order by item_id desc) t join (select @pv:=6)tmp where t.item_id=@pv;
create function `issubelement`(pparentid int, pid int) returns int(11) set ischild = 0;
set curid = pid;
set curparent = -1;
set lastparent = -2;
set lastparent = curparent;
select parentid from `test` where id=curid limit 1 into curparent;
if curparent = pparentid then set ischild = 1;
set curid = curparent;
set @wantedsubtreeid = 3;
select * from test where issubelement(@wantedsubtreeid,id) = 1 or id = @wantedsubtreeid;
create table if not exists `test` ( `id` int(11) not null, `parentid` int(11) default null, `name` varchar(300) not null, primary key (`id`);
select t.col1, t.col2, @pv := t.col3 col3 from (select * from table1 order by col1 desc) t join (select @pv := 1) tmp where t.col1 = @pv;
create procedure `getval`() create table x(id int,name varchar(20));
select found_rows() into found_row ;
if found_row = 0 then end if;
if i <= r_len then set i = i + 1;
end loop label1;
set found_row = found_row - 1;
select * from x;
drop procedure if exists split_value_into_multiple_rows $$ create procedure split_value_into_multiple_rows(tablename varchar(20), id_column varchar(20), value_column varchar(20), delim char(1)) set @expr = concat('create temporary table tmp_table1 (id int not null, value varchar(255)) engine=memory select ', id_column,' id, ', value_column,' value from ',tablename);
drop temporary table if exists tmp_table2;
create temporary table tmp_table2 (id int not null, value varchar(255) not null) engine=memory;
if done then end if;
set occurrences = (select char_length(value) - set i=1;
set splitted_value = (select trim(substring_index( substring_index(value, delim, i), delim, -1)));
select * from tmp_table2;
drop temporary table tmp_table1;
create table interests ( interest_id int not null auto_increment primary key, interest varchar(30) not null create table contact_interest ( contact_id int not null, interest_id int not null, constraint fk_contact_interest_my_contacts_contact_id foreign key (contact_id) references my_contacts (contact_id), constraint fk_contact_interest_interests_interest_id foreign key (interest_id) references interests (interest_id) from my_contacts, tmp_table2, interests where my_contacts.contact_id = tmp_table2.id and interests.interest = tmp_table2.value;
select 1 i union all select i+1 from n where i < 1000 ) select distinct s.id, s.oaddress, -- n.i, -- use the index to pick the nth word, the last words will always repeat. remove the duplicates with distinct reverse(substr(reverse(trim(substring_index(s.oaddress,' ',n.i))),1, instr(reverse(trim(substring_index(s.oaddress,' ',n.i))),' '))), trim(substring_index(s.oaddress,' ',n.i))) oth from app_schools s, n;
create function strsplit(x varchar(65000), delim varchar(12), pos integer) set output = replace(substring(substring_index(x, delim, pos) if output = '' then set output = null; end if;
end $$ create procedure badtabletogoodtable() set i = 1;
select id, strsplit(name, ',', i) from badtable where strsplit(name, ',', i) is not null;
select tablename.id, substring_index(substring_index(tablename.name, ',', numbers.n), ',', -1) name from numbers inner join tablename id, n;
select tablename.id, substring_index(substring_index(tablename.name, ',', numbers.n), ',', -1) name from (select 1 n union all select 2 union all select 3 union all select 4 union all select 5) numbers inner join tablename id, n;
select 1 as id, 'a,b,c' as names union select 2, 'b' recurs as ( select id, 1 as pos, names as remain, substring_index( names, ',', 1 ) as name from input union all select id, pos + 1, substring( remain, char_length( name ) + 2 ), substring_index( substring( remain, char_length( name ) + 2 ), ',', 1 ) from recurs where char_length( remain ) > char_length( name ) ) select id, name from recurs;
n as ( select 1 as n union select n + 1 from n, t where n <= length(items) - length(replace(items, ',', ''))) select distinct substring_index(substring_index(items, ',', n), ',', -1);
select t.id, j.name from mytable t join json_table( t.name, '$[*]' columns (name varchar(50) path '$');
select t.id, j.name from mytable t join json_table( replace(json_array(t.name), ',', '","'), '$[*]' columns (name varchar(50) path '$');
select substring_index(substring_index('ab,bc,cd',',',help_id+1),',',-1) as oid from ( select @xi:=@xi+1 as help_id from (select 1 union select 2 union select 3 union select 4 union select 5) xc2, (select @xi:=-1) xc0 where help_id < length('ab,bc,cd')-length(replace('ab,bc,cd',',',''))+1;
select @xi:=@xi+1 as help_id from (select 1 union select 2 union select 3 union select 4 union select 5) xc2, (select @xi:=-1) xc0;
select substring_index(substring_index('ab,bc,cd',',',help_id+1),',',-1) as oid from numbers_table where help_id < length('ab,bc,cd')-length(replace('ab,bc,cd',',',''))+1;
create table words ( word varchar(100) select word, length(word) as num_bytes, char_length(word) as num_characters from words;
select * from   my_table where  substr(my_field,1,5) = "abcde";
select * from dbo.table where datalength(column_name) = 3;
alter table mytable add constraint constraint_name default getdate() for mycolumn;
create table orders( o_id int not null, orderno int not null, p_id int, orderdate date default getdate() // you can set default constraints while creating the table );
alter table [dbo].[table_name] add  constraint [constraint_name] default (getdate()) for [column_name];
alter table [dbo].[table_name]( [pdate] [datetime] default getdate());
alter table [dbo].[prod_whse_actual] add [date] date default getdate() not null;
create table api_key(api_key_id int not null identity(1,1);
select column_name from information_schema.columns where 1=1 and table_schema = 'public' and table_name   =:'table_name'  ;
select * from a_table;
if (j > 1) join t in target on m.id equals t.id select m).toarray();
select [extent1].[id] as [id] from  [dbo].[main] as [extent1];
set @sql = 'select from [dbo].[main] as [extent1] where [extent1].[id] in (' if @count > 0 set @sql = @sql + ',' set @count = @count + 1 set @sql = @sql + cast(@count as nvarchar) end set @sql = @sql + ')';
(myentities db, guid containshelperid) => from cust in db.customers join x in db.helperforcontainsofinttype on cust.customerid equals x.referenceid where x.helperid == containshelperid select cust;
status status) if (chunksize < 1);
set local temp_buffers = '1000mb'; -- enough to hold the temp table create temp table tmp as select t.* from   tbl t where  d.id is null;      -- copy surviving rows into temporary table select * from tmp;        -- insert back surviving rows.;
delete from tbl t where  t.id = d.id;
select item_id from other_table where condition_x = true ) delete from table where table.item_id = to_delete.item_id and not to_delete.item_id is null;
and not to_delete.item_id is null;
create index tblindex on tbl ( id );
select * from tbl with (updlock, index(tblindex)) where id=10.;
select * from <tablename> with rowlock xlock holdlock;
set transaction isolation level { read uncommitted | read committed | repeatable read | serializable } select ...;
alter database yourdbnamehere set read_committed_snapshot on;
alter database yourdbnamehere set allow_snapshot_isolation on;
alter database yourdbnamehere set read_committed_snapshot on;
update dbo.customer set fieldforlock = fieldforlock where customerid = @customerid;
update <tablename> (rowlock) set <somecolumn> = <somecolumn> where id=1;
select (rowlock);
select * from <tablename> with (xlock,readpast) where rowid = @someid update <tablename> set <column>=@somevalue where rowid=@someid;
select id from products;
create view app.foobar as select id from products;
select * from table1, table2 left join table3 on row1 = row3; --throws an error;
select * from table2, table1 left join table3 on row1 = row3; --works as expected;
check the instance of the sql script window, you may be in a different instance;
check if your join is correct;
alter table location add transitiontype smallint null update location set transitiontype =  4 alter table location alter column transitiontype smallint not null;
set @startdate = dateadd(mm, datediff(mm,0,getdate())-1, 0) set @enddate = dateadd(mm, 1, @startdate) select * from member where date_created between @startdate and @enddate;
set @startdate = dateadd(mm, datediff(mm, 0, getdate()) - 1, 0) set @enddate = dateadd(dd, -1, dateadd(mm, 1, @startdate)) select * from member where date_created between @startdate and @enddate;
select field1, field2, fieldn from table where datepart(month, date_created) = 4 and datepart(year, date_created) = 2009;
select field1, field2, fieldn from table where datepart(month, date_created);
select * from member where datepart(m, date_created) = datepart(m, dateadd(m, -1, getdate())) and datepart(yyyy, date_created) = datepart(yyyy, dateadd(m, -1, getdate()));
select * from [member] where datepart("m", date_created) = datepart("m", dateadd("m", -1, getdate())) and datepart("yyyy", date_created) = datepart("yyyy", dateadd("m", -1, getdate()));
set @startdate = dateadd(mm, -1, getdate()) set @startdate = dateadd(dd, datepart(dd, getdate())*-1, @startdate) set @enddate = dateadd(mm, 1, @startdate) select * from member where date_created between @startdate and @enddate;
where date_created >= @startofpreviousmonth and date_created < @startofcurrentmonth;
set @startofcurrentmonth = dateadd(month, datediff(month, 0, current_timestamp), 0) select * from member where date_created >= dateadd(month, -1, @startofcurrentmonth) -- this was originally    misspelled and date_created < @startofcurrentmonth;
if (@curdate = 1) select * from featured_deal where datepart( month,created_date)=12 and datepart(year,created_date) = (datepart(year,getdate())-1) end else begin select * from featured_deal where datepart( month,created_date)=(datepart( month,getdate())-1) and datepart(year,created_date) = datepart(year,getdate()) end;
select @prevmonth = datename( month,dateadd(mm, datediff(mm, 0, getdate()) - 1, 0)) +;
select * from tablename where order_date > dateadd(week, -1, getdate()+1) and order_date<=getdate();
set @startdate = dateadd(mm, -1, getdate()) set @startdate = dateadd(dd, datepart(dd, getdate())*-1, @startdate) set @enddate = dateadd(mm, 1, @startdate) set @startdate = dateadd(dd, 1 , @startdate);
select * from table where trunc(somedatefield, 'month') =;
where date_created >= dateadd(month, datediff(month, 31, current_timestamp), 0) and date_created < dateadd(month, datediff(month, 0, current_timestamp), 0);
select convert(date, dateadd(day,-day(getdate()),getdate()));
select * from dbo.member d where  convert(date, date_created,101)>=convert(date,dateadd(m, datediff(m, 0, current_timestamp)-1, 0)) and convert(date, date_created,101) < convert(date, dateadd(m, datediff(m, 0, current_timestamp)-1, 0),101);
select * from customer where month(date) = month(current_timestamp) and year(date) = year(current_timestamp);
select from  #emp where datediff(month,createddate,getdate()) = 1;
select from #emp where datediff(day,createddate,getdate()) between 1 and 30;
select * from dbtable where the_date >= convert(varchar(10),dateadd(m, -1, dateadd(d, - datepart(dd, getdate())+1, getdate())),120) and the_date <= dateadd(ms, -3, convert(varchar(10),dateadd(m, 0, dateadd(d, - datepart(dd, getdate())+1, getdate())),120));
select * from dbtable where the_date >= convert(varchar(10),dateadd(m, -1, dateadd(d, - datepart(dd, getdate())+1, getdate())),120) and the_date < select convert(varchar(10),dateadd(m, -1, dateadd(d, - datepart(dd, getdate())+1, getdate())),120);
select convert(varchar(10),dateadd(m, -1, dateadd(d, - datepart(dd, getdate())+1, getdate())),120);
select convert(varchar(10),dateadd(m, -1, dateadd(d, - datepart(dd, getdate())+1, getdate())),120);
select dateadd(ms, -3, convert(varchar(10),dateadd(m, 0, dateadd(d, - datepart(dd, getdate())+1, getdate())),120));
select convert(varbinary(8), 16777215);
select convert(int, 0xffffff);
select convert(int, convert(varbinary, '0x1fffff', 1)) select convert(int, convert(varbinary, '1fffff', 2));
select dbo.tohex(4095) --> fff;
create function tohex(@value int) as begin set @seq = '0123456789abcdef' set @result = substring(@seq, (@value%16)+1, 1) set @digit = substring(@seq, ((@value/16)%16)+1, 1) set @value = @value/16 if @value <> 0 set @result = @digit + @result end  end go;
select @hexstr = convert(varbinary, @intval, 1);
@parameters varchar(50) select @query = 'select @result = convert(int,' + @hb + ')', @parameters = '@result int output' exec master.dbo.sp_executesql @query, @parameters, @intval output;
select 100, master.dbo.fn_varbintohexstr(100);
(select master.dbo.fn_cdc_hexstrtobin( ;
convert(varbinary(3),(select master.dbo.fn_cdc_hexstrtobin( --intel processors, registers are switched, so reverse them;
set @dato = convert(xml, '<dato>ff</dato>') select cast( rw.value( 'xs:hexbinary( text()[1])' , 'varbinary(max)' ) as int ) from @dato.nodes('dato') as t(rw);
create function [dbo].[inttoalpha](@value int) as begin set @codechars = 'abcdefghijklmnopqrstuvwxyz' set @result = substring(@codechars, (@value % @codelength) + 1, 1) set @digit = substring(@codechars, ((@value / @codelength) % @codelength) + 1, 1) set @value = @value / @codelength if @value <> 0 set @result = @digit + @result end  end;
create function [dbo].[alphatoint](@value varchar(7)) as begin set @codechars = 'abcdefghijklmnopqrstuvwxyz' set @reverse = reverse(@value) set @digit = substring(@reverse, @index + 1, 1) set @digitvalue = (charindex(@digit, @codechars) - 1) * power(@codelength, @index) set @result = @result + @digitvalue set @index = @index + 1 end return @result;
select format(512+255,'x');
set @str = 'f000be1a' set @ndx = len(@str) set @runningtotal = 0 set @exponent = len(@str) - @ndx set @runningtotal = @runningtotal + case substring(@str, @ndx, 1) end set @ndx = @ndx - 1 end ;
if object_id('dbo.hextoint') is not null drop function dbo.hextoint create function dbo.hextoint (@chars varchar(max)) set @chars = rtrim(ltrim(@chars)) set @len = len(@chars) set @i = 1 set @r = 0 set @pow = @len - @i set @char = substring(@chars, @i, 1) if @char = '0' set @tmp = 0 else if @char = '1' set @tmp = 1 else if @char = '2' set @tmp = 2 else if @char = '3' set @tmp = 3 else if @char = '4' set @tmp = 4 else if @char = '5' set @tmp = 5 else if @char = '6' set @tmp = 6 else if @char = '7' set @tmp = 7 else if @char = '8' set @tmp = 8 else if @char = '9' set @tmp = 9 else if @char = 'a' set @tmp = 10 else if @char = 'b' set @tmp = 11 else if @char = 'c' set @tmp = 12 else if @char = 'd' set @tmp = 13 else if @char = 'e' set @tmp = 14 else if @char = 'f' set @tmp = 15 set @r = @r + @tmp * power(16,@pow) set @i = @i + 1 end return @r end;
if object_id('dbo.inttohex') is not null drop function dbo.inttohex create function dbo.inttohex (@val int) set @tmp = @val set @r = '' set @v1 = @tmp / 16 set @v2 = @tmp % 16 if @v2 = 0 set @char = '0' else if @v2 = 1 set @char = '1' else if @v2 = 2 set @char = '2' else if @v2 = 3 set @char = '3' else if @v2 = 4 set @char = '4' else if @v2 = 5 set @char = '5' else if @v2 = 6 set @char = '6' else if @v2 = 7 set @char = '7' else if @v2 = 8 set @char = '8' else if @v2 = 9 set @char = '9' else if @v2 = 10 set @char = 'a' else if @v2 = 11 set @char = 'b' else if @v2 = 12 set @char = 'c' else if @v2 = 13 set @char = 'd' else if @v2 = 14 set @char = 'e' else if @v2 = 15 set @char = 'f' set @tmp = @v1 set @r = @char + @r if @tmp = 0 end return @r end;
select format(10,'x2');
set @result = substring(@seq, (@workingvalue%@basesize)+1, 1) set @digit = substring(@seq, ((@workingvalue/@basesize)%@basesize)+1, 1) set @workingvalue = @workingvalue/@basesize if @workingvalue <> 0 set @result = @digit + @result end  select @value as value, @basesize as basesize, @result as result;
set @digit = right(@workingvalue,1) set @digitpositioninsequence = charindex(@digit,@seq) set @result = @result + ( (@digitpositioninsequence -1) * @positionmultiplier) set @workingvalue = left(@workingvalue,len(@workingvalue)-1) set @positionmultiplier = @positionmultiplier * @basesize end  select @value as value, @basesize as basesize, @result as result;
update mytable set mycolumn = concat( repeat( "0", 8 - length(mycolumn) mycolumn ) where length(mycolumn) < 8;
update table set phone_num = concat('0', phone_num);
select lpad('1234567', 8, '0');
select lpad(column, 8, 0) from table;
update table set columnname=lpad(nums,8,0);
alter table `table` change `numbercolumn` `numbercolumn` char(8);
update table set `numbercolumn`=lpad(`numbercolum`, 8, '0');
set @searchtext = '12' select  t.table_name as tablename, ( select c.column_name + ',' from   information_schema.columns c where  t.table_name = c.table_name and c.data_type in ('nvarchar','varchar') ) from    information_schema.tables t delete from @tables where columnnamescsv is null select row_number() over(order by tablename), tablename, columnnamescsv from   @tables delete from @tables where n is null update @tables set columnnamescsv = substring(columnnamescsv, 0, len(columnnamescsv)) update @tables set sql = 'select * from ['+tablename+'] where '''+@searchtext+''' in ('+columnnamescsv+')' @i int, @sql varchar(4000) select @i = 1, @c = count(1) from   @tables select @sql = sql from @tables where n = @i set @i = @i+1 end;
set @searchtext = '12' select   t.table_name as tablename, (   select  c.column_name + ' like ''%'+@searchtext+'%'' or ' from    information_schema.columns c where   t.table_name = c.table_name and c.data_type in ('nvarchar','varchar') from     information_schema.tables t delete from @tables where columnnamescsvlike is null select row_number() over(order by tablename), tablename, columnnamescsvlike from @tables delete from @tables where n is null update @tables set  columnnamescsvlike = substring(columnnamescsvlike, 0, len(columnnamescsvlike)-2) update @tables set likesql = 'select * from ['+tablename+'] where '+columnnamescsvlike @i int, @likesql varchar(4000) select @i = 1, @c = count(1) from @tables select @likesql = likesql from @tables where n = @i set @i = @i +1 end;
@table_name     sysname, @table_schema   sysname, @column_name    sysname, @sql_string     varchar(2000) set @search_string = 'test' set @sql_string = 'if exists (select * from ' + quotename(@table_schema) + '.' + quotename(@table_name) + ' where ' + quotename(@column_name) + ' like ''%' + @search_string + '%'') print ''' + quotename(@table_schema) + '.' + quotename(@table_name) + ', ' + quotename(@column_name) + '''' end  end ;
set @search_string = 'what.you.are.searching.for';
create table ##string_locations ( table_name varchar(1000), field_name varchar(1000), field_value varchar(8000) ) set nocount on @field_name varchar(1000) set @table_name = '' set @search_string = quotename('%' + @search_string + '%','''') set @field_name = '' set @table_name = ( select min(quotename(table_schema) + '.' + quotename(table_name)) from information_schema.tables where table_type = 'base table' and ) set @field_name = ( select min(quotename(column_name)) from information_schema.columns where table_schema    = parsename(@table_name, 2) and ) if @field_name is not null 'select ''' + @table_name + ''',''' + @field_name + ''',' + @field_name + ) end ;
select table_name, field_name, field_value from ##string_locations (nolock);
set @searchchar =  -- like 'a%', '11/11/2006' select distinct b.name as tablename from sysobjects b where b.type='u' and b.name  'dtproperties' select c.name as columnname from sysobjects b, syscolumns c where c.id = b.id and set @cmdmain = 'select ' + char(39) + @tablename + char(39) + ' as tablename,'+ set @cmdmaincount = 'select count(*) from [' + @tablename + '] where ' set @cmdjoin = '' set @cmdjoin = @cmdjoin + 'convert(varchar(5000),[' +@columnname + ']) like ' + char(39) + @searchchar + char(39) + ' or ' end close db set @cmdmaincount = 'if ('+ @cmdmaincount + left(@cmdjoin, len(@cmdjoin) - 3)+ ') > 0 begin ' set @cmdmain = @cmdmaincount + @cmdmain + left(@cmdjoin, len(@cmdjoin) - 3) set @cmdmain = @cmdmain + ' end ' exec (@cmdmain) end close dbtable;
if search string is date, its format should be yyyy-mm-dd set ansi_nulls on set quoted_identifier on alter procedure searchintables as begin set nocount on;
set @parmdefinition = n'@xmlout varchar(max) output' select a.name,b.name from sys.tables a where a.name like 'tbl_tax_sections' select a.name,b.name fom sys.tables a where a.type = 'u' set @searchsql ='select @xmlout=(select patindex(''%'+ @myvalue+ '%''' set @searchsql =@searchsql  + ', (select * from '+@schema_name+'.'+@table_name+' for xml auto) ))' exec sp_executesql @searchsql, @parmdefinition, @xmlout=@xmlin output if @xmlin <> 0 print @schema_name+'.'+@table_name end close tables_cur end go;
create table #result( id      int identity, -- just for register seek order colname varchar(255), qtrows  int ) set @tolookfor = '[input your search criteria here]' select '[' + usr.name + '].[' + tbl.name + ']' as tblname, '[' + col.name + ']' as colname, lower(typ.name) as typname from sysobjects tbl syscolumns col ) where tbl.xtype = 'u' and lower(typ.name) in( 'char', 'nchar', 'varchar', 'nvarchar', 'text', 'ntext' ) set @crlf = char(13) + char(10) if @typname in('text', 'ntext') set @sql = '' set @sql = @sql + 'insert into #result(tblname, colname, qtrows)' + @crlf set @sql = @sql + 'select @tblname, @colname, count(*)' + @crlf set @sql = @sql + 'from ' + @tblname + @crlf set @sql = @sql + 'where patindex(''%'' + @tolookfor + ''%'', ' + @colname + ') > 0' + @crlf end else begin set @sql = '' set @sql = @sql + 'insert into #result(tblname, colname, qtrows)' + @crlf set @sql = @sql + 'select @tblname, @colname, count(*)' + @crlf set @sql = @sql + 'from ' + @tblname + @crlf set @sql = @sql + 'where ' + @colname + ' like ''%'' + @tolookfor + ''%''' + @crlf end  n'@tblname varchar(255), @colname varchar(255), @tolookfor varchar(255)', @tblname, @colname, @tolookfor end  select * from #result where qtrows > 0 drop table #result;
create procedure searchtables as  if left blank , it will check for all the tables in the database exec searchtables @tablenames = 't1' exec searchtables @tablenames = 't2' exec searchtables @tablenames = '%' exec searchtables @tablenames        = 't1' set nocount on ( tablename sysname ) ( tablename        sysname ) if ltrim(rtrim(@tablenames)) in ('' ,'%') select name from sys.tables end else begin select @sql = 'select ''' + replace(@tablenames,',',''' union select ''') + '''' end  select sch.name + '.' + st.name, ( select '[' + sc.name + ']' + ' like ''' + @searchstr + ''' or ' + char(10) from sys.columns sc join sys.types sty and sty.user_type_id =sc.user_type_id where sty.name in ('varchar','char','nvarchar','nchar') and sc.object_id = st.object_id ) from  sys.tables st join @checktablenames chktbls join sys.schemas sch where st.name <> 'searchtmp' update @sqltbl set sqlstatement = 'select * into searchtmp from ' + tablename + ' where ' + substring(whereclause,1,len(whereclause)-5) delete from @sqltbl where whereclause is null select top 1 @tmptblname = tablename , @sql = sqlstatement from @sqltbl where isnull(execstatus ,0) = 0 if @generatesqlonly = 0 if object_id('searchtmp','u') is not null drop table searchtmp exec (@sql) if exists(select 1 from searchtmp) select tablename=@tmptblname,* from searchtmp end  end else begin end  update @sqltbl set execstatus = 1 where tablename = @tmptblname end  set nocount off;
set @searchstring = '%searchstring%' select @sql = stuff(( select ' union all select ''' + table_name + ''' as tablename, ''' + column_name + ''' as columnname, ' + column_name + ' as valuename' + from information_schema.columns where data_type in ('nvarchar', 'varchar');
set @searchstring = '%wdb1014%' select @sql = stuff(( select ' union all select ''' + table_name + ''' as tbl, ''' + column_name + ''' as col, [' + column_name + '] as val' + from information_schema.columns where data_type in ('nvarchar', 'varchar', 'char', 'ntext') exec (@sql);
create procedure spfindall (@find varchar(max) = '') as begin set nocount on;
select  @query = @query + case when @query = '' then '' else ' union all ' end + from sys.schemas s sys.tables t on s.[schema_id] = t.[schema_id] sys.columns c on t.[object_id] = c.[object_id] sys.types ty on c.user_type_id = ty.user_type_id where ty.name like '%char' end;
exec spfindall 'hello world';
set @searchstrcolumnvalue = '%searchthis%' /* use like syntax */ set @fullrowresult = 1 set @fullrowresultrows = 3 set @searchstrtablename = null /* null for all tables, uses like syntax */ set @searchstrcolumnname = null /* null for all columns, uses like syntax */ set @searchstrinxml = 0 /* searching xml data may be slow */ if object_id('tempdb..#results') is not null drop table #results create table #results (tablename nvarchar(128), columnname nvarchar(128), columnvalue nvarchar(max),columntype nvarchar(20)) set nocount on set @quotedsearchstrcolumnvalue = quotename(@searchstrcolumnvalue,'''') set @tablename = ( select min(quotename(table_schema) + '.' + quotename(table_name)) from    information_schema.tables where       table_type = 'base table' and table_name like coalesce(@searchstrtablename,table_name) and quotename(table_schema) + '.' + quotename(table_name) > @tablename and objectproperty(object_id(quotename(table_schema) + '.' + quotename(table_name)), 'ismsshipped') = 0 ) if @tablename is not null set @sql = 'select quotename(column_name),data_type from    information_schema.columns where       table_schema    = parsename(''' + @tablename + ''', 2) and table_name  = parsename(''' + @tablename + ''', 1) and data_type in (' + case when isnumeric(replace(replace(replace(replace(replace(@searchstrcolumnvalue,'%',''),'_',''),'[',''),']',''),'-','')) = 1 then '''tinyint'',''int'',''smallint'',''bigint'',''numeric'',''decimal'',''smallmoney'',''money'',' else '' end + '''char'',''varchar'',''nchar'',''nvarchar'',''timestamp'',''uniqueidentifier''' + case @searchstrinxml when 1 then ',''xml''' else '' end + ') and column_name like coalesce(' + case when @searchstrcolumnname is null then 'null' else '''' + @searchstrcolumnname + '''' end  + ',column_name)' exec (@sql) select top 1 @columnname = column_name,@columntype = data_type from @columnnametable set @sql = 'select ''' + @tablename + ''',''' + @columnname + ''',' + case @columntype when 'xml' then 'left(cast(' + @columnname + ' as nvarchar(max)), 4096),''' else 'left(' + @columnname + ', 4096),''' end + @columntype + ''' from ' + @tablename + ' (nolock) ' + else @columnname end + ' like ' + @quotedsearchstrcolumnvalue if @@rowcount > 0 if @fullrowresult = 1 set @sql = 'select top ' + cast(@fullrowresultrows as varchar(3)) + ' ''' + @tablename + ''' as [tablefound],''' + @columnname + ''' as [columnfound],''fullrow>'' as [fullrow>],*' + else @columnname end + ' like ' + @quotedsearchstrcolumnvalue end delete from @columnnametable where column_name = @columnname end end end set nocount off;
@table_name     sysname, @table_id       int, @column_name    sysname, @sql_string     varchar(2000) set @search_string = 'stringtosearch' and system_type_id in (167, 175, 231, 239, 99) set @sql_string = 'if exists (select * from ' + @table_name + ' where [' + @column_name + '] like ''%' + @search_string + '%'') print ''' + @table_name + ', ' + @column_name + '''' end  end ;
select distinct a,b,c,d,count(*) count from my_table group by a,b,c,d;
select distinct a from my_table union select distinct b from my_table union select distinct c from my_table union select distinct d from my_table;
select (select group_concat(distinct a) from my_table) as a, (select group_concat(distinct b) from my_table) as b, (select group_concat(distinct c) from my_table) as c, (select group_concat(distinct d) from my_table) as d;
select a, b from mytable group by a, b;
select distinct(concat(a,b)) as cc from my_table group by (cc);
select distinct value from ( select distinct a as value from my_table union select distinct b as value from my_table union select distinct c as value from my_table;
delete top (10) yourtable where col in ('1','2','3','4') delete top (10) yourtable where col in ('1','2','3','4') end;
delete k from yourtable1 k;
delete from [table] where [col] = '1';
delete from [table] where [col] = 1;
delete from [table] where cast([col] as int) = 1;
alter table [tablename] nocheck constraint all;
alter index all on [tablename] disable;
alter index all on [tablename] rebuild;
alter table [tablename] check constraint all;
select * from sys.databases where database_id=16 select * from sys.partitions where hobt_id=72057595075231744 select * from sys.objects where object_id=2105058535;
delete from tablename where col1 = 'v1';
delete from tablename where col1 = 'rubbish';
update statistics tablename;
alter table importbarcodes rebuild;
select id, value, (value/2) as calculated from mytable;
update mytable set calculated = value/2;
create trigger halfcolumn_insert after insert on table update table set calculated = value / 2 where id = new.id;
create trigger halfcolumn_update after update on table update table set calculated = value / 2 where id = new.id;
create trigger halfcolumn_update before update on my_table set new.calculated = new.value/2;
create trigger halfcolumn_insert before insert on my_table set new.calculated = new.value/2;
create trigger halfcolumn_update before update on my_table set new.calculated = new.value/2;
alter table tbl_test add column calc_val int;
create table order_details (price double, quantity int, amount double as (price * quantity));
select column_name, data_type, character_maximum_length from information_schema.columns where table_name = 'table1';
select columnproperty(object_id('mytable'), 'remarks', 'precision');
select sum(datalength(your_field)) as fieldsize from your_table;
create function [dbo].[getmaxvarcharcolumnlength] (@tableschema nvarchar(max), @tablename nvarchar(max), @columnname varchar(max)) as begin where table_schema = @tableschema and table_name = @tablename and column_name = @columnname);
if len(@name) > [dbo].[getmaxvarcharcolumnlength]('person', 'familystatename', 'name');
select col_length('table', 'column');
select s.name from sys.columns c where s.name = 'dbo' and t.name in ('varchar') -- , 'char', 'nvarchar', 'nchar') o.name, c.name;
select column_name, data_type, character_maximum_length from information_schema.columns where table_name = 'mytable';
select datalength(remarks) as fieldsize from mytable;
cards.hash_card, cards.`table`, users.name, 0 as total, cards.card_status, cards.created_at as last_update from cards where hash_card not in ( select orders.hash_card from orders ) union select cards.id_card, orders.hash_card, cards.`table`, users.name, sum(orders.quantity*orders.product_price) as total, cards.card_status, max(orders.created_at) last_update from menu.orders;
select date(date_add(m_inv_reqdate, interval + 1 day)) from  tr08_investment;
select * from `fab_scheduler` where eventdate>=(now() - interval 1 day)) and eventdate<now() order by eventdate desc;
select date_add('2010-05-11', interval 1 day) as tomorrow;
select * from fab_scheduler where custid = '123456' and curdate() = date(date_add(eventdate, interval 1 day));
select ... date_field + interval 1 day;
select * from fab_scheduler where custid = 1334666058 and eventdate = eventdate + interval 1 day;
select convert(date,getdate()) or  select * from [user] u where  convert(date,u.datecreated) = '2014-02-07';
select * from [user] u where u.datecreated = '2014-02-07';
select * from [user] u where u.datecreated between '2014-02-07' and '2014-02-08';
select * from [user] u where cast(u.datecreated as date) = '2014-02-07';
select * from [user] u where cast(u.datecreated as date) = '2016-07-05';
select * from [user] u where convert(varchar(10),u.datecreated, 120) = '2014-02-07';
select * from [user] u where u.datecreated >= '2014-02-07' and u.datecreated < dateadd(day,1,'2014-02-07');
select * from [user] u where convert(varchar, u.datecreated, 120) like '2014-02-07%';
select * from [user] u where convert(varchar(10),u.datecreated, 120) = '2014-02-07';
create table dbo.mytable select mydecimalcolumn, mynumericcolumn from dbo.mytable;
select * from accounts_details where account_id=1001 union select * from accounts_details where account_id=1002;
select purpose.pname,company.cname from purpose where pname='fever' and cname='abc' in ( select mname from medication where mname like 'a%';
select contactid where flag = 'volunteer' and flag = 'uploaded' [...];
select * from (your_table_name) where flag = 'volunteer' or flag = 'uploaded';
select * from (your_table_name) where flag = 'volunteer' or flag = 'uploaded';
select contactid where flag = 'volunteer' select contactid where flag = 'uploaded';
where flag like "%volunteer%" and flag like "%uploaded%";
having count(*) = _;
select contact_id from your_table where flag in ('volunteer', 'uploaded', ...) having count(*) = 2 -- // must match number in the where flag in (...) list;
select t1.contact_id from your_table t1 join your_table t2 on t1.contact_id = t2.contact_id and t2.flag = 'uploaded' where t1.flag = 'volunteer';
select t.contactid from your_table t where flag in ('volunteer', 'uploaded') having count(distinct t.flag) = 2;
select t.contactid from your_table t where flag in ('volunteer', 'uploaded') having count(t.flag) = 2;
select contactid where flag = 'volunteer' and flag = 'uploaded'...;
select contactid where flag = 'volunteer' or flag = 'uploaded'...;
select contactid, count(*) from <your_table> where flag in ('volunteer','uploaded') having count(*)>1;
select contactid  where flag = 'volunteer' or flag = 'uploaded';
select a.contactid from (select contactid from testtbl where flag = 'volunteer')a , (select contactid from testtbl where flag = 'uploaded') b where a.contactid = b.contactid;
select .....long select statement here.... ) select * from ( select * from select * from cte where cte.maincol= 1 order by cte.colx asc offset 0 rows union all select * from ( select * from cte where cte.maincol = 0 order by cte.coly desc offset 0 rows;
select * from ( select stockmain.vrnoa, item.description as item_description, party.name as party_name, stockmain.vrdate, stockdetail.qty, stockdetail.rate, stockdetail.amount, row_number() over (order by vrdate desc) as rownum  --< order by from stockmain where stockmain.etype='purchase' where myderivedtable.rownum between 1 and 5;
create table tab(columna decimal(10,2), columnb decimal(10,2), columnc decimal(10,2)) as ( select columna, columnb, columnc, columna + columnb as calccolumn1 from tab ) select columna, columnb, calccolumn1, calccolumn1 / columnc as calccolumn2 from  tab_cte;
select columna, columnb, c.calccolumn1 as calccolumn1, c.calccolumn1 / columnc as calccolumn2 from t42;
create table tab(columna number(10,2),columnb number(10,2),columnc number(10,2));
select columna, columnb, sub.calccolumn1, sub.calccolumn1 / columnc as calccolumn2 from tab t;
select columna, columnb, sub.calccolumn1, sub.calccolumn1 / columnc as calccolumn2 from tab t where sub.calccolumn1 = 12;
select columna, columnb, calccolumn1, calccolumn1 / columnc as calccolumn2 from ( select columna, columnb, columnc, columna + columnb as calccolumn1 from t42;
select columna, columnb, columna + columnb as calccolumn1, (columna + columnb) / columnc as calccolumn2 from t42;
select columna, columnb, columna + columnb as calccolumn1;
select t0.foo, t1.bar from first_table t0;
alter table mytable default current_timestamp;
alter table mytable default current_timestamp;
update `table` set `timestamp` = `timestamp`, `col` = 'new data' ;
update table set x=y, timestampcolumn=timestampcolumn where a=b;
default current_timestamp;
set lastupdateddate=now() where;
set transaction isolation level read uncommitted;
set statistics time off;
set statistics io off;
values ('<yourschema>.<youtablename>') set @object_id = object_id(@name) end close db_cursor ( select ic.[object_id] from sys.index_columns ic with (nowait) join sys.columns c with (nowait) on ic.[object_id] = c.[object_id] and ic.column_id = c.column_id where ic.[object_id] = @object_id fk_columns as ( select k.constraint_object_id from sys.foreign_key_columns k with (nowait) join sys.columns rc with (nowait) on rc.[object_id] = k.referenced_object_id and rc.column_id = k.referenced_column_id join sys.columns c with (nowait) on c.[object_id] = k.parent_object_id and c.column_id = k.parent_column_id where k.parent_object_id = @object_id and @generatefks = 1 ) select @sql = case when @generateusedatabase = 1 then n'use ' + @targetdatabase + n';' + @cr else n'' end as nvarchar(max)) case @generatesetnocount else n'' end as nvarchar(max)) case when @usetransaction = 1 then n'set xact_abort on' + @cr else n'' end as nvarchar(max)) case when @generatedropifitexists = 1 then cast( n'if object_id(''' + quotename(object_schema_name(@object_id)) + n'.' + quotename(object_name(@object_id)) + n''',''sn'') is not null drop synonym ' + quotename(object_schema_name(@object_id)) + n'.' + quotename(object_name(@object_id)) + n';' + @cr as nvarchar(max)) else cast( n'' as nvarchar(max)) end + case when @generatedropifitexists = 1 then --drop table if exists n'if object_id(''' + quotename(object_schema_name(@object_id)) + n'.' + quotename(object_name(@object_id)) + n''',''u'') is not null drop table ' + quotename(object_schema_name(@object_id)) + n'.' + quotename(object_name(@object_id)) + n';' + @cr as nvarchar(max)) else n'' end else n'' end) as nvarchar(max)) case when @generatedropfkifitexists = 1 then --drop foreign keys select cast( n'alter table ' + quotename(s.name) + n'.' + quotename(t.name) + n' drop constraint ' + rtrim(f.name) + n';' + @cr as nvarchar(max)) from sys.tables t where f.referenced_object_id = @object_id else n'' end else n'' end) as nvarchar(max)) case when @generatecreatetable = 1 then n'create table ' + quotename(object_schema_name(@object_id)) + n'.' + quotename(object_name(@object_id)) + @cr + n'(' + @cr + stuff(( select cast( @tb + n',' + quotename(c.name) + n' ' + isnull(replicate(' ',@datatypespacer - len(quotename(c.name))),'')  --isnull(replicate) then len(quotename(c.name)) > @datatypespacer case when c.is_computed = 1 then n' as ' + cc.[definition] else upper(tp.name) + case when tp.name in (n'varchar', n'char', n'varbinary', n'binary', n'text') then n'(' + case when c.max_length = -1 then n'max' else cast(c.max_length as nvarchar(5)) end + n')' then n'(' + case when c.max_length = -1 then n'max' else cast(c.max_length / 2 as nvarchar(5)) end + n')' then n'(' + cast(c.scale as nvarchar(5)) + n')' then n'(' + cast(c.[precision] as nvarchar(5)) + n',' + cast(c.scale as nvarchar(5)) + n')' else n'' end + case when c.collation_name is not null and @generatecollation = 1 then n' collate ' + c.collation_name else n'' end + case when c.is_nullable = 1 then n' null' else n' not null' end + case when dc.[definition] is not null then case when @generateconstraintnameofdefaults = 1 then n' constraint ' + quotename(dc.name) else n'' end + n' default' + dc.[definition] else n'' end + case when ic.is_identity = 1 and @generateidentity = 1 then n' identity(' + cast(isnull(ic.seed_value, n'0') as nchar(1)) + n',' + cast(isnull(ic.increment_value, n'1') as nchar(1)) + n')' else n'' end end + @cr as nvarchar(max)) from sys.columns c with (nowait) where c.[object_id] = @object_id as nvarchar(max)) else cast('' as nvarchar(max)) end + case when @generatekeyconstraints <> 1 then n'' else select n', ' + quotename(c.name) + n' ' + case when ic.is_descending_key = 1 then n'desc' else n'asc' end from sys.index_columns ic with (nowait) join sys.columns c with (nowait) on c.[object_id] = ic.[object_id] and c.column_id = ic.column_id where ic.is_included_column = 0 and ic.[object_id] = k.parent_object_id and ic.index_id = k.unique_index_id from sys.key_constraints k with (nowait) left join sys.indexes kidx on where k.parent_object_id = @object_id and k.[type] = n'pk'), n'') + n')'  + @cr end as nvarchar(max)) case when and (select top 1 data_compression_desc from sys.partitions where object_id = @object_id and index_id = 1) <> n'none' then n'with (data_compression=' + (select top 1 data_compression_desc from sys.partitions where object_id = @object_id and index_id = 1) + n')' + @cr else n'' + @cr end as nvarchar(max)) else n'' end) as nvarchar(max)) isnull((select ( select @cr + then n' nocheck' else n' check' end + select n', ' + quotename(k.cname) + n'' from fk_columns k where k.constraint_object_id = fk.[object_id] select n', ' + quotename(k.rcname) + n'' from fk_columns k where k.constraint_object_id = fk.[object_id] else n'' end + case else n'' end + @cr + n'alter table ' + + quotename(object_schema_name(@object_id)) + n'.' + quotename(object_name(@object_id)) + + n' check constraint ' + quotename(fk.name)  + n'' + @cr from sys.foreign_keys fk with (nowait) join sys.objects ro with (nowait) on ro.[object_id] = fk.referenced_object_id where fk.parent_object_id = @object_id as nvarchar(max)) else n'' end) as nvarchar(max)) case when @generateindexes = 1 then isnull(((select select n', ' + quotename(c.name) + n'' + case when c.is_descending_key = 1 then n' desc' else n' asc' end from index_column c where c.is_included_column = 0 and c.index_id = i.index_id select n', ' + quotename(c.name) + n'' from index_column c where c.is_included_column = 1 and c.index_id = i.index_id from sys.indexes i with (nowait) where i.[object_id] = @object_id and i.is_primary_key = 0 and i.[type] in (1,2) and @generateindexes = 1 as nvarchar(max)) else cast(n'' as nvarchar(max)) end + else n'' end) as nvarchar(max)) case when @generatedelete = 1 then (case when exists (select * from sys.foreign_keys where referenced_object_id = @object_id) then else n'truncate table ' + quotename(object_schema_name(@object_id)) + n'.' + quotename(object_name(@object_id)) + n';' + @cr as nvarchar(max)) else cast(n'' as nvarchar(max)) end + else n'' end) as nvarchar(max)) case when @generateinsertinto = 1 then cast( case when exists (select * from sys.columns c where c.[object_id] = @object_id and is_identity = 1) and @generateidentityinsert = 1 then else cast('' as nvarchar(max)) end + ( @tb + n' ' + substring( ( select @tb + ','+ quotename(name) + @cr from sys.columns c where c.[object_id] = @object_id and system_type_id <> 189 /*timestamp*/ and is_computed = 0 and (is_identity = 0 or @generateidentityinsert in (0,1)) ) ( @tb + n' ' + substring( ( select @tb + ','+ quotename(name) + @cr from sys.columns c where   c.[object_id] = @object_id and system_type_id <> 189 /*timestamp*/ and is_computed = 0 and (is_identity = 0 or @generateidentityinsert  in (0,1)) ) else cast('' as nvarchar(max)) end as nvarchar(max)) else cast( n'' as nvarchar(max)) end + case when @usetransaction = 1 then @cr + n'commit tran; ' else n'' end as nvarchar(max)) if len(@sql) > (@i + @len) set @len = len(substring(@sql, @i, @maxchunk)) - charindex(@cr, reverse(substring(@sql, @i, @len))) + 1 set @i      =  @i + @len set @len    =  @maxchunk end ;
select @object_name = '[' + s.name + '].[' + o.name + ']' from tempdb.sys.objects o with (nowait) join tempdb.sys.schemas s with (nowait) on o.[schema_id] = s.[schema_id] where object_id = @temptable_objectid ( select ic.[object_id] from tempdb.sys.index_columns ic with (nowait) join tempdb.sys.columns c with (nowait) on ic.[object_id] = c.[object_id] and ic.column_id = c.column_id where ic.[object_id] = @object_id fk_columns as ( select k.constraint_object_id from tempdb.sys.foreign_key_columns k with (nowait) join tempdb.sys.columns rc with (nowait) on rc.[object_id] = k.referenced_object_id and rc.column_id = k.referenced_column_id join tempdb.sys.columns c with (nowait) on c.[object_id] = k.parent_object_id and c.column_id = k.parent_column_id where k.parent_object_id = @object_id ) select @sql = 'create table ' + @object_name + char(13) + '(' + char(13) + stuff(( select char(9) + ', [' + c.name + '] ' + case when c.is_computed = 1 then 'as ' + cc.[definition] else upper(tp.name) + case when tp.name in ('varchar', 'char', 'varbinary', 'binary', 'text') then '(' + case when c.max_length = -1 then 'max' else cast(c.max_length as varchar(5)) end + ')' then '(' + case when c.max_length = -1 then 'max' else cast(c.max_length / 2 as varchar(5)) end + ')' then '(' + cast(c.scale as varchar(5)) + ')' then '(' + cast(c.[precision] as varchar(5)) + ',' + cast(c.scale as varchar(5)) + ')' else '' end + case when c.collation_name is not null then ' collate ' + c.collation_name else '' end + case when c.is_nullable = 1 then ' null' else ' not null' end + case when dc.[definition] is not null then ' default' + dc.[definition] else '' end + case when ic.is_identity = 1 then ' identity(' + cast(isnull(ic.seed_value, '0') as char(1)) + ',' + cast(isnull(ic.increment_value, '1') as char(1)) + ')' else '' end end + char(13) from tempdb.sys.columns c with (nowait) join tempdb.sys.types tp with (nowait) on c.user_type_id = tp.user_type_id where c.[object_id] = @object_id select ', [' + c.name + '] ' + case when ic.is_descending_key = 1 then 'desc' else 'asc' end from tempdb.sys.index_columns ic with (nowait) join tempdb.sys.columns c with (nowait) on c.[object_id] = ic.[object_id] and c.column_id = ic.column_id where ic.is_included_column = 0 and ic.[object_id] = k.parent_object_id and ic.index_id = k.unique_index_id from tempdb.sys.key_constraints k with (nowait) where k.parent_object_id = @object_id and k.[type] = 'pk'), '') + ')'  + char(13) select char(13) + then ' nocheck' else ' check' end + select ', [' + k.cname + ']' from fk_columns k where k.constraint_object_id = fk.[object_id] select ', [' + k.rcname + ']' from fk_columns k where k.constraint_object_id = fk.[object_id] else '' end + case else '' end + char(13) + 'alter table ' + @object_name + ' check constraint [' + fk.name  + ']' + char(13) from tempdb.sys.foreign_keys fk with (nowait) join tempdb.sys.objects ro with (nowait) on ro.[object_id] = fk.referenced_object_id where fk.parent_object_id = @object_id select ', [' + c.name + ']' + case when c.is_descending_key = 1 then ' desc' else ' asc' end from index_column c where c.is_included_column = 0 and c.index_id = i.index_id select ', [' + c.name + ']' from index_column c where c.is_included_column = 1 and c.index_id = i.index_id from tempdb.sys.indexes i with (nowait) where i.[object_id] = @object_id and i.is_primary_key = 0 and i.[type] = 2 select @sql;
exec etl.gettabledefinitions '{friendlyname}', '{databasename}', 'all', 0, null;
exec etl.gettabledefinitions '{friendlyname}', '{databasename}', 'dbo', 0, null;
exec etl.gettabledefinitions '{friendlyname}', '{databasename}', 'all', 1, '{linkedservername}';
create procedure etl.gettabledefinitions ( @systemname nvarchar(128) ) as  select @inschemaname = case when @schemaname = n'all' then n's.[name]' else '''' + @schemaname + '''' end;
if @linkedserver = 0 select @sql = n' set nocount on;
( id int identity(1,1) select s.[name] + n''.'' + t.[name] as [name] from [' + @databasename + '].sys.tables t join [' + @databasename + '].sys.schemas s on t.[schema_id] = s.[schema_id] where t.[name] not in (''tally'',''loc_and_seg_cap1'',''loc_and_seg_cap2'',''loc_and_seg_cap3'',''loc_and_seg_cap4'',''tablenames'') and s.[name] = ' + @inschemaname + ' select @maxint = count(0) from @tables;
( select ic.[object_id] from [' + @databasename + '].sys.index_columns ic with (nolock) join [' + @databasename + '].sys.columns c with (nolock) on ic.[object_id] = c.[object_id] and ic.column_id = c.column_id join [' + @databasename + '].sys.tables t on c.[object_id] = t.[object_id] ) ( select k.constraint_object_id from [' + @databasename + '].sys.foreign_key_columns k with (nowait) join [' + @databasename + '].sys.columns rc with (nowait) on rc.[object_id] = k.referenced_object_id and rc.column_id = k.referenced_column_id join [' + @databasename + '].sys.columns c with (nowait) on c.[object_id] = k.parent_object_id and c.column_id = k.parent_column_id join [' + @databasename + '].sys.tables t on c.[object_id] = t.[object_id] where @generatefks = 1 ) select @sql = @sql + case when @generateusedatabase = 1 then n''use '' + @targetdatabase + n'';'' + @cr else n'''' end as nvarchar(200)) case @generatesetnocount else n'''' end as nvarchar(max)) case when @usetransaction = 1 then n''set xact_abort on'' + @cr else n'''' end as nvarchar(max)) case when @generatedropifitexists = 1 then cast(n''if object_id('''''' + quotename(object_schema_name(t.[object_id], t.[database_id])) + n''.'' + quotename(object_name(t.[object_id], t.[database_id])) + n'''''',''''sn'''') is not null drop synonym '' + quotename(object_schema_name(t.[object_id], t.[database_id])) + n''.'' + quotename(object_name(t.[object_id], t.[database_id])) + n'';'' + @cr as nvarchar(max)) else cast(n'''' as nvarchar(max))   end case when @generatedropifitexists = 1 then --drop table if exists else n'''' end else n'''' end) as nvarchar(max)) case when @generatedropfkifitexists = 1 then --drop foreign keys select cast( n''alter table '' + quotename(s.[name]) + n''.'' + quotename(t.[name]) + n'' drop constraint '' + rtrim(f.[name]) + n'';'' + @cr as nvarchar(max)) from [' + @databasename + '].sys.tables t where f.referenced_object_id = t.[object_id] else n'''' end else cast(n'''' as nvarchar(max)) end) as nvarchar(max)) case when @generatecreatetable = 1 then n''create table '' + quotename(object_schema_name(t.[object_id], t.[database_id])) + n''.'' + quotename(object_name(t.[object_id], t.[database_id])) + @cr + n''('' + @cr + stuff(( select cast( @tab + n'','' + quotename(c.[name]) + n'' '' + isnull(replicate('' '',@datatypespacer - len(quotename(c.[name]))),'''') case when c.is_computed = 1 then n'' as '' + cc.[definition] else upper(tp.[name]) + case when tp.[name] in (n''varchar'', n''char'', n''varbinary'', n''binary'', n''text'') then n''('' + case when c.max_length = -1 then n''max'' else cast(c.max_length as nvarchar(5)) end + n'')'' then n''('' + case when c.max_length = -1 then n''max'' else cast(c.max_length / 2 as nvarchar(5)) end + n'')'' then n''('' + cast(c.scale as nvarchar(5)) + n'')'' then n''('' + cast(c.[precision] as nvarchar(5)) + n'','' + cast(c.scale as nvarchar(5)) + n'')'' else n'''' end + case when c.collation_name is not null and @generatecollation = 1 then n'' collate '' + c.collation_name else n'''' end + case when c.is_nullable = 1 then n'' null'' else n'' not null'' end + case when dc.[definition] is not null then case when @generateconstraintnameofdefaults = 1 then n'' constraint '' + quotename(dc.[name]) else n'''' end + n'' default'' + dc.[definition] else n'''' end + case when ic.is_identity = 1 and @generateidentity = 1 then n'' identity('' + cast(isnull(ic.seed_value, n''0'') as nchar(1)) + n'','' + cast(isnull(ic.increment_value, n''1'') as nchar(1)) + n'')'' else n'''' end end + @cr as nvarchar(max)) from [' + @databasename + '].sys.columns c with (nowait) and c.column_id = cc.column_id and c.[object_id] = dc.parent_object_id and c.column_id = dc.parent_column_id and c.[object_id] = ic.[object_id] and c.column_id = ic.column_id where c.[object_id] = t.[object_id] else cast(n'''' as nvarchar(max)) end case when @generatekeyconstraints <> 1 then n'''' else isnull((select @tab + n'', constraint '' + quotename(k.[name]) + n'' primary key '' + isnull(kidx.[type_desc], n'''') + n''('' + select n'', '' + quotename(c.[name]) + n'' '' + case when ic.is_descending_key = 1 then n''desc'' else n''asc'' end from [' + @databasename + '].sys.index_columns ic with (nowait) join [' + @databasename + '].sys.columns c with (nowait) on c.[object_id] = ic.[object_id] and c.column_id = ic.column_id where ic.is_included_column = 0 and ic.[object_id] = k.parent_object_id and ic.index_id = k.unique_index_id from [' + @databasename + '].sys.key_constraints k with (nowait) and k.unique_index_id = kidx.index_id where k.parent_object_id = t.[object_id] and k.[type] = n''pk''), n'''') + n'')''  + @cr end as nvarchar(max)) case when @generatedatacompressionoptions = 1 and (select top 1 data_compression_desc from [' + @databasename + '].sys.partitions where object_id = t.[object_id] and index_id = 1) <> n''none'' then n''with (data_compression='' + (select top 1 data_compression_desc from [' + @databasename + '].sys.partitions where object_id = t.[object_id] and index_id = 1) + n'')'' + @cr else n'''' + @cr end as nvarchar(max)) else n'''' end) as nvarchar(max)) isnull((select ( select @cr + then n'' nocheck'' else n'' check'' end + select n'', '' + quotename(k.cname) + n'''' from fk_columns k where k.constraint_object_id = fk.[object_id] and fk.[object_id] = t.[object_id] select n'', '' + quotename(k.rcname) + n'''' from fk_columns k where k.constraint_object_id = fk.[object_id] and fk.[object_id] = t.[object_id] else n'''' end + case else n'''' end + @cr + n''alter table '' + quotename(object_schema_name(t.[object_id], t.[database_id])) + n''.'' + quotename(object_name(t.[object_id], t.[database_id])) + n'' check constraint '' + quotename(fk.[name])  + n'''' + @cr from [' + @databasename + '].sys.foreign_keys fk with (nowait) join [' + @databasename + '].sys.objects ro with (nowait) on ro.[object_id] = fk.referenced_object_id where fk.parent_object_id = t.[object_id] as nvarchar(max)) else n'''' end) as nvarchar(max)) case when @generateindexes = 1 then isnull(((select select n'', '' + quotename(c.[name]) + n'''' + case when c.is_descending_key = 1 then n'' desc'' else n'' asc'' end from index_column c where c.is_included_column = 0 and c.[object_id] = t.[object_id] and c.index_id = i.index_id select n'', '' + quotename(c.[name]) + n'''' from index_column c where c.is_included_column = 1 and c.[object_id] = t.[object_id] and c.index_id = i.index_id from [' + @databasename + '].sys.indexes i with (nowait) where i.[object_id] = t.[object_id] and i.is_primary_key = 0 and i.[type] in (1,2) and @generateindexes = 1 as nvarchar(max)) else n'''' end else n'''' end) as nvarchar(max)) case when @generatedelete = 1 then (case when exists (select top 1 [name] from [' + @databasename + '].sys.foreign_keys where referenced_object_id = t.[object_id]) then else n''truncate table '' + quotename(object_schema_name(t.[object_id], t.[database_id])) + n''.'' + quotename(object_name(t.[object_id], t.[database_id])) + n'';'' + @cr as nvarchar(max)) else n'''' end else n'''' end) as nvarchar(max)) case when @generateinsertinto = 1 then cast( case when exists (select top 1 c.[name] from [' + @databasename + '].sys.columns c where c.[object_id] = t.[object_id] and c.is_identity = 1) and @generateidentityinsert = 1 then else n'''' end ( @tab + n'' '' + substring( ( select @tab + '',''+ quotename(c.[name]) + @cr from [' + @databasename + '].sys.columns c where c.[object_id] = t.[object_id] and c.system_type_id <> 189 /*timestamp*/ and c.is_computed = 0 and (c.is_identity = 0 or @generateidentityinsert in (0,1)) ) ( @tab + n'' '' + substring( ( select @tab + '',''+ quotename(c.[name]) + @cr from [' + @databasename + '].sys.columns c where c.[object_id] = t.[object_id] and c.system_type_id <> 189 /*timestamp*/ and c.is_computed = 0 and (c.is_identity = 0 or @generateidentityinsert  in (0,1)) ) else n'''' end as nvarchar(max)) else n'''' end case when @usetransaction = 1 then @cr + n''commit tran; '' else n'''' end as nvarchar(700)) from @tables t where id = @int set @int = @int + 1;
end  exec [master].dbo.printmax @sql;
select @sql = n'execute ('' set nocount on;
end  set @string = replace(replace(@sql, char(13) + char(10), char(10)), char(13), char(10)) if charindex(char(10), @string) between 1 and 4000 set @currentend = charindex(char(10), @string) -1 set @offset = 2 end else begin set @currentend = 4000 set @offset = 1 end print substring(@string, 1, @currentend) set @string = substring(@string, @currentend + @offset, len(@string)) end  exec (@sql);
select isnull(smsp.definition, ssmsp.definition) as [definition] from sys.all_objects as sp where (sp.type = n'v' or sp.type = n'p' or sp.type = n'rf' or sp.type=n'pc')and(sp.name=n'yourobjectname' and schema_name(sp.schema_id)=n'dbo');
database northwind = server.databases["northwind"];
table categories   = northwind.tables["categories"];
create table [dbo].[workout]( [workoutid] [bigint] identity(1,1) not null, [timesheetdate] [datetime] not null, [dateout] [datetime] not null, [employeeid] [int] not null, [ismainworkplace] [bit] not null, [departmentuid] [uniqueidentifier] not null, [workplaceuid] [uniqueidentifier] null, [teamuid] [uniqueidentifier] null, [workshiftcd] [nvarchar](10) null, [workhours] [real] null, [absencecode] [varchar](25) null, [paymenttype] [char](2) null, [categoryid] [int] null, [year]  as (datepart(year,[timesheetdate])), constraint [pk_workout] primary key clustered ( [workoutid] asc alter table [dbo].[workout] add constraint [df__workout__ismainw__2c1e8537]  default ((1)) for [ismainworkplace] alter table [dbo].[workout]  with check add  constraint [fk_workout_employee_employeeid] foreign key([employeeid]) alter table [dbo].[workout] check constraint [fk_workout_employee_employeeid];
select @table_name = 'dbo.workout' select @object_name = '[' + s.name + '].[' + o.name + ']' from sys.objects o with (nowait) join sys.schemas s with (nowait) on o.[schema_id] = s.[schema_id] where s.name + '.' + o.name = @table_name and o.[type] = 'u' and o.is_ms_shipped = 0 ( select ic.[object_id] from sys.index_columns ic with (nowait) join sys.columns c with (nowait) on ic.[object_id] = c.[object_id] and ic.column_id = c.column_id where ic.[object_id] = @object_id fk_columns as ( select k.constraint_object_id from sys.foreign_key_columns k with (nowait) join sys.columns rc with (nowait) on rc.[object_id] = k.referenced_object_id and rc.column_id = k.referenced_column_id join sys.columns c with (nowait) on c.[object_id] = k.parent_object_id and c.column_id = k.parent_column_id where k.parent_object_id = @object_id ) select @sql = 'create table ' + @object_name + char(13) + '(' + char(13) + stuff(( select char(9) + ', [' + c.name + '] ' + case when c.is_computed = 1 then 'as ' + cc.[definition] else upper(tp.name) + case when tp.name in ('varchar', 'char', 'varbinary', 'binary', 'text') then '(' + case when c.max_length = -1 then 'max' else cast(c.max_length as varchar(5)) end + ')' then '(' + case when c.max_length = -1 then 'max' else cast(c.max_length / 2 as varchar(5)) end + ')' then '(' + cast(c.scale as varchar(5)) + ')' then '(' + cast(c.[precision] as varchar(5)) + ',' + cast(c.scale as varchar(5)) + ')' else '' end + case when c.collation_name is not null then ' collate ' + c.collation_name else '' end + case when c.is_nullable = 1 then ' null' else ' not null' end + case when dc.[definition] is not null then ' default' + dc.[definition] else '' end + case when ic.is_identity = 1 then ' identity(' + cast(isnull(ic.seed_value, '0') as char(1)) + ',' + cast(isnull(ic.increment_value, '1') as char(1)) + ')' else '' end end + char(13) from sys.columns c with (nowait) join sys.types tp with (nowait) on c.user_type_id = tp.user_type_id where c.[object_id] = @object_id select ', [' + c.name + '] ' + case when ic.is_descending_key = 1 then 'desc' else 'asc' end from sys.index_columns ic with (nowait) join sys.columns c with (nowait) on c.[object_id] = ic.[object_id] and c.column_id = ic.column_id where ic.is_included_column = 0 and ic.[object_id] = k.parent_object_id and ic.index_id = k.unique_index_id from sys.key_constraints k with (nowait) where k.parent_object_id = @object_id and k.[type] = 'pk'), '') + ')'  + char(13) select char(13) + then ' nocheck' else ' check' end + select ', [' + k.cname + ']' from fk_columns k where k.constraint_object_id = fk.[object_id] select ', [' + k.rcname + ']' from fk_columns k where k.constraint_object_id = fk.[object_id] else '' end + case else '' end + char(13) + 'alter table ' + @object_name + ' check constraint [' + fk.name  + ']' + char(13) from sys.foreign_keys fk with (nowait) join sys.objects ro with (nowait) on ro.[object_id] = fk.referenced_object_id where fk.parent_object_id = @object_id select ', [' + c.name + ']' + case when c.is_descending_key = 1 then ' desc' else ' asc' end from index_column c where c.is_included_column = 0 and c.index_id = i.index_id select ', [' + c.name + ']' from index_column c where c.is_included_column = 1 and c.index_id = i.index_id from sys.indexes i with (nowait) where i.[object_id] = @object_id and i.is_primary_key = 0 and i.[type] = 2;
create table [dbo].[workout] ( [workoutid] bigint not null identity(1,1) ) alter table [dbo].[workout] with check add constraint [fk_workout_employee_employeeid] foreign key([employeeid]) references [dbo].[employee] ([employeeid]) alter table [dbo].[workout] check constraint [fk_workout_employee_employeeid] create nonclustered index [ix_workout_workshiftcd_absencecode] on [dbo].[workout] ([workshiftcd] asc, [absencecode] asc);
drop function [dbo].[get_table_script] create function get_table_script ( @vstablename varchar(50) ) select @scriptcommand = ( case when tc.constraint_name is null then '' else 'alter table ' + so.name + ' add constraint ' + end ) from sysobjects as so ( select '  [' + column_name + '] ' + ( case data_type then '' then '' then '(' + cast( numeric_precision_radix as varchar ) + ', ' + cast( numeric_scale as varchar ) + ') ' else coalesce( '(' + case when character_maximum_length = -1 then 'max' else cast( character_maximum_length as varchar ) end + ')' , '' ) end ) ( case when exists ( select id from syscolumns where ( object_name(id) = so.name ) and ( name = column_name ) and ( columnproperty(id,name,'isidentity') = 1 ) ) then 'identity(' + else '' end ) + ' ' + ( case when is_nullable = 'no' then 'not ' else '' end ) + 'null ' + ( case when information_schema.columns.column_default is not null then 'default ' + information_schema.columns.column_default else '' end ) + ', ' from information_schema.columns where ( table_name = so.name ) ( tc.table_name = so.name ) and ( tc.constraint_type  = 'primary key' ) and ( tc.table_name = @vstablename ) ) ( select '[' + column_name + '], ' from  information_schema.key_column_usage as kcu where ( kcu.constraint_name = tc.constraint_name ) where ( xtype = 'u' ) and ( name not in ('dtproperties') ) end;
select [dbo].get_table_script '<your_table_name>';
exec sp_ppinscripttabla 'table_name';
create function sp_ppintipolongitud ( @xtype int, @length int, @isnullable int ) as begin set @ret = '' select @ret = t.name + case when name in ('varchar', 'nvarchar', 'char', 'nchar') then '(' + convert(varchar, @length) + ')' else '' end + ' ' + case @isnullable when 1 then 'null' else 'not null' end from systypes t where t.xtype = @xtype end go create procedure sp_ppinscriptllavesforaneas ( @vchtabla sysname, @vchresultado varchar(8000) output ) as begin tablaf sysname, tablar sysname, colf sysname, colr sysname, fkname sysname) select tablaf.name as tablaf, tablar.name as tablar, colf.name as colf, colr.name as colr, ofk.name as fkname from sysforeignkeys fk, sysobjects ofk, sysobjects tablaf, sysobjects tablar, syscolumns colf, syscolumns colr where tablaf.name = @vchtabla and ofk.id = fk.constid and tablaf.id = fk.fkeyid and tablar.id = fk.rkeyid and colf.id = tablaf.id and colf.colid = fk.fkey and colr.id = tablar.id and colr.colid = fk.rkey set @vchforeign = '' select top 1 @fkname = fkname from @tmpfk set @vchcolumnasf = '' set @vchcolumnasr = '' select top 1 @colf = colf, @colr = colr, @tablar = tablar from @tmpfk where fkname = @fkname delete from @tmpfk where colf = @colf and colr = @colr and tablar = @tablar and fkname = @fkname set @vchcolumnasf = @vchcolumnasf + @colf + ', ' set @vchcolumnasr = @vchcolumnasr + @colr + ', ' end  set @vchcolumnasf = left(@vchcolumnasf, len(@vchcolumnasf) - 1) set @vchcolumnasr = left(@vchcolumnasr, len(@vchcolumnasr) - 1) set @vchtemp = 'constraint ' + @fkname + ' foreign key (' + @vchcolumnasf + ') ' set @vchtemp = @vchtemp + 'references ' + @tablar + ' (' + @vchcolumnasr + ')' set @vchforeign = @vchforeign + char(9) + @vchtemp + ',' + char(13) end  select @vchresultado = case when len(@vchforeign) >=2 then left(@vchforeign, len(@vchforeign) - 2) else @vchforeign end end go create procedure sp_ppinscripttabla ( @vchtabla sysname ) as  set nocount on exec sp_ppinscriptllavesforaneas @vchtabla, @foreign output select 'create ' + case o.xtype when 'u' then 'table' when 'p' then 'procedure' else '??' end + ' ' + from sysobjects o where o.name = @vchtabla union all -- campos + identitys + defaults select char(9) + c.name + ' ' +                                 -- nombre case when c.colstat & 1 = 1                                     -- identity (si aplica) then ' identity(' + convert(varchar, ident_seed(@vchtabla)) + ',' + convert(varchar, ident_incr(@vchtabla)) + ')' else '' end + case when not od.name is null                                   -- defaults (si aplica) then ' constraint ' + od.name + ' default ' + replace(replace(cd.text, '((', '('), '))', ')') else '' end + ', ' from sysobjects o, syscolumns c systypes t where o.id = object_id(@vchtabla) and o.id = c.id and c.xtype = t.xtype union all -- primary keys y unique keys select char(9) + 'constraint ' + o.name + ' ' + case o.xtype when 'pk' then 'primary key' else 'unique' end + ' ' + from sysobjects o, sysindexes i where o.parent_obj = object_id(@vchtabla) and o.xtype in ('pk','uq') and i.id = o.parent_obj and o.name = i.name union all -- check constraints select char(9) + 'constraint ' + o.name + ' check ' + c.text + ', ' from sysobjects o, syscomments c where o.parent_obj = object_id(@vchtabla) and o.xtype in ('c') and o.id = c.id union all -- foreign keys select @foreign union all select ')' set nocount off;
alter table subs add unique (subs_email);
values (?, ?, ?) subs_birthday = values(subs_birthday);
select * from ( ( table1 join table2 on table1.column1 = table2.column2) --result of join is treated as a temp table join table3 on table1.column1 = table3.column3 join table4 on table4.column4 = table2.column2;
select ... from ((origintable join jointable1 on ...) join jointable2 on ...) join jointable3 on ...;
select * from sometable where null is null;
select * from sometable where null is not null;
if convert(bit, 0) end;
if convert(bit, 0) = 0;
select * from sometable where true;
select * from sometable where 1=1;
select * from sometable where 1=1;
set @true = 1 set @false = 0 select * from sometable where @true = @true;
select * from somewhere where 'true';
select * from <table> where <columna> = 'true';
select id from t where id < (select max(id) from t);
select a.lastname from orders o where a.customerid = o.customerid and count( a.customerid ) >= 5 ) as smallestorderamount from account a;
select o.customerid from account a where a.customerid = o.customerid and count( o.customerid ) >= 5 ) as cnt from orders o;
select employeeid, sum(amount) from sales having sum(amount) > 20000;
select employeeid, sum(amount) from sales where employeeid in ( select max(employeeid) from employees);
create function gettotalsalesbyproduct(@productname varchar(500)) as begin set @totalamount = (select sum(saleamount) from sales where product=@productname) end;
select productname, sum(saleamount) as totalsales from sales where dbo.gettotalsalesbyproduct(productname)  > 1000;
select count( * ) from agents having count(*)>3;
select * from table where auth_user.lastactivity > current_timestamp - interval '100 days';
select ( date_part('year', now())::text;
select now()::date + 100 as date1, current_date - 100 as date2;
select * from table where column_date > now()- interval '6 hours';
select * from tablename where to_char(added_time, 'yyyy-mm-dd')  = to_char( now(), 'yyyy-mm-dd' );
set global time_zone = '+8:00';
create table as;
create table my_table_copy as select * from my_table;
create table my_table_copy as select * from my_table;
create table my_table_copy (like my_table including all);
create table new_table as table existing_table;
create table new_table as table existing_table;
create table new_table as select * from existing_table where condition;
select count(*) from table; -- make a seq scan to make sure the table is at least;
select * into newtable from oldtable;
select indexdef from pg_indexes where tablename='oldtable';
select c.oid, n.nspname, c.relname from pg_catalog.pg_class c where c.relname ~ '^(oldtable)$' and pg_catalog.pg_table_is_visible(c.oid) select a.attname, pg_catalog.format_type(a.atttypid, a.atttypmod), (select substring(pg_catalog.pg_get_expr(d.adbin, d.adrelid) for 128) from pg_catalog.pg_attrdef d where d.adrelid = a.attrelid and d.adnum = a.attnum and a.atthasdef), a.attnotnull, a.attnum from pg_catalog.pg_attribute a where a.attrelid = '74359' and a.attnum > 0 and not a.attisdropped;
select yr, count(title) from actor join casting on actor.id = casting.actorid join movie on casting.movieid = movie.id where name = 'john travolta' from actor join casting on actor.id = casting.actorid join movie on casting.movieid = movie.id where name = 'john travolta';
select yr, count(title) from actor join casting on actor.id=actorid join movie on movie.id=movieid where name = 'john travolta' having count(title)=(select top 1 count(title) from casting join movie on movieid=movie.id join actor on actor.id=actorid where name='john travolta';
select yr, count(title) from actor join casting on actor.id=actorid join movie on movie.id=movieid where name = 'john travolta' having count(title)= from (select count(title) as cnt from actor join casting on actor.id=actorid join movie on movie.id=movieid where name = 'john travolta';
select c.yr, count(*) as ct, max(count(*)) over () as max_ct from   actor   a join   casting c on c.actorid = a.id where  a.name = 'john travolta';
select c.yr, count(*) as ct from   actor   a join   casting c on c.actorid = a.id where  a.name = 'john travolta' limit  1;
select yr, ct from  ( select c.yr, count(*) as ct, rank() over (order by count(*) desc) as rnk from   actor   a join   casting c on c.actorid = a.id where  a.name = 'john travolta' where  rnk = 1;
select yr, count(*) num from ...;
select top 1 yr,count(*)  from movie join casting on casting.movieid=movie.id join actor on casting.actorid = actor.id where actor.name = 'john travolta';
select m.yr, count(*) as num_movies from movie m join casting c on c.movieid = m.id join actor a on a.id = c.actorid and a.name = 'john travolta';
select max(y.num) from (select count(*) as num from table x) y;
select total_final.yr, total_final.num_movies from ( select total.num_movies, rank() over (order by num_movies desc) rnk from ( select m.yr, count(*) as num_movies from movie m join casting c on c.movieid = m.id join actor a on a.id = c.actorid where a.name = 'john travolta' where rnk = 1;
select yr, count(title) from actor join casting on actor.id = casting.actorid join movie on casting.movieid = movie.id where name = 'john travolta' from actor join casting on actor.id = casting.actorid join movie on casting.movieid = movie.id where name = 'john travolta';
select * from ( select yr as year, count(title) as tcount from actor join casting on actor.id = casting.actorid join movie on casting.movieid = movie.id where name = 'john travolta' where rownum < 2;
create view sal as select yr,count(*) as ct from where a.name='john' and a.id=c.actorid and c.movieid=m.id)group by yr;
select yr from sal where ct =(select max(ct) from sal);
select "vendors"."vendorid", "vendors"."name","result"."total" from (select "trans"."vendorid", ("trans"."a"+"trans"."b"+"trans"."c")    as "total" from "trans" where "trans"."year"=2014 join "vendors" on "result"."vendorid"="vendors"."vendorid" where "vendors"."class"='i' and "result"."total" > 200;
select "tab_1"."birthdate", "tab_1"."col_1" from ( select birthdate, dateadd(year, 18, birthdate) as "col_1" from employees where "tab_1"."col_1" >= '2000-12-31';
select jobs.*, case when lead_informations.state is not null then lead_informations.state else 'new' end as lead_state from jobs and lead_informations.mechanic_id = 3 where lead_informations.state is null;
select jobs.*, (select case when lead_informations.state is not null then lead_informations.state else 'new' end) as lead_state from jobs and lead_informations.mechanic_id = 3 ) select * from jobs_refined where lead_state = 'new';
select * from ( select jobs.*, (case when lead_informations.state is not null then lead_informations.state else 'new' end) as lead_state from "jobs" and lead_informations.mechanic_id = 3 where (lead_state = 'new');
drop table if exists create table new_table ( num int(11), row_id varchar(255), row_value varchar(255), row_date datetime create procedure do_repeat(in current_loop_date datetime) user_behavior_search_tagged_keyword_statistics_with_type ( num, row_id, row_value, row_date ) select # do something interesting here row_id, row_value, row_date from old_table where row_date >= current_loop_date and set current_loop_date = current_loop_date + interval 1 week;
drop procedure if exists do_repeat// alter table new_table add primary key add key add key;
set @@autocommit=0;
select date,avg(vol) from volume;
select t1.customer, t1.sku, t1.typedesc from transactiondatatransit as t1 where t2.customernum is not null;
and t1.sku = t3.sku;
and t3.customer is null;
select user_id from users;
select user_id from users where user_id not in ();
select user_id from users where user_id not in (null);
select user_id from users where user_id in (1001, 1002, 1003) and user_id not in (select user_id from users where user_id in (null));
select id from user where id in (null);
select * from users where name in ();
select * from users where 1 = 2;
select * from users where name not in ();
select * from users where 1 = 1;
select * from users where (name in () or name = 'alice');
select * from users where (1 = 2 or name = 'alice');
if (empty($arr)) { select user where id in (0);
if (!empty($arr)) {;
select user from tbl1 where id in (select id from tbl1 where false);
and column in ($values);
username,password from    ( delete table1 deleted.password where username = 'x' and password = 'x';
delete sourcetable where <conditions (if any)>;
select * into  event_log_temp from event_log;
delete from event_log;
delete from [source];
delete from table1 as a, table2 as b where (a.conditions) and  (a.id = b.id);
delete from source_table where id = 1 ) select * from deleted_rows;
postgres(# delete from test1 where id = 1;
create table tbl_part1 val varchar(10) null, partitioncolumn  varchar(10) constraint ck_part1 check(partitioncolumn = 'tbl_part1'), constraint tbl_part1_pk primary key(partitioncolumn, id) create table tbl_part2 val varchar(10) null, partitioncolumn  varchar(10) constraint ck_part2 check(partitioncolumn = 'tbl_part2'), constraint tbl_part2_pk  primary key(partitioncolumn, id) create view tbl(id, val, partitioncolumn) as select id, val, partitioncolumn from dbo.tbl_part1 union all select id, val, partitioncolumn from dbo.tbl_part2;
select * from tbl_part1 update tbl set partitioncolumn = 'tbl_part2';
select * from tbl_part2;
delete from table1 where criteria;
select <columns> from table1 where <condition>;
delete from table1 where <condition>;
and exists <in table2>;
select * into tbl_newtablename from tbl_oldtablename where condition1=@condition1value;
delete from tbl_oldtablename where condition1=@condition1value;
select username,password from table1 where username='x' and password='x';
delete from table1 where username='x' and password='x';
delete from tbl_oldtablename where id in (select id from tbl_newtablename);
select right(db_name(), charindex('_', reverse(db_name()) + '_') - 1);
select left(db_name(), len(db_name()) - charindex('_', reverse(db_name()) + '_'));
set @string='c:\program files\microsoft sql server\mssql\data\adventureworks_data.mdf' as (select *,row_number() over (order by (select null)) as rownum from [dbo].[splitstrings_numbers](@string,'\') ) select top 1 item from cte order by rownum desc;
create function dbo.lastindexof(@source text, @pattern char) as begin select into @ret charindex(@pattern, reverse(@source), 1) - 1));
select instr(foo.filepath, '/',1, length(foo.filepath) - length( replace( foo.filepath, '/',  ''))) as indexoflastslash from foo;
select instr(foo.filepath, '/',1, length( replace( foo.filepath, '/',  'xx')) - length(foo.filepath))  as indexoflastslash from foo;
if object_id('instr', 'fn') is not null drop function instr create function instr (@str varchar(8000), @substr varchar(255), @start int, @occurrence int) as begin @pos int = @start;
set @pos = charindex(@substr, @str, @pos);
if @pos is null or @pos = 0 if @found = 1 set @found = @found - 1;
set @pos = @pos + 1;
select len(foo.filepath) - charindex('\', reverse(foo.filepath))+1 as lastindexofslash from foo;
create function dbo.lastindexof(@source nvarchar(80), @pattern char);
create function dbo.stringbeforelastindex(@source nvarchar(80), @pattern char) set @lastindex = (len(@source)) -  charindex(@pattern, reverse(@source));
create function dbo.lastindexof(@text ntext, @delimiter ntext) as begin if (@text is null) return null;
if (@delimiter is null) return null;
if (@index < 1) return 0;
drop table #temp create table #temp ( id int identity(1,1) not null, value varchar(100) not null ) set @id=(select max(id) from #temp) select @results = coalesce(@results + ',', '') +  convert(varchar(12),value) from #temp where id<@id;
select *, user.id as user_id from ...;
select news.id as news_id, user.id as user_id ....;
select news.id, news.title, news.author, news.posted, users.id, users.name, users.registered from news users;
select *, w.site_name as wo_site_name from ws_work_orders w join ws_inspections i where w.hma_num not in(select hma_number from ws_inspections) order by cast(w.hma_num as unsigned);
select student_id as fees_link, student_class as class_link from students_fee_tbl;
select student_id, student_class from students_fee_tbl;
create view view_news as select news.id news_id, user.id user_id, user.name user_name, [ other fields ] from news, users where news.user_id = user.id;
select table1.* , table2.* , table3.* from table1 left join table2 on table1.dup = table2.dup left join table3 on table2.dup = table3.dup;
select table3.* , table2.* , table1.* from table1 left join table2 on table1.dup = table2.dup left join table3 on table2.dup = table3.dup;
from django.db.models import func price_isnull=isnull('price_isnull'), ).order_by( 'price_isnull', '-price', );
from my_project.utils.django import f;
from django.db.models import f as djangof from django.db.models.expression import orderby as djangoorderby if self.nulls_last is not none: 'ordering': ordering_value, };
from django.db.models import f;
company=company).order_by('-date_due');
from django.db import models, connections to utilize postgresql feature of setting position of null records if using is none and connection is none: if using: from django.db.models.sql.compiler import sqlcompiler if self.connection.vendor == 'postgresql' and result:;
from django.db import connections, models from django.db.models.sql.compiler import sqlcompiler if result and self.connection.vendor == 'postgresql': if using is none and connection is none: if using:;
from django.db.models import coalesce, value;
from mytable where <various conditions> limit 1) union all  from mytable where <various conditions> limit 1);
select <some columns> from mytable where <various conditions> limit 1;
select <some columns> from mytable where <various conditions> limit 1;
select <some columns>, row_number() over (order by date desc) as first_row, /*it's logical required to be the same as major query*/ from mytable where <various conditions> select <some columns> from scan_plan where scan_plan.first_row = 1 or scan_plan.last_row = 1;
select min(column), max(column), userid from table_name where (conditions) userid desc;
select max(column) from tablename where (filter) union all  select min(column) from tablename as tablename1 where (filter) column;
create or replace function public.first_agg ( anyelement, anyelement ) select $1;
create aggregate public.first ( sfunc    = public.first_agg, basetype = anyelement, stype    = anyelement create or replace function public.last_agg ( anyelement, anyelement ) select $2;
create aggregate public.last ( sfunc    = public.last_agg, basetype = anyelement, stype    = anyelement;
select * from {table_name} where {x_column_name}=( select d.{x_column_name} from ( select rownum as rno,{x_column_name} from {table_name})d where d.rno=( select count(*) from {table_name}));
select <rows> from table_name where rowid=(select min(rowid) from table_name) union select <rows> from table_name where rowid=(select max(rowid) from table_name);
select * from table_name where rowid=(select min(rowid) from table_name) or rowid=(select max(rowid) from table_name);
select <some columns> from ( select <some columns>, row_number() over (order by date desc) as rn, count(*) over () as total_count from mytable where <various conditions> where rn = 1 or rn = total_count;
select * from `aboutus` order by id desc limit 1;
select * from `aboutus` order by id asc limit 1;
select top 1 * from viewattendencereport where employeeid = 4 and attendencedate >='1/18/2020 00:00:00' and attendencedate <='1/18/2020 23:59:59' union select top 1 * from viewattendencereport where employeeid = 4 and attendencedate >='1/18/2020 00:00:00' and attendencedate <='1/18/2020 23:59:59';
select <some columns> from mytable where date >= (select date from mytable) or date <= (select date from mytable);
select first_value(timestamp) over (order by timestamp asc) as created_dt, last_value(timestamp) over (order by timestamp asc) as last_update_dt, last_value(action) over (order by timestamp asc) as last_action from events;
select distinct order_id, first_value(timestamp) over (partition by order_id order by timestamp asc) as created_dt, last_value(timestamp) over (partition by order_id order by timestamp asc) as last_update_dt, last_value(action) over (partition by order_id order by timestamp asc) as last_action from events as x;
select * from table where locate('rid ', fieldtosearch) > 0 or locate(' rid', fieldtosearch) > 0;
select * from table where keywords regexp '^rid[ $]' or keywords regexp ' rid[ $]';
select * from table where keywords regexp '[^ ]rid[ $]';
select * from table where keywords regexp '[[:<:]]rid[[:>:]]';
select * from table where keywords regexp '\\brid\\b';
select * from table where keywords regexp '[[:<:]]rid[[:>:]]';
select * from table where keywords regexp '([[:blank:][:punct:]]|^)rid([[:blank:][:punct:]]|$)';
where end-date is null;
select * from mytable where name = 'bob';
select * from mytable where name != 'bob';
select * from mytable where name is null;
select inet_aton('127.0.0.1');
select inet_ntoa('2130706433');
select 1 from pg_constraint where conname = 'constraint_name'";
create or replace function create_constraint_if_not_exists ( t_name text, c_name text, constraint_sql text ) if not exists (select constraint_name from information_schema.constraint_column_usage where table_name = t_name  and constraint_name = c_name) then end if;
select create_constraint_if_not_exists( 'foo', 'bar', 'alter table foo add constraint bar check (foobies < 100);');
alter table foo drop constraint if exists bar;
alter table foo add constraint bar ...;
alter table foo drop constraint if exists bar;
alter table foo add constraint bar ...;
alter table foo add constraint bar ... ;
if not exists ( select  constraint_schema from    information_schema.check_constraints where   constraint_schema = 'myschema' and   constraint_name = 'myconstraintname' ) then alter table myschema.mytable add constraint myconstraintname check (column <= 100);
if not exists (select constraint_name from information_schema.table_constraints where table_schema='schame_name' and upper(table_name) = then  alter table table_name add constraint contraint_name..... ;
else raise notice 'constraint contraint_name already exists in table table_name';
select table1.col1, table1.col2, table1.col3, table2.col4 from table1 inner join;
select table1.col1, table1.col2, table1.col3, table2.col4 from table1 inner join;
select table1.col1, table1.col2, table1.col3, table2.col4 from table1 and isnull(table1.col2, 'zzzz') = isnull(table2.col2,'zzzz');
select table1.col1, table1.col2, table1.col3, table2.col4 from table1 inner join table2 on table1.col1 = table2.col1 and ((table1.col2 = table2.col2) or (table1.col2 is null and table2.col2 is null));
select * from tablea a join tableb b on isnull(a.colid,'') = isnull(b.colid,'');
select table1.col1, table1.col2, table1.col3, table2.col4 from table1 left outer join and table1.col2 = table2.col2;
select table1.col1, table1.col2, table1.col3, table2.col4 from table1 or (table1.col1 is null and table2.col1 is null) );
select * from t1 where not id in (select distinct t2.id from t2);
select firstname as first_name from table1;
select firstname as first_name from table1;
select firstname as first_name from table1;
select firstname as first_name, lastname as last_name, coalesce(contactphoneareacode1, contactphonenumber1) as contact_phone from table1;
select firstname , lastname , if(firstname is null and lastname is null, null,' _ ',concat(coalesce(firstname ,''), coalesce(lastname ,''))) as contact_phone from   table1;
from yourapp import settings from yourapp import models if (ext == '.csv'): if conn is not none:;
create temp table tmp_x (id int, apple text, banana text); -- but see below update tbl set    banana = tmp_x.banana from   tmp_x where  tbl.id = tmp_x.id;
drop table tmp_x; -- else it is dropped at end of session automatically;
create temp table tmp_x as select * from tbl limit 0;
create temp table ...;
set temp_buffers = '500mb';  -- example value;
create index tmp_x_id_idx on tmp_x(id);
set @sqcur = cursor local static read_only for select row_number() over (order by(select null)) as rownum from yourinttable set @i += 1 end end try end catch;
select table1.id, isnull((select 'true' from table2 where table2.id = tabel1.id),'false') as columname, etc from table1;
select tabel1.id, case when exists (select id from table2 where table2.id = table1.id) then 'true' else 'false' end as newfiled from table1;
select tabel1.id, case when table2.id is not null then 'true' else 'false' end as newfiled from table1;
select t1.id [id] from table1 [t1];
select id, 'true' as newfiled from tabel1 select id, 'true' as newfiled from tabel2 union select id, 'false' as newfiled from tabel1 select id, 'false' as newfiled from tabel2;
select year(current_timestamp);
update table set column = year(date_column);
update t set column = year(t1.date_column) from table_source t1 join table_target t on (join condition) where ....;
create table users ( userid int,date_of_birth date ) select datediff(year,date_of_birth, getdate()) - (case when (dateadd(year, datediff(year,date_of_birth, getdate()),date_of_birth)) > getdate() then 1 else 0 end) as years, month(getdate() - (dateadd(year, datediff(year, date_of_birth, getdate()), date_of_birth))) - 1 as months, day(getdate() - (dateadd(year, datediff(year,date_of_birth, getdate()), date_of_birth))) - 1 as days, from users;
select * from mytable where year(transaction_day)='2013';
set @idate=getdate();
select year(date_column) from table_name;
select  col1 from    table2;
( portfolio_id , building_id , created_date , last_modified_date ) select 34, building_id, getdate(), null from #temp_buildings;
( portfolio_id , building_id , created_date , last_modified_date ) select 34, building_id, getdate(), null from #temp_buildings;
( portfolio_id , building_id , created_date , last_modified_date ) select 34 , building_id, getdate(), null from    #temp_buildings;
select name, 'unpaid' as status from table;
select [ all | distinct ];
select * from ... limit 5 offset 10;
select * from friend f where not exists ( select 1 from likes l where f.id1 = l.id and f.id2 = l.id2 );
select * from   friend f where  l.id1 is null;
select * from table1 t1 where concat(t1.first_name,t1.last_name) not in (select concat(t2.first_name,t2.last_name) from table2 t2);
set sql_notes = 0;      -- temporarily disable the "table already exists" warning create table if not exists ... set sql_notes = 1;      -- and then re-enable the warning again;
drop database test;
create database if not exists `test`;
set @old_foreign_key_checks=@@foreign_key_checks, foreign_key_checks=0;
create table if not exists `tblsample` (  `recid` int(11) not null default '0', `cvfilename` varchar(250)  not null default '', `cvpagenumber`  int(11) null, `cilineno` int(11)  null, `batchname`  varchar(100) not null default '', `type` varchar(20) not null default '', `data` varchar(100) not null default '', primary key  (`id`);
create database if not exists `test`;
set @old_foreign_key_checks=@@foreign_key_checks, foreign_key_checks=0;
`id` int(11) not null auto_increment, `recid` int(11) not null default '0', `cvfilename` varchar(250)  not null default '', `cvpagenumber`  int(11) null, `cilineno` int(11)  null, `batchname`  varchar(100) not null default '', `type` varchar(20) not null default '', `data` varchar(100) not null default '', primary key  (`id`);
create table "tbl" ("id" number not null)';
if sqlcode = -955 then null; else raise; end if;
select * from xyz where deleted_at is null;
select all pages where is_deleted = 1;
select all pages where pages;
set identity_insert exampletable on create table #identitycheck (id int identity(1,1)) set identity_insert #identitycheck on drop table #identitycheck end try set @tablewithidentity= @msg;
set @tablewithidentity = set @tablewithidentity = substring(@tablewithidentity,1, charindex('''',@tablewithidentity,1)-1) drop table #identitycheck end catch if @tablewithidentity<>'' end else begin end;
exec dbo.getidentityinsert 'yourdb', 'yourschema', 'yourtable', @identityinsert out select @identityinsert;
create procedure dbo.getidentityinsert as  set nocount on set @dbschematable = @dbname + '.' + @schemaname + '.' + @table set @object_id = object_id(@dbschematable) if @object_id is null end  set @object_id = object_id(@dbschematable) if objectproperty(@object_id,'tablehasidentity') = 0 set @identityinsert = 'no_identity' end else begin create table #getidentityinsert(id int identity) set identity_insert #getidentityinsert on set identity_insert #getidentityinsert off drop table #getidentityinsert set @identityinsert = 'off' end end try select @errormessage = error_message(), @errorseverity = error_severity(), @errorstate = error_state(), @errornumber = error_number();
if @errornumber = 8107  --identity_insert is already set on a table set @othertable = substring(@errormessage, charindex(char(39), @errormessage)+1, 2000) set @othertable = substring(@othertable, 1, charindex(char(39), @othertable)-1) if @othertable = @dbschematable set @identityinsert = 'on' end else begin set @identityinsert =  'off' end end else begin end  end catch select [identity_insert] = @identityinsert end go;
set identity_insert;
if  set @i = 1 --sql wants something to happen in the "if" side of an if/else end  else --you definitely have identity_insert on.  done as else instead of the other way around so that if there is no inserted table, it will run anyway end;
select is_identity from sys.columns where object_id = object_id('mytable', 'u') and name = 'column_name';
if exists (select * from sys.columns where object_id = object_id('mytable', 'u') and is_identity = 1) else ... code that should not run with identity insert;
set @cmd = cast((select 'set identity_insert ' + from sys.columns c join sys.tables t on t.object_id = c.object_id where c.is_identity = 1 exec sp_executesql @cmd;
set @mytablename = 'testtable' select case objectproperty(object_id(@mytablename), 'tablehasidentity') else 'no identity columns' end as hasidentity;
end try set identity_insert table off;
set identity_insert ... off;
set identity_insert ... off;
select objectproperty(object_id('mytable'), 'tablehasidentity');
select case objectproperty(object_id('mytable'), 'tablehasidentity');
select * from sys.columns where object_id = object_id('mytable', 'u') and name = 'mytableidentitycolumnname';
select  stock.idstock from    [inventory].[dbo].[stock] stock where   (case when stock.idstock in;
select foreignstockid from   [subset].[dbo].[products];
select stock.idstock, stock.descr from   [inventory].[dbo].[stock] stock where  stock.idstock not in (select foreignstockid from   [subset].[dbo].[products] where  foreignstockid is not null);
select stock.idstock, stock.descr from   [inventory].[dbo].[stock] stock where  not exists (select * from   [subset].[dbo].[products] p where  p.foreignstockid = stock.idstock);
where employees.getrange(i, count).contains(address.employeeid) select address).tolist();
select id from x where id in (1, 2, ..., 1000,,1500);
select id from x where id in (1, 2, ..., 999) or id in (1000,...,1500);
select id from x where (x.id, 0) in ((1, 0), (2, 0), (3, 0),.....(n, 0));
select id from x where id in (select id from <temporary-table>);
select field1, field2, field3 from table1 where  name in ('value1', 'value2', ..., 'value999') or name in ('value1000', ..., 'value1999') or ...;
select col1, col2, col3... from table1 where id in (select id from table2 where conditions...);
create or replace type type_table_of_varchar2 as table of varchar(100);
select field1, field2, field3 from table1 where name in ( select * from table (select cast(? as type_table_of_varchar2) from dual);
select field1, field2, field3 from table1 where (1, name) in ((1, value1), (1, value2), (1, value3),.....(1, value5000));
select * from tablea where tablea.field1 in (1,2,...999) union select * from tablea where tablea.field1 in (1000,1001,...1999) union select * from tablea where tablea.field1 in (2000,2001,...2999);
select 'value1' name from dual union all select 'value2' name from dual union all ... select 'value10000+' name from dual) select field1, field2, field3 from table1 t1;
select item_id, token from item_subs where (item_id, 0) in ((:item_id_0, 0)...(:item_id_n, 0));
select cus_id, token from cus_subs where (cus_id, 0) in ((:cus_id_0, 0)...(:cus_id_n, 0));
select :item_id_0 item_id, :cus_id_0 cus_id union all ... select :item_id_n item_id, :cus_id_n cus_id ) select i.item_id item_id, i.token token from item_subs i union all select d.item_id item_id, c.token token from cus_subs c;
select * from tablea where id = 1 or id = 2 or id = 3 ...;
if (start > end) {;
update table_a set column_a_1 = (select table_b.column_b_1 from table_b where table_b.user_name = table_a.user_name ) from table_b where table_b.user_name = table_a.user_name ) where exists ( select * from table_b where table_b.user_name = table_a.user_name );
( select song_id, artist_id from online_performance ) update record_performance set op_song_id=(select song_id from a), op_artist_id=(select artist_id from a);
update table_a set (column_a_1, column_a_2) = (select table_b.column_b_1, table_b.column_b_2 from table_b where table_b.user_name = table_a.user_name ) where exists ( select * from table_b where table_b.user_name = table_a.user_name );
update table_a set column_a_1 = table_b.column_b_1 from table_b where table_b.user_name = table_a.user_name;
update table_a set (column_a_1, column_a_2) = (table_b.column_b_1, table_b.column_b_2) from table_b where table_b.user_name = table_a.user_name;
if ( !empty($r) ){;
select from database2..mytable;
select * into anotherdatabase..copyoftable from onedatabase..tablename;
( [folderstatusid], [code], [title], [last_modified] ) select [folderstatusid], [code], [title], [last_modified] from dbo.twodatabase.f_file_stat;
create table test ( blah text create index test_blah_txtpat_idx on test(blah text_pattern_ops);
set regress=# explain select 1 from test where blah ~ '12.*';
index cond: ((blah ~>=~ '12'::text) and (blah ~<~ '13'::text)) index cond: ((blah ~>=~ '12'::text) and (blah ~<~ '13'::text));
create table tbl(string text);
select x::text from generate_series(1, 10000) x;
create index tbl_string_text_pattern_idx on tbl(string text_pattern_ops);
select * from tbl where string ~ '^1234';  -- left anchored pattern;
select sum(cash) as money from table t1, table2 t2 where t1.branch = t2.branch and t1.transid = t2.transid and valuedate > @startmonthdate having money > 0;
case when boolean_expression then result_expression [ ...n ] end;
select sum(case else 0 from table a where a.branch = p.branch and a.transid = p.transid;
where id_campo not in (@idcamposexcluidos);
where id_campo not in ('817,803,495');
where id_campo not in ('817','803','495');
set @idcamposexcluidos='817,803,495';
where find_in_set(id_campo, @idcamposexcluidos) = 0;
set @idcamposexcluidos = '|817|803|495|';
select * from your_table where @idcamposexcluidos not like concat('%|', id_campo, '|%');
create type lista as ( clave int4, valor int4 create or replace function test(in varray lista[]) where find_in_set(id_campo, varray);
where id_campo in ( select 817 as valor union all select 803 as valor union all select 495 as valor);
case when expression1 is not null then expression1 else expression2 end;
from demo where somecol = 1 ), 1 );
select case then (select nullable from demo where somecol = 1) else 1 end;
select @value2 = 2, @value4 = 4 select coalesce(@value1, @value2, @value3, @value4) select coalesce(@value1, @value4, @value3, @value2);
select * from sometable where isnull(somenullablebitfield, -1) != isnull(someothernullablebitfield, -1);
select * from sometable where coalesce(somenullablebitfield, -1) != coalesce(someothernullablebitfield, -1);
( select convert(bit, 1) as biton, convert(bit, 0) as bitoff, convert(bit, null) as bitnull ) select biton, bitoff, bitnull, isnull(biton, -1) isnullbiton,         -- true from input;
select isnull(@x, @y) ---> output is '123' select coalesce(@x, @y) ---> output is '123456789';
select case ("column_name") end from "table_name";
select countryname = isnull("columnname", 'india') from countries;
select 'coalesce', coalesce(@c5, 'longer name') union all select 'isnull',   isnull(@c5,   'longer name');
select isnull(@x, @y) as [isnull], coalesce(@x, @y) as [coalesce];
select isnull(@x, @y) as [isnull];
select coalesce(@x, @y) as [coalesce];
drop table if exists [dbo].[datasource01];
select isnull(10, 20) as [c1] drop table if exists [dbo].[datasource02];
select coalesce(10, 20) as [c1];
case when (<subquery>) is not null then (<subquery>) else 0 end;
values (1000,n'test'),(1001,n'test2');
values (1000,n'test') values (1001,n'test2');
select 1000, n'test' union all select 1001, n'test2';
select 'first' ,1 union all select 'second' ,2 union all select 'third' ,3 union all select 'fourth' ,4 union all select 'fifth' ,5;
select value1 ,value2 union all select value1 ,value2 union all select value1 ,value2 union all select value1 ,value2 union all select value1 ,value2;
batchfilexml    xml, responsefilexml xml, processeddate   date, rowversion      binary(8) ) update batchreports set    isprocessed = 1 inserted.responsefilexml, deleted.processeddate, inserted.timestamp where  batchreports.batchreportguid = @someguid select * from   @t;
update batchreports set isprocessed = 1 where batchreports.batchreportguid = @someguid;
select batchfilexml, responsefilexml, processeddate from batchreports where batchreports.batchreportguid = @someguid update batchreports set isprocessed = 1 where batchreports.batchreportguid = @someguid;
update batchreports set isprocessed = 1 where batchreports.batchreportguid = @someguid;
lastmodifieddate datetime, rowversion timestamp, batchreportid int ) update batchreports set isprocessed = 1 where batchreports.batchreportguid = @someguid select * from @t;
lastmodifieddate datetime, rowversion binary(8), batchreportid int ) update batchreports set isprocessed = 1 where batchreports.batchreportguid = @someguid select * from @t;
update [dbo].[batchreports] set [isprocessed] = @0 where (([batchreportguid] = @1) and ([rowversion] = @2)) select [rowversion], [lastmodifieddate] from [dbo].[batchreports] where @@rowcount > 0 and [batchreportguid] = @1;
values ('steve', 'brown') select t.[customerid], t.[customerguid], t.[rowversion], t.[createddate] from @generated_keys as g where @@rowcount > 0;
update batchreports set where batchreports.batchreportguid = @someguid;
select b.* from @t t join batchreports b on t.id = b.id;
delete from tablename if exists (select * from sys.identity_columns where object_name(object_id) = 'tablename' and last_value is not null);
end else begin exec (@sql);
if exists (select * from tablename) delete from  tablename end;
from sys.identity_columns ic case when @reseedbit = 0 then 1 end ;
if @last_value is null end else begin end;
select *, count(*) as noofoccurrences from tablename group by * having count(*) > 1;
set @num = 1 set @fields = '' select 'seq' = identity(int,1,1) , column_name from req.information_schema.columns where table_name = n'new340b' set @fields = @fields + ',' + (select column_name from #field_list where seq = @num) set @num = @num + 1 end  set @fields = right(@fields,len(@fields)-1);
select * from table;
select * from table group by *;
select distinct * from @t;
select distinct * from myfootable;
select * from myfootable group by *;
select * from myfootable group by id, value;
select distinct * from myfootable;
( select sum(intfield) as total from table ) select *, a.total from table t;
set global innodb_strict_mode=on;
alter table `table` row_format=dynamic;
set global innodb_strict_mode = 0;
set global innodb_file_format=barracuda;
set global innodb_file_per_table=on;
select t.id, t.count, (select sum(x.count) from table x where x.id <= t.id) as cumulative_sum from table t;
select t.id, t.count, @running_total := @running_total + t.count as cumulative_sum from table t join (select @running_total := 0) r;
join (select @running_total := 0) r;
update t set cumulative_sum = ( select sum(x.count) from t x where x.id <= t.id );
create trigger calcumluativesum  before insert on sometable set cumulative_sum = ( select sum(x.count) from sometable x where x.id <= new.id ) set  new.cumulative_sum = cumulative_sum;
update yourtable set cumulative_sum = (@csum := @csum + count);
select id, count, (@csum := @csum + count) as cumulative_sum from yourtable;
select q1.d, q1.c, (@runtot := @runtot + q1.c) as rt from (select count(*) as c from  orders where  haspaid > 0;
select id, count, @total := @total + count as cumulative_sum from yourtable, (select @total := 0) as total ;
select t1.id, t1.count, sum(t2.count) cumulative_sum from table t1 join table t2 on t1.id >= t2.id;
select * from table t1;
select * from table t1 join table t2 on t1.id >= t2.id;
select t1.id, t1.count, sum(t2.count) cumulative_sum from table t1 join table t2 on t1.id >= t2.id;
select *, sum(cnt) over(order by id) as cumulative_sum from tab;
select [externalid] from [equipmentserialsmaster] where lower('0'+[externalid]) collate latin1_general_cs_as != '0'+[externalid];
select * from table where upper(column) != binary(column);
select * from mytable where binary(columnx) regexp '^[a-z]';
select * from yourtable where binary_checksum(lower(columnname)) = binary_checksum(columnname);
select * from your_table where col_a '[a-z]';
select * from tablename where tablecolumnname like '%[a-z]%';
select * from test where col1 like '%[abcdefghijklmnopqrstuvwxyz]%';
select * from yourtable where upper([column_name]) collate latin1_general_cs_as !=[column_name];
select * from mytable where columnx regexp '^[a-z]';
select * from my_table where upper(some_field) != some_field;
select column1 from table1 where column1 collate latin1_general_cs_as = 'casesearch';
alter table table1 alter column column1 varchar(20);
exec sp_help databasename;
select * from my_table where my_column = 'my string';
select emp_cd, val1, val2, val3, sum(val1 + val2 + val3) as total from emp;
select (coalesce(sum(val1),0) + coalesce(sum(val2), 0) from emp;
select  (isnull(val1,0) + isnull(val2,0) + isnull(val3,0)) as 'total' from emp;
select val1, val2, val3, total = val1 + val2 + val3 from dbo.emp;
update dbo.emp set total = val1 + val2 + val3;
alter table dbo.emp add currenttotal as val1 + val2 + val3 persisted;
select val1, val2, val3, currenttotal from dbo.emp;
select val1, val2, val3, (val1 + val2 + val3) as 'total' from emp;
select sum(val1) as 'val1', sum(val2) as 'val2', sum(val3) as 'val3', (sum(val1) + sum(val2) + sum(val3)) as 'total' from emp;
select sum(num_tax_amount+num_total_amount) from table_name;
select emp_cd, val1, val2, val3, (val1+val2+val3) as total from emp;
(val1+val2+val3) as total from emp;
update emp set total = val1+val2+val3;
select column1, column2 from table1 where column3 in ( select top(1) from table2 ) select column1, column2 from table1 where column3 in ( select top(1) from table2 );
select column1, column2 from table where column3 in ( select top(1) column4 from table2 );
select column1, column2 from table1 where column3 in ( select top(1) from table2 table3 );
select column1 from table1 where column3 in ( select top(1) column4 from table2 );
select sdcolumn123 from table1 where column3 in ( ... ) select sdcolumn123, dscolumn234, asdcolumn345, dscolumn456, ascolumn554, gfcolumn645 sdcolumn754, fdcolumn845, sdcolumn954, fdcolumn1054 from table1 where column3 in ( ... );
from table1 where column3 in (select top(1) column4 from table2 inner join;
select column1, column2 from   table1 where  column3 in(select     top(1) column4 from       table2 );
select column1, column2 from table1 where column3 in (select top(1) from table2;
select column1, column2 from table1 where column3 in (select top(1) column4 from table2;
select column1, column2 from table1 where column3 in ( select top(1) column4 from table2 );
select column1, column2 from table1 where column3 in (select column4 from table2 join table3;
select column1 from table1 where column3 in ( select top(1) column4 from table2 );
select column1 from table1 where column3 in ( select top(1) column4 from table2 );
select  column1, column2 from    table1 where   column3 in ( select top(1) column4 from    table2 );
select column1, column2 from table1 where column3 in ( select column4 from table2 join table3 on );
select column1, column2 from table1 join table2 on join table3 on;
select column1, column2 from table1 t1 where column3 in (select top(1) column4 from table2 t2 join table3 t3;
select column1, column2 from table1 t1 where column3 in from table2 t2 join table3 t3;
select column1, column2, col3, col4, column5, column6, column7, isnull(column8, 'fedex') shipper, case upper(column9) from table1 t1 where column3 in from table2 t2 join table3 t3;
select column1, column2 from table1, table2 where table1.column1 = table2.column4 and table1.col5    = "hi" or table2.myfield = 678;
select column1, column2 from table1 where column3 in ( select top(1) from table2 );
select column1, column2, function1 ( column1, column2 case when column1 = 1 then else b end as case1 from table1 t1 where ( filterclause1 and filterclause2 ) or ( filterclause3 and filterclause4 );
select column1, column2 from table1 where column3 in ( select top(1) column4 from table2 );
select produtos_cesta.cod_produtos_cesta, produtos.nome_pequeno, tab_contagem.cont, produtos_cesta.sku, produtos_kits.sku_r as sku_kit, sku_final = case else produtos_cesta.sku estoque = case else produtos.estoque produtos_cesta.unidades as unidades1, unidades_x_quantidade = case else cast(produtos_cesta.quantidade * produtos_cesta.unidades as int) unidades = case else produtos_cesta.unidades unidades_parent = produtos_cesta.unidades, produtos_cesta.quantidade, produtos.controla_estoque, produtos.status from produtos_cesta select produtos_cesta.cod_produtos_cesta, cont = sum( case when produtos_kits.quantidade is not null then produtos_kits.quantidade else 1 end ) from produtos_cesta where shopper_id = '" + mscsshopperid + @"' produtos_cesta.cod_produtos_cesta, produtos_cesta.sku, produtos_cesta.unidades ) as tab_contagem where shopper_id = '" + mscsshopperid + @"' produtos_cesta.cod_produtos_cesta, tab_contagem.cont, produtos_cesta.sku, produtos_kits.sku_r, produtos.cod_produtos_kits_tipo, produtos2.estoque, produtos.controla_estoque, produtos.estoque, produtos.status, produtos.nome_pequeno, produtos_cesta.unidades, produtos_cesta.quantidade, produtos_kits.quantidade produtos_cesta.sku, produtos_cesta.unidades desc;
select column1, column2 from table1 where column3 in ( select top (1) from table2 table3 );
select column1, column2 from table1 where column3 in ( select top(1) from table2 inner join );
select column1, column2 from table1 join where condition1=xxx and ( condition3=aaa or );
select column1, column2 from table1 where (column3 in ( select top(1) column4 from table2;
create table item_config (item_id int, colour varchar, size varchar, fabric varchar);
select itemkey,itemvalue from key_value_pairs where itemid='123';
select itemvalue from key_value_pairs where itemid='123' and itemkey='fabric';
create table valid_keys ( id            number(10) not null, description   varchar(32) not null, constraint pk_valid_keys primary key(id) create table item_values ( item_id number(10) not null, key_id  number(10) not null, item_value varchar2(32) not null, constraint pk_item_values primary key(item_id), constraint fk_item_values_iv foreign key (key_id) references valid_keys (id);
select * from contenttype;
drop table if exists contenttype;
drop table if exists `tablename` ;
create table `tablename` ...;
drop database `having_issues`;
create database  if not exists `issga` /*!40100 default character set utf8 */;
drop table if exists protocolo;
create table protocolo ( `idprotocolo` int(11) not null auto_increment, `tipo` varchar(30) default null, `estado` int(2) default 0, primary key (`idprotocolo`);
drop if exists ...;
table already exists;
drop view `my-view-that-has-same-name-as-table`;
drop table if exists;
drop table if exists `my_table`;
create table `my_table` ( ...;
drop table if exists `my_table`; drop view if exists `my_table`;
create table `my_table` ( ...;
update foo set sync = ~@isnew;
select b, 1 - b from (select cast(1 as bit) as b union all select cast(0 as bit) as b) sampletable;
select dateadd(day, datediff(day, 0, getdate()), 0);
select  dateadd(year, datediff(year, 0, getdate()), 0) select  dateadd(quarter, datediff(quarter, 0, getdate()), 0) select  dateadd(month, datediff(month, 0, getdate()), 0) select  dateadd(day, datediff(day, 0, getdate()), 0) select  dateadd(hour, datediff(hour, 0, getdate()), 0) select  dateadd(second, datediff(second, '20000101', getdate()), '20000101');
select cast(floor(cast(@datetime as float)) as datetime);
select convert(varchar(10), getdate(), 120);
select convert(datetime, convert(varchar(10), getdate(), 120) , 120);
select top 1000000 crets from tblmeasurelogv2 select top 1000000 cast(floor(cast(crets as float)) as datetime) from tblmeasurelogv2 select top 1000000 convert(datetime, convert(varchar(10), crets, 120) , 120) from tblmeasurelogv2 select top 1000000 dateadd(day, datediff(day, 0, crets), 0) from tblmeasurelogv2;
select cast(getdate()as varchar(11))as datetime;
select cast(cast(getdate() as int) as datetime);
select cast(getdate() as date);
select id, @rank:=@rank+1 from tbl order by id;
update tbl a join (select id, @rank:=@rank+1 as rank from tbl order by id) b;
select min(id) as next_id from ((select a.id from (select 1 as id) a where b.id is null)) c;
alter table tbl auto_increment = 16;
select a.name, a.amount, b.rank from cust a, (select amount, @rank:=@rank+1 as rank from cust order by amount desc) b where a.amount = b.amount;
alter table foo auto_increment=1;
select count(*) from course;
delete from table;
alter table table auto_increment = 1;
else if($id>1 && $id<$num){ // deleting middle row else if($id == $num){ // deleting last row;
alter table table_name drop column_name;
alter table table_name add column_name int not null auto_increment primary key first;
alter table my_table add `id` int not null auto_increment first, add primary key (`id`);
if (myrs.next()) { if (!myrs.next()) {;
create table new_table_name  select * from existing_table_name;
delete from new_table_name;
if (!(test-path $sqlpsreg -erroraction "silentlycontinue")) "microsoft.sqlserver.smo", "microsoft.sqlserver.smoextended", "microsoft.sqlserver.dmf", "microsoft.sqlserver.wmienum", "microsoft.sqlserver.sqlwmimanagement", "microsoft.sqlserver.connectioninfo ", "microsoft.sqlserver.management.registeredservers", "microsoft.sqlserver.management.sdk.sfc", "microsoft.sqlserver.sqlenum", "microsoft.sqlserver.regsvrenum", "microsoft.sqlserver.servicebrokerenum", "microsoft.sqlserver.connectioninfoextended", "microsoft.sqlserver.management.collector", "microsoft.sqlserver.management.collectorenum" ) if ($assembly -eq $null) if ((get-pssnapin -name sqlserverprovidersnapin100 -erroraction silentlycontinue) -eq $null);
create function;
select dbo.fcalculateestimatedate(647,default);
select dbo.fcalculateestimatedate(647);
alter function [dbo].[fcalculateestimatedate] (@vworkorderid numeric) select @result = [dbo].[fcalculateestimatedate_v2] (@vworkorderid,default) end  create function [dbo].[fcalculateestimatedate_v2] (@vworkorderid numeric,@todate datetime=null) end;
string.format("<doc>{0}</doc>", string.join("", array.select(function(s) string.concat("<d>", s.tostring(), "</d>")))), loadoptions.none) end function;
create database [testbeddb] create login [testbeduser] with password=n'? create user [testbeduser] for login [testbeduser] with default_schema=[dbo] exec sp_addrolemember n'db_owner', n'testbeduser' create table dbo.table1 ( t1id int not null primary key );
values (1), (2), (3), (4), (5), (6), (7), (8), (9), (10);
create type t1ids as table ( t1id int create procedure dbo.findmatchingrowsintable1( @table1ids as t1ids readonly ) as begin set nocount on;
select table1.t1id from dbo.table1 as table1 join @table1ids as paramtable1ids on table1.t1id = paramtable1ids.t1id;
typeof( int ) );
@"data source=.\sqlexpress;initial catalog=testbeddb;persist security info=true;user id=testbeduser;password=letmein12;connect timeout=5" );
testbedconnection );
sqldatareader[ "t1id" ] );
set @ids = '100,2,3,4,5' --parameter passed set @ids = ',' + @ids + ',' select   * from     tablename where    charindex(',' + cast(id as nvarchar(50)) + ',', @ids) > 0;
set @yourlistofids = '1,2,3,4,5,6,7,8' select * from yourtable where id in(select cast(value as int) from string_split(@yourlistofids, ','));
select @list = '1,2,3,4,5,6,7,8' 'delete from table where id not in (' + @list + ')' );
delete yourtable from yourtable                           d where s.value is null;
create table numbers constraint pk_numbers primary key clustered (number asc)with (pad_index  = off, statistics_norecompute  = off, ignore_dup_key = off, allow_row_locks  = on, allow_page_locks  = on) on [primary] set @x=0 set @x=@x+1 end;
create function [dbo].[fn_listtotable] ( @spliton              char(1)              --required, the character to split the @list string on ) ( listvalue varchar(500) ) as begin select * from dbo.fn_listtotable(',','1,12,123,1234,54321,6,a,*,|||,,,,b') select listvalue from (select from ( select @spliton + @list + @spliton as list2 where substring(list2, number, 1) = @spliton where listvalue is not null and listvalue!='' end --function fn_listtotable;
select col1, col2, col3... from  yourtable;
delete yourtable from yourtable                                d where s.listvalue is null;
create procedure [dbo].[deletealldata] ( @xmldoc xml ) as begin exec sp_xml_preparedocument @handle output, @xmldoc delete from where your_id_column not in ( select * from openxml (@handle, '/ids/id') with (id int '.') ) exec sp_xml_removedocument @handle;
create table #temp create proc myproc as begin delete yourtable from yourtable where s.id is null end;
select *,rownum from table;
select rownum,* from table;
select rownum, table.* from table;
alter table dbo.tablename add constraint df_tablename_columnname default '01/01/2000' for columnname;
alter table dbo.mytable add constraint my_con default getdate() for created update mytable set created = getdate() where created is null alter table dbo.mytable alter column created datetime not null;
update dbo.tablename set created="01/01/2000" where created is null;
{ vlookup(sheet1!a1:a, {sheet2!a1:a, sheet2!b1:c}, {2,3}, false) );
{ vlookup(sheet1!a1:a, {sheet2!c1:c, sheet2!a1:b}, {2,3}, false) );
if exists(select * from my_table where end;
if      exists ( select  my_field1, my_field2, my_field3, my_field4, my_field5, my_field6 from    my_table select  @in_my_field1, @in_my_field2, @in_my_field3, @in_my_field4, @in_my_field5, @in_my_field6 ) end;
if exists(select * from my_table where or (my_field1 is null and @in_my_field1 is null))  and or (my_field2 is null and @in_my_field2 is null))  and or (my_field3 is null and @in_my_field3 is null))  and or (my_field4 is null and @in_my_field4 is null))  and or (my_field5 is null and @in_my_field5 is null))  and or (my_field6 is null and @in_my_field6 is null))) end;
( ( -- neither is null, values are not equal and source.field1 is not null and target.field1 <> source.field1 ) or ( -- target is null but source is not and source.field1 is not null ) or ( -- source is null but target is not and source.field1 is null ) );
( -- neither is null, values are not equal not (target.field1 is null or source.field1 is null) and target.field1 <> source.field1 or (target.field1 is null or source.field1 is null) and not (target.field1 is null and source.field1 is null) );
(  nullif(target.field1, source.field1), nullif(source.field1, target.field1) );
not ((f1 is null and f2 is null) or (f1 is not null and f2 is not null and f1 = f2));
not ((f1 is null and f2 is null) or (f1 is not null and f2 is not null and f1 = f2));
delete * from table_name;
drop table_name create table table_name;
delete from table_name;
delete from tablename where id in (1,2) -- add as many id as you want.;
delete from tablename where id in ( 1, 2, 3, 4, 5, 6;
delete from tablename where id in (1,2);
delete from tablename where (id between 1 and 255) and (id not in (254));
delete from tablename where id in (1,2,3,...,254);
delete from tablename where id between 1 and 254;
delete from tablename where id between 1 and 254 and id<>10;
delete from tablename where id not in (5,124,221);
delete from tablename where id<254 and id>3;
delete from tablename where id in;
delete from tablename where <your-condition>;
delete from table_name where id between 1 and 256;
delete from tablename where tablename.id = any (select id from tablename where id = id);
select sum (case when totalhousm is null then 0 else totalhousm end) as total from leaverequest;
select sum(isnull(totalhoursm,0)) as total from leaverequest;
select sum(    isnull(totalhoursm  ,0) from leaverequest;
select sum(coalesce(totalhoursm,0));
delete from dd from ( select top 1 * from my_table;
delete from dd from ( select *, row = row_number() over (order by (select 1)) from my_table where row = 1;
delete field from table where field in (select top 1 field from table order by field desc);
( select top 1 * from    mytable ) delete from    q;
delete top (1) from   mytable;
select * from table;
( id int identity(1,1) not null primary key, data nvarchar(50) not null ) select 'hello' union select 'world' set rowcount 1 delete from @table set rowcount 0 select * from @table;
delete from table limit 1;
delete from table limit 1;
delete top(1) from table;
delete from table where rownum = 1;
select extract(epoch from now());
select unix_timestamp(now());
select unix_timestamp();
select round( date_part( 'epoch', now() ) );
select date_part('milliseconds', current_timestamp);
select extract(milliseconds from current_timestamp);
select curtime(4);
select (unix_timestamp(now()) * 1000000 + microsecond(now(6))) as unix_now_in_microseconds;
select conv( concat( substring(uid,16,3), substring(uid,10,4), substring(uid,1,8)) from (select uuid() uid) as alias;
select (unix_timestamp(now(3)) * 1000);
select round(unix_timestamp(curtime(4)) * 1000);
select (extract (epoch from <date_column>::timestamp)::float*1000 as unix_tms from <table>;
select round(extract (epoch from now())::float*1000);
select unix_timestamp_ms(now(3));
select unix_timestamp_ms(datetimefield);
create function unix_timestamp_ms returns int soname 'unix_timestamp_ms.so';
select current_timestamp(6);
select round(date_format(curtime(3), "%f")/1000);
select date_format(curtime(6), "%f");
select current_timestamp()  => 2018-01-18 12:05:34;
select unix_timestamp(current_timestamp()) => 1516272429;
select current_timestamp(3) => 2018-01-18 12:05:58.983;
select cast( 1000*unix_timestamp(current_timestamp(3)) as unsigned integer) ts => 1516272274786;
create table `ts_test_table` ( `id` int(1) not null, `not_fractional_timestamp` timestamp null default current_timestamp, primary key (`id`);
create table `ts_test_table2` ( `id` int(1) not null, `some_data` varchar(10) collate utf8mb4_unicode_ci not null, `fractional_timestamp` timestamp(3) null default current_timestamp(3) on update current_timestamp(3), primary key (`id`);
select unix_timestamp(now(4));
select round(unix_timestamp() + (microsecond(utc_time(6))*0.000001), 4);
create function unix_ms() return bigint deterministic end;
select unix_ms();
select (unix_timestamp() * 1000) as unix_now_in_microseconds; --- 1600698677000;
select case when stage = 1 then 'running' else 'not running' end as run_status from processes;
case when boolean-expression then else statements;
if boolean-expression then else statements end if;
if select count(*) from orders > 0 then delete from orders else insert into orders values (1,2,3);
if exists (select from orders) then delete from orders;
else insert into orders values (1,2,3);
if (select count(*) from orders) > 0 ...;
if (select count(*) > 0 from orders) ...;
if exists (select from orders) ...;
delete from orders;
if not found then end if;
select coalesce(nullif(other,''),industry) ind from registration;
select coalesce(nullif(other,''),industry) ind from registration;
case when other <> '' then other else industry end;
case when 'fubar' <> '' then other else industry end;
case when true then other else industry end;
case when '' <> '' then other else industry end;
case when false then other else industry end;
case when null <> '' then other else industry end;
case when null then other else industry end;
select c.* from tempdb.sys.columns c where t.name like '#mytemptable%';
select * from tempdb.sys.columns where object_id =;
select * from tempdb.information_schema.columns where table_name like '#mytemptable%';
create table #test (a int, b char(1)) select * from #test exec tempdb..sp_columns '#test';
select * from tempdb.information_schema.columns where table_name = object_id('tempdb..#test'), (select database_id from sys.databases where name = 'tempdb'));
select c.name as fields from where t.name like '#mytemptable%';
select * from tempdb.information_schema.columns where table_name=object_name(object_id('#table'));
create definer=`test`@`%` procedure `myproc`(in myvarparam varchar(40)) if myvarparam = '' then set myvarparam = 'default-value'; end if;
create procedure `blah` ( mydefaultparam int default 0 ) end;
drop procedure if exists blah// drop procedure if exists blah2// drop procedure if exists blah1// drop procedure if exists blah0// create procedure blah(param1 int unsigned, param2 int unsigned) select param1, param2;
create procedure blah2(param1 int unsigned, param2 int unsigned) create procedure blah1(param1 int unsigned) create procedure blah0();
set myparam = ifnull(myparam, 0);
set @@global.sql_mode= 'no_auto_create_user,no_engine_substitution';
if object_id('tempdb..#temptable') is not null drop table #temptable;
select 1 as id,'arul' as names select * from #temptable;
select * into temptable1 from #temptable where 1=0;
exec sp_help temptable1;
select top 0 * into temptable1 from #temptable;
exec sp_help temptable1;
create temp table tmp_table as select * from original_table limit 0;
alter table pg_temp_3.tmp_table drop column primary_key;
select top 0 * from myrealtable;
select top 0 * into #temptable from mytable;
select * into #temptable from tablename where 1<>1;
create temporary table temp_foo like foo;
create temporary table temp_foo select * from foo;
create temporary table temp_foo as select * from foo;
select sequence_owner, sequence_name from dba_sequences;
select * from user_sequences;
select datediff(day, getdate(), getdate() + 1) as daydiff select datediff(minute, getdate(), getdate() + 1) as minutediff select datediff(second, getdate(), getdate() + 1) as seconddiff select datediff(week, getdate(), getdate() + 1) as weekdiff select datediff(hour, getdate(), getdate() + 1) as hourdiff;
select datediff(minute,job_start,job_end);
select convert(varchar(10),dateadd(minute,datediff(minute,job_start,job_end),'2011-01-01 00:00:00.000'),114) select cast(dateadd(minute,datediff(minute,job_start,job_end),'2011-01-01 00:00:00.000') as time);
select start_date as firstdate,end_date as seconddate from [adventureworks2012].dbo.learndate;
select cast(job_end - job_start) as time(0)) from tablea;
select timediff(time(endtime ), time(starttime )) from tbl_name;
select substring(convert(varchar(20),(job_end - job_start),120),12,8) from tablea;
set @start_date = getdate() set @end_date    = dateadd(second, 3910, getdate());
select convert(varchar(12), dateadd(ms, datediff(ms, @start_date, @end_date), 0), 114) as timediff;
select datediff(minute,job_start, job_end)/60.00;
select datediff(year,        '2005-12-31 23:59:59.9999999', '2006-01-01 00:00:00.0000000');
select datediff(quarter,     '2005-12-31 23:59:59.9999999', '2006-01-01 00:00:00.0000000');
select datediff(month,       '2005-12-31 23:59:59.9999999', '2006-01-01 00:00:00.0000000');
select datediff(dayofyear,   '2005-12-31 23:59:59.9999999', '2006-01-01 00:00:00.0000000');
select datediff(day,         '2005-12-31 23:59:59.9999999', '2006-01-01 00:00:00.0000000');
select datediff(week,        '2005-12-31 23:59:59.9999999', '2006-01-01 00:00:00.0000000');
select datediff(hour,        '2005-12-31 23:59:59.9999999', '2006-01-01 00:00:00.0000000');
select datediff(minute,      '2005-12-31 23:59:59.9999999', '2006-01-01 00:00:00.0000000');
select datediff(second,      '2005-12-31 23:59:59.9999999', '2006-01-01 00:00:00.0000000');
select datediff(millisecond, '2005-12-31 23:59:59.9999999', '2006-01-01 00:00:00.0000000');
create table `order` ( `order#` char(4) not null, `ord_date` date, primary key (`order#`) );
select "from" = 'from' from foo;
select [from] = 'from' from foo;
select * from yourreportquery;
select ... into ...;
select * from yourtable select * from #temptable;
create table temp as select * from original_table;
select employeeid,employeename from employee where employeeid>101 order by employeename;
select employeeid,employeename from employee where employeeid>101 order by employeename;
from sqlalchemy import create_engine;
select username from all_users;
select * from dba_users;
select username from dba_users;
select * from all_users;
select username from dba_users;
select username from dba_users where default_tablespace not in ('sysaux', 'system', 'users');
select * from all_users;
select * from dba_users;
select * from user_users;
select * from all_users;
from django.db import transaction;
from django.db import transaction;
...     entry(headline="django 1.1 announced"), ...     entry(headline="breaking: django is awesome");
from django.db import transaction;
from django.db import transaction;
if request.method=="get": if p_n != "" and p_q != "" and p_p != "":;
if request.method=="get": if p_n != "" and p_q != "" and p_p != "":;
create view view_test as select * from table where id = (select convert(int, convert(binary(4), context_info)) from master.dbo.sysprocesses where spid = @@spid);
set context_info 2 select * from view_test;
select * from table where id = 2;
create function dbo.fxnexample (@parameter1 integer) as return ( select field1, field2 from sometable where field3 = @parameter1 ) select * from dbo.fxnexample(1);
create function dbo.fxnexample (@parameter1 integer) as begin select field1, field2 from sometable where field3 = @parameter1 end;
select distinct col1 from [table] where col2 > 2 order by col1, col2;
select rsc.radioservicecodeid, rsc.radioservicecode + ' - ' + rsc.radioservice as radioservice from sbi_l_radioservicecodes rsc where rscg.radioservicegroupid in or @radioservicegroup is null;
select distinct (c.firstname + ' ' + c.lastname) as fullname from saleslt.customer c select distinct (c.firstname + ' ' + c.lastname) from saleslt.customer c select distinct (c.firstname + ' ' + c.lastname) as fullname from saleslt.customer c select distinct (c.firstname + ' ' + c.lastname) as fullname, customerid from saleslt.customer c select distinct (c.firstname + ' ' + c.lastname) as fullname from saleslt.customer c;
select distinct test.* from ( select rsc.radioservicecodeid, rsc.radioservicecode + ' - ' + rsc.radioservice as radioservice from sbi_l_radioservicecodes rsc where rscg.radioservicegroupid in or @radioservicegroup is null;
select tablea.id from tablea left outer join tableb on (tablea.id = tableb.id) where tableb.id is null;
select id from tablea a where not exists;
select id from tablea select id from tableb;
create table tablea as ( select rownum-1 id, chr(rownum-1+70) bb, chr(rownum-1+100) cc from dual connect by rownum<=4 create table tableb as ( select rownum id, chr(rownum+70) data1, chr(rownum+100) cc from dual union all select rownum+2 id, chr(rownum+70) data1, chr(rownum+100) cc from dual connect by rownum<=3 select * from tablea;
select * from tableb;
select id from tablea where id not in (select id from tableb) order by id desc;
select tablea.id from tablea left join tableb on (tablea.id = tableb.id) where tableb.id is null order by tablea.id desc;
select id from tablea a where not exists (select 1 from tableb b where b.id = a.id) select id from tablea select id from tableb order by id desc;
select parenttable.id from parenttable where childtable.id is null;
create table employees ( id int, name varchar(50) not null, photo varbinary(max) not null ) select 10, 'john', bulkcolumn from openrowset( bulk 'c:\photo.bmp', single_blob) as employeepicture;
create table employeeprofile ( empid int, empname varchar(50) not null, empphoto varbinary(max) not null );
select 1001, 'vadivel', bulkcolumn from openrowset( bulk 'c:\image1.jpg', single_blob) as employeepicture;
update employees set [photo] = (select where id = 10;
values ('umar' from openrowset( bulk 'path-to-file.jpg', single_blob) as image1) from openrowset( bulk 'path-to-file.jpg', single_blob) as image2);
select  max(date) from    mytable;
select  max(date) over (order by id) from    mytable;
create table t1(c1 int not null primary key foreign key references t1(c1));
create table employees ( id integer not null primary key, managerid integer references employees(id), name varchar(30) not null;
exec @returnvalue = sp_someproc;
exec @returnvalue = sp_one;
exec @returnvalue = sp_one;
factory, c, implementors[0], s.getenabledfilters());
translator, factory, criteriaimpl, criteriaimpl.getentityorclassname(), session.getloadqueryinfluencers()   );
factory, criteriaimpl, criteriaimpl.entityorclassname, nhibernate.loader.criteria.criteriaquerytranslator.rootsqlalias);
(nhibernate.persister.entity.iouterjoinloadable)factory.getentitypersister(implementors[0]), translator, factory, criteriaimpl, criteriaimpl.entityorclassname, session.enabledfilters);
factory, executablecriteria, executablecriteria.getentityorclassname(), criteriaquerytranslator.root_sql_alias);
factory, executablecriteria, executablecriteria.getentityorclassname(), criteriaquerytranslator.root_sql_alias);
if (sql !=null){ if (parameters!=null && parameters.length>0){;
criteriaimpl, implementors[0].tostring(), loadqueryinfluencers);
if (sql != null) if (parameters != null && parameters.length > 0) if (val instanceof boolean) else if (val instanceof string) else if (val instanceof number) else if (val instanceof class) else if (val instanceof date) "yyyy-mm-dd hh:mm:ss.sss");
else if (val instanceof enum) else { " and ", "\nand ").replaceall(" on ", "\non ").replaceall("<>", "!=").replaceall("<", " < ").replaceall(">", " > ");
(new org.hibernate.loader.criteria.criteriajoinwalker( (org.hibernate.persister.entity.outerjoinloadable) ((org.hibernate.impl.criteriaimpl)crit).getsession().getfactory().getimplementors( ((org.hibernate.impl.criteriaimpl)crit).getentityorclassname())[0]), new org.hibernate.loader.criteria.criteriaquerytranslator( ((org.hibernate.impl.criteriaimpl)crit).getsession().getfactory(), ((org.hibernate.impl.criteriaimpl)crit), ((org.hibernate.impl.criteriaimpl)crit).getentityorclassname(), org.hibernate.loader.criteria.criteriaquerytranslator.root_sql_alias), ((org.hibernate.impl.criteriaimpl)crit).getsession().getfactory(), (org.hibernate.impl.criteriaimpl)crit, ((org.hibernate.impl.criteriaimpl)crit).getentityorclassname(), ((org.hibernate.impl.criteriaimpl)crit).getsession().getenabledfilters() );
create or replace procedure greetings end ;
create or replace function totalemployees select count(*) into total from employees;
create or replace procedure my_proc create or replace function my_func;
select foo from foobar;
set @teststringfield = n'string which is too long' select @teststringfield;
update ...where varchar100column = @varcharmaxvalue;
select @sql = 'b', @nsql = 'b';
select len(@sql), len(@nsql), datalength(@sql), datalength(@nsql) select len(c) from @t;
select len(@sql + c), len(@nsql + c), datalength(@sql + c), datalength(@nsql + c) from @t;
create procedure sptest ( @p1 varchar(2), @p2 varchar(3) );
create procedure sptest ( @p1 varchar(max), @p2 varchar(max) ) select @p1int=p1, @p2int=p2 from @test;
select distinct substring ( stuff(( select distinct ',' + [fieldb] from tablename order by 1 for xml path(''), type).value('.', 'nvarchar(max)') from tablename;
select t.name,string_agg (c.name, ',') as csv from sys.tables t join sys.columns c on t.object_id = c.object_id;
select fielda from tablename;
select fielda from tablename;
select fielda from tablename;
select fielda from tablename;
select fielda, fieldb from tablename) select t0.fielda select ',' + t1.fieldb from cte_tablename t1 where t1.fielda = t0.fielda from cte_tablename t0;
select fielda, fieldb from tablename select fielda from cte_tablename;
select fielda from tablename;
select fielda, string_agg(fieldb, '') as data from yourtable;
select distinct t1.fielda, stuff((select distinct '' + t2.fieldb from yourtable t2 where t1.fielda = t2.fielda from yourtable t1;
(store_id,product_type);
(store_id,product_type);
select * into #temp from ( select 'quarter 1' period,'amar' name ,97 marks union all select 'quarter 1','ram',88 union all select 'quarter 1','simi',76 union all select 'quarter 2','amar',94 union all select 'quarter 2','ram',82 union all select 'quarter 2','simi',71 union all select 'quarter 3' ,'amar',95 union all select 'quarter 3','ram',83 union all select 'quarter 3','simi',77 union all select 'quarter 4' ,'amar',91 union all select 'quarter 4','ram',84 union all select 'quarter 4','simi',79;
select * from #temp union all select period,name,sum(marks) total from #temp having period is null and name is not null;
select * from #temp union all select period,name,sum(marks) total from #temp having period is not null and name is null;
select period,name,sum(marks) total from #temp having period is not null or name is not null;
select case when period is null then 'total' else period end period, case when name is null then 'total' else name end name, sum(marks) marks from #temp select @cols = coalesce (@cols + ',[' + period + ']', '[' + period + ']') from    (select distinct period from #temp2) pv set @query = 'select * from ( select * from #temp2 ( sum(marks) exec sp_executesql @query;
select distinct dbo.getdirectorypath(filename) as instancedatapaths from sys.sysaltfiles where filename like '%.mdf' and filename not like '%\mssql\binn\%' select distinct dbo.getdirectorypath(filename) as instancelogpaths from sys.sysaltfiles where filename like '%.ldf' and filename not like '%\mssql\binn\%';
set @datafilename = (select top 1 rtrim(ltrim(name)) from master.sys.master_files where database_id >4 and file_id = 1)+'.mdf' set @logfilename =   (select top 1 rtrim(ltrim(name)) from master.sys.master_files where database_id >4 and file_id = 2)+'.ldf' select ( select top 1 substring(physical_name, 1, charindex(@datafilename, lower(physical_name)) - 1) from master.sys.master_files where database_id >4 and file_id = 1) as 'data file'  from master.sys.master_files where database_id >4 and file_id = 2)  as 'log file';
select serverproperty('instancedefaultdatapath') as [default_data_path], serverproperty('instancedefaultlogpath') as [default_log_path];
exec master.dbo.xp_instance_regread n'software\microsoft\mssqlserver\mssqlserver', n'defaultdata', @defaultdatalocation output exec master.dbo.xp_instance_regread n'software\microsoft\mssqlserver\mssqlserver', n'defaultlog', @defaultloglocation output select @defaultdatalocation as 'default data location', @defaultloglocation as 'default log location';
set _basedirquery=select substring(physical_name, 1, charindex(n'master.mdf', lower(physical_name)) - 1) ^ from master.sys.master_files where database_id = 1 and file_id = 1;
if errorlevel 1 echo error with automatically determining sql data directory by querying your server&echo using windows authentication. if "%_basedir:~-1%"=="\" set "_basedir=%_basedir:~0,-1%" set input=%~3 if "%~3" neq "" ( :askagain set /p "input=%~1 [%~3]:" if "!input!" equ "" ( goto :askagain ) set /p "input=%~1 [null]: " ) set "%~2=%input%" set "_line=%%i" if "!_line:~0,2!" == "c:" ( set "_basedir=!_line!" ) );
database settings;
database default locations;
exec master.dbo.xp_instance_regread n'hkey_local_machine', n'software\microsoft\mssqlserver\mssqlserver', n'defaultdata', @defaultdata output exec master.dbo.xp_instance_regread n'hkey_local_machine', n'software\microsoft\mssqlserver\mssqlserver', n'defaultlog', @defaultlog output exec master.dbo.xp_instance_regread n'hkey_local_machine', n'software\microsoft\mssqlserver\mssqlserver', n'backupdirectory', @defaultbackup output exec master.dbo.xp_instance_regread n'hkey_local_machine', n'software\microsoft\mssqlserver\mssqlserver\parameters', n'sqlarg0', @masterdata output select @masterdata=substring(@masterdata, 3, 255) select @masterdata=substring(@masterdata, 1, len(@masterdata) - charindex('\', reverse(@masterdata))) exec master.dbo.xp_instance_regread n'hkey_local_machine', n'software\microsoft\mssqlserver\mssqlserver\parameters', n'sqlarg2', @masterlog output select @masterlog=substring(@masterlog, 3, 255) select @masterlog=substring(@masterlog, 1, len(@masterlog) - charindex('\', reverse(@masterlog))) select isnull(@defaultdata, @masterdata) defaultdata, isnull(@defaultlog, @masterlog) defaultlog, isnull(@defaultbackup, @masterlog) defaultbackup;
select instancedefaultdatapath = serverproperty('instancedefaultdatapath'), instancedefaultlogpath = serverproperty('instancedefaultlogpath');
select db.name, f.physical_name from sys.databases db join sys.master_files f on db.database_id=f.database_id;
select physical_name from;
select physical_name from sys.master_files where database_id = db_id(n'model');
select substring(physical_name, 1, charindex(n'master.mdf', lower(physical_name)) - 1) from master.sys.master_files where database_id = 1 and file_id = 1;
create database mydatabasename;
exec master.dbo.xp_regread @rootkey='hkey_local_machine', @key='software\microsoft\microsoft sql server\mssql10.mssqlserver\setup', @value_name='sqldataroot', @value=@regvalue output, @output = 'no_output' select @regvalue as dataandlogfilepath;
create database dbname;
exec sp_helpdb 'dbname';
update tablename set    [bitcolumnname] = ~[bitcolumnname], .... where  ....;
set @theflipbit = ~ @thebit select @theflipbit;
select idcolumn, bitfieldy, bitfieldy ^ 1 as toggled from tablex;
update tablex set bitfieldy = bitfieldy ^ 1 where ...;
update tbltest set mybitfield = case when mybitfield = 1 then 0 else 1 end;
update tbltest set else null -- or 1 or 0 depending on requirements end;
update mytable set somecolumn = case when somecolumn = 0 then 1 end;
select * from service s where s.service_id = ?;
if exists(select * from ....) end else -- do something;
if not exists , @@row_count;
select * from .... end;
select count(*) as countthis ....;
if checkrow_rs("countthis")="0" then ...;
select found_rows();
select * from service s where s.service_id = ?;
if @@rowcount = 0 select 'no data' end;
if exists(select * from service s where s.service_id = ?) end;
select count(*) as count from service s where s.service_id = ?;
if exists(select 1 from service s where s.service_id = ?) end;
select * from service s where s.service_id = ?;
if @@rowcount > 0;
select * from service s where s.service_id = ?;
if @@rowcount=0 end;
select count(1) from service s where s.service_id = ?;
select top (1000) * from test where drawname != 'null' and cast(drawdate as date) = cast (getdate() as date);
select * from table where date(column_date) = curdate();
where created_date between current_timestamp-180 and current_timestamp;
select [column_1], [column_1], ... from (your_table) where date_format(record_date, '%e%c%y') = date_format(now(), '%e%c%y');
select * from dates where dte = cast(current_timestamp as date);
select * from datetimes where dtm >= cast(current_timestamp as date) and dtm < dateadd(dd, 1, cast(current_timestamp as date));
select * from datetimes2 where dtm2 >= cast(current_timestamp as date) and dtm2 < dateadd(dd, 1, cast(current_timestamp as date));
select * from dates where dte = cast(now() as date);
select * from datetimes where dtm >= cast((now()) as date) and dtm < cast((now() + interval 1 day) as date);
select * from dates where dte = current_date;
select * from timestamps where ts >= 'today' and ts < 'tomorrow';
select to_char(dte, 'yyyy-mm-dd hh24:mi:ss') dte from dates where dte >= trunc(current_date) and dte < trunc(current_date) + 1;
select to_char(ts, 'yyyy-mm-dd hh24:mi:ss') ts from timestamps where ts >= trunc(current_date) and ts < trunc(current_date) + 1;
select * from dates where dte = (select date('now'));
select dtm from datetimes where dtm >= datetime(date('now')) and dtm < datetime(date('now', '+1 day'));
select datetime(dtm, 'unixepoch', 'localtime') from datetimes where dtm >= strftime('%s', date('now')) and dtm < strftime('%s', date('now', '+1 day'));
select  getdate() select  cast(getdate() as date);
select dateadd(dd, datediff(dd, 0, getdate()), 0);
select  getdate();
select  dateadd(dd, 0, datediff(dd, 0, getdate()));
select getdate() select cast(getdate() as date) create table test (id int) select * from sysobjects where cast(crdate as date) = cast(getdate() as date) drop table test;
select getdate() select dateadd(millisecond, -3, cast(cast(getdate()+1 as date) as datetime)) select cast(getdate() as date) create table test (id int) select * from sysobjects where crdate between cast(getdate() as date) and dateadd(millisecond, -3, cast(cast(getdate()+1 as date) as datetime)) drop table test;
select * from tbl where datediff(d, yourdate, getdate())=0;
select getdate() --2012-05-01 10:14:13.403;
select day(getdate())  --1 select month(getdate())  --5 select year(getdate()) --2012;
select cast (getdate() as date) --2012-05-01;
alter table tbl_quiz_attempt_master drop index index_name;
alter table tbl_quiz_attempt_master drop index `primary`;
alter table mytable drop index key_name;
alter table <table_name> drop index <index_name>;
alter table your_table add unique(target_column_name);
alter table your_table drop index target_column_name;
alter table student_login_credentials drop index created_at;
set @b = something;
set ansi_nulls on set quoted_identifier on go alter procedure [dbo].[validate] @a varchar(50) as  select top 1 password from dbo.tbluser where login = @a;
if (exists (select rolename from dbo.roles where @rolename = rolename)) select 1 else select 0;
create proc mysp @b varchar(50) output as set @password = from dbo.tbluser where login = @a);
direction = parameterdirection.output, size = 1 direction = parameterdirection.output, size = 1000;
create procedure splogincheck @password varchar(100) , @loginstatus char(1) = null output, @error varchar(1000) output as begin set nocount on;
set @error = 'none' set @loginstatus = '' if exists(select top 1 * from emp_master where empname=@username and emppassword=@password) set @loginstatus='y' end  else begin set @loginstatus='n' end  end end try set @error = error_message() end end catch end go;
set ansi_nulls on set quoted_identifier on alter procedure [dbo].[validate] @b varchar(50) output as  set @b = from dbo.tbluser where login = @a);
set ansi_nulls on set quoted_identifier on alter procedure [dbo].[validate] @b varchar(50) output as begin select @b;
set ansi_nulls on set quoted_identifier on create procedure [dbo].[insertnewuser]( @neuname nvarchar(255), @neupassword nvarchar(255), @neuposition nvarchar(255) ) as  set @check = (select count(eid) from eusers where euname = @neuname);
set @lastid = @@identity;
end try select error_line() as errline, error_message() as errmessage, error_severity() as errsevirity end catch end;
if (dal.dal.conn.state != connectionstate.closed) {;
new sqlparameter("neupassword","moro$ilka"), new sqlparameter("neuposition","moroz");
create procedure isemailexists as begin set nocount on;
if exists(select email from users where email = @email) end else begin end end;
select id, file_name from dbo.filestorage where id = (select max(id) from dbo.filestorage);
select field1,field2,(select distinct field3 from tbl2 where criteria) as field3 from tbl1 group by field1,field2;
select distinct field1,field2,(select distinct field3 from tbl2 where criteria) as field3 from tbl1;
select * from table_name;
select col1, col2, col3 from data group by col1, col2, col3;
select col1, col2 from data group by col1, col2;
select col1, col2, col3 from data group by col1, col2;
select col1, col2, sum(col3) from data group by col1, col2;
select col1, col2, col3 from data group by col1, col2, col3;
select distinct col1, col2, col3 from data;
create table dataset ( val1 char ( 1 char ), val2 varchar2 ( 10 char ), val3 number );
dataset ( val1, val2, val3 ) values ( 'b', 'b-details', 2 );
dataset ( val1, val2, val3 ) values ( 'a', 'a-details', 1 );
dataset ( val1, val2, val3 ) values ( 'c', 'c-details', 3 );
dataset ( val1, val2, val3 ) values ( 'a', 'dup', 4 );
dataset ( val1, val2, val3 ) values ( 'c', 'c-details', 5 );
select * from dataset;
select val1, count ( * ) from dataset a val1;
select val1, count ( * ) from dataset a val1, val2;
select val1, val2 from dataset a val1, val2;
select val1 from dataset a val1, val2;
select month(date)+'-'+year(date), ....;
select cast(month(date) as varchar(2)) + '-' + cast(year(date) as varchar(4)) as mjesec, sum(marketingexpense) as sumamarketing, sum(revenue) as sumazarada from [order] where (idcustomer = 1) and (date between '2001-11-3' and '2011-11-3');
cast(year(date) as varchar(4)) + '-' + right('00' + cast(month(date) as varchar(2)), 2);
select month(date) + '-' + year(date) as mjesec, sum(marketingexpense) as from [order] where (idcustomer = 1) and (date between '2001-11-3' and '2011-11-3');
select to_char (datum, 'mm-yyyy') as mjesec from test;
select dateadd(month, datediff(month, 0, o.[date]), 0) as mjesec, sum(marketingexpense) as sumamarketing, sum(revenue) as sumazarada from [order] o where (idcustomer = 1) and (o.[date] between '2001-11-3' and '2011-11-3');
select date_format(date, '%m-%y') from [order] date_format(date, '%m-%y');
select format(date,'mm.yy');
select (year(date) * 100) + month(date) as yyyymm from [order];
select format(date,'mm.yyyy') as mjesec, sum(marketingexpense) as sumamarketing, sum(revenue) as sumazarada from [order] where (idcustomer = 1) and (date between '2001-11-3' and '2011-11-3');
select s.name as schemaname, t.name as tablename, p.rows as rowcounts, sum(a.total_pages) * 8 as totalspacekb, sum(a.used_pages) * 8 as usedspacekb, (sum(a.total_pages) - sum(a.used_pages)) * 8 as unusedspacekb from sys.tables t sys.schemas s on s.schema_id = t.schema_id sys.indexes i on t.object_id = i.object_id sys.partitions p on i.object_id = p.object_id and i.index_id = p.index_id sys.allocation_units a on p.partition_id = a.container_id where t.name not like 'dt%'    -- filter out system tables for diagramming and t.is_ms_shipped = 0 and i.object_id > 255 t.name, s.name, p.rows s.name, t.name;
and i.index_id in (0,1);
and i.index_id > 1;
select object_id, sum (reserved_page_count) as reserved_pages, sum (used_page_count) as used_pages, sum (case else lob_used_page_count + row_overflow_used_page_count from sys.dm_db_partition_stats select p.object_id, sum(reserved_page_count) as reserved_pages, sum(used_page_count) as used_pages from sys.dm_db_partition_stats p, sys.internal_tables it where it.internal_type in (202,204,211,212,213,214,215,216) and p.object_id = it.object_id ) select object_schema_name(p.object_id) + '.' + object_name(p.object_id) as tablename, (p.reserved_pages + isnull(e.reserved_pages, 0)) * 8 as reserved_kb, pages * 8 as data_kb, (case when p.used_pages + isnull(e.used_pages, 0) > pages then (p.used_pages + isnull(e.used_pages, 0) - pages) else 0 end) * 8 as index_kb, (case when p.reserved_pages + isnull(e.reserved_pages, 0) > p.used_pages + isnull(e.used_pages, 0) then (p.reserved_pages + isnull(e.reserved_pages, 0) - p.used_pages + isnull(e.used_pages, 0)) else 0 end) * 8 as unused_kb from pages p;
select date, user, status, notes from [sometable] ( select max(date) as latestdate, [user] from [sometable] and [sometable].user = submax.user;
select date, user, status, notes from ( select m.*, row_number() over (partition by user order by date desc) as rn from [sometable] m where m2.rn = 1;
as ( select date, user, status, notes, row_number() over (partition by user order by date desc) from [sometable] ) select user, date, status, notes from userstatus where ord = 1;
select date, user, status, notes from test_most_recent where date in ( select max(date) from test_most_recent group by user);
select * from userstatus where userstatusid in ( select max(userstatusid) from userstatus group by user );
select * from tbl where col like 'abc%' union select * from tbl where col like 'xyz%' union select * from tbl where col like 'pqr%';
create table tbl (col varchar(255));
select * from tbl where col like 'abc%' union select * from tbl where col like 'xyz%' union select * from tbl where col like 'pqr%';
create temporary table patterns ( pattern varchar(20) select t.* from tbl t join patterns p on (t.col like p.pattern);
select distinct t.* from tbl t join patterns p on (t.col like p.pattern);
select * from tbl where col like '[abc-xyz-pqr]%';
select * from tbl where col like 'abc%' or col like 'xyz%' or col like 'pqr%';
select * from tbl where regexp_like(col, '^(abc|xyz|pqr)');
create  function [dbo].[fn_split](@text varchar(8000), @delimiter varchar(20)) ( position int identity primary key, value varchar(8000) ) as begin set @index = -1 set @index = charindex(@delimiter , @text) if (@index = 0) and (len(@text) > 0) end if (@index > 1) set @text = right(@text, (len(@text) - @index)) end else set @text = right(@text, (len(@text) - @index)) end return end;
select * from my_table inner join (select value from fn_split('abc,mop',',')) as split_table on my_table.column_name like '%'+split_table.value+'%';
set @drugclassstring = 'c3,c2'; -- you can pass null also if @drugclassstring is null set @drugclassstring = 'c3,c2,c4,c5,rx,ot'; -- if null you can set your all conditional case that will return for all select dn.drugclass_fk , dn.cdrugname from drugname as dn;
set ansi_nulls on;
set quoted_identifier on;
alter function [dbo].[splitstring](@stringtosplit varchar(max), @delimeter     char(1)      = ',') as begin select @pos = charindex(@delimeter, @stringtosplit);
select @name = substring(@stringtosplit, 1, @pos-1);
select @stringtosplit = substring(@stringtosplit, @pos+1, len(@stringtosplit)-@pos);
select @stringtosplit;
select * from [source database].[dbo].[source table];
select * into <destinationtable> from <sourcedatabase>.dbo.<sourcetable>;
select * from [sourceserver].[sourcedatabase].dbo.yourtablenamehere;
destinationdatabase = dbdestination.name, copyallobjects = false, destinationloginsecure = true, dropdestinationobjectsfirst = true, copydata = true;
create table yourtable );
set nocount on select @x=0,@y=0 update yourtable set yourname='new name' set @x=@x+1 update yourtable set yourname='new name' where yourname='new name' set @y=@y+@@rowcount end print @y;
set nocount on select @x=0,@y=0 set @x=@x+1 delete yourtable where yourname='new name' set @y=@y+@@rowcount end print @y;
database > reverse engineer;
database > forward engineer;
select  proname, prosrc from    pg_catalog.pg_namespace n join    pg_catalog.pg_proc p where   nspname = 'public';
select  proname, proargnames, prosrc from    pg_catalog.pg_namespace n join    pg_catalog.pg_proc p where   nspname = 'public';
drop function <name>(<args>);
select proname from pg_proc where proowner <> 1;
select  p.proname from    pg_catalog.pg_namespace n join    pg_catalog.pg_proc p where   n.nspname = 'public';
select n.nspname as schema_name from   pg_proc p join   pg_namespace n on n.oid = p.pronamespace and    n.nspname = 'schema_name' and    p.prosrc like '%table_name%';
select t1.a, t2.b from t1 join t2 on t1.a like '%'+t2.b +'%';
select t1.notes, t2.name from table1 t1 join table2 t2 on t1.notes like concat('%', t2.name ,'%');
alter table allitems;
create table animals ( id mediumint not null auto_increment, name char(30) not null, primary key (id);
alter table t_name modify c_name int(10) auto_increment primary key;
alter table tblcatalog;
alter table `table1` change `itemid` `itemid` int( 11 ) not null auto_increment;
alter table `allitems`;
alter table allitems;
create table allitems( itemid int(10)unsigned, itemname varchar(50) alter table allitems change itemid itemid int(10)auto_increment primary key;
values ('apple'), ('orange'), ('banana');
select * from allitems;
alter table allitems change itemid itemid int(10)auto_increment primary key;
alter table allitems modify itemid int(5);
alter table tbl auto_increment = 100;
create table tmpphotos as select distinct * from photos;
drop table photos;
alter table tmpphotos rename to photos;
delete from p1 where p1.id > p2.id and p1.merchant_id = p2.merchant_id and p1.url = p2.url;
select * from ( select id, row_number() over(partition by merchant_id, url order by id asc) as row from photos where dups.row > 1;
delete from photos as p1 where p1.id > p2.id and p1.merchant_id = p2.merchant_id and p1.url = p2.url;
select * from emp e select * from emp e, dept d where d.deptno = e.deptno;
select * from emp e select * from emp e, dept d where d.deptno (+) = e.deptno;
select * from emp e select * from emp e, dept d where d.deptno = e.deptno(+);
select * from emp e select * from emp e, dept d;
select * from emp e select * from emp e, dept d where d.deptno (+) = e.deptno(+);
select e.last_name, d.department_name from employees e, departments d where e.department_id = d.department_id(+);
select e.last_name, d.department_name from employees e;
select e.last_name, d.department_name from employees e, departments d where e.department_id(+) = d.department_id;
select e.last_name, d.department_name from employees e;
select e.last_name, d.department_name from employees e, departments d where e.department_id = d.department_id(+) union all select null, d.department_name from departments d where not exists select e.last_name, d.department_name from employees e;
select employee_id, manager_id from employees where employees.manager_id(+) = employees.employee_id;
select e1.employee_id, e1.manager_id, e2.employee_id from employees e1, employees e2 where e1.manager_id(+) = e2.employee_id;
alter table dbo.mytable add alter table dbo.mytable drop constraint df_mytable_mycolumn;
create table testinsertcomputedcolumn ( firstname varchar(100), lastname char(50) select 'v', 'gv8';
select * from testinsertcomputedcolumn;
alter table testinsertcomputedcolumn add fullname as firstname + lastname persisted not null;
select * from testinsertcomputedcolumn;
alter table [table] add [column] int null update [table] set [column] = <default_value> alter table [table] alter column [column] int not null;
alter table <yourtable> add <newcolumn> <newcolumntype> not null default <defaultvalue> alter table tablename add columnname datetime not null default getdate();
alter table my_table add stage int null update my_table set <a valid not null values for your column> alter table my_table alter column stage int not null;
delete guide_category where id_guide_category in (  select id_guide_category from guide_category as gc where g.title is null );
delete  gc.* from    guide_category as gc guide as g where   g.title is null;
delete from    guide_category as gc where   id_guide not in ( select  id_guide from    guide );
delete from guide_category where id_guide not in (select id_guide from guide);
create table table1 (refno varchar(10)) create table table2 (refno varchar(10)) select * from table1 select * from table2 delete t1 from table1 t1 join table2 t2 on t1.refno = t2.refno;
delete pgc from guide_category pgc where g.id_guide is null;
select   row_number() over (order by <field> nulls last) as rownum, * from     foo_tbl;
select row_number() over(), *  -- notice: no fields are needed from   foo_tbl;
select    count(*) rownum, foo.* from      datatable foo join      datatable bar;
select num, name[num] from ( select generate_series( 1, (select count(*) from names) ) as num ( select array_agg(name) as name from names;
if not exists(select * from clock where clockdate = '08/10/2012') and username = 'test');
if not exists(select * from clock where;
if not exists(select * from clock where and username = 'test');
where clockdate = { fn current_date() } and username = 'test';
if (not exists(select * from clock where cast(clockdate as date) = '08/10/2012') and username = 'test') end else begin update clock set breakout = getdate() where cast(clockdate as date) = '08/10/2012' and username = 'test' end;
if (not exists(select * from clock where clockdate = '08/10/2012') and username = 'test') end else begin update clock set breakout = getdate() where clockdate = '08/10/2012' and username = 'test' end;
not exists(select...);
update set breakout = getdate() values (getdate(), source.username, getdate());
select @primarykey, @value1, @value2 where not exists from thetable with (updlock, holdlock) where primarykey = @primarykey);
set @existing = (select primarykey from table where param1field = @param1 and param2field = @param2) if @existing is not null end else return 0 end;
end try if error_number() <> 2627 end catch;
if exists(select);
update set value1 = source.value1, value2 = source.value2;
end try if error_number() <> 2627 select @errormessage = error_message(), @errorseverity = error_severity(), @errorstate = error_state();
@errormessage, @errorseverity, @errorstate end end catch;
set xact_abort on;
if columnproperty(object_id('code'), 'colorid', 'allowsnull') is null alter table code add colorid uniqueidentifier null;
end go update code set colorid = '...' where ...;
set xact_abort on if columnproperty(object_id('color'), 'codeid', columnid) is null alter table color add codeid [uniqueidentifier] null if xact_state() = 1 update color set codeid= 'b6d266dc-b305-4153-a7ab-9109962255fc' where [name] = 'red' if xact_state() = 1;
alter table [table] add [xyz] nvarchar(256);
exec sys.sp_executesql @query = @sql;
) select pg_typeof(jo -> 'a'), pg_typeof(jo ->> 'a'), pg_typeof(ja -> 1), pg_typeof(ja ->> 1) from t;
select info -> 'customer' as customer from orders;
select info ->> 'customer' as customer from orders;
create table json_test ( id integer, val jsonb;
(2, jsonb_build_object('member', 12)), (3, null);
select id, val -> 'member'  as arrow, pg_typeof(val -> 'member')  as arrow_pg_type, val -> 'member' is null as arrow_is_null, val ->> 'member' as dbl_arrow, pg_typeof(val ->> 'member')  as dbl_arrow_pg_type, val ->> 'member' is null as dbl_arrow_is_null, case when jsonb_typeof(val -> 'member') = 'null' then true else false end as is_json_null from json_test;
select * from ?;
select * from 'mytable';
select * from {$mytable};
create database if not exists ?;
exec n'select bla..';
create or replace function get_object_fields(my_name text, out f1 text, out f2 text) as $$ select t1.name, t2.name from  table1 t1 where t1.name = my_name and t2.name = my_name;
select get_object_fields( 'pending') ;
select * from get_object_fields( 'pending');
select (get_object_fields( 'pending')).f1;
create function test_ret(a text, b text) returns record as $$ if length(a) < length(b) then select true, a || b, 'a shorter than b' into ret;
else select false, b || a into ret;
create function test_ret(a text, b text) returns record as $$ if length(a) < length(b) then else ret := (false, (b || a)::text, null::text);
create or replace function get_object_fields(_school_id int select into user1_id, user1_name from   users u where  u.school_id = _school_id limit  1;  -- make sure query returns 1 row - better in a more deterministic way? select into user2_name from   users u where  u.id = user2_id;
end $func$  language plpgsql;
select * from get_object_fields(1);
create or replace function get_object_fields2(_school_id int) select u1.id, u1.name, u2.id, u2.name from   users u1 join   users u2 on u2.id = u1.id + 1 where  u1.school_id = _school_id limit  1;  -- may be optional end $func$  language plpgsql;
select * from get_object_fields2(1);
create or replace function schemaname.get_two_users_from_school(schoolid bigint) as $function$ select id, name from schemaname.user where school_id = schoolid;
select * from schemaname.get_two_users_from_school(schoolid) as x(a bigint, b varchar);
create or replace function get_object_fields ( name text ) as $$ end $$ language plpgsql;
create type my_type as (f1 varchar(10), f2 varchar(10) /* , ... */ );
create or replace function get_object_fields(name text) as $$ select f1, f2, f3 from table1 where pk_col = 42;
select f3 from table2 where pk_col = 24;
end $$ language plpgsql;
create or replace function get_object_fields(name text);
create table courses ( id integer not null, name text, created_by integer, jc text;
select ... having ...;
select @date = '10/31/09' select t1.empname, t1.region, t1.tourstartdate, t1.tourenddate, t1.forddate, fordtype  = max(case when o.orderdate = t1.forddate then o.ordertype  else null end), fordtotal = max(case when o.orderdate = t1.forddate then o.ordertotal else null end), t1.lorddate, lordtype  = max(case when o.orderdate = t1.lorddate then o.ordertype  else null end), lordtotal = max(case when o.orderdate = t1.lorddate then o.ordertotal else null end) from (--derived table t1 returns the tourdates, and the order dates select e.empid, e.empname, et.region, et.tourstartdate, et.tourenddate, forddate = min(o.orderdate), lorddate = max(o.orderdate) from #employees e inner join #emptours et where et.tourstartdate <= @date and (et.tourenddate > = @date or et.tourenddate is null) and o.orderdate between et.tourstartdate and @date and (t1.forddate = o.orderdate or t1.lorddate = o.orderdate);
select c.name as column_name, type_name(c.user_type_id) as data_type, c.is_nullable, c.max_length, c.precision, c.scale from sys.columns c join sys.types t where c.object_id=object_id('your_table_name');
select table_name          as 'table name', column_name         as 'column name', case when data_type like '%char' then data_type + '(' + convert(varchar, character_maximum_length) + ')' then data_type then data_type + '(' + convert(varchar, datetime_precision) + ')' then data_type then data_type + '(' + convert(varchar, numeric_precision) + ', ' + convert(varchar, numeric_precision_radix) + ')' end                 as 'data type', case when is_nullable = 'no' then 'not null' else 'null' end                 as 'pk/lk/not null' from information_schema.columns table_name, ordinal_position;
select * from information_schema.columns;
select ... into;
select * from enormous_collection_of_views_tables_etc;
select column_name, data_type, character_maximum_length from information_schema.columns where table_name='yourtable';
select column_name, data_type, character_maximum_length from information_schema.columns where table_name = 'your_table_name';
select top 10 * from <datasource>;
exec tempdb.dbo.sp_help n'#temptable';
select * from tempdb.sys.columns where [object_id] = object_id(n'tempdb..#temptable');
create procedure [fn].[getqueryresultmetadata] as begin select c.name                          [columnname], tp.name                         [columntype], c.max_length                    [maxlength], c.[precision]                   [precision], c.[scale]                       [scale], c.[is_nullable]                 isnullable from tempdb.sys.columns              c tempdb.sys.types                tp and -- exclude custom types where [object_id] = object_id(n''tempdb..#querymetadata'');
exec sp_executesql @sqltoexec end;
exec sp_describe_first_result_set @query, null, 0;
select * into tmp1 from ( select top 1 /* rest of your query expression here */ );
select o.name as obj_name, type_name(c.user_type_id) as type_name, c.* from sys.objects as o join sys.columns as c  on o.object_id = c.object_id where o.name = 'tmp1';
drop table tmp1;
alter database mydb add file ( name = n'filestreamname', filename = n'd:\sql databases\filestreamspace' );
create file encountered operating system error **32**(failed to retrieve text for this error. reason: 15105) while attempting to open or create the physical file;
exec sp_attach_single_file_db @dbname = 'spdb', @physname = 'd:\spdb.mdf';
alter table table_name modify password varchar(20) after id;
alter table table_name change column column_name column_name data_type after another_column_name;
alter table [table] change column [column] [column] [column definition] after [column];
alter table [table] modify column [column] [column definition] after [column];
alter table table_name modify password varchar(20) after id;
alter table table_name modify password varchar(20) varchar(20) after id;
if (statement != null) { if (dbconnection != null) {;
select statement;
select ... from ... where unix_timestamp() - unix_timestamp(thefield) < 259200;
where t.date >= date_add(curdate(), interval -3 day);
where t.date >= ( curdate() - interval 3 day );
where t.date >= date_add(curdate(), interval '-3' day);
select datediff(now(),pickup_date) as noofday from cir_order where datediff(now(),pickup_date)>2;
select * from cir_order where cir_order.`cir_date` >= date_add( curdate(), interval -10 day );
select age(current_timestamp);
select abs(extract(epoch from timestamp1 - timestamp2)/3600);
delete from session_table where time-initialized < '2 days';
delete from session_table where time_initialized < '$yesterday';
select ( (extract (epoch from ( '2012-01-01 18:25:00'::timestamp - '2012-01-01 18:25:02'::timestamp ) ) );
select * from yourtable where your_timestamp_field > to_date('05 dec 2000', 'dd mon yyyy');
select * from yourtable where your_timestamp_field > current_timestamp - interval '5 minutes';
select * from yourtable where your_timestamp_field > current_timestamp - interval '5 hours';
select * from information_schema.table_constraints;
alter table <my_table> drop constraint <constraint_name>;
alter table feature drop constraint feature_constraint;
alter table feature drop constraint feature_pkey;
drop index feature_unique;
alter table tablename alter column column_want_to_remove_constriant drop not null;
select * from (select * from tablea union select * from tableb where u.col1 = ...;
select * from ( select * from table1 where field1 = value1 union select * from table2 where field1 = value2;
select column1..... from table1 where column1='' union select column1..... from table2 where column1= '';
case case_value else statements end;
case when <search_condition> then statements else statements end;
select case course_enrollment_settings.base_price;
select case when course_enrollment_settings.base_price = 0      then 1;
select case when course_enrollment_settings.base_price = 0      then 1 end;
case course_enrollment_settings.base_price;
select case when course_enrollment_settings.base_price = 0      then 1 else 6 end as 'calc_base_price', course_enrollment_settings.base_price from course_enrollment_settings where course_enrollment_settings.base_price = 0;
select case 0 else 6, ...;
select case when course_enrollment_settings.base_price = 0      then 1 else 6 end as 'calc_base_price', course_enrollment_settings.base_price from course_enrollment_settings where course_enrollment_settings.base_price = 0;
case case_value end case;
if (case_value == when_value);
if (case_value == (case_value > 100));
if (case_value == false);
if (case_value == 0);
case when search_condition then statement_list end case;
case when x = a then ...;
set dateformat mdy --indicates the general format is month day year;
create table dbo.t(d datetime);
select distinct username from users where company = bbc or company = itv;
select username from users where company = bbc union select username from users where company = itv;
select username from users where company = bbc or company = itv;
select username from users where company = bbc union all select username from users where company = itv;
select username from users where company in ('bbc', 'itv');
select username from users where company = 'bbc' or company = 'itv';
select username from users where company in ('bbc', 'itv');
select username from users where company = 'bbc' or city = 'london';
select username from users where company = 'bbc' union select username from users where city = 'london';
create table t1(cpk int identity(1,1) not null, col1 int, col2 char(3));
select * from t1 update t1 set col2 = null;  /* run some update statement */ select * from t1;       /* oops ... forgot the where clause */ select * from t1;       /* tans rolled back, data restored. */ update t1 set col2 = 'cba' where cpk = 4;   /* run some update statement */ select * from t1;               /* did it correctly this time */ drop table t1;
select s.video_id from videos s join (select max(video_id) as id from videos group by video_category) max;
create table test( i integer, c integer, v integer values (3, 1, 1), (3, 2, 2), (3, 3, 3), (4, 2, 4), (4, 3, 5), (4, 4, 6), (5, 3, 7), (5, 4, 8), (5, 5, 9), (6, 4, 10), (6, 5, 11), (6, 6, 12);
select t.c, t.v from test t join (select test.c, max(i) as mi from test group by c) j on;
select video_category, max(video_id) as video_id, substring(max(concat(lpad(video_id, 11, '0'), video_url)), 12) as video_url, substring(max(concat(lpad(video_id, 11, '0'), video_date)), 12) as video_date, substring(max(concat(lpad(video_id, 11, '0'), video_title)), 12) as video_title, substring(max(concat(lpad(video_id, 11, '0'), short_description)), 12) as short_description from videos video_category;
select -- overall totals count(1) as videos_in_category, datediff(max(video_date), min(video_date)) as timespan,  substring(max(concat(lpad(video_id, 11, '0'), video_url)), 12) as last_video_url, ... substring(min(concat(lpad(video_id, 11, '0'), video_url)), 12) as first_video_url, ...;
select top 100 from master.dbo.spt_values order by rownum;
start, end, lasttokenend = -1, token;
end = end, ispairmatch = ispairmatch, isexecautoparamhelp = isexecautoparamhelp, sql = sql.substring(start, end - start + 1), token = (tokens)token, };
select 'drop procedure [' + schema_name(p.schema_id) + '].[' + p.name + '];' from sys.procedures p;
create procedure [dbo].[deleteallprocedures] as declare @schemaname varchar(500) where p.type = 'p' and is_ms_shipped = 0 and p.name not like 'sp[_]%diagram%' if @procname <> 'deleteallprocedures' end close cur;
select @sql=@sql+'drop procedure ['+name +'];' from sys.objects where type = 'p' and  is_ms_shipped = 0;
select 'drop procedure ' + p.name from sys.procedures p exec (@deleteproccommand) end ;
set @n = char(10) select @procedure = isnull( @procedure + @n, '' ) + from sys.procedures exec sp_executesql @procedure;
select name as procedure_name from sys.procedures;
from delallprocedures set @command='' set @command=@command+'drop procedure '+@procname from delallprocedures end close delallprocedures;
select @sql += n'drop procedure dbo.' where name like n'spname%' and schema_name(schema_id) = n'dbo';
exec sp_executesql @sql;
set @sql='' select @sql=@sql+'drop procedure ['+name +'];' from sys.objects where type = 'p' and  is_ms_shipped = 0;
set @sql= '' select @sql= @sql+ n'drop procedure "' + replace(specific_schema, n'"', n'""') + n'"."' + replace(specific_name, n'"', n'""') + n'"; ' from information_schema.routines where (1=1) and routine_type = 'procedure' and routine_name not in ( 'dt_adduserobject' );
select @sql = @sql + n'drop procedure ' + quotename(specific_schema) + n'.' + quotename(specific_name) + n';' + @linefeed from information_schema.routines where routine_type = 'procedure' and routine_name not in ( select name from sys.procedures where is_ms_shipped <> 0 );
from sys.procedures p end close cur;
select schema_name(schema_id) + '.' + name from sys.objects where type = 'p';
end close spcursor;
delete i1 from table i1 and i1.colo = i2.customer_invoice_id and i1.id < i2.id where i2.customer_invoice_id is not null;
drop temporary table if exists to_delete;
create temporary table to_delete as ( select -- escolhe todos os ids duplicados menos os que ficam na bd group_concat(id order by campos_ordenacao desc separator ','), length(group_concat(id order by campos_ordenacao desc separator ','))  from teste_dup having count(*) > 1 --  duplicado set session group_concat_max_len=4294967295;
select group_concat(ids separator ',') from to_delete into outfile 'sql.dat';
drop temporary table if exists del3;
create temporary table del3 as (select cast(1 as signed) as ix limit 0);
alter table del3 add index(ix);
delete teste_dup -- tabela from teste_dup -- tabela join del3 on id=ix;
create table tmp like mytable;
alter table tmp add unique index(text1, text2, text3, text4, text5, text6);
delete from mytable where id not in ( select id from tmp);
alter ignore table duptest add unique index(a,b);
select * from my_tbl order by text3 desc;
delete from dups where id not in( select id from ( select distinct id, text1, text2 from dups );
select distinct id, text1, text2, text3 from dups;
create table tmp like yourtable;
alter table tmp add unique (text1, text2);
drop table deleteme;
select * from table order by random() limit 1;
select * from table order by random() limit 1;
select foo from bar where id >= (abs(random()) % (select max(id) from bar)) limit 1;
select foo from bar where _rowid_ >= (abs(random()) % (select max(_rowid_) from bar)) limit 1;
select * from table where id in (select id from table order by random() limit x);
$qb->expr()->eq('o.bar', 1), $qb->expr()->eq('o.bar', 2);
where [...] and (field like '%abc%' or field like '%def%');
$qb->expr()->like('field', $qb->expr()->literal('%' . $pattern . '%'));
create function dbo.vavalidemail(@email varchar(100)) if (@email <> '' and @email not like '_%@__%.__%') set @bitretval = 0  -- invalid else set @bitretval = 1   -- valid end;
select * from users where dbo.vavalidemail(email) = 0;
select * from users where email not like '_%@__%.__%';
select * from people where email not like '%_@__%.__%';
select * from users where not and  left(ltrim([email]),1) <> '@' and  right(rtrim([email]),1) <> '.' and  charindex('.',[email],charindex('@',[email])) - charindex('@',[email]) > 1 and  len(ltrim(rtrim([email]))) - len(replace(ltrim(rtrim([email])),'@','')) = 1 and  charindex('.',reverse(ltrim(rtrim([email])))) >= 3 and  (charindex('.@',[email]) = 0 and charindex('..',[email]) = 0);
select email from loginuser where or patindex ('[@.-_]%', email) > 0   -- valid but cannot be starting character or patindex ('%[@.-_]', email) > 0   -- valid but cannot be ending character or email not like '%@%.%'   -- must contain at least one @ and one . or email like '%..%'        -- cannot have two periods in a row or email like '%@%@%'       -- cannot have two @ anywhere or email like '%.@%' or email like '%@.%' -- cant have @ and . next to each other or email like '%.cm' or email like '%.co' -- unlikely. probably typos or email like '%.or' or email like '%.ne' -- missing last letter;
select user_guid, user_guid email_address, creation_date, email_verified, active from user_data where or length(substring (email_address from '[@.-_]%')) > 0   -- valid but cannot be starting character or length(substring (email_address from '%[@.-_]')) > 0   -- valid but cannot be ending character or email_address not like '%@%.%'   -- must contain at least one @ and one . or email_address like '%..%'        -- cannot have two periods in a row or email_address like '%@%@%'       -- cannot have two @ anywhere or email_address like '%.@%' or email_address like '%@.%' -- cant have @ and . next to each other or email_address like '%.cm' or email_address like '%.co' -- unlikely. probably typos or email_address like '%.or' or email_address like '%.ne' -- missing last letter;
select * from `emails` where `email` not regexp '[-a-z0-9~!$%^&*_=+}{\\\'?]+(\\.[-a-z0-9~!$%^&*_=+}{\\\'?]+)*@([a-z0-9_][-a-z0-9_]*(\\.[-a-z0-9_]+)*\\.(aero|arpa|biz|com|coop|edu|gov|info|int|mil|museum|name|net|org|pro|travel|mobi|[a-z][a-z])|([0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}))(:[0-9]{1,5})?';
delete from `contatti` where `email` not like "%.it" and `email` not like "%.com" and `email` not like "%.fr" and `email` not like "%.net" and `email` not like "%.ru" and `email` not like "%.eu" and `email` not like "%.org" and `email` not like "%.edu" and `email` not like "%.uk" and `email` not like "%.de" and `email` not like "%.biz" and `email` not like "%.ch" and `email` not like "%.bg" and `email` not like "%.info" and `email` not like "%.br" and `email` not like "%.pt" and `email` not like "%.za" and `email` not like "%.vn" and `email` not like "%.es" and `email` not like "%.in" and `email` not like "%.dk" and `email` not like "%.ni" and `email` not like "%.ar";
create function [dbo].[isvalidemailformat] ( @emailaddress varchar(500) ) as begin set @emailaddress = ltrim(rtrim(@emailaddress));
select @result = case when and left(ltrim(@emailaddress),1) <> '@' and right(rtrim(@emailaddress),1) <> '.' and left(ltrim(@emailaddress),1) <> '-' and charindex('.',@emailaddress,charindex('@',@emailaddress)) - charindex('@',@emailaddress) > 2 and len(ltrim(rtrim(@emailaddress))) - len(replace(ltrim(rtrim(@emailaddress)),'@','')) = 1 and charindex('.',reverse(ltrim(rtrim(@emailaddress)))) >= 3 and (charindex('.@',@emailaddress) = 0 and charindex('..',@emailaddress) = 0) and (charindex('-@',@emailaddress) = 0 and charindex('..',@emailaddress) = 0) and (charindex('_@',@emailaddress) = 0 and charindex('..',@emailaddress) = 0) and isnumeric(substring(@emailaddress, 1, 1)) = 0 and charindex(',', @emailaddress) = 0 and charindex('!', @emailaddress) = 0 and charindex('-.', @emailaddress)=0 and charindex('%', @emailaddress)=0 and charindex('#', @emailaddress)=0 and charindex('$', @emailaddress)=0 and charindex('&', @emailaddress)=0 and charindex('^', @emailaddress)=0 and charindex('''', @emailaddress)=0 and charindex('\', @emailaddress)=0 and charindex('/', @emailaddress)=0 and charindex('*', @emailaddress)=0 and charindex('+', @emailaddress)=0 and charindex('(', @emailaddress)=0 and charindex(')', @emailaddress)=0 and charindex('[', @emailaddress)=0 and charindex(']', @emailaddress)=0 and charindex('{', @emailaddress)=0 and charindex('}', @emailaddress)=0 and charindex('?', @emailaddress)=0 and charindex('<', @emailaddress)=0 and charindex('>', @emailaddress)=0 and charindex('=', @emailaddress)=0 and charindex('~', @emailaddress)=0 and charindex('`', @emailaddress)=0 and charindex('.', substring(@emailaddress, charindex('@', @emailaddress)+1, 2))=0 and charindex('.', substring(@emailaddress, charindex('@', @emailaddress)-1, 2))=0 and len(substring(@emailaddress, 0, charindex('@', @emailaddress)))>1 and charindex('.', reverse(@emailaddress)) > 2 and charindex('.', reverse(@emailaddress)) < 5 then 1 else  0 end end;
select email from people where email like '%_@__%.__%' and patindex('%[^a-z,0-9,@,.,_]%', replace(email, '-', 'a')) = 0;
select email from people where not (email like '%_@__%.__%' and patindex('%[^a-z,0-9,@,.,_]%', replace(email, '-', 'a')) = 0);
create proc getemail @gmail varchar(22) as  set select @a=substring(@gmail,charindex('@',@gmail),len(@gmail)-charindex('@',@gmail)+1) if (@a = 'gmail.com) else  end;
create function [dbo].[f_isemail] ( @emailaddr varchar(360) -- email address to check as begin if @emailaddr is null or @emailaddr not like '[0-9a-za-z]%@__%.__%' or @emailaddr like '%@%@%' or @emailaddr like '%..%' or @emailaddr like '%.@' or @emailaddr like '%@.' or @emailaddr like '%@%.-%' or @emailaddr like '%@%-.%' or @emailaddr like '%@-%' or charindex(' ',ltrim(rtrim(@emailaddr))) > 0 set @afterlastdot=reverse(substring(reverse(@emailaddr),0,charindex('.',reverse(@emailaddr))));
if  len(@afterlastdot) not between 2 and 17 set @afterarobase=reverse(substring(reverse(@emailaddr),0,charindex('@',reverse(@emailaddr))));
if len(@afterarobase) not between 2 and 255 select top 1 @beforearobase=value from  string_split(@emailaddr, '@');
if len(@afterarobase) not between 2 and 255 select top 1 @hasdomaintoolong=1 from string_split(@afterarobase, '.') where len(value)>63 if @hasdomaintoolong=1 select @alphabetplus = 'abcdefghijklmnopqrstuvwxyz01234567890!#$%&*+-/=?^_`.{|}~' set @pos = @pos + 1 if @alphabetplus not like '%' + substring(@beforearobase, @pos, 1) + '%' set @ok = 0 end  if @ok=0 select @alphabetplus = 'abcdefghijklmnopqrstuvwxyz01234567890-.' set @pos = @pos + 1 if @alphabetplus not like '%' + substring(@afterarobase, @pos, 1) + '%' set @ok = 0 end  if @ok=0 end;
create function [dbo].[containsvailidemail] (@input varchar(250)) as begin else 0 end end;
select [dbo].[containsvailidemail] (email) from [dbo].[user];
create function [rec].[f_isemail] ( @emailaddr varchar(360) -- email address to check as begin if @emailaddr is null or @emailaddr not like '[0-9a-za-z]%@__%.__%' or @emailaddr like '%@%@%' or @emailaddr like '%..%' or @emailaddr like '%.@' or @emailaddr like '%@.' or @emailaddr like '%@%.-%' or @emailaddr like '%@%-.%' or @emailaddr like '%@-%' or charindex(' ',ltrim(rtrim(@emailaddr))) > 0 set @afterlastdot=reverse(substring(reverse(@emailaddr),0,charindex('.',reverse(@emailaddr))));
if  len(@afterlastdot) not between 2 and 17 set @afterarobase=reverse(substring(reverse(@emailaddr),0,charindex('@',reverse(@emailaddr))));
if len(@afterarobase) not between 2 and 255 select top 1 @beforearobase=value from  string_split(@emailaddr, '@');
if len(@afterarobase) not between 2 and 255 select top 1 @hasdomaintoolong=1 from string_split(@afterarobase, '.') where len(value)>63 if @hasdomaintoolong=1 select @alphabetplus = 'abcdefghijklmnopqrstuvwxyz01234567890!#$%&*+-/=?^_`.{|}~' set @pos = @pos + 1 if @alphabetplus not like '%' + substring(@beforearobase, @pos, 1) + '%' set @ok = 0 end  if @ok=0 select @alphabetplus = 'abcdefghijklmnopqrstuvwxyz01234567890-.' set @pos = @pos + 1 if @alphabetplus not like '%' + substring(@afterarobase, @pos, 1) + '%' set @ok = 0 end  if @ok=0 end;
select emailaddress as validemail from contacts where emailaddress like '%_@__%.__%' and patindex('%[^a-z,0-9,@,.,_,\-]%', emailaddress) = 0;
case when email not like  '%@xx%' and  email like  '%@%' and  char_length( otranslate( trim( email), '._-@0123456789abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz', '') then 'n' else 'y'  end as invalid_email_ind;
select email from employee where not regexp_like(email, [a-z0-9._%+-]+@[a-z0-9.-]+\.[a-z]{2,4}, i);
select * from calls c join users u or c.requestor_id = u.user_id where u.dept = 4;
select distinct * from ( select * from calls where a.dept = 4 union select * from calls where r.dept = 4;
select distinct * from (<your query>) as subquery;
select concat('select ''',table_name,''', count(*) from ', table_name, ' union all') from information_schema.tables where table_schema = 'clw';
set @tableschema = 'my_schema';
set session group_concat_max_len = 10000000;
set @rowcounts = ( select group_concat(concat('select ''',table_name,''', count(*) from ', table_name) separator ' union all ') from information_schema.tables where table_schema = @tableschema;
create database if not exists `admin`;
drop procedure if exists `database_tables_row_count`;
create procedure `database_tables_row_count`(in tableschema varchar(255)) if (select count(table_name) from information_schema.tables where table_schema = `tableschema`) = 0 then set msg = concat('unknown database \'', `tableschema`, '\'');
set session group_concat_max_len = 10000000;
set @rowcounts = ( select group_concat(concat('select ''',table_name,''' as `table`, count(*) as `row_count` from ', `tableschema`, '.', table_name) separator ' union all ') from information_schema.tables where table_schema = `tableschema` and table_type = 'base table' if @rowcounts is not null then else # if no base tables found then return an empty set select 1 where 0 = 1;
and table_type = 'base table';
and table_type in ('base table', 'view');
select group_concat(query separator ' union all ') as full_query from (select concat('select ''',table_name,''', count(*) from ', table_name) as query from information_schema.tables) as t1 into @sql from (select table_name tablename from information_schema.tables where table_schema not in;
select table_name, table_rows from   `information_schema`.`tables` where  `table_schema` = 'schema' and table_type = 'base table';
select concat("select '",table_name,"', count(*) from ",table_name,";") from `information_schema`.`tables` where `table_schema` = '[your schema here]';
select table_name, table_rows from information_schema.tables;
select table_name, table_rows from `information_schema`.`tables` where `table_schema` = 'your_db_name';
select sum(cnt) from ( select count(*) as cnt from table1 union all select count(*) as cnt from table2 union all select count(*) as cnt from table3;
update pedi_invoicedetail set doctotal = v.doctotal from pedi_invoicedetail ( select invoicenumber, sum(sale + vat) as doctotal from pedi_invoicedetail;
as ( select  invoicenumber, sum(sale + vat) as doctotal from    pedi_invoicedetail ) update pedi_invoicedetail set pedi_invoicedetail.doctotal = cte_doctotal.doctotal from cte_doctotal;
doctotal, sum(sale + vat) over(partition by invoicenumber) as newdoctotal from    pedi_invoicedetail ) update  t set     doctotal = newdoctotal;
as ( select sum(sale + vat) as doctotal_1 from pedi_invoicedetail ) update cte_doctotal set doctotal = cte_doctotal.doctotal_1;
union (select a from t2 where a=11 and b=2 order by a limit 10);
select * from union (select a from t2 where a=11 and b=2 order by a limit 10);
select distinct (select min(ti.country_id) from tbl_countries ti where t.country_title = ti.country_title) as country_id from tbl_countries t;
select country_id, country_title from ( select *, row_number() over (partition by country_title order by country_id) as rn from tbl_countries) t where rn = 1;
select t1.country_id, t1.country_title from tbl_countries t1 where t2.country_title is null;
select t1.country_id, t1.country_title from tbl_countries t1 where not exists (select 1 from tbl_countries t2 where t1.country_title = t2.country_title and t1.country_id > t2.country_id);
select distinct title,id from tbl_countries;
select min(id) as id, title from tbl_countries;
delete from products where rowid in ( select max(sl) from ( select itemcode, (rowid) sl from products where itemcode in ( select itemcode from products group by itemcode having count(itemcode)>1;
select country_id, country_title from (select country_id, country_title, case when country_title=lag(country_title, 1, 0) over(order by country_title) then 1 else 0 end as "duplicates" from tbl_countries) where "duplicates"=0;
select group_concat(column_name) from information_schema.columns where table_schema = 'computers' and;
select concat('select ', (select group_concat(column_name) from information_schema.columns where table_schema='computers' and;
select res2.* from (select res1.*,row_number() over(partition by res1.title order by res1.id)as num from (select * from [dbo].[tbl_countries])as res1 where res2.num=1;
select country_id,country_title from( select country_id,country_title,row_number() over (partition by country_title where rn=1;
if (schema_id('acme') is null) exec ('create schema [acme] authorization [dbo]') end;
if (schema_id('myschema') is not null) drop schema [myschema];
end  create schema [myschema] authorization [dbo];
if (not exists (select * from sys.schemas where name = 'acme')) exec ('create schema [acme] authorization [dbo]') end;
if (not exists (select * from sys.schemas where name = 'acme')) exec ('create schema [acme] authorization [dbo]') end;
create procedure sp_truncateifexists as begin if exists ( select 1 from information_schema.tables where table_name = @tablevariable ) set @query = 'truncate table ' + @tablevariable end end go;
create proc dbo.foo @start int as begin id    int, value varchar(20)) value) select id, value from   xtable where  id = @start;
end  exec dbo.foo @start set @start = @start + 1 end;
delete from @tablevariable;
set ansi_nulls on set quoted_identifier on create procedure [dbo].[clearouttable_p1] as  set @truncatesql = 'truncate table ' + @tablename if exists (select name from sys.all_objects where name = 'clearouttable_temp'and type = 'p') drop procedure [dbo].[clearouttable_temp] end  exec ('create procedure [dbo].[clearouttable_temp] as '+@truncatesql+'') exec [dbo].[clearouttable_temp] drop procedure [dbo].[clearouttable_temp];
delete @variabletable;
delete @variabletable;
select user_id, (case user_id when 1 then 1 else 0 end) as first_user from user;
select user_id, if(user_id = 1, 1, 0) as first_user from user;
select * from( select distinct on(availables.bookdate) `availables`.* from `availables` inner join `rooms` on `rooms`.id = `availables`.room_id where (rooms.hotel_id = 5056 and availables.bookdate between '2009-11-22' and '2009-11-24') or arel:;
select a,b,c,d,e from table group by a;
select distinct on (a) a,b,c,d,e from table order by a,b,c;
:joins => [ :room ], :conditions => [ "rooms.hotel_id = ? and availables.bookdate between ? and ?", hostel_id, date.to_s, (date+days-1).to_s ], :group => available.column_names.collect{|col| "availables.#{col}"}, :order => 'availables.updated_at');
select * from tablename where col_name like '%190';
set @newdata='ids_enum_change_262147_190' select reverse(substring(reverse(@newdata),0,charindex('_',reverse(@newdata))));
select reverse( --4. 0, charindex( -- 2. reverse(<field_name>) -- 1. ) ) ) from <table_name>;
select right(column, 3);
select right(rtrim(columnname), 3);
select substring(columnname, len(columnname)-2, 3);
select reverse(substring(reverse(columnname), 1, 3));
create table orders ( id serial not null primary key, info json not null values ( '{ "customer": "lily bush", "items": {"product": "diaper","qty": 24}}' ( '{ "customer": "josh william", "items": {"product": "toy car","qty": 1}}' ( '{ "customer": "mary clark", "items": {"product": "toy train","qty": 2}}';
select info -> 'customer' as customer from orders;
select info ->> 'customer' as customer from orders where info -> 'items' ->> 'product' = 'diaper';
create database testjsonxml;
create table testtbl1(id int identity,somexml xml);
create table testtbl2(id int identity,somejson nvarchar(max));
create table target1(somestring nvarchar(max));
create table target2(somestring nvarchar(max));
create table times(test varchar(10),diff int) select n'<root> from tally;
select n'{ "warranty": "1 year parts and labor" "productid": "' + cast(nmbr as nvarchar(10)) + '", "productname": "road bike" { "warranty": "1 year parts and labor" "productid": "' + cast(nmbr + 1 as nvarchar(10)) + '", "productname": "cross bike" from tally;
select somexml.value('(/root/products/productdescription/features/maintenance/text())[1]', 'nvarchar(4000)') from testtbl1;
select json_value(somejson, n'$.root.products.productdescription[0].features.maintenance') from testtbl2;
set @startdt = sysdatetime();
select somexml.value('(/root/products/productdescription/productname/text())[2]', 'nvarchar(4000)') from testtbl1 select 'xml',datediff(millisecond,@startdt,sysdatetime());
set @startdt = sysdatetime();
select json_value(somejson, n'$.root.products.productdescription[1].productname') from testtbl2 select 'json',datediff(millisecond,@startdt,sysdatetime());
select test,sum(diff) as sumtime, count(diff) as counttime from times drop database testjsonxml;
where a=1 and b=2;
drop table if exists person create table person value nvarchar(max) constraint [content should be formatted as json] check ( isjson(value)>0 ) );
drop table if exists person create table person (       constraint [email addresses must be formatted as json array] check ( isjson(emailaddresses)>0 ) );
alter table person add constraint [age should be number] check ( isnumeric(json_value(value, '$.age'))>0 ) alter table person add constraint [person should have skills] check ( json_query(value, '$.skills') is not null) values ('{"age": "not a number", "skills":[]}') values ('{"age": 35}');
create table person   ) values (compress(@json));
select user.id as user_id;
select actionname from [useraction] where userid = @userid;
index = order.find_index(:id) index = arrangement.length - 1 end  end end end;
end  end end end;
end end  end  end end;
select  "users".* from "users" order by name asc limit $1 offset $2  [["limit", 3], ["offset", 2];
end records = self.order(created_at: :desc).where('id < ?', records.last.id).limit(batch_size) end end end;
end records = self.order(id: :desc).where('id < ?', records.last.id).limit(batch_size) end end end  end;
drop table if exists `example`.`numbers`;
create table  `example`.`numbers` ( `id` int(10) unsigned not null auto_increment, primary key  (`id`);
values ( null );
select `x`.* from (select date_add('2010-06-06', interval `n`.`id` - 1 day) from `numbers` `n` where date_add('2010-06-06', interval `n`.`id` -1 day) <= '2010-06-14' ) x;
select `x`.`ts` as `timestamp`, coalesce(`y`.`score`, 0) as `cnt` from (select date_format(date_add('2010-06-06', interval `n`.`id` - 1 day), '%m/%d/%y') as `ts` from `numbers` `n` where date_add('2010-06-06', interval `n`.`id` - 1 day) <= '2010-06-14') x;
-- anchor select '2010-08-01' dt union all -- recursion with stop condition select dt + interval 1 day from all_dates where dt + interval 1 day <= '2010-08-15' ) select * from all_dates;
-- anchor select '2010-08-01' dt union all -- recursion with stop condition select dt + interval 1 day from all_dates where dt + interval 1 day <= '2010-08-15' ) select d.dt date, coalesce(t.score, 0) score from all_dates d;
select a.days from ( select from_unixtime( floor( unix_timestamp() / (15 * 60) ) * (15 * 60)) - interval 15 * (a.a + (10 * b.a) + (100 * c.a)) minute as days from       (select 0 as a union all select 1 union all select 2 union all select 3 union all select 4 union all select 5 union all select 6 union all select 7 union all select 8 union all select 9) as a where a.days >= curdate() - interval 30 day;
select if(score is null, 0, score) as score, b.days as date from (select a.days from ( select curdate() - interval (a.a + (10 * b.a) + (100 * c.a)) day as days from       (select 0 as a union all select 1 union all select 2 union all select 3 union all select 4 union all select 5 union all select 6 union all select 7 union all select 8 union all select 9) as a where a.days >= curdate() - interval 30 day) b;
select if(score is null, 0, score) as score, b.days as date;
from ( select curdate() - interval (a.a + (10 * b.a) + (100 * c.a)) day as days from       (select 0 as a union all select 1 union all select 2 union all select 3 union all select 4 union all select 5 union all select 6 union all select 7 union all select 8 union all select 9) as a where a.days >= curdate() - interval 30 day) b;
visualizations values (null);
join [table] on ...;
select * from table where id between 1 and 100;
select floor(datediff (now(), birthday)/365) as age;
select *,year(curdate())-year(dob) - (right(curdate(),5) < right(dob,5)) as age from your_table;
select year(current_timestamp) - year(dob) - (right(current_timestamp, 5) < right(dob, 5)) as age from your_table;
select datediff(current_date, str_to_date(t.birthday, '%d-%m-%y'))/365 as ageinyears from your_table t;
set @birthday = cast('1980-05-01' as date);
set @today = current_date();
select year(@today) - year(@birthday) - then 1 else 0;
drop function if exists getidade;
create function getidade( data_nascimento datetime ) set ano_atual = year(curdate());
set mes_atual = month( curdate());
set dia_atual = day( curdate());
set ano = year( data_nascimento );
set mes = month( data_nascimento );
set dia = day( data_nascimento );
set idade = ano_atual - ano;
set idade = idade - 1;
set idade = idade - 1;
select getidade('1983-09-16');
select getidade(substring_index('1983-09-16 23:43:01', ' ', 1));
select date_format(now(), '%y') - date_format(date_of_birth, '%y') - as age from table;
db::raw("floor(datediff(current_date, str_to_date(users.birthdate, '%y-%m-%d'))/365) as age_way_one"),;
select year(now()) - year(dob) - ( dayofyear(now()) < dayofyear(dob) ) as age from table where ...;
create function `f_age`(in_dob datetime) returns int(11) if date_format(now(  ),'00-%m-%d') >= date_format(in_dob,'00-%m-%d') then set l_age=date_format(now(  ),'%y')-date_format(in_dob,'%y');
else -- yet to have a birthday this year set l_age=date_format(now(  ),'%y')-date_format(in_dob,'%y')-1;
select f_age('1979-02-11') as age;
select f_age(date) as age from table;
select timestampdiff(year, '1970-02-01', curdate()) as age;
select birthdate, (year(curdate())-year(birthdate)) as age from `member`;
select timestampdiff (year, your_column, curdate()) from your_table as age;
select ifnull(max(x), 0) as maxx from tbl where xid = 1;
select isnull(max(x), 0) as maxx from tbl where xid = 1;
select ifnull(max(x), 0, max(x)) as maxx from tbl where xid = 1;
select case max(x) when null then 0 else max(x) from tbl where xid = 1;
select coalesce(max(x), 0) as maxx from tbl where xid = 1;
select coalesce(max(x),0) as maxx from tbl where xid = 1;
select nvl(max(x), 0) as maxx from tbl where xid = 1;
select iif(max(faculty_id) is null,0,max(faculty_id)) as max_faculty_id from faculties;
update table set datetimecol = dateadd(day, (abs(checksum(newid())) % 65530), 0);
create view vrandnumber as select rand() as randnumber create function randnumber(@min int, @max int) as begin end go update table1 set thedate = dateadd(d,0-dbo.randnumber(1,365),getdate());
set @date_from = '1985-10-14';
set @date_to = '2009-04-27';
update fiscalyear set startdate = ( -- remember, we want to add a random number to the ( -- this will force our random number to be >= 0. ( -- this will give us a huge random number that ) ) );
select dateadd(day, abs(checksum(newid()) % 3650), '2000-01-01') from your_table;
update your_table set your_date_field = dateadd(day, abs(checksum(newid()) % 3650), '2000-01-01') where your_conditions;
update table set time= dateadd(d, round(datediff(d, '2010-01-01', '2013-12-31') * rand(checksum(newid())), 0), dateadd(second,checksum(newid())%48000, '2010-01-01'));
set [birth date] = dateadd(day, (abs(checksum(newid())) % 16250), '1940-1-1 00:00:00.001');
select @daysrandom= datediff(day,@datefrom,@dateto) select @daysrandom = round(((@daysrandom -1) * rand()), 0) select @millisrandom = round(((99999999) * rand()), 0) select @dateto = dateadd(day, @daysrandom, @datefrom) select @dateto = dateadd(millisecond, @millisrandom, @dateto) select @dateto;
select dateadd(day, (abs(checksum(newid())) % 3650) * -1, getdate());
update yourtablename set yourdatetiemcolumnname = dateadd(millisecond, @milliseconds, dateadd(second, @random, @fromdate)) where id = @rank set @rank = @rank + 1;
select  priority, coalesce(cnt, 0) from    ( select  1 as priority union all select  2 as priority union all select  3 as priority union all select  4 as priority union all select  5 as priority ( select  priority, count(*) as cnt from    jobs priority;
select jobid, jobname, sum(priority1) as priority1, sum(priority2) as select jobid, jobname, case when priority = 1 then 1 else 0 end as priority1, case when priority = 2 then 1 else 0 end as priority2, case when priority = 3 then 1 else 0 end as priority3, case when priority = 4 then 1 else 0 end as priority4, case when priority = 5 then 1 else 0 end as priority5 from tablename );
select jobid, jobname, sum(case when priority = 1 then 1 else 0 end) as priority1, sum(case when priority = 2 then 1 else 0 end) as priority2, sum(case when priority = 3 then 1 else 0 end) as priority3, sum(case when priority = 4 then 1 else 0 end) as priority4, sum(case when priority = 5 then 1 else 0 end) as priority5 from jobs jobid, jobname;
select t.jobid, t.jobname, count(p1.jobid) as priority1, count(p2.jobid) as priority2, count(p3.jobid) as priority3, count(p4.jobid) as priority4, count(p5.jobid) as priority5 from thetable t t.jobid, t.jobname;
select jobid, jobname, sum(case priority when 1 then 1 else 0 end) as priority1, sum(case priority when 2 then 1 else 0 end) as priority2, sum(case priority when 3 then 1 else 0 end) as priority3, sum(case priority when 4 then 1 else 0 end) as priority4, sum(case priority when 5 then 1 else 0 end) as priority5 from thetable jobid, jobname;
select jobid, jobname, count(case when priority=1 then 1 end) as priority1, count(case when priority=2 then 1 end) as priority2, count(case when priority=3 then 1 end) as priority3, count(case when priority=4 then 1 end) as priority4, count(case when priority=5 then 1 end) as priority5 from tablename;
select count(student_id) as 'studentcount' from coursesemone where student_id=3 having count(student_id) < 6 and count(student_id) > 0;
select jobid, jobname,  count(iif (priority=2, 1, null)) as priority2, count(iif (priority=3, 1, null)) as priority3, count(iif (priority=4, 1, null)) as priority4, count(iif (priority=5, 1, null)) as priority5 from tablename;
select *  from table order  by datetime(datetimecolumn) desc limit 1;
select * from data order by strftime('%s', date_column) desc;
select * from table order by date(datecolumn) desc limit 1;
select * from table order by datecolumn desc limit 1;
select * from 'repair' order by "date" desc;
select * from table julianday(datecolumn) desc limit 1;
update table_name set column_name = replace(column_name,"search str","replace str");
update schemname.tablename t set t.columnname = replace(t.columnname, t.oldvalue, t.newvalue);
update table-name set column-name = replace(table-name.column-name, 'string-to-replace', 'replacement-string');
select replace(t.column, 'est1', 'rest1') from my_table t;
update my_table t set column = replace(t.column, 'est1', 'rest1');
select  case when serverproperty('editionid') = -1253826760 then 'desktop' end as 'edition';
select @@version;
select serverproperty('edition');
select serverproperty('editionid');
select serverproperty('edition');
select serverproperty('productversion') as 'product version', serverproperty('productlevel') as 'product level', serverproperty('edition') as 'product edition', serverproperty('buildclrversion') as 'clr version', serverproperty('collation') as 'default collation', serverproperty('instancename') as 'instance', serverproperty('lcid') as 'lcid', serverproperty('servername') as 'server name';
default collation     instance   lcid   server name;
create type mytable as table ( foo int, bar int select *, sys.fn_physlocformatter(%%physloc%%) as [physloc] from @t exec sp_executesql sys.fn_physlocformatter(%%physloc%%) as [physloc] from @t', n'@t mytable readonly', @t=@t;
create table #t (id int) set @value = n'1' set @sql = n'insert into #t (id) values (' + @value + n')' exec (@sql) select * from #t drop table #t;
update r set assoc_item_1 = case when @curr_row = 1 then foo.relsku else assoc_item_1 end, assoc_item_2 = case when @curr_row = 2 then foo.relsku else assoc_item_2 end, assoc_item_3 = case when @curr_row = 3 then foo.relsku else assoc_item_3 end, assoc_item_4 = case when @curr_row = 4 then foo.relsku else assoc_item_4 end, assoc_item_5 = case when @curr_row = 5 then foo.relsku else assoc_item_5 end, ... from (select relsku from @tsku where tid = @curr_row1) foo where r.rowid = @curr_row;
create procedure rafcustom_room_getrelatedproducts;
if object_id('tempdb..##relpro', 'u') is not null drop table ##relpro end  create table ##relpro ( rowid int identity(1,1), id int, item_name nvarchar(max), sku nvarchar(max), vendor nvarchar(max), product_img_180 nvarchar(max), rpgroup int, assoc_item_1 nvarchar(max), assoc_item_2 nvarchar(max), assoc_item_3 nvarchar(max), assoc_item_4 nvarchar(max), assoc_item_5 nvarchar(max), assoc_item_6 nvarchar(max), assoc_item_7 nvarchar(max), assoc_item_8 nvarchar(max), assoc_item_9 nvarchar(max), assoc_item_10 nvarchar(max) select distinct zp.productid, zp.name, zp.sku, (select m.name from znodemanufacturer m(nolock) where m.manufacturerid = zp.manufacturerid), 'http://s0001.server.com/is/sw11/dg/' + from product zp(nolock) inner join rf_extendedproduct ep(nolock) on ep.productid = zp.productid where zp.activeind = 1 and substring(zp.sku, 1, 2) <> 'gc' and zp.name <> 'platinum' and zp.sku = (case when @product_sku is not null then @product_sku else zp.sku end) end  @tot_rows int= 0, @sku nvarchar(15) = null;
if object_id('tempdb..##tsku', 'u') is not null drop table ##tsku end create table ##tsku (tid int identity(1,1), relsku nvarchar(15));
select @curr_row = (select min(rowid) from ##relpro);
select @tot_rows = (select max(rowid) from ##relpro);
select @sku = sku from ##relpro where rowid = @curr_row;
select distinct top(10) tzp.sku from product tzp(nolock) inner join where (assoc.isactive=1) and (tzp.activeind = 1) and (assoc.productid = @sku) @tot_rows1 int = (select max(tid) from ##tsku);
@sqlstat nvarchar(500) = null;
set @col_name =  'assoc_item_' + convert(nvarchar(2), @curr_row1);
set @sqlstat = 'update ##relpro set ' + @col_name + ' = (select relsku from ##tsku where tid = ' + convert(nvarchar(2), @curr_row1) + ') where rowid = ' + convert(nvarchar(2), @curr_row);
set @curr_row1 = @curr_row1 + 1;
end end set @curr_row = @curr_row + 1;
end  select * from ##relpro;
create table #tempjoin ( old_id int, new_id int);
set @table_name = 'object';
set @strsql='insert into '+@table_name+' select '+@columns+' from #tempjoin cj;
@recapd_number_key char(10), @census_sub_code varchar(1), @recapd_field_name char(100), @recapd_table_name char(100), @number_key varchar(10),  if object_id('[permits].[dbo].[mytempapd_txt]') is not null drop table [permits].[dbo].[mytempapd_txt] create table [permits].[dbo].[mytempapd_txt] ( [mycol1] char(10) null, [mycol2] char(1) null,  ) set @strsqlmain = ('insert into mytempapd_txt select [number_key], '+ rtrim(@recapd_field_name) +' from '+ rtrim(@recapd_table_name) + ' where number_key = '''+ rtrim(@number_key) +'''') exec (@strsqlmain) select @recapd_number_key = mycol1, @census_sub_code = mycol2 from [permits].[dbo].[mytempapd_txt] drop table [permits].[dbo].[mytempapd_txt];
create extension;
create extension dblink;
create extension dblink schema extensions;
create extension dblink;
select pg_namespace.nspname, pg_proc.proname from pg_proc, pg_namespace where pg_proc.pronamespace=pg_namespace.oid and pg_proc.proname like '%dblink%';
select dblink_connect('host=localhost user=postgres password=enjoy dbname=postgres');
select @a=0, @b=1, @i=0, @c=0 set @c=@a+@b set @i=@i+1 set @a=@b set @b=@c end;
as ( -- anchor member definition select 0 as recursionlevel, 0 as fibonaccinumber, 1 as nextnumber union all -- recursive member definition select a.recursionlevel + 1       as recursionlevel, a.nextnumber           as fibonaccinumber, a.fibonaccinumber + a.nextnumber as nextnumber from fibonaccinumbers a where a.recursionlevel < 10 ) select 'f' + cast( fn.recursionlevel as varchar) as fibonacciordinal, fn.fibonaccinumber, fn.nextnumber from fibonaccinumbers fn;
having count(*) > 1;
select sum(count) from (select count(`table_name`.`id`) as `count` from `table_name` where {some condition} group by {some_column} having count(`table_name`.`id`) > 1) as `tmp`;
select sum(count) from (select count(`table_name`.`id`) as `count` from `table_name` where `table_name`.`name` is not null and `table_name`.`name` != '' group by `table_name`.`name` having count(`table_name`.`id`) > 1) as `tmp`;
select sum(t1.cnt) from from table group by column having count(column) > 1) as t1 ;
select max(groupname) [name], max(aux2)[type], count(0) [count], sum(count(0)) over(partition by groupid) as [total] from [myview] where active=1 and type='app' and completed=1 and [date] between '01/01/2014' and getdate() and id = '5b9xxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx' and groupid is not null;
select @@rowcount;
as ( select col_name, count(*) as ctn from tab_name group by col_name having count(col_name)>1 ) select sum(ctn) from c;
select nvl(name, 'sum'), count(*) from table;
select sum(count) from (select name, count(name) as count from yourtable;
select name, count(id) as count from table group by name;
select name, count(1) as cnt from table1 union all select 'sum' name, count(1) from table1;
select case when (grouping(name) = 1) then 'sum' else isnull(name, 'unknown') end name, count(1) as cnt from table1;
select name, count(name) as count from table union all  select 'sum' name, count(name) from table;
select name, count(*) as count from yourtable group by name union all select "sum" as name, count(*) as count from yourtable;
select name, count(name) as count from yourtable union select 'sum' , count(name) from yourtable;
select  isnull(name,'sum'), count(*) as count from table_name;
select isnull([name],'sum'),count([name]) as count from tablename;
select name, count(name) as count, sum(count(name)) over() as total_count from table group by name;
create index ix_a_wxy on a (fieldw, fieldx, fieldy);
select fieldx, fieldy from a where fieldw = 108 union all select fieldx, fieldy from a where fieldw = 109;
select a.fieldx, a.fieldy from ( select fieldw = 108 union select fieldw = 109 union select fieldw = 113 union select fieldw = 891 join a a on a.fieldw = _a.fieldw;
create type [dbo].[udt_int] as table ( [id] [int] not null );
select fieldx, fieldy from a;
select * from tablea a tableb b tablec c;
select * from dbo.tablea a;
select * from tablea a;
select * from tablea join tableb on tablea.primary_key = tableb.foreign_key join tableb on tableb.foreign_key = tablec.foreign_key;
update my_table set data = replace(data::text, ',"attrb":' || (data->'attrb')::text, '')::json;
create or replace function remove_key(json_in json, key_name text) end loop;
select remove_key(('{"name":"my name", "items" :[{ "id" : 1, "name" : "name 1"}, { "id" : 2, "name 2" : "item2 name"}]}')::json, 'name');
create or replace function set_key(json_in json, key_name text, key_value text) end loop;
select jsonb '{"a":1,"b":2}' - 'a', -- will yield jsonb '{"b":2}';
select '{"a":[null,{"b":[3.14]}]}' #- '{a,1,b,0}';
select data::text::json as before, ('{' || array_to_string(array_agg(to_json(l.key) || ':' || l.value), ',') || '}')::json as after from (values ('{"attra":1,"attrb":true,"attrc":["a","b","c"]}'::json)) as v(data), lateral (select * from json_each(data) where "key" <> 'attrb') as l;
create or replace function "json_object_delete_keys"("json" json, variadic "keys_to_delete" text[]) as $function$ select coalesce( (select ('{' || string_agg(to_json("key") || ':' || "value", ',') || '}') from json_each("json") where "key" <> all ("keys_to_delete")), '{}';
update my_table set data = json_object_delete_keys(data, 'attrb');
select '{"a": {"key":"value"}, "b": 2, "c": true}'::jsonb - 'a';
update my_table set data = data - 'attrb';
create or replace function delete_mytable_data_key( _id integer, _key character varying) update my_table set where id = _id;
select '{"a": true, "c": true}'::jsonb || '{"a": false, "b": 2}'::jsonb;
create function remove_multiple_keys(in object jsonb, variadic keys_to_delete text[], out jsonb) as $$ select jsonb_object_agg(key, value) from (select key, value from jsonb_each("object") where not (key = any("keys_to_delete"));
select remove_multiple_keys(my_json_object, variadic (select array_agg(keys) from table_with_keys));
select '{"a": "b"}'::jsonb - 'a';
select '{"a": "b"}'::jsonb #- '{a}';
select '{"foo": 10, "bar": [], "baz": {}}'::jsonb #- '{baz}';
update table_to_update t set jsoncolumnwitharray = (select json_agg(jsonitem) from (select json_array_elements(t1.jsoncolumnwitharray)::jsonb #- '{customerchange, oldperiod}' as jsonitem from table_to_update t1 where t1.id = t1.id) as t2);
"oldperiod": null { "oldperiod": null;
update sometable t set somefield = newvalue from ( select id, json_object_agg(l.key, l.value)::text as newvalue from sometable t, lateral ( select * from json_each(t.somefield::json) where "key" <> all (array['key1', 'key2', 'key3']) where t.id = upd.id;
create table mytable ( id serial primary key, somefield text;
select * from test where date between '2011-01-11' and '2011-08-11';
select * from test where strftime('%y-%m-%d', date) between "11-01-2011" and "11-08-2011";
select * from test where date(date) between date('2011-01-11') and date('2011-8-11');
select * from tablename where julianday(substr(date,7)||'-'||substr(date,4,2)||'-'||substr(date,1,2)) between julianday('2011-01-11') and julianday('2011-08-11');
select * from tablename where julianday( substr(substr(date, instr(date, '/')+1), instr(substr(date, instr(date, '/')+1), '/')+1) case when length( substr(date, instr(date, '/')+1, instr(substr(date, instr(date, '/')+1),'/')-1) then substr(date, instr(date, '/')+1, instr(substr(date, instr(date, '/')+1), '/')-1) else '0'||substr(date, instr(date, '/')+1, instr(substr(date, instr(date, '/')+1), '/')-1) end ||'-'|| case when length(substr(date,1, instr(date, '/')-1 )) =2 then substr(date,1, instr(date, '/')-1 ) else '0'||substr(date,1, instr(date, '/')-1 ) end ) between julianday('2015-03-14') and julianday('2015-03-16');
create or replace;
drop trigger if exists yourtrigger_name on "yourschemaname"."yourtablename";
create or replace function trigger_function;
if not exists(select * from information_schema.triggers where event_object_table = 'table_name' and trigger_name = 'trigger_name' ) then create trigger trigger_name after insert on table_name for each row execute procedure trigger_function();
drop trigger if exists my_trigger create trigger my_trigger;
create (trigger, type , ...);
create trigger trigger_workidexist end $$;
if (null != value);
if p_retailerid.length = 0 or p_retailerid = "0" then else sqlparam.value = p_retailerid end if;
alter table tablename add primary key (id)           ---or drugid, whichever you want it to be pk;
alter table your_table add primary key (drugid);
alter table table_name add constraint myprimarykey primary key(column);
database --> table_name --->structure --->action  ---> primary -->click on primary;
select name from customers union all select 'jason';
select  age, name from    users union select  25 as age, 'betty' as name;
select name from users union [all] select 'jason';
select name from user union [all] select 'jason' from dual;
select ticketid, listagg(person, ', ') people from table group by ticketid;
as ( select ticketid, person, row_number() over (partition by ticketid order by person) "rownum", count(*) over (partition by ticketid) "count" from table ) select ticketid, ltrim(sys_connect_by_path(person,','),',') people from data where "rownum" = "count" and prior "rownum" = "rownum" - 1 ticketid;
select t.ticketid, stuff(isnull((select ', ' + x.person from @tickets x where x.ticketid = t.ticketid isnull((select ', ' + x.person from @tickets x where x.ticketid = t.ticketid from @tickets t;
select ticketid, group_concat(person order by person separator ', ') people from table group by ticketid;
select distinct t.ticketid, stuff((select ', ', i.person as [text()] from @tickets i where i.ticketid = t.ticketid from @tickets t;
select distinct t.ticketid, stuff((select ', ' + i.person    /* notice this line is different */ from @tickets i where i.ticketid = t.ticketid from @tickets t;
[ticketid] char(5) not null, [person] nvarchar(15) not null ) ('t0001', 'bob'), ('t0002', 'catherine'), ('t0002', 'doug'), ('t0003', 'elaine') select * from @tickets select [ticketid], stuff((select ',' + person from @tickets where ( ticketid=result.ticketid) for xml path ('')),1,1,'') as batchnolist from @tickets as result;
select mt.* from mytable mt inner join ( select id, min(record_date) as mindate from mytable;
select id, min(record_date), other_cols from mytable;
select t.* from (select m.*, @g := 0 from mytable m --here i have a big query where (1 = case when @g = 0 or @g <> id then 1 else  0 end ) and (@g := id) is not null;
select categoryid, productid, productname, unitprice from products a where unitprice = ( select min(unitprice) from products b where b.categoryid = a.categoryid);
select t2.id,t2.record_date,t2.other_cols from (select row_number() over(partition by id order by record_date)as rownum,id,record_date,other_cols from mytable)t2 where t2.rownum = 1;
select department, min_salary, (select s1.last_name from staff s1 where s1.salary=s3.min_salary ) lastname from (select department, min (salary) min_salary from staff s2 group by s2.department) s3;
select * from t t1 where record_date = ( select min(record_date) from t t2 where t2.group_id = t1.group_id);
and key_id = (select min(key_id) from t t3 where t3.record_date = t1.record_date and t3.group_id    = t1.group_id);
select workordernum, min(date) from workorders where date >= to_date('2015-01-01','yyyy-mm-dd') workordernum;
select * from ( select row_num() over (partition by id order by record_date, other_cols) as rownum, * from products p where rownum = 2;
create trigger "give trigger name" after insert on "table name";
create trigger `cisterna_bupd` before update on `cisterna` for each row if old.id_cisterna_estado<>new.id_cisterna_estado or old.observacion_cisterna_estado<>new.observacion_cisterna_estado or old.fecha_cisterna_estado<>new.fecha_cisterna_estado then  end if;
drop trigger if exists `my_trigger_name`;
create trigger `my_trigger_name` after update on `my_table_name` for each row if !(old.a <=> new.a and old.b <=> new.b) then `a`, `b` new.`a`, new.`b` end if;
select if(1<>null,1,0);
update foo set b = 3 where a=3 and b <> 3;
if new.a <> old.a or new.b <> old.b /* etc, all the way to new.z <> old.z */ then insert into bar (a, b) values(new.a, new.b) ;
if new.ts <> old.ts then insert into bar (a, b) values(new.a, new.b) ;
create table foo (a int, b int, ts timestamp);
create table bar (a int, b int);
create trigger ins_sum after update on foo if new.ts <> old.ts then end if;
select * from foo;
update foo set b = 3 where a = 3;
select * from foo where a = 3;
select * from bar;
update foo set b = 4 where a=3;
select * from foo;
select * from bar;
from u in db.programlocations join b in db.programs from y1 in yg.defaultifempty() where y1 == null select u.programid;
from u in db.programlocations select u.programid;
join pl in programlocations from pl in pp.defaultifempty() where pl == null select p;
join pl in programlocations from pl in pp.defaultifempty() where pl == null select p;
programname = "scary lesson" programid = p.programid, programlocationname = "haunted house" programname = "terrifying teachings" programid = p.programid, programlocationname = "mystical mansion" programname = "unassociated program";
select pfa.petid, pt.pettypedesc, pfa.petname, pf.petowner, pf.remarks, pat.adoptedby from dbo.petforadoption pfa join dbo.petadoptiontran pat join dbo.pettypes pt join dbo.petprofile pf;
create table data ( id integer not null auto_increment, key varchar(255), data text, ;
select id, password from user where email_address = "xyz@xyz.com";
select id, password from user where email_address = "xyz@xyz.com";
select parent_id, -- user id from items where spec_id = 3 -- make sure this is a 'password' item and parent_id in select id from items where spec_id = 1 -- make sure this is a 'user' item and id in select parent_id -- id of the parent item of the 'email_address' item from items where spec_id = 2 -- make sure this is a 'email_address' item and data = "xyz@xyz.com" -- with the desired data value ) );
select parent_id, data from items where spec_id = (select id from specs where name = "password") and parent_id in ( select id from items where spec_id = (select id from specs where name = "user") and id in ( select parent_id from items where spec_id = (select id from specs where name = "email_address") and data = "xyz@xyz.com" ) );
create definer=`root`@`localhost` procedure `sp_create_server_user`( in p_server_id varchar(100), in p_db_user_pw_creds varchar(32), in p_premium_status_name varchar(100), in p_premium_status_limit int, in p_user_tag varchar(255), in p_first_name varchar(50), in p_last_name varchar(50) ) select errno as mysql_error;
select ... for share/update;
if ($handle) { if (substr(rtrim($query), -1) === ';') {;
create table foo ( string varchar(100) create procedure simpleproc (out param1 int) select count(*) into param1 from foo;
if (substr(rtrim($query), -1) == ';'){;
if (($i != ($linecount - 1)) || (strlen($lines[$i]) > 0)) if (isset($lines[$i][0]) && $lines[$i][0] != "#") else { if (($i != ($token_count - 1)) || (strlen($tokens[$i] > 0))) // which means they're escaped quotes. if (($unescaped_quotes % 2) == 0) else { // which means they're escaped quotes. if (($unescaped_quotes % 2) == 1) else {;
if (substr(rtrim($query), -1) == ';'){;
if (!$link) { if (is_file($sqlfile) === true) { if (is_resource($sqlfile) === true) { if (preg_match('~' . preg_quote($sqldelimiter, '~') . '\s*$~is', end($query)) === 1) { if (mysql_query($query) === false) { if (is_string($query) === true) {;
if (substr($line, 0, 2) == '--' || $line == '') if (substr(trim($line), -1, 1) == ';');
if ($line != '' && strpos($line, '--') === false) { if (substr($query, -1) == ';') {;
if ($isfirstrow) { if (trim($row) == '' || preg_match('/^\s*(#|--\s)/sui', $row)) { if (preg_match('/^delimiter\s+[^ ]+/sui', $row)) { if (isquoted($delimiteroffset, $row)) { if (strlen($sql) > 0) { if ($ismulticomment) { if (preg_match('#\*/#sui', $sql)) { if (isquoted($foundon, $sql)) { if (substr($comment, 0, 2) == '/*') { if ($closedon !== false) { if ($offset > strlen($text)) if ($text[$i] == "'") if ($text[$i] == "\\" && $isquoted) if (!$query = $mysqli->query($sql)) {;
else if($cmd4 == "drop") else if(($cmd6 == "insert") || ($cmd6 == "create"));
if (substr(rtrim($query), -1) == ';'){;
if (substr(rtrim($query), -1) == ';'){;
if (!mysql_errno() && @mysql_num_rows($result) > 0) { else { if (preg_match("/(\w|\w)+`(\w|\w)+) {;
if ($mysqli->multi_query($sql)) {;
if (!empty($distilled)) {;
create table foo( bar varchar(80), baz int not null);
create table foo(bar varchar(80), baz int not null);
if ($commentstart !== false) { if (strlen($line)) { if (substr($statement, -1) == ";") { else {;
update table set column = replace(column, 'find value', 'replacement value') where xxx;
update versionedfields set value = replace(value,'<iframe','<a><iframe') update versionedfields set value = replace(value,'> </iframe>','</a>');
update versionedfields set value = replace(replace(value,'<iframe','<a>iframe'), '> </iframe>','</a>');
select my_num*5 as another_number from ( select 10 as my_num from table;
create view table10 as select 10 as my_num from table;
select my_num * 5 as another_number from table10;
select 10 as my_num, 10 * 5 as another_number from table;
select 10 as my_num, (select my_num) * 5 as another_number from table;
select my_num, my_num*5 as another_number from table;
exec tempdb..sp_help #temptable;
exec tempdb..sp_columns '#temptable';
select * from tempdb.information_schema.columns where table_name in ( select name from tempdb.sys.tables where object_id=object_id('tempdb.dbo.#temptable') select * from tempdb.sys.columns where object_id=object_id('tempdb.dbo.#temptable');
select * from tempdb.sys.tables where object_id=object_id('tempdb.dbo.#temptable');
exec tempdb.dbo.sp_help n'#temp';
select * from tempdb.sys.columns where [object_id] = object_id(n'tempdb..#temp');
exec tempdb..sp_help #temp;
exec tempdb.dbo.sp_help @objname = n'#temp';
select [column] = c.name, [type] = t.name, c.max_length, c.precision, c.scale, c.is_nullable from tempdb.sys.columns as c and t.system_type_id = t.user_type_id where [object_id] = object_id(n'tempdb.dbo.#temp');
select name, system_type_name, is_nullable from sys.dm_exec_describe_first_result_set(n'select a.col2, b.col1... from ...;',null,1);
select * from [sys].[dm_exec_describe_first_result_set] (n'select object_id, name, type_desc from sys.indexes', null, 0);
select cols.name from tempdb.sys.columns cols join sys.types ty on cols.user_type_id = ty.user_type_id where object_id = object_id('tempdb..#temp');
select top 10 * from db.dbo.mytable set @tablename = '#temp' select case data_type else column_name + ' ' + data_type end +  case when is_nullable <> 'yes' then ' not null' else '' end 'datatype' from information_schema.columns where table_name like @tablename + '%' set @result = '' select @result = @result + [val] + n',' from @tmp where val is not null set @result = substring(@result, 1, (len(@result)-1)) set @result = replace(@result, '-1', 'max') select @result;
select activity.pid, activity.usename, activity.query, blocking.pid as blocking_id, blocking.query as blocking_query from pg_stat_activity as activity join pg_stat_activity as blocking on blocking.pid = any(pg_blocking_pids(activity.pid));
create view lock_monitor as( select coalesce(blockingl.relation::regclass::text,blockingl.locktype) as locked_item, now() - blockeda.query_start as waiting_duration, blockeda.pid as blocked_pid, blockeda.query as blocked_query, blockedl.mode as blocked_mode, blockinga.pid as blocking_pid, blockinga.query as blocking_query, blockingl.mode as blocking_mode from pg_catalog.pg_locks blockedl join pg_stat_activity blockeda on blockedl.pid = blockeda.pid join pg_catalog.pg_locks blockingl on( ( (blockingl.transactionid=blockedl.transactionid) or join pg_stat_activity blockinga on blockingl.pid = blockinga.pid and blockinga.datid = blockeda.datid where not blockedl.granted and blockinga.datname = current_database() select * from lock_monitor;
select pid, usename, pg_blocking_pids(pid) as blocked_by, query as blocked_query from pg_stat_activity where cardinality(pg_blocking_pids(pid)) > 0;
select pg_blocking_pids(pid) as blocked_by from pg_stat_activity where cardinality(pg_blocking_pids(pid)) > 0;
select query from pg_stat_activity where pid in (select unnest(pg_blocking_pids(pid)) as blocked_by from pg_stat_activity where cardinality(pg_blocking_pids(pid)) > 0);
alter table companytransactions drop constraint [df__companytr__creat__0cdae408];
if exists(select * from information_schema.columns where table_name = n'table_name' and column_name = n'lower_limit') select top 1 @sql = n'alter table [table_name] drop constraint ['+dc.name+n']' from sys.default_constraints dc join sys.columns c where dc.parent_object_id = object_id('[table_name]') and c.name = n'lower_limit' if @@rowcount = 0 end exec (@sql) alter table table_name drop column lower_limit;
end else print 'column lower_limit does not exist';
exec sp_helpconstraint '<your table name>';
alter table <your_table_name> drop constraint <constraint_name_that_you_copied_in_1>;
alter table <yourtablename> drop column column1, column2;
default constraint;
alter table companytransactions drop constraint [df__companytr__creat__0cdae408];
alter table companytransactions drop column [created];
alter table myschema.mytable add;
alter table myschema.mytable add constraint df_mytable_mycolumn default null for mycolumn;
select persons.name, persons.ss, fears.fear from persons;
select persons.name, persons.ss, fears.fear from persons;
select p.name, p.ss, f.fear from persons p person_fear pf fears f;
select p.name, p.ss, f.fear from persons p;
select p.personid as person_id, p.name, p.ss, f.fearid as fear_id, f.fear from person_fear as pf where f.fearid = pf.fearid and p.personid = pf.personid;
select p.*, f.fear from persons p;
select persons.name, persons.ss, fears.fear from persons;
limit :limit offset :offset;
limit '10' offset '1';
limit 10 offset 1;
alter table `{$installer->gettable('sales/quote_payment')}` add `custom_field_one` varchar( 255 ) not null, add `custom_field_two` varchar( 255 ) not null;
select sum(if(day_1 = 1,1,0)+if(day_3 = 1,1,0)++if(day_4 = 1,1,0)) from attendence where class_period_id='1' and student_id='1';
select student, (sum(mark1)+sum(mark2)+sum(mark3)....+sum(markn)) as total from your_table;
select subject, sum(mark) total from subjects s;
select concat('select ', group_concat(`column_name` separator '+'), ' from scorecard') from  `information_schema`.`columns` where `table_schema` = (select database()) and   `table_name`   = 'scorecard' and   `column_name` like 'mark%';
select mark1+mark2+mark3 from scorecard;
select `student`, sum(ifnull(`mark1`, 0) + ifnull(`mark2`, 0) + ifnull(`mark3`, 0)) as `total_marks` from student_scorecard;
select @id = min(fpat.patientid) from tbpatients fpat where (fpat.insnotes is not null and datalength(fpat.insnotes)>0) select fpat.patientid, fpat.insnotes from tbpatients fpat where (fpat.insnotes is not null and datalength(fpat.insnotes)>0) and fpat.patientid=@id select @id = min(fpat.patientid) from tbpatients fpat where (fpat.insnotes is not null and datalength(fpat.insnotes)>0)and fpat.patientid>@id end;
idx int identity(1,1), col1 int ) set @counter = 1 select @colvar = col1 from @table1 where idx = @counter set @counter = @counter + 1 end;
select top 1 @datakey = datakey from @table1 delete from @table1 where datakey = @datakey end;
set @rowstoprocess=@@rowcount set @currentrow=0 set @currentrow=@currentrow+1 select @selectcol1=col1 from @table1 where rowid=@currentrow end;
( loopid  int  not null  identity(1,1) ) select mydata from mytable set @loopid = @@rowcount select @mydata = mydata from @checkthese where loopid = @loopid set @loopid = @loopid - 1 end;
set @cnt = @cnt+1;
select valuerow from (select valuerow from @vtable where t1.rowid = @cnt set @cnt = @cnt+1;
set @rowstoprocess = @@rowcount select * from @table1 where rowid=@rowstoprocess set @rowstoprocess = @rowstoprocess - 1; -- countdown end;
create procedure printsequenceseries as begin set nocount on;
select @series_count = count(*) from parse_comma_delimited_integer(@comaseperatedsequenceseries, ',')  --- order by item desc set @curr_count = 1 set @sql = 'select top 1 t.* from ' + exec sp_executesql @sql set @curr_count = @curr_count + 1;
exec  printsequenceseries '11,2,33,14,5,60,17,98,9,10';
create function [dbo].[parse_comma_delimited_integer] ( @list       varchar(8000), @delimiter  varchar(10) = ', ' ) ( item int ) as begin if charindex(@delimiter,@list) > 0 select @item = substring(@list,1,(charindex(@delimiter, @list)-1)) select @list =  substring(@list,(charindex(@delimiter, @list) + end else begin select @item = @list select @list = null end  ( item ) select item = convert(int, @item) end return end;
create function test_range() as begin set @rows = (select count(*) from @rangetable) set @row = @row + 1 select top 1 @id = id, @num = rangefrom, @rangeto = rangeto  from @rangetable where id > @id set @num = @num + 1 end end return end;
select replace(replace(countycode, char(10), ''), char(13), '') from [mssqltipsdemo].[dbo].[countryinfo];
create function xls(@string nvarchar(max) ) as begin set @string = replace (@string, char(9), ' ') set @string = replace (@string, char(10), ' ') set @string = replace (@string, char(13), ' ') end  create function xls(@string nvarchar(max) ) as begin set @string = replace (@string, char(9), ' ') set @string = replace (@string, char(10), ' ') set @string = replace (@string, char(13), ' ') end;
select dbo.xls(description) from server_inventory;
select '"' + columnname + '"' as columnname from tablename;
select '"' + replace(columnname, '"', '""') + '"' as columnname from tablename;
select quotename(columnname, '"') as columnname from tablename;
select replace(col, char(13) + char(10), ', ') from table;
set @delimiter = '|' set @double_quote = '"' set @text = 'this select @text select @double_quote + replace(@text, @double_quote, @delimiter) + @double_quote;
select       lastname + ', ' + firstname as 'fullname' from         customers;
select       lastname + ', ' + firstname as 'fullname' from         customers;
select       lastname + ', ' + firstname as 'fullname' from         customers;
select fullname from ( select lastname + ', ' + firstname as fullname from customers;
select fullname from ( select case when lastname is null then firstname end as fullname from customers;
select lastname + ', ' + firstname as fullname from person;
select x.fullname from ( select lastname + ', ' + firstname as fullname from person;
select lastname + ', ' + firstname as fullname from person;
select lastname + ', ' + firstname as fullname from person;
select       lastname + ', ' + firstname as 'fullname', birthday, title from         customers;
select fullname from ( select coalesce(lastname+', '+firstname, firstname) as fullname from customers;
select case when lastname is null then firstname end as 'fullname' from customers lastname, firstname;
select accountnumber, amount as myalias from transactions;
select accountnumber, isnull(amount, 0) as myalias from transactions;
select case when lastname is null then firstname end as 'fullname' from  customers group by 1`;
select       fullname from         customers;
select recordid, startdate, enddate from tmp where enddate is null union select recordid, min(startdate), max(enddate) from tmp group by recordid;
select recordid, min(startdate), max(isnull(enddate, getdate())) from tmp;
select recordid, min(startdate), case when max(case when enddate is null then 1 else 0 end) = 0 then max(enddate) end from tmp group by recordid;
( select recordid, min(startdate) as min_start , max(enddate) as max_end from tmp ) select a.recordid, a.min_start , case when b.recordid is  null then a.max_end end as max_end from cte1 a;
select recordid, min(startdate), case when count(enddate) = count(*) then max(enddate) end from tmp;
select case when else 0 end as flag from mytable;
select recordid, min(startdate), nullif(max(coalesce(enddate,'9999-12-31')),'9999-12-31') from tmp group by recordid;
select other_table.a as a, other_table.b as b, other_table.c as c, '0' as d from other_table;
"mysql-scripts/firstscript.sql"));
"mysql-scripts/secondscript.sql"));
if (!line.isempty()) if (st != null);
select name, 76 = age from [...];
where name = 'frank';
where datedropped = 0 and case else 'false' end = 'true';
where datedropped = 0 and ( @jobsonhold = 1 and dateappr >= 0 or (@jobsonhold <> 1 or @jobsonhold is null) and dateappr <> 0 );
where datedropped = 0 and ( (isnull(@jobsonhold, 0) = 1 and dateappr >= 0) or (isnull(@jobsonhold, 0) != 1 and dateappr != 0) );
select dateappr, timeappr, tat, laserltr, permit, ltrprinter, jobname, jobnumber, jobdesc, actqty, (actqty-ltrprinted) as l, (actqty-qtyinserted) as m, ((actqty-ltrprinted)-(actqty-qtyinserted)) as n from [test].[dbo].[mm] where datedropped = 0 and ( (isnull(@jobsonhold, 0) = 1 and dateappr >= 0) or (isnull(@jobsonhold, 0) != 1 and dateappr != 0) );
where datedropped = 0 and ( (isnull(@jobsonhold, 0) = 1 and dateappr >= 0) or (isnull(@jobsonhold, 0) <> 1 and dateappr <> 0) );
select * from x where condition1 and ((@pol is not null and x.policyno = @pol) or (@st is not null and x.state = @st)) and otherconditions;
select now()::timestamp(0);
select date_trunc('second', now()::timestamp);
select date_trunc('second', current_timestamp::timestamp);
select date_trunc('minute', current_timestamp::timestamp);
select date_trunc('second', current_timestamp::timestamp)::time;
alter table emp modify column name varchar(100);
alter table emp change column name name varchar(100);
select object_id table_id, column_id column_position from sys.columns where object_id is not null and object_id = object_id('tablename') and name = 'columntobedropped' ) select @constraints = coalesce(@constraints, 'constraint ') + '[' + name + '], ' from sysobjects where ( -- is check constraint and id is not null and id in ( select object_id --, object_name(object_id) from sys.sql_dependencies, table_id_column_position where object_id is not null and referenced_major_id = table_id_column_position.table_id and referenced_minor_id = table_id_column_position.column_position ) -- is default constraint and id is not null and id in ( select object_id from sys.default_constraints, table_id_column_position where object_id is not null and parent_object_id = table_id_column_position.table_id and parent_column_id = table_id_column_position.column_position ) set @sql = 'alter table tablename drop ' + coalesce(@constraints, '') + ' column columntobedropped';
alter table tablename drop constraint c1, ..., column columntobedropped;
select object_name(parent_object_id) as tablename, name as constraintname from sys.default_constraints order by tablename, constraintname;
select object_name(id) as tablename, object_name(constid) as constraintname from sysconstraints order by tablename, constraintname;
select @constraintname = name from sys.default_constraints where parent_object_id = object_id(@tablename) and parent_column_id = ( select column_id from sys.columns where name = @columnname and object_id = object_id(@tablename)) if @constraintname is not null;
as is produced in batch mode or when the --batch or --silent option as \n, \t, \0, and \\. the --raw option disables this character and the use of raw mode to disable escaping:;
select count(*) from table where datasets = '{}';
select  count(*) from    table where   datasets = array(select 1 where false);
select count(*) from table where array_upper(datasets, 1) is null;
select id, name, employee_id from table where array_column = array[null]::array_datatype;
select id, name, employee_id from tab_emp where employee_id = array[null]::uuid[];
select count(*) from table where cardinality(datasets) = 0;
create table if not exists `tests`.`data_table` ( `id` int(10) unsigned not null auto_increment, `title` varchar(2000) character set latin1 not null, `description` text character set latin1 not null, primary key (`id`);
drop table if exists `tests`.`data_table_temp`;
create temporary table `tests`.`data_table_temp` select * from `tests`.`data_table`;
alter table `tests`.`data_table_temp`  engine = myisam;
alter table `tests`.`data_table_temp` add fulltext `ftk_title_description` ( `title` , `description` select *, match (`title`,`description`) from `tests`.`data_table_temp` where match (`title`,`description`) drop table `tests`.`data_table_temp`;
// change this option for your need;
new zend_search_lucene_analysis_analyzer_common_utf8num_caseinsensitive() // +search for 'foo' in field 'field1';
select column, levenshtein(column, 'search_string') as distance from table where levenshtein(column, 'search_string') < distance_limit;
select * from table where column_name like "%search_string%";
select * from table where column_name like "%search_string%" collate utf8_bin;
select column, levenshtein(column, 'search_string') as distance // for sorting from table where column_name like "%search_string%" distance desc;
select 23, date('2013-02-12'), 22.5 from dual where not exists (select 1 from funds where id = 23 and date = date('2013-02-12'));
values (23, date('2013-02-12'), 22.5);
select t.* from (select 23 id,  '2013-02-12' date,  22.43 price) t funds on funds.id = t.id and funds.date = t.date where funds.id is null;
alter table funds add unique key `fund_date` (`fund_id`, `date`);
values (23, date('2013-02-12'), 22.5) values (23, date('2013-02-12'), 22.5);
set time_zone = 'proper timezone';
select convert_tz(now(),@@session.time_zone,'+03:00');
where convert_tz(timeperiod, 'utc', '{$this->timezone}') not between {$timeperiods['today_start']} and {$timeperiods['today_end']};
select  table_schema + '.' + table_name from information_schema.tables where table_name in;
set @schema=( select top 1 table_schema from information_schema.tables where table_name='mytable' ) if @schema<>'dbo' setuser @schema;
select * from mytable;
select user.id, user.name, count(post.*) as posts from user;
select user_id, name, date_logged_in  select u.user_id, u.name, ulh.date_logged_in from users as u join user_login_history as ulh where u.user_id = 1234;
where ... and charindex(',' + pitran.linepropertyid + ',', @myparameter_list) > 0;
if object_id('tempdb..#parse','u') is not null drop table #parse select @desc = flddesc from dbcustomdata.dbo.tbldirectreferralformparameters where fldfrom = @from and fldorderid = @orderid create table #parse (flddesc varchar(255)) select @start = 1, @end = 1 set @end = charindex(',',@desc,@start) if @end = 0 end else begin end set @start = @end + 1 end  select * from #parse;
alter function [dbo].[fn_mvparam] set @repparam = replace(@repparam,char(39)+char(39),char(39)) select @chrind = 1 select @chrind = charindex(@delim,@repparam) if @chrind  > 0 select @piece = left(@repparam,@chrind - 1) else select @piece = @repparam select @repparam = right(@repparam,len(@repparam + '1')-1 - @chrind) if len(@repparam) = 0 break end return end;
create function [dbo].[fn_splitint] ( @list       nvarchar(4000), @delimiter  char(1)= ',' ) ( position int identity primary key, number int ) as  select @index = 1 select @index = charindex(@delimiter,@list) if @index  > 0     -- if found, take the value left of the delimiter select @itemvalue = left(@list,@index - 1) else               -- if none, take the remainder as the last value select @itemvalue = @list select @list = right(@list,len(@list) - @index) if len(@list) = 0 break end  end;
where id in (select number from dbo.fn_splitint(@sparameterstring,','));
set @s = char(39) + replace(@s, ',', char(39) + ',' + char(39)) + char(39);
select @repparam = replace(@repparam,'''''','''');
create function [dbo].[fn_mvparam] ( @repparam varchar(max), @delim char(1)= ',' ) where id in (select param from fn_mvparam(@planidlist,',')) select @repparam = replace(@repparam,'''''','''') select @chrind = 1 select @chrind = charindex(@delim,@repparam) if @chrind > 0 select @piece = left(@repparam,@chrind - 1) else select @piece = @repparam select @repparam = right(@repparam,datalength(@repparam) - @chrind) if datalength(@repparam) = 0 break end return end;
alter function [dbo].[fn_mvparam] select @chrind = 1 select @chrind = charindex(@delim,@repparam) if @chrind  > 0 select @piece = left(@repparam,@chrind - 1) else select @piece = @repparam select @repparam = right(@repparam,len(@repparam) - @chrind) if len(@repparam) = 0 break end return end;
where somecolumn in(select param from dbo.fn_mvparam(@sparameterstring,','));
where yourcolumn in (@<your param name>);
where charindex(convert(nvarchar, custnum), @custnum) > 0;
select * from your_table yt;
select * from your_table where (charindex(your_column, @log_status,0) > 0);
select count(*) as count_1 from "table";
from sqlalchemy import select, func, integer, table, column, metadata table = table("table", metadata, column('primary_key', integer), column('other_column', integer)  # just to illustrate );
from sqlalchemy.sql.expression import func;
from sqlalchemy import func;
select count(*) from user_song join song on user_song.song_id = song.id where user_song.user_id = %(user_id) and user_song.is_liked is 1 and song.genre = 'rock';
and_( usersong.user_id == user_id, usersong.is_liked.is_(true), song.genre == 'rock' ) );
select * from employee inner join [order];
select company.company_id,company.company_name, invoice_details.invoice_no, product_details.price from company inner join invoice_details where price='60000';
select * from table1;
select * from table1 inner join table2 on table1.primarykey = table2.foreignkey;
select t1.col, t3.col from table1 join table2 on table1.primarykey = table2.foreignkey join table3 on table2.primarykey = table3.foreignkey;
select o.orderid, c.customername, l.lname, s.studadd, s.studmarks from orders o;
select table1 .columnname, table3 .columnname from table1;
select salesheader.invoicedate,actualsales,deptname,tblinvdepartment.deptcode ,locationcode from salesdetail inner join salesheader on salesdetail.invoiceno = salesheader.invoiceno inner join tblinvdepartment on tblinvdepartment.deptcode = salesdetail.deptcode;
select eb.n_empid, em.s_empname, deg.s_designationname, dm.s_deptname from tbl_employeemaster em;
select employment_status.staff_type, count(monthly_pay_register.age), monthly_pay_register.basic_salary, monthly_pay_register.total_monthly_allowances, monthly_pay_register.monthly_gross, monthly_pay_register.total_monthly_deductions, monthly_pay_register.monthly_pay from (monthly_pay_register inner join deduction_logs employment_status on deduction_logs.employee_no = employment_status.employee_no where monthly_pay_register.`year`=2017 and monthly_pay_register.`month`='may';
select wucsname as wucs_name,year,tot_households,tot_households,tot_male_farmers  from tbl_gender;
if exists (select name from sysobjects where name = 'ig_insertdealer' and type = 'p') drop proc dbo.ig_insertdealer create procedure dbo.ig_insertdealer;
if exists (select 1 from information_schema.routines where routine_name = 'synchronizeremotecatalog' and routine_schema = 'dbo' and routine_type = 'procedure') exec ('drop procedure dbo.synchronizeremotecatalog');
if exists (select 1 from information_schema.routines where routine_name = 'synchronizeremotecatalog' and routine_schema = 'dbo' and routine_type = 'procedure') drop procedure dbo.synchronizeremotecatalog;
create trigger dbo.existingtable on dbo.anothertable for update as set nocount on;
if exists(...) drop;
create procedure dbo.my_proc as select * from dbo.a where i < 10;
select object_id('dbo.my_proc');
drop procedure if exists dbo.my_proc;
create procedure dbo.my_proc as -- some meaningless comment select * from dbo.a where i < 10;
select object_id('dbo.my_proc');
create procedure dbo.my_proc2 as select * from dbo.a where i < 10;
select object_id('dbo.my_proc2');
create or alter procedure dbo.my_proc2 as -- some meaningless comment select * from dbo.a where i < 10;
select object_id('dbo.my_proc2');
if not exists (select * from sys.objects where object_id = object_id(n'[dbo].[a]') and type in (n'u')) create table [dbo].[a]( [i] [int] identity(1,1) not null primary key, [g] [uniqueidentifier] null, [z] varchar(10) end go select newid(), number from (select cast([key] as int) as number from openjson( '[1' + replicate(',1',3000-1)+']') create procedure dbo.my_proc as select * from dbo.a where z like '12%' and 1 = (select 1);
exec dbo.my_proc;
exec sp_query_store_flush_db;
select qsq.query_id, qsq.query_text_id, qsq.context_settings_id, qsq.[object_id], object_name(qsq.[object_id]) as [object_name], qsp.is_forced_plan, qsqt.query_sql_text, qsrs.count_executions, cast(qsp.query_plan as xml) as sql_query_plan from sys.query_store_query qsq join sys.query_store_query_text qsqt join sys.query_store_plan qsp join sys.query_store_runtime_stats qsrs where query_sql_text like '%dbo.a%' and qsq.[object_id] <> 0 create nonclustered index ix_dbo_a_z exec dbo.my_proc;
exec sp_query_store_flush_db;
select qsq.query_id, qsq.query_text_id, qsq.context_settings_id, qsq.[object_id], object_name(qsq.[object_id]) as [object_name], qsp.is_forced_plan, qsqt.query_sql_text, qsrs.count_executions, cast(qsp.query_plan as xml) as sql_query_plan from sys.query_store_query qsq join sys.query_store_query_text qsqt join sys.query_store_plan qsp join sys.query_store_runtime_stats qsrs where query_sql_text like '%dbo.a%' and qsq.[object_id] <> 0 exec sp_query_store_flush_db;
select qsq.query_id, qsq.query_text_id, qsq.context_settings_id, qsq.[object_id], object_name(qsq.[object_id]) as [object_name], qsp.is_forced_plan, qsqt.query_sql_text, qsrs.count_executions, cast(qsp.query_plan as xml) as sql_query_plan from sys.query_store_query qsq join sys.query_store_query_text qsqt join sys.query_store_plan qsp join sys.query_store_runtime_stats qsrs where query_sql_text like '%dbo.a%' and qsq.[object_id] <> 0 exec dbo.my_proc;
exec sp_query_store_flush_db;
select qsq.query_id, qsq.query_text_id, qsq.context_settings_id, qsq.[object_id], object_name(qsq.[object_id]) as [object_name], qsp.is_forced_plan, qsqt.query_sql_text, qsrs.count_executions, cast(qsp.query_plan as xml) as sql_query_plan from sys.query_store_query qsq join sys.query_store_query_text qsqt join sys.query_store_plan qsp join sys.query_store_runtime_stats qsrs where query_sql_text like '%dbo.a%' and qsq.[object_id] <> 0 drop procedure if exists dbo.my_proc;
create procedure dbo.my_proc as -- some meaningless comment added by developer select * from dbo.a where z like '12%' and 1 = (select 1);
exec dbo.my_proc;
exec sp_query_store_flush_db;
select qsq.query_id, qsq.query_text_id, qsq.context_settings_id, qsq.[object_id], object_name(qsq.[object_id]) as [object_name], qsp.is_forced_plan, qsqt.query_sql_text, qsrs.count_executions, cast(qsp.query_plan as xml) as sql_query_plan from sys.query_store_query qsq join sys.query_store_query_text qsqt join sys.query_store_plan qsp join sys.query_store_runtime_stats qsrs where query_sql_text like '%dbo.a%' and qsq.[object_id] <> 0;
if not exists (select * from sys.objects where object_id = object_id(n'[dbo].[a]') and type in (n'u')) create table [dbo].[a]( [i] [int] identity(1,1) not null primary key, [g] [uniqueidentifier] null, [z] varchar(10) end go select newid(), number from (select cast([key] as int) as number from openjson( '[1' + replicate(',1',3000-1)+']') create procedure dbo.my_proc as select * from dbo.a where z like '12%' and 1 = (select 1);
exec dbo.my_proc;
exec sp_query_store_flush_db;
select qsq.query_id, qsq.query_text_id, qsq.context_settings_id, qsq.[object_id], object_name(qsq.[object_id]) as [object_name], qsp.is_forced_plan, qsqt.query_sql_text, qsrs.count_executions, cast(qsp.query_plan as xml) as sql_query_plan from sys.query_store_query qsq join sys.query_store_query_text qsqt join sys.query_store_plan qsp join sys.query_store_runtime_stats qsrs where query_sql_text like '%dbo.a%' and qsq.[object_id] <> 0 create nonclustered index ix_dbo_a_z exec dbo.my_proc;
exec sp_query_store_flush_db;
select qsq.query_id, qsq.query_text_id, qsq.context_settings_id, qsq.[object_id], object_name(qsq.[object_id]) as [object_name], qsp.is_forced_plan, qsqt.query_sql_text, qsrs.count_executions, cast(qsp.query_plan as xml) as sql_query_plan from sys.query_store_query qsq join sys.query_store_query_text qsqt join sys.query_store_plan qsp join sys.query_store_runtime_stats qsrs where query_sql_text like '%dbo.a%' and qsq.[object_id] <> 0 exec sp_query_store_flush_db;
select qsq.query_id, qsq.query_text_id, qsq.context_settings_id, qsq.[object_id], object_name(qsq.[object_id]) as [object_name], qsp.is_forced_plan, qsqt.query_sql_text, qsrs.count_executions, cast(qsp.query_plan as xml) as sql_query_plan from sys.query_store_query qsq join sys.query_store_query_text qsqt join sys.query_store_plan qsp join sys.query_store_runtime_stats qsrs where query_sql_text like '%dbo.a%' and qsq.[object_id] <> 0 exec dbo.my_proc;
exec sp_query_store_flush_db;
select qsq.query_id, qsq.query_text_id, qsq.context_settings_id, qsq.[object_id], object_name(qsq.[object_id]) as [object_name], qsp.is_forced_plan, qsqt.query_sql_text, qsrs.count_executions, cast(qsp.query_plan as xml) as sql_query_plan from sys.query_store_query qsq join sys.query_store_query_text qsqt join sys.query_store_plan qsp join sys.query_store_runtime_stats qsrs where query_sql_text like '%dbo.a%' and qsq.[object_id] <> 0 create or alter procedure dbo.my_proc as -- some meaningless comment added by developer select * from dbo.a where z like '12%' and 1 = (select 1);
exec dbo.my_proc;
exec sp_query_store_flush_db;
select qsq.query_id, qsq.query_text_id, qsq.context_settings_id, qsq.[object_id], object_name(qsq.[object_id]) as [object_name], qsp.is_forced_plan, qsqt.query_sql_text, qsrs.count_executions, cast(qsp.query_plan as xbml) as sql_query_plan from sys.query_store_query qsq join sys.query_store_query_text qsqt join sys.query_store_plan qsp join sys.query_store_runtime_stats qsrs where query_sql_text like '%dbo.a%' and qsq.[object_id] <> 0;
create table dbo.silly_logging(id int identity(1,1) primary key create procedure dbo.my_procedure as insert into dbo.silly_logging(comment) values ('sql server startup');
exec sp_procoption @procname = 'dbo.my_procedure' select name, create_date, modify_date, is_auto_executed from master.sys.procedures where is_auto_executed = 1;
drop procedure dbo.my_procedure;
create procedure dbo.my_procedure as -- adding meaningless comment values ('sql server startup');
select name, create_date, modify_date, is_auto_executed from master.sys.procedures where is_auto_executed = 1;
create proc dbo.myproc as;
if objectproperty(object_id('dbo.myview'), 'isview') is null begin end go alter view dbo.myview as;
if objectproperty(object_id('dbo.myproc'), 'isprocedure') is null begin end go alter procedure dbo.myproc as set nocount on;
if objectproperty(object_id('dbo.myudf'), 'isscalarfunction') is null begin end go alter function dbo.myudf(@s varchar(100)) returns int as end go;
if objectproperty(object_id('dbo.myudf'), 'istablefunction') is null begin end go alter function dbo.myudf(@s varchar(100)) -- columns returned by the function ) end go;
if not exists (select * from sys.objects where object_id = object_id(n'[aaa_test]') and type in (n'p', n'pc')) alter procedure aaa_test @par2 int=0 as begin select @par1 as par1, case @par2 when 0 then 'default' else 'other' end as par2 end go;
exec aaa_test 1 exec aaa_test 1,5;
if object_id('[dbo].[<name_of_routine, , >]') is null if object_id('[dbo].[<name_of_routine, , >]') is null if object_id('[dbo].[<name_of_routine, , >]') is null;
if object_id('[dbo].[<name_of_trigger, , >]') is null -- check if trigger exists if object_id('[dbo].[<name_of_view, , >]') is null -- check if view exists;
create or alter;
drop procedure if exists dbo.synchronizeremotecatalog create procedure dbo.synchronizeremotecatalog as begin end ;
create or alter;
create or alter procedure dbo.synchronizeremotecatalog as begin end;
if object_id('spcallsomething') is null alter procedure spcallsomething ...;
alter table `users` change `id` `id` int(11) not null auto_increment;
create table `users`( `user_id` int(10) not null auto_increment, `username` varchar(255) not null, `password` varchar(255) not null, primary key (`user_id`);
create table `table`.`users` ( `id` int(11) not null auto_increment, `username` varchar(50) not null, `password` varchar(50) not null, `dir` varchar(100) not null, primary key (`id`);
create table `table`.`users` ( `id` int(11) not null auto_increment, `username` varchar(50) not null, `password` varchar(50) not null, `dir` varchar(100) not null, primary key (`id`(11));
create table `table`.`users` ( `id` int(11) not null auto_increment, `username` varchar(50) not null, `password` varchar(50) not null, `dir` varchar(100) not null, primary key (`id`);
if (process.env.restartdb) {;
select create_time from information_schema.tables where table_schema = 'your_schema' and table_name = 'your_table';
select * from ( select a.identifier from table_a a where a.identifier = b.identifier where month_no > upd_date;
from table_a a where a.identifier = b.identifier) select * from inner_table where month_no > upd_date;
create or replace view_1 as (select ...);
select * from view_1;
select a.identifier from table_a a select -- variables where vars.month_no > upd_date;
select a.identifier from table_a a, table_b b where .identifier = b.identifier having month_no > upd_date;
commandtype = commandtype.storedprocedure, commandtext = "storeguid", parameters = { <b>sqldbtype = sqldbtype.uniqueidentifier</b>, // right here;
select 1+1 select 2+2 select 3+3 end;
select * from dual;
set autoprint on;
select 'foo','bar' from dual;
set serveroutput on;
select foo, bar from foobar;
set serveroutput on;
create procedure sample(id select count(*) into x from table where userid=id;
select foo,bar from foobar into v_foo, v_bar;
select foo, bar from foobar;
create package pkg1 as end pkg1;
create package body pkg1 as end loop;
select * from table(pkg1.f1(5));
select extract(epoch from now());
select to_timestamp( extract(epoch from now()));
select timestamp with time zone 'epoch' select to_timestamp(extract(epoch from now()))::date;
select (timestamp with time zone 'epoch' select to_timestamp(extract(epoch epoch_ms))::date;
select timestamp 'epoch' + (<table>.field::int) * interval '1 second' as started_on from <table>;
select to_timestamp(cast(epoch_ms as bigint)/1000);
select to_timestamp(cast(epoch_ms/1000 as bigint))::date;
select * from table where col in (123,123,222,....) or col in (456,878,888,....);
create table sometemptable as select yourcolumn from sometable where userpickedmultiplerecordsfromsomelistorsomething;
select * from othertable where yourcolumn in ( select yourcolumn from sometemptable );
create type idtable as table (id int not null primary key);
create procedure sp__procedure_name as  select * from table where col in (select id from @orderids);
select * from user where userid in (1,2,3,etc);
not (expr1 and expr2) -> not expr1 or not expr2 not (expr1 or expr2) -> not expr1 and not expr2;
not field1 in (value1, value2)  -- for longer lists not field1 = value1 and not field1 = value2  -- for shorter lists;
not (table1.field1 = value1 and exists (select * from table2 where table1.field1 = table2.field2));
not table1.field1 = value1 or not exists (select * from table2 where table1.field1 = table2.field2));
select c from t1 where c not in ( select c from t2 );
select distinct t1.c from t1 natural left outer join t2 where t2.c is null;
select c from t1 except select c from t2;
select  * from    mytable where   col1 > @value1 or col2 < @value2;
select  * from    mytable where   col1 > @value1 union select  * from    mytable where   col2 < @value2;
select  mo.* from    ( select  id from    mytable where   col1 > @value1 union select  id from    mytable where   col2 < @value2 join    mytable mo;
select  * from    mytable where   col in ( select  othercol from    othertable );
select  * from    mytable mo where   exists ( select  null from    othertable o where   o.othercol = mo.col );
select  mo.grouper, ( select  sum(col) from    mytable mi where   mi.grouper = mo.grouper ) from    ( select  distinct grouper from    mytable;
select  mo.grouper, sum(col) from    mytable mo.grouper;
select  t1.col1, t2.col2 from    table1 t1;
select  t1.col1, t2.col2 from    table1 t1 table2 t2 union all select  null, t2.col2 from    table1 t1 table2 t2 where   t1.id is null;
select  distinct(animal_id) as animal_id from    animal animal_id;
select  distinct(animal_id) as animal_id from    ( select  0 as gender, animal_id, father as parent from    animal union all select  1, animal_id, mother from    animal ) animal_id;
select  * from    ranges where   end_date >= @start and start_date <= @end;
select  * from    ranges where   (start_date > @start and start_date <= @end) or (@start between start_date and end_date);
select  mi.id, sum(mo.value) as running_sum from    mytable mi join    mytable mo mi.id;
select  to_char(sum(xac_amount * rte_rate), 'fm999g999g999g999g999g999d999999') from    t_transaction x join    t_rate r ( select  xac_currency, max(rte_date) from    t_rate where   rte_currency = xac_currency and rte_date <= xac_date );
( select  cur_id as eff_currency, dte_date as eff_date, rte_rate as eff_rate from    ( select  cur_id, dte_date, ( select  max(rte_date) from    t_rate ri where   rte_currency = cur_id and rte_date <= dte_date from    ( select  ( select  max(rte_date) from    t_rate from    dual ( select  max(rte_date) - min(rte_date) from    t_rate ) ( select  1 as cur_id from    dual union all select  2 as cur_id from    dual t_rate and rte_date = rte_effdate ) select  to_char(sum(xac_amount * eff_rate), 'fm999g999g999g999g999g999d999999') from    ( select  xac_currency, trunc(xac_date) as xac_date, sum(xac_amount) as xac_amount, count(*) as cnt from    t_transaction x xac_currency, trunc(xac_date) ) join    v_rate and eff_date = xac_date;
select  * from    mytable mo where   exists ( select  * from    othertable o where   o.othercol = mo.col );
select  mo.* from    mytable mo inner join othertable o on o.othercol = mo.col;
select  * from    mytable mo where   not exists ( select  * from    othertable o where   o.othercol = mo.col );
select  mo.* from    mytable mo left outer join othertable o on o.othercol = mo.col where   o.othercol is null;
where ((a or b) or c);
where a or b or c;
select foo.a, bar.a from foomatic  foo, bartastic bar where foo.id = bar.id and select ban.id from bantabulous ban where ban.bandana = 42 );
select foo.a, bar.a from foomatic    foo, bartastic   bar, bantabulous ban where foo.id = bar.id and;
select foo.a, bar.a from foomatic    foo join bartastic   bar on bar.id = foo.id join bantabulous ban on ban.id = bar.id where ban.bandana = 42;
select * from tablename where criteria;
select column1, column2 from tablename where criteria;
create table mytable ( id int identity primary key, foo int ) create nonclustered index index1 on mytable(id, foo) select id, foo from mytable -- all requested data are covered by index;
select oi.title, c.name, c.address from porderitem poi join porder po on po.id = poi.fk_order join customer c on c.id = po.fk_customer where po.orderdate > ? and po.status = 'shipping';
create index porder_custitem on porder (orderdate, id, status, fk_customer);
select id from mytable where telephone_number = '55442233';
create date:        2018-01-25 @param2 = 3, @param3 = 2;
update pallets set class_code = 'x' where and class_code != 'd' and class_code = 'z' and historical = 'n' and quantity > 0 and getdate() > dateadd(minute, 30, creation_date) and pallet_id in ( -- only update pallets that we've created an adjustment record for select adjust_id from adjustments where adjustmentstatus = 0 and recid > @maxadjnumber;
set timing on <br> set linesize 180<br> select name from v$database;
select to_char(sysdate, 'day dd month yyyy hh24:mi:ss') "start time" from dual select to_char(sysdate, 'day dd month yyyy hh24:mi:ss') "end time" from dual;
create table client (client_id integer not null primary key auto_increment, name varchar(64));
create table portfolio (portfolio_id integer not null primary key auto_increment, client_id integer references client.id, cash decimal(10,2), stocks decimal(10,2));
(1, 10.11, 23.22), (2, 30.30, 40.40), (2, 40.40, 50.50);
select client_id, name, max(cash + stocks) from client join portfolio using (client_id);
select client_id, max(cash + stocks) as maxtotal from portfolio;
select portfolio_id, cash + stocks from portfolio join (select client_id, max(cash + stocks) as maxtotal from portfolio where cash + stocks = maxtotal;
select client_id, name, portfolio_id, cash + stocks from client join portfolio using (client_id) join (select client_id, max(cash + stocks) as maxtotal from portfolio where cash + stocks = maxtotal;
select client_id, name, portfolio_id, cash + stocks from client join portfolio using (client_id) join (select client_id, max(cash + stocks) as maxtotal from portfolio where cash + stocks = maxtotal;
select clients.id, clients.name, portfolios.id, sum ( portfolios.portfolio + portfolios.cash ) as total from clients, portfolios where clients.id = portfolios.client_id limit 30;
create function dbo.udf_getnumeric ( @stralphanumeric varchar(256) ) as begin set @intalpha = patindex('%[^0-9]%', @stralphanumeric) set @stralphanumeric = stuff(@stralphanumeric, @intalpha, 1, '' ) set @intalpha = patindex('%[^0-9]%', @stralphanumeric ) end end return isnull(@stralphanumeric,0) end go;
select dbo.udf_getnumeric(column_name) from table_name;
select left(val,patindex('%[^0-9]%', val+'a')-1) from( select substring(@var, patindex('%[0-9]%', @var), len(@var)) val;
( string nvarchar(50) ) values ('003preliminary examination plan'), ('coordination005'), ('balance1000sheet') select left(subsrt, patindex('%[^0-9]%', subsrt + 't') - 1) from ( select subsrt = substring(string, pos, len(string)) from ( select string, pos = patindex('%[0-9]%', string) from @temp;
set @stringalphanum = 'aaaa1234bbbb3333' set @sizestringalfanumerica = len(@stringalphanum) set @countcharacter = 1 if substring(@stringalphanum,@countcharacter,1) not like '[0-9]%' set @character = substring(@stringalphanum,@countcharacter,1) set @stringalphanum = replace(@stringalphanum, @character, '') end set @countcharacter = @countcharacter + 1 end set @countcharacter = 0 end select @stringalphanum;
( string nvarchar(50) ) values ('003preliminary examination plan'), ('coordination005'), ('balance1000sheet') select substring(string, patindex('%[0-9]%', string), patindex('%[0-9][^0-9]%', string + 't') - patindex('%[0-9]%', string) + 1) as number from @temp;
select '003preliminary examination plan' as numberstring union all select 'coordination005' as numberstring union all select 'balance1000sheet' as numberstring union all select '1300 456 678' as numberstring union all select '(012) 995 8322  ' as numberstring union all select '073263 6122,' as numberstring first_char_processed as ( select len(numberstring) as currentstringlength, isnull(cast(try_cast(replace(left(numberstring, 1),' ','z') as tinyint) as nvarchar),'') as firstcharasnumeric, cast(isnull(cast(try_cast(nullif(left(numberstring, 1),'') as tinyint) as nvarchar),'') as nvarchar(4000)) as newstring, cast(substring(numberstring,2,len(numberstring)) as nvarchar) as remainingstring from source_table union all select len(remainingstring) as currentstringlength, cast(try_cast(replace(left(remainingstring, 1),' ','z') as tinyint) as nvarchar) as firstcharasnumeric, cast(isnull(newstring,'') as nvarchar(3999)) + isnull(cast(try_cast(nullif(left(remainingstring, 1),'') as tinyint) as nvarchar(1)),'') as newstring, substring(remainingstring,2,len(remainingstring)) as remainingstring from first_char_processed fcp2 where fcp2.currentstringlength > 1 ) select newstring from first_char_processed where currentstringlength = 1;
create or alter function dbo.udf_number_from_text( @text nvarchar(max), @search_term nvarchar(1000) = n'', @number_position tinyint = 1, @rtl bit = 0 as begin if @text is null or len(@text) = 0 goto exit_label;
set @text = trim(@text);
if len(@text) = len(@search_term) goto exit_label;
if len(@search_term) > 0 set @search_term_index = charindex(@search_term, @text);
if @search_term_index = 0 goto exit_label;
if @search_term_index > 0 if @rtl = 0 set @text = trim(right(@text, len(@text) - @search_term_index - len(@search_term) + 1));
else set @text = trim(left(@text, @search_term_index - 1));
if len(@text) = 0 goto exit_label;
set @number_start = patindex(@patt_number, @text);
if @number_start > 0 if @number_start = len(@text) select cast(substring(@text, @number_start, 1) as int);
else begin set @text = right(@text, len(@text) - @number_start + 1);
set @number_end = patindex(@patt_not_number, @text);
if @number_end = 0 select cast(@text as int);
else begin select cast(left(@text, @number_end - 1) as int);
if @number_end = len(@text) else begin set @text = trim(right(@text, len(@text) - @number_end));
if len(@text) = 0 break;
if @rtl = 0 select @result = coalesce(a.val, 0) from (select row_number() over (order by m.id asc) as c_row, m.val from @found_numbers as m) as a where a.c_row = @number_position;
else select @result = coalesce(a.val, 0) from (select row_number() over (order by m.id desc) as c_row, m.val from @found_numbers as m) as a where a.c_row = @number_position;
select dbo.udf_number_from text(n'text text 10 text, 25 term', n'term',2,1);
select substring(@fieldname, patindex('%[0-9]%', @fieldname), (len(@fieldname) - @lenst -@lenend));
create function udf_getnumbersfromstring (@string varchar(max)) as begin set    @string = replace(@string, substring(@string, patindex('%[^0-9]%', @string), 1), '') end;
select substr('003preliminary examination plan  ',regexp_instr ('003preliminary examination plan  ', '[[:digit:]]'),regexp_count ('003preliminary examination plan  ', '[[:digit:]]')) sample1, substr('coordination005',regexp_instr ('coordination005', '[[:digit:]]'),regexp_count ('coordination005', '[[:digit:]]')) sample2, substr('balance1000sheet',regexp_instr ('balance1000sheet', '[[:digit:]]'),regexp_count ('balance1000sheet', '[[:digit:]]')) sample3 from dual;
select substring(column_name,patindex('%[0-9]%', column_name),patindex('%[0-9][^0-9]%', column_name)-patindex('%[0-9]%', column_name)+1) from table name;
select substring(string, patindex('%[0-9]%', string), patindex('%[0-9][^0-9]%', string + 't') - patindex('%[0-9]%', string) + 1) as number from (values ('003preliminary examination plan'), ('coordination005'), ('balance1000sheet')) as a(string);
set @puvodni = n'abc1d8e8ttr987avc' select @puvodni;
set @return = concat(@return, substring(@string,patindex(@matchexpression, @string),1)) set @string = stuff(@string, patindex(@matchexpression, @string), 1, '') end select (@return);
select table_rows from information_schema.tables where table_name='the_table_you_want' -- can end here if only 1 db and table_schema = database();      -- see comment below if > 1 db;
select id from table order by id desc limit 1;
select `auto_increment` from   information_schema.tables where  table_schema = 'databasename' and    table_name   = 'tablename';
select id from table order by id desc limit 1;
select auto_increment from information_schema.tables where table_name = 'table';
select extract(year from sysdate) from dual;
select sysdate from dual;
select * from mytable where trunc(mydate, 'year') = trunc(sysdate, 'year');
select * from demo where  somedate between to_date('01/01 00:00:00', 'dd/mm hh24:mi:ss') and     to_date('31/12 23:59:59', 'dd/mm hh24:mi:ss');
select to_char(sysdate, 'yyyy') from dual;
between trunc(sysdate, 'year') and add_months(trunc(sysdate, 'year'), 12)-1/24/60/60;
select trunc(sysdate, 'year') begin_year from dual;
select * from table where extract( year from date_field) = extract(year from sysdate);
end try if @@trancount > 0 end catch;
select id, col from ( select tbl_a.id, tbl_a.col from tbl_a union all select tbl_b.id, tbl_b.col from tbl_b where id in (select id from tbl_a) and id in (select id from tbl_b) id, col having count(*) = 1;
select tbl, id, col from ( select tbl_a.id, tbl_a.col, "name_to_display1" as "tbl" from tbl_a union all select tbl_b.id, tbl_b.col, "name_to_display2" as "tbl" from tbl_b where id in (select id from tbl_a) and id in (select id from tbl_b) id, col having count(*) = 1;
if ( mysqli_connect_error() ) { if ( !is_array( $sourcedb_content) ) { if ( !is_array( $testdb_content) ) { if ( $errors > "" ) { else if ( $result === true ) return true;
else { select column_name,ordinal_position,data_type,column_type from ( select column_name,ordinal_position, data_type,column_type,count(1) rowcount from information_schema.columns where ( (table_schema='$source' and table_name='$table') or ) and table_name in ('$table') column_name,ordinal_position, data_type,column_type having count(1)=1 else {;
select t1.user_id,t2.user_id from t1 left join t2 on t1.user_id = t2.user_id and t1.username=t2.username and t1.first_name=t2.first_name and t1.last_name=t2.last_name;
select min (tbl_name) as tbl_name, pk, column_list from ( select ' source_table ' as tbl_name, s.pk, s.column_list from source_table as s union all select 'destination_table' as tbl_name, d.pk, d.column_list from destination_table as d having count(*) = 1;
select * from t1 where id not in (select id from t2) union  select * from t2 where id not in (select id from t1);
select  'robot' as `set`, r.* from    robot r where   row(r.col1, r.col2, ) not in ( select  col1, col2, ... from    tbd_robot ) union all select  'tbd_robot' as `set`, t.* from    tbd_robot t where   row(t.col1, t.col2, ) not in ( select  col1, col2, ... from    robot );
select * from yourfunctionname(parameter1, parameter2);
select * from fn('myfunc');
select * from table order by length(field) desc;
select * from table order by length(data) desc;
select * from table order by char_length(field);
select * from database order by len(data);
select * from yourtable order by length(column_name) desc;
select * from customer order by length(customername) desc;
alter table distributors add constraint check_types check (element_type in ('lesson', 'quiz') );
constraint check_types check (element_type::text = any (array['lesson'::character varying, 'quiz'::character varying) );
check constraint:;
alter table distributors add constraint check_types check (element_type = 'lesson' or element_type = 'quiz');
create type element_type as enum ('lesson', 'quiz');
create or replace function check_discussion_element_type() returns trigger as $$ select element_type into new_element_type from discussion where discussion.element_id = new.element_id;
if new_element_type != 'lesson' and new_element_type != 'quiz' then raise exception 'unexpected discussion type';
create trigger t_check_discussion_element_type after update or insert on discussion for each row execute procedure check_discussion_element_type();
from this: exec @anid = dbo.storedproc_fetch @id, @anotherid, @finalid exec dbo.adifferentstoredproc @anid (no value here) set @anid= (select top 1 * from @t);
create procedure [dbo].[sp_delete_item] as begin set nocount off select @cnt =count(id) from itemtransaction where itemid = @itemid end else begin set @status =1;
create procedure getimmediatemanager @managerid int output as begin select @managerid = managerid from humanresources.employee where employeeid = @employeeid if @@rowcount = 0 -- manager not found? end;
exec @return_status = getimmediatemanager 2, @managerid output;
if @return_status = 1 else print n'managerid is ' + @managerid;
create proc myproc as begin end go exec @i = myproc;
create proc myproc @b varchar(50) output as begin select @a = 1, @b='hello' end go exec myproc @i output, @j output;
create proc myproc as begin select name from sysobjects end go exec myproc;
select table_schema , table_name , column_name , ordinal_position , column_default , data_type , character_maximum_length , numeric_precision , numeric_precision_radix , numeric_scale , datetime_precision from   information_schema.columns where table_schema in ('dbo','meta') and table_name in (select name from sys.tables);
select * into #temptable from tablename exec [tempdb].[dbo].[sp_help] n'#temptable';
if (rs != null) { if (rs.next()) {;
select sc.name as columnname from sys.columns as sc and ep.minor_id = sc.column_id where  and ep.name = 'ms_description';
select c.name field, t.name type, c.precision, c.scale, c.is_nullable, c.collation_name from sys.columns c where object_id=object_id('<table to inspect>');
select col.name columnname,prop.value description, tbl.name tablename, sch.name schemaname from sys.columns col  left outer join  sys.extended_properties prop;
from dbo.sysobjects where xtype = 'u' and name <> 'sysdiagrams' sql: sql)) from    information_schema.table_constraints tc where constraint_type = 'primary key' and tc.constraint_name = cu.constraint_name and tc.table_name = c.table_name and cu.table_schema = c.table_schema and cu.column_name = c.column_name) ) from sys.objects obj where obj.type = 'u' and obj.name = c.table_name and col.name = c.column_name and col.is_identity = 1) ) from information_schema.columns c where (@schema is null or c.table_schema = @schema) and (@tablename is null or c.table_name = @tablename) sql: sql, param: new { schema = schema, tablename = table }, commandtype: commandtype.text) columns = tablecolumns, childconstraints = children, parentconstraints = parents select kcu1.constraint_name as [constraintname] from information_schema.referential_constraints rc and kcu1.constraint_schema = rc.constraint_schema and kcu1.constraint_name = rc.constraint_name and kcu2.constraint_schema = rc.unique_constraint_schema and kcu2.constraint_name = rc.unique_constraint_name where kcu1.ordinal_position = kcu2.ordinal_position and (@table is null or kcu1.table_name = @table or kcu2.table_name = @table) and (@schema is null or kcu1.table_schema = @schema or kcu2.table_schema = @schema) sql: sql, param: new { table = table, schema = schema }, commandtype: commandtype.text)) from    information_schema.table_constraints a where constraint_type = 'primary key' and a.constraint_name = b.constraint_name and a.table_name = @tablename and a.table_schema = @schema";
sql: sql, param: new { tablename = tablename, schema = schema }, commandtype: commandtype.text)) from sys.objects o where o.type = 'u' and c.is_identity = 1 and o.name = @tablename";
sql: sql, param: new { tablename = tablename }, commandtype: commandtype.text)) from information_schema.routines where routine_type = 'procedure' and (specific_schema = @schema or @schema is null) and (specific_name = @procname or @procname is null) and ((specific_name not like 'sp_%' and specific_name not like 'procutils_generateclass' and (specific_schema = @schema or @schema is null)) or specific_schema <> @schema)";
sql: sql, param: new { schema = schema, procname = procname }, commandtype: commandtype.text).tolist());
if (!string.isnullorempty(schema)) else { if (count < prms.count) if (sqlconnection.state != connectionstate.open) sqlconnection.open();
if (ds.tables.count > 0) from sys.objects as so where so.object_id in (select from sys.objects where type in ('p', 'fn')) and (so.name = @procname or @procname is null) and (schema_name(schema_id) = @schema or @schema is null) sql: sql, param: new { schema = schema, procname = sprocname }, commandtype: commandtype.text));
select tablename = tbl.table_schema + '.' + tbl.table_name, tabledescription = tableprop.value, columnname = col.column_name, columndatatype = col.data_type, columndescription = coldesc.columndescription from information_schema.tables tbl and tableprop.minor_id = 0 and tableprop.name = 'ms_description' select sc.object_id, sc.column_id, sc.name, colprop.[value] as columndescription from sys.columns sc and colprop.minor_id = sc.column_id and colprop.name = 'ms_description' and coldesc.name = col.column_name where tbl.table_type = 'base table';
select  t.name as [table name], c.name as [column name], p.name as [data type], p.max_length as[size],   cast(p.precision as varchar) +/+ cast(p.scale as varchar) as [precision/scale] from adventureworks.sys.objects as t join adventureworks.sys.columns as c join adventureworks.sys.types as p where t.type_desc=user_table;
select table_schema, table_name, column_name, ordinal_position, column_default, data_type, character_maximum_length, numeric_precision, numeric_precision_radix, numeric_scale, datetime_precision from adventureworks.information_schema.columns;
select col.column_name, ordinal_position, data_type, character_maximum_length, numeric_precision, numeric_precision_radix, numeric_scale, datetime_precision, is_nullable, constraint_type, columnproperty(object_id(col.table_name), col.column_name, 'isidentity') is_identity, columnproperty(object_id(col.table_name), col.column_name, 'iscomputed') is_computed from information_schema.columns col ( select column_name, constraint_type from information_schema.constraint_column_usage a where a.table_name = 'user' where col.table_name = 'user';
select * from information_schema.tables select * from information_schema.columns;
select tablename = tbl.table_schema + '.' + tbl.table_name, tabledescription = prop.value, columnname = col.column_name, columndatatype = col.data_type from information_schema.tables tbl and col.table_schema = tbl.table_schema and prop.minor_id = 0 and prop.name = 'ms_description' where tbl.table_type = 'base table';
select      u.name + '.' + t.name as [table], td.value as [table_desc], c.name as [column], cd.value as [column_desc] from        sysobjects t and     td.minor_id = 0 and     td.name = 'ms_description' and     cd.minor_id = c.colid and     cd.name = 'ms_description' where t.type = 'u';
select group_concat(`x`) from `tbl`;
select group_concat(`x`) from `tbl`;
select group_concat(`x`), ifnull(`y`, `x`) as `grp` from `tbl`;
select `table1`.*, ifnull(ancestor,uuid()) as unq_ancestor from `table1` where (enabled = 1);
select `table1`.*, group_concat(id separator ',') as `children_ids`, if(isnull(ancestor),table1.id,null) as `do_not_group_on_null_ancestor` from `table1` where (enabled = 1);
select table1.*, group_concat(id separator ',') as children_ids from table1 where (enabled = 1) then table1.id else 0 end;
select column1,column2,column3,group_concat(if(column4='', null, column4)) as from ( select column1,group_concat(column2) as column2,sum(column3 ) as column3,'' as from table1 union all  select column1,'' as column2,'' as column3,group_concat(column4) as from table 2;
select * from tblpm n where date_updated=(select date_updated from tblpm n;
select * from tblpm n from tblpm group by control_number having date_updated=max(date_updated);
select * from tblpm n where date_updated=(select max(date_updated) from tblpm where control_number=n.control_number);
select n.* from tblpm n select control_number, max(date_updated) as date_updated from tblpm group by control_number;
select foo from   bar where  <some condition> limit  <pagesize>;
if (sequencequeryresult != null);
if (initialstate != connectionstate.open) if (initialstate != connectionstate.open);
set identity_insert [students] on;
where t : class;
select  a.field1 from table1 a join table2 b where a.field5 = 'test' and b.field3 = 1 select  a.field1 from table1 a where a.field5 = 'test' and b.field3 = 1 select  a.field1 from table1 a where a.field5 = 'test';
create table pilotskills ( pilot_name char(15) not null, plane_name char(15) not null ) create table hangar ( plane_name char(15) not null );
select distinct pilot_name from pilotskills as ps1 where not exists ( select * from hangar where not exists ( select * from pilotskills as ps2 where ) );
select distinct u.user_name from users as u join accepted_answers as a1 on u.user_id = a1.user_id where not exists ( select * from target_language_tags t where not exists ( select * from accepted_answers as a2 join questions as q on a2.question_id = q.question_id join question_tags as qt on qt.question_id = q.question_id where qt.tag_name = t.tag_name and ) );
--                                              because pad_index uses the percentage specified by fillfactor. if the percentage specified set nocount on;
if object_id(n'tempdb.dbo.#work_to_do') is not null drop table #work_to_do create table #work_to_do ( [sql_id] [int] identity(1, 1) [tsql_text] [varchar](1024) , [completed] [bit] ) set @version = cast(left(cast(serverproperty(n'productversion') as [nvarchar](128)), charindex('.', cast(serverproperty(n'productversion') as [nvarchar](128))) - 1) + n'.' + replace(right(cast(serverproperty(n'productversion') as [nvarchar](128)), len(cast(serverproperty(n'productversion') as [nvarchar](128))) - charindex('.', cast(serverproperty(n'productversion') as [nvarchar](128)))), n'.', n'') as [numeric](18, 10)) if @datacompression in (n'page', n'row', n'none') and ( @version >= 10.0 and serverproperty(n'engineedition') = 3 ) set @includedatacompressionargument = n'y' end  if @includedatacompressionargument is null set @includedatacompressionargument = n'n' end  select 'alter index [' + i.[name] + '] on' + space(1) + quotename(t2.[table_catalog]) + '.' + quotename(t2.[table_schema]) + '.' + quotename(t2.[table_name]) + space(1) + 'rebuild with (' + space(1) + + case then 'pad_index =' + space(1) + case i.[is_padded] then 'on' then 'off' end else 'pad_index =' + space(1) + @padindex end + case then ', fillfactor =' + space(1) + convert([varchar](3), replace(i.[fill_factor], 0, 100)) else ', fillfactor =' + space(1) + convert([varchar](3), @fillfactor) end + case then '' else ', sort_in_tempdb =' + space(1) + @sortintempdb end + case then '' else ', online =' + space(1) + @onlinerebuild end + ', statistics_norecompute =' + space(1) + case st.[no_recompute] then 'off' then 'on' end + ', allow_row_locks =' + space(1) + case i.[allow_row_locks] then 'off' then 'on' end + ', allow_page_locks =' + space(1) + case i.[allow_page_locks] then 'off' then 'on' end + case then case then '' else ', data_compression =' + space(1) + @datacompression end else '' end + case then '' else ', maxdop =' + space(1) + convert([varchar](2), @maxdop) end + space(1) + ')' from [sys].[tables] t1 and i.[index_id] > 0 and i.[type] in (1, 2) and t2.[table_type] = 'base table' and st.[name] = i.[name] select @sqlstatementid = min([sql_id]) from #work_to_do where [completed] = 0 select @currenttsqltoexecute = [tsql_text] from #work_to_do where [sql_id] = @sqlstatementid exec [sys].[sp_executesql] @currenttsqltoexecute update #work_to_do set [completed] = 1 where [sql_id] = @sqlstatementid select @sqlstatementid = min([sql_id]) from #work_to_do where [completed] = 0 end;
--           you may pass a specific database name if you only create procedure sp_rebuildallindexes( @fillfactor     int = 90, @targetdatabase nvarchar(100) = null) as begin tablename varchar(200) if isnull( @targetdatabase, '' ) = '' set @databasestoindex = cursor from   master..sysdatabases else set @databasestoindex = cursor from   master..sysdatabases where  name = @targetdatabase set @tableselect = 'insert into @tablestoreindex select concat(table_catalog, ''.'', table_schema, ''.'', table_name) as tablename from ' exec sp_executesql end  select tablename from   @tablestoreindex end  end;
exec sp_msforeachtable 'set quoted_identifier on; alter index all on ? rebuild';
set @fillfactor = 80 select quotename(object_schema_name([object_id]))+'.' + quotename(name) as tablename from sys.tables set @sql = 'alter index all on ' + @tablename + ' rebuild with (fillfactor = ' + convert(varchar(3),@fillfactor) + ')' exec (@sql) end close tablecursor;
select dbschemas.[name] as 'schema', dbtables.[name] as 'table', dbindexes.[name] as 'index', indexstats.avg_fragmentation_in_percent, indexstats.page_count from sys.dm_db_index_physical_stats (db_id(), null, null, null, null) as indexstats and indexstats.index_id = dbindexes.index_id where indexstats.database_id = db_id() and dbtables.[name] like '%%';
select name from master.sys.databases where name in ('your database name')  -- databases and state = 0 -- database is online and is_in_standby = 0 -- database is not read only for log shipping set @cmd = 'declare tablecursor cursor read_only for select ''['' + table_catalog + ''].['' + table_schema + ''].['' + exec (@cmd) set @cmd = 'alter index all on ' + @table + ' rebuild' exec (@cmd) end try end catch end  end close databasecursor;
select @string ( select 'alter index [' + dbindexes.[name] + '] on [' + db.name + '].[' + dbschemas.[name] + '].[' + dbtables.[name] from sys.dm_db_index_physical_stats(db_id(), null, null, null, null) as indexstats and indexstats.index_id = dbindexes.index_id where dbindexes.name is not null and indexstats.database_id = db_id() and indexstats.avg_fragmentation_in_percent >= 10 exec (@string);
select name from master.sys.databases where name not in ('master','msdb','tempdb','model','distribution')  -- databases to exclude and state = 0 -- database is online and is_in_standby = 0 -- database is not read only for log shipping set @cmd = 'declare tablecursor cursor read_only for select ''['' + table_catalog + ''].['' + table_schema + ''].['' + exec (@cmd) set @cmd = 'alter index all on ' + @table + ' rebuild' exec (@cmd) end try end catch end  end close databasecursor;
exec sp_send_dbmail @profile_name='yourprofilename', @recipients='test@example.com', @subject='test message', @body='this is the body of the test message.;
select @id=min(id), @max_id=max(id) from [email_adresses] select @email_id=email_id from [email_adresses] set @query='sp_send_dbmail @profile_name=''yourprofilename'', @recipients='''+@email_id+''', @subject=''test message'', @body=''this is the body of the test message. exec @query select @id=min(id) from [email_adresses] where id>@id end;
create table #emailaddresses (email varchar(25)) select @recipients = coalesce(@recipients + ';', '') + email from #emailaddresses select @recipients drop table #emailaddresses;
as declare @results varchar(max) set @subjecttext = 'your subject' set @results = 'your results' exec msdb.dbo.sp_send_dbmail @recipients = 'xxxx@xxxx.com', @body = @results, @subject = @subjecttext, @exclude_query_output = 1 --suppress 'mail queued' message;
exec msdb.dbo.sp_send_dbmail @subject='testing email from sql server', @body='<p>it worked!</p><p>email sent successfully</p>', @body_format='html', @from_address='sender name <sender@yourdomain.com>', @reply_to='sender@yourdomain.com';
set ansi_nulls on set quoted_identifier on create procedure mass_email as select email from [dbo].[emailmessagetable] set @body = (select body from [dbo].[emailmessagetable] where email = @email) exec msdb.dbo.sp_send_dbmail @recipients = @email, @body = @body, @subject = 'credentials for web';
end close test_cur;
exec msdb.dbo.sp_send_dbmail @recipients = 'to email here', @copy_recipients ='cc email here',             --for cc email if exists @body = 'mail body here', @body_format='html', @importance ='high', @file_attachments='c:\test.pdf';               --for attachments if exists;
update table set phonenumber = dbo.stripnonnumeric(phonenumber);
update table set phonenumber = dbo.stripnonnumeric(phonenumber) where phonenumber like '%[^0-9]%';
create function string.comparablephone( @string nvarchar(32) ) returns bigint as ( select row_number() over (order by (n1+n10) desc), -- since we are using stuff, for the position to continue to be accurate, start from the greatest position and work towards the smallest from (select 0 as n1 union select 1 union select 2 union select 3 union select 4 union select 5 union select 6 union select 7 union select 8 union select 9) as d1, (select 0 as n10 union select 10 union select 20 union select 30) as d10 where (n1+n10) between 1 and len(@string) and substring(@string, (n1+n10), 1) not in (select chr from @keepers) ) select @string = stuff( @string, position, 1, '' ) from found id asc; -- important to process the removals in order, see row_number() above if len(@string) = 0 end;
select i.phone, i.first_name, i.last_name from imported as i where c.phone is null -- exclude those that already exist;
create function dbo.removenonnumericchar(@str varchar(500)) set @startingindex=0 set @startingindex= patindex('%[^0-9]%',@str) if @startingindex <> 0 set @str = replace(@str,substring(@str,@startingindex,1),'') end else    break;
end return @str end  select dbo.removenonnumericchar('aisdfhoiqwei352345234@#$%^$@345345%^@#$^');
create function [fnremovenonnumericcharacters](@strtext varchar(1000)) as begin set @strtext = stuff(@strtext, patindex('%[^0-9]%', @strtext), 1, '') end return @strtext end;
set @phone = replace(replace(replace(replace(@phone,'(',''),' ',''),'-',''),')','');
create function [dbo].[removealphacharacters](@inputstring varchar(1000)) as begin set @inputstring = stuff(@inputstring,patindex('%[^0-9]%',@inputstring),1,'') end ;
create function [dbo].[udf_removenumericstringsfromstring] ( @str varchar(100) ) ( -- 100 rows select top (len(@str)) row_number() over (order by (select null)) from (values (0),(0),(0),(0),(0),(0),(0),(0),(0),(0)) a(n) ) select outstr =  stuff( (select substring(@str, n,1) st from tally where isnumeric(substring(@str, n,1)) = 1 select outstr from dbo.udf_removenumericstringsfromstring('fjkfhk759734977fwe9794t23');
drop schema if exists schema_name create schema schema_name;
select schema_name from information_schema.schemata where schema_name = 'name';
select exists(select 1 from information_schema.schemata where schema_name = 'name');
select exists(select 1 from pg_namespace where nspname = 'name');
select exists (select 1 from information_schema.schemata where catalog_name = 'my_bd_with_uppercase_characters_in_its_name');
if not exists( select schema_name from information_schema.schemata where schema_name = 'pgcrypto' ) then execute 'create schema pgcrypto';
create schema if not exists foo;
create schema if not exists tenant;
select exists (select 1 from pg_catalog.pg_namespace where nspowner <> 1 and nspname = 'schemaname');
select 1 from pg_catalog.pg_namespace where nspowner <> 1 -- ignore tables made by postgres itself and nspname = 'schemaname';
alter table ... alter constraint;
so the default setting of not deferrable can be altered to deferrable and back.";
select replace_foreign_key('user_rates_posts', 'post_id', 'on delete cascade');
create or replace function as $$ select tc.constraint_name, ccu.table_name as foreign_table_name, ccu.column_name as foreign_column_name from information_schema.table_constraints as tc join information_schema.key_column_usage as kcu join information_schema.constraint_column_usage as ccu where constraint_type = 'foreign key' and tc.table_name= f_table and kcu.column_name= f_column;
alter table t1 drop constraint ... alter table t1 add constraint ...;
case class test(name: string, m: map[string, string]);
or val rowrdddffinal = rowrdddf.select("map.one");
case class subrecord(x: int) case class arrayelement(foo: string, bar: int, vals: array[double]) case class record( an_array: array[int], a_map: map[string, string], a_struct: subrecord, an_array_of_structs: array[arrayelement]) record(array(1, 2, 3), map("foo" -> "bar"), subrecord(1), array( arrayelement("foo", 1, array(1.0, 2.0, 2.0)), arrayelement("bar", 2, array(3.0, 4.0, 5.0)))), record(array(4, 5, 6), map("foz" -> "baz"), subrecord(2), array(arrayelement("foz", 3, array(5.0, 6.0)), arrayelement("baz", 4, array(7.0, 8.0))));
set @date = getdate() set @date = dateadd(day, 1, @date) select @date;
select getdate() -- 2010-02-05 10:03:44.527 select convert(varchar(12),getdate(),100) +' '+ 'date -100- mmm dd yyyy' -- feb 5 2010 union select convert(varchar(10),getdate(),101) +' '+ 'date -101- mm/ddyyyy' union select convert(varchar(10),getdate(),102) +' '+ 'date -102- yyyy.mm.dd' union select convert(varchar(10),getdate(),103) +' '+ 'date -103- dd/mm/yyyy' union select convert(varchar(10),getdate(),104) +' '+ 'date -104- dd.mm.yyyy' union select convert(varchar(10),getdate(),105) +' '+ 'date -105- dd-mm-yyyy' union select convert(varchar(11),getdate(),106) +' '+ 'date -106- dd mmm yyyy' --ex: 03 jan 2007 union select convert(varchar(12),getdate(),107) +' '+ 'date -107- mmm dd,yyyy' --ex: jan 03, 2007 union select convert(varchar(12),getdate(),109) +' '+ 'date -108- mmm dd yyyy' -- feb 5 2010 union select convert(varchar(12),getdate(),110) +' '+ 'date -110- mm-dd-yyyy' --02-05-2010 union select convert(varchar(10),getdate(),111) +' '+ 'date -111- yyyy/mm/dd' union select convert(varchar(12),getdate(),112) +' '+ 'date -112- yyyymmdd' -- 20100205 union select convert(varchar(12),getdate(),113) +' '+ 'date -113- dd mmm yyyy' -- 05 feb 2010 select convert(varchar, getdate(), 20) -- 2010-02-05 10:25:14 select convert(varchar, getdate(), 23) -- 2010-02-05 select convert(varchar, getdate(), 24) -- 10:24:20 select convert(varchar, getdate(), 25) -- 2010-02-05 10:24:34.913 select convert(varchar, getdate(), 21) -- 2010-02-05 10:25:02.990 select convert(varchar(12),getdate(),108) +' '+ 'date -108- hh:mm:ss' -- 10:05:53 select convert(varchar(12),getdate(),114) +' '+ 'date -114- hh:mm:ss:ms' -- 10:09:46:223 select convert(varchar, getdate(), 22) -- 02/05/10 10:23:11 am select getdate()+1 select month(getdate())+1 select year(getdate())+1;
select dateadd(day, 1, getdate());
set @columnname='' set @sql='' select @sql=@sql+'union select '''+d.name+'.''+sh.name+''.''+o.name collate sql_latin1_general_cp1_ci_as as name,c.name collate sql_latin1_general_cp1_ci_as as columnname,c.column_id from '+d.name+'.sys.columns            c where c.name like ''%'+@columnname+'%'' and sh.name<>''sys'' from sys.databases d select @sql=right(@sql,len(@sql)-5)+'order by 1,3' exec (@sql);
select table_catalog from information_schema.columns where column_name like ''%columnnamehere%''';
select @query = 'use ? select ''?'' as databasename, sys.columns.name as columnname  , sys.tables.name  as tablename   , schema_name (sys.tables.schema_id) as schemaname from sys.columns join sys.tables where sys.columns.name = ''id'' ' exec sp_msforeachdb @query;
select distinct name from syscolumns;
select name from syscolumns;
select distinct column_name  from information_schema.columns;
select object_name(id) as tablename, name as columnname from syscolumns;
select sys.columns.name as columnname, tables.name as tablename from sys.columns join sys.tables on sys.columns.object_id = tables.object_id;
exec sp_msforeachdb 'use ? select * from information_schema.columns ';
set @columnname = 'course_id' +''','''+'courseid' ( [databasename] nvarchar(128) null, [columnname] sysname null, [objectname] nvarchar(257) not null, [objecttype] nvarchar(60) null, [datatype] nvarchar(151) null, [nullable] varchar(8) not null, [miscinfo] nvarchar(max) not null ) set @sql_string2 = 'select s.name as columnname else t.name end as datatype else ''not null'' end as nullable else '' identity(''+isnull(convert(varchar(10),ic.seed_value),'''')+'',''+isnull(convert(varchar(10),ic.increment_value),'''')+'')=''+isnull(convert(varchar(10),ic.last_value),''null'') end +case else '' computed(''+isnull(sc.definition,'''')+'')'' end +case else '' check(''+isnull(cc.definition,'''')+'')'' end as miscinfo from sys.columns                           s select  name  from sys.databases where state = 0 and name not in ('msdb','tempdb','model','docxpress') set @sql_string1 = 'use [' + @dbname + ']' set @sql_string1 = @sql_string1 + @sql_string2 exec sp_executesql @sql_string1;
select * from ##temp_column_info;
drop table ##temp_column_info;
end close db_cursor;
select * from @column_info order by 2,3 end --------------------------- set nocount on [table_catalog]              nvarchar(128) null ) select  name  from sys.databases where state = 0 and name not in ('msdb','tempdb','model','docxpress') set @sql_string2 = ' select * into ##temp_column_info from [' + @dbname + '].information_schema.columns where upper(column_name) like ''course%'' if @dbug = 1  select @sql_string2 as '@sql_string2';
exec sp_executesql @sql_string2;
select * from ##temp_column_info;
drop table ##temp_column_info;
end select * from @hanktst order by 4,2,3 set @temprowcnt = (select cast(count(1) as varchar(10)) from @hanktst ) end --------;
@vchdynamicquery as varchar(max), @databasescursor cursor set @databasescursor = cursor for select name from sys.databases where database_id > 4 set @vchdynamicquery = b.table_name as ''table name'', stuff((select '', '' + a.column_name from ' + @vchdynamicdatabasename + '.information_schema.columns a where a.table_name = b.table_name from ' + @vchdynamicdatabasename + '.information_schema.columns b where b.table_name like ''%%'' and b.column_name like ''%%'' end close @databasescursor;
set @table_name = '' set @column_name = '' select rownumber = row_number() over( partition by t.[name] order by t.[name],c.column_id  ), schema_name( t.schema_id ) as schemaname , t.[name] as table_name , c.[name] as field_name , systype.name , c.max_length , c.is_nullable , c.is_identity , c.scale , c.precision from sys.tables as t where ( type = 'u' ) and ( c.name like '%' + @column_name + '%' ) and ( t.name like '%' + @table_name + '%' );
select @sql=@sql+'union select '''+d.name +'.''+sh.name+''.''+o.name collate sql_latin1_general_cp1_ci_as,c.name collate sql_latin1_general_cp1_ci_as,c.column_id from '+d.name +'.sys.columns            c from sys.databases d select @sql=right(@sql,len(@sql)-5)+'order by 1,3' exec (@sql);
select * from information_schema.columns where column_name = 'my_column';
select o.name,c.name from sys.columns            c;
select o.name as [table], c.name as [column] from sys.columns            c;
select s.name as columnname else t.name end as datatype else 'not null' end as nullable else ' identity('+isnull(convert(varchar(10),ic.seed_value),'')+','+isnull(convert(varchar(10),ic.increment_value),'')+')='+isnull(convert(varchar(10),ic.last_value),'null') end +case else ' computed('+isnull(sc.definition,'')+')' end +case else ' check('+isnull(cc.definition,'')+')' end as miscinfo from sys.columns                           s;
set @sql='' select @sql=@sql+'union select '''+d.name+'.''+sh.name+''.''+o.name,c.name,c.column_id from '+d.name+'.sys.columns            c from sys.databases d select @sql=right(@sql,len(@sql)-5)+'order by 1,3' exec (@sql);
set @sql='' select @sql=@sql+'union select '''+d.name+'.''+sh.name+''.''+o.name,c.name,c.colid from '+d.name+'..syscolumns            c from master.dbo.sysdatabases d select @sql=right(@sql,len(@sql)-5)+'order by 1,3' exec (@sql);
from sys.columns            c;
select * from information_schema.columns;
select * from dbname.information_schema.columns;
select datalength(companyname), companyname from customers;
select model, date from doc where date in (select max(date) from doc group by model);
select model, date from doc where date = (select max(date) from doc group by model limit 0, 1);
select model, max(date) from doc;
select model, date from doc where date in (select max(date) from doc);
select d.model, d.date, d.color, d.etc from doc d where d.date in (select max(d2.date) from doc d2 where d2.model=d.model);
select model, date, color, etc from (select model, date, color, etc, max(date) over (partition by model) max_date from doc) predoc where date=max_date;
select model, date from doc group by model order by date desc;
select t.model, t.date from doc t;
select model, date from doc order by date desc limit 1;
select model, date from (select * from doc order by date desc) as sortedtable;
select a, b, c, d from ( select 1 as a, 2 as b, 3 as c, 4 as d union all select 5 , 6, 7, 8;
create temporary table temptable ( id int, name char(100) ) type=heap;
select * from temptable;
drop table temptable;
select * from table(values (1,7), (2, 6), (3, 13), ...) as sometable(id, count);
( select 0 as nbr union all select 1 union all select 2 union all select 3 union all select 4 union all select 5 union all select 6 union all select 7 union all select 8 union all select 9 sequence (seq) as ( select units.nbr + tens.nbr + hundreds.nbr from digits as units ) select s1.seq from sequence as s1;
select a, b from (values (1, 2), (3, 4), (5, 6), (7, 8), (9, 10) ) as mytable(a, b);
select regexp_substr('abc[def]ghi', '\[(.+)\]', 1,1,null,1) from dual;
select substr( match, 2, length(match)-2 ) from ( select regexp_substr('abc[def]ghi', '\[(.+)\]') match from dual;
select regexp_replace(de_desc, '.*\[(.+)\].*', '\1') from database;
array_agg(jsonb_build_object('att1', column1, 'att2', column2)), to_jsonb('{"att1":null, "att2":null}'::json) );
create or replace function public.json_clean_array(p_data json) as $$ select json_agg(value) from json_array_elements(p_data) where value::text <> 'null' and value::text <> '""';
create or replace function public.json_clean(p_data json) as $$ select ('{' || string_agg(to_json(key) || ':' || value, ',') || '}') :: json from json_each(p_data) where value::text <> 'null' and value::text <> '""';
create or replace function public.json_clean(p_data json) as $$ select json_object_agg(key, value) from json_each(p_data) where value::text <> 'null' and value::text <> '""';
select c.id, c.name, coalesce(json_agg(e) filter (where e.user_id is not null), '[]') as emails from contacts c;
select c.id, c.name, case when exists (select true from emails where user_id=c.id) then json_agg(e) else '[]' end from contacts c;
select c.id, c.name, case when count(e) = 0 then '[]' else json_agg(e) end as emails from contacts as c;
select c.id, c.name, coalesce(e.emails, '[]') as emails from contacts as c select e.user_id, json_agg(e) as emails from emails as e group by e.user_id;
select c.id, c.name, array_to_json(array(select email from emails e where e.user_id=c.id)) from contacts c;
create or replace function public.json_clean_array(data json) as $$ select array_to_json(array_agg(value)) :: json from ( select value from json_array_elements(data) where cast(value as text) != 'null' and cast(value as text) != '';
select friend_id as friend, json_clean_array(array_to_json(array_agg(comment))) as comments from some_entity_that_might_have_comments;
create or replace function public.json_clean(data json) as $$ select ('{' || string_agg(to_json(key) || ':' || value, ',') || '}') :: json from ( with to_clean as ( select * from json_each(data) ) select * from json_each(data) where cast(value as text) != 'null' and cast(value as text) != '';
select c.id, c.name, coalesce(nullif(json_agg(e)::text, '[null]'), '[]')::json as emails from contacts c;
select parsename('123.234.23.14', 1);
( select '131.33.2.201' as ip_address union all select '2.12.4.4' as ip_address union all select '131.33.2.202' as ip_address union all select '2.12.4.169' as ip_address union all select '131.107.2.201' as ip_address ) select ip_address from ip_addresses;
select * from table_name where dob > '1/21/2012';
select * from table_name where dob between '1/21/2012' and '2/22/2012';
select ifnull('some value', 'some other value');
select ifnull(null,'some other value');
select coalesce(null, 'some other value');
select coalesce(null, 'some value', 'some other value');
select coalesce(null, null, null, null, 'first non-null value');
select isnull(null, null);
select isnull(null, cast(null as varchar));
select coalesce(null, null, null, null, null);
select coalesce(null, null, null, null, 'first non-null value');
case when (a1 is not null) then a1 when (a2 is not null) then a2 else an end;
select a.mbitno ,a.mbstqt,ifnull(b.apr,0) from ( select mmstcd,mbstat,mbfaci,mbwhlo,mbitno,mbstqt,mbalqt from libl.mitbal  inner join libl.mitmas on where mbcono=200 and mbstat in ('20','50') and mmstcd>0 ) as a left join ( select mlfaci,mlwhlo,mlitno,mlstas,sum(mlstqt) as apr from libl.mitloc where mlcono=200 and mlstas='2' ) where a.mbitno in 'gwf0240xpec' and a.mbstqt>0 and a.mbstqt<>ifnull(b.apr,0);
create index [index name] on [table name] ( [column name] );
create nonclustered index my_idx on my_table (my_col1 asc, my_col2 asc) include (my_col3);
create [ unique ] [ clustered | nonclustered ] index index_name;
create index index_name;
create unique index index_name on table_name (column_name);
create clustered index cl_id on sales(id);
create nonclustered index nonci_pc on sales(productcode);
create index name_index on employee (employee_name);
create index name_index on employee (employee_name, employee_age);
create index <index_name> on <table_name>(<column_name>);
create unique index <index_name> on <table_name>(<column_name>);
if (nextabove == -1) { if (nextabove != -1) {;
select x from table1;
if (a[i] === b[j]) { else if (a[i] < b[j]) { else j++;
if (binarysearch($numbers2, $n1) >= 0) {;
if (!hm[list1[i]]) { if (hm[list2[i]] >= 1) {;
if (isset($keys1[$n2]) { // o(1);
if (a[$apos] == b[$bpos])// found a match else if (a[$apos] > b[$bpos]) // b is lower than a, so have b try and catch up to a. else if (a[$apos] < b[$bpos]) // the value at a is less than the value at b, so increment b;
( [1001] => 2 );
if (isset($counts[$n1])) {;
if (in_array($n1, $numbers2));
alter table tbl_name drop foreign key fk_symbol;
select * from information_schema.key_column_usage where referenced_table_name = 'yourtable';
set foreign_key_checks=0; drop table bericht; set foreign_key_checks=1;
set foreign_key_checks = 0;
drop table if exists customers;
drop table if exists orders;
drop table if exists order_details;
set foreign_key_checks = 1;
alter table 'bericht' drop foreign key 'your_foreign_key';
alter table 'bericht' add constraint 'your_foreign_key' foreign key ('column_foreign_key') references 'other_table' ('column_parent_key') on update cascade on delete set null;
where people.marriage_status != %(status_1)s or people.marriage_status is null;
select people.name as people_name, people.marriage_status as people_marriage_status from people where people.marriage_status is null or people.marriage_status != ?;
select questionid, ltrim(max(sys_connect_by_path(elementid,',')) from   (select questionid, elementid, row_number() over (partition by questionid order by elementid) as curr, row_number() over (partition by questionid order by elementid) -1 as prev from   emp);
select question_id, wm_concat(element_id) as elements from   questions;
select question_id, listagg(element_id, ',') within group (order by element_id) from your_table;
select * from someable join splitfunction(@ids) as splits on sometable.id = splits.id;
create function [dbo].[func_splitorderids] ( @orderlist varchar(500) ) ( orderid int ) as begin set @orderlist = ltrim(rtrim(@orderlist))+ ',' set @pos = charindex(',', @orderlist, 1) if replace(@orderlist, ',', '') <> '' set @orderid = ltrim(rtrim(left(@orderlist, @pos - 1))) if @orderid <> '' values (cast(@orderid as int)) --use appropriate conversion end set @orderlist = right(@orderlist, len(@orderlist) - @pos) set @pos = charindex(',', @orderlist, 1) end end return end;
if exists (select * from dbo.sysobjects where id = object_id(n'[dbo].[uspsplittextlist]') and objectproperty(id, n'isprocedure') = 1) drop procedure [dbo].[uspsplittextlist] set quoted_identifier on set ansi_nulls on create procedure uspsplittextlist @delimiter           varchar(3) as  set nocount on create table #list_items ( item_order integer, item_begpos integer, item_endpos integer ) if @list_text is not null set @inputlen = datalength(@list_text) set @textpos = 1 set @delimchar = substring(@delimiter, 1, 1) set @delimlen = datalength(@delimiter) set @itembegpos = 1 set @itemorder = 1 set @chunklen = 1 set @chunk = substring(@list_text, @textpos, 8000) set @chunkpos = 1 set @chunklen = datalength(@chunk) set @delimpos = charindex(@delimchar, @chunk, @chunkpos) if substring(@list_text, (@textpos + @delimpos - 1), @delimlen) = @delimiter values (@itemorder, @itembegpos, (@textpos + @delimpos - 1) - 1) set @itemorder = @itemorder + 1 set @itembegpos = (@textpos + @delimpos - 1) + @delimlen set @chunkpos = @delimpos + @delimlen end else begin set @chunkpos = @delimpos + 1 end  set @delimpos = charindex(@delimchar, @chunk, @chunkpos) end  set @textpos = @textpos + @chunklen end  if @itembegpos <= @inputlen values (@itemorder, @itembegpos, @inputlen) end  delete from #list_items where item_endpos < item_begpos select substring(@list_text, item_begpos, (item_endpos - item_begpos + 1)) as item_text, item_order, item_begpos, item_endpos from #list_items end  drop table #list_items set quoted_identifier off set ansi_nulls on;
as  set @query =' select * from table where id in('+@id+')';
create table numbers constraint pk_numbers primary key clustered (number asc)with (pad_index  = off, statistics_norecompute  = off, ignore_dup_key = off, allow_row_locks  = on, allow_page_locks  = on) on [primary] set @x=0 set @x=@x+1 end;
create function [dbo].[fn_listtotable] ( @spliton              char(1)              --required, the character to split the @list string on ) ( listvalue varchar(500) ) as begin select * from dbo.fn_listtotable(',','1,12,123,1234,54321,6,a,*,|||,,,,b') select listvalue from (select from ( select @spliton + @list + @spliton as list2 where substring(list2, number, 1) = @spliton where listvalue is not null and listvalue!='' end --function fn_listtotable;
select col1, col2, col3... from  yourtable;
select * from sometable where tableid in(select listvalue from dbo.fn_listtotable(',',@ids) s);
select * from sometable where charindex(','+cast(tableid as varchar(8000))+',', @ids) > 0;
alter function dbo.split_id(@string varchar(8000)) as begin set @delimiter =',' select @idx = 1 if len(@string)<1 or @string is null  return set @idx = charindex(@delimiter,@string) if @idx!=0 set @slice = left(@string,@idx - 1) else set @slice = @string set @string = right(@string,len(@string) - @idx) if len(@string) = 0 break end return end;
set     [dispatchcyclenumber] ='10' where  ordernumber in(select * from xa.fn_splitorderids(@invoicenumberlist))** create function [xa].[fn_splitorderids] ( @orderlist varchar(500) ) ( orderid int ) as begin set @orderlist = ltrim(rtrim(@orderlist))+ ',' set @pos = charindex(',', @orderlist, 1) if replace(@orderlist, ',', '') <> '' set @orderid = ltrim(rtrim(left(@orderlist, @pos - 1))) if @orderid <> '' values (cast(@orderid as int)) --use appropriate conversion end set @orderlist = right(@orderlist, len(@orderlist) - @pos) set @pos = charindex(',', @orderlist, 1) end end return end;
create function [dbo].[fn_listtotable] ( @spliton              char(1)              --required, the character to split the @list string on ) ( listvalue varchar(500) ) as begin set @number = @number + 1 set @lengthchildstring = charindex(@spliton, @processstring, @number + 1) - @number - 1 if @lengthchildstring > 0 set @childstring = ltrim(rtrim(substring(@processstring, @number + 1, @lengthchildstring))) if @childstring is not null and @childstring != '' set @number = @number + @lengthchildstring - 1 end end end  end;
select listvalue from dbo.fn_listtotable('/','a/////bb/c');
set @ids = @ids + @delim;
select 1, charindex(@delim, @ids, 1), substring(@ids, 1, charindex(@delim, @ids, 1) - 1) union all select i + 1, charindex(@delim, @ids, ls + 1), substring(@ids, ls + 1, charindex(@delim, @ids, ls + 1) - charindex(@delim, @ids, ls) - 1) from cte where  charindex(@delim, @ids, ls + 1) > 1 ) select t.* from yourtable t cte c;
create procedure [dbo].[getaccounts](@accountids nvarchar) as begin select * from accountstable where accountid in (select * from @accountids) end  create type intlisttabletype as table (n int not null) exec getaccounts @tvp;
set @ids = 1,2,3,5,4,6,7,98,234 set @xml = cast('<i>' + replace(@ids, ',', '</i><i>') + '</i>' as xml) select * from sometable;
set @accumulatekeywordcopy ='';
set @iddupcopy ='';
set @iddup = (select convert(varchar(max), <columnname>) from <tablename> where <clause>) set @accumulatekeywordcopy = ','+@accumulatekeyword+',';
set @iddupcopy = ','+@iddup +',';
set @iddupcheck = charindex(@iddupcopy,@accumulatekeywordcopy);
create or replace procedure udp_setbookmark ( p_userid in varchar2 update t_er_bewertung set lesezeichen = p_bookmark where stamm_id in( select regexp_substr(p_userid,'[^,]+', 1, level) from dual and er_id = (select max(er_id) from t_er_bewertung_kopie);
end udp_setbookmark;
set @str='a,b,c,d,e,bert,ernie,1,2,3,4,5' set @delimiter =',' set @xml = cast(('<x>'+replace(@str,@delimiter ,'</x><x>')+'</x>') as xml) select n.value('.', 'varchar(10)') as value from @xml.nodes('x') as t(n);
set @ids = '1,2,3,5,4,6,7,98,234';
select cn1,cn2,cn3 from tablename where columnname in (select value from fn_splitlist(@ids, ','));
select * from sometable where tableid in (select value from @ids);
create function [dbo].[fn_splitlist] ( @instring     varchar(max)  = '', @indelimiter  char(1)       = ',' -- keep the delimiter to 100 chars or less.  generally a delimiter will be 1-2 chars only. ) ( unit  varchar(1000) collate latin1_general_bin ) as begin select distinct ltrim(rtrim(piece.value('./text()[1]', 'varchar(1000)'))) collate database_default as unit from ( -- select cast(('<x>' + replace(s0.prsstring, s0.prssplitdelimit, '</x><x>') + '</x>') as xml).query('.') as units from ( -- select (select @instring for xml path('')) as prsstring, (select @indelimiter for xml path('')) as prssplitdelimit end;
set @ids = '1,2,3,5,4,6,7,98,234';
select * from sometable as st;
select name where find_in_set(id, values);
set @ids = '1,2,3,5,4,6,7,98,234';
select * from sometable where ','+@ids+',' like '%,'+convert(varchar(50),tableid)+',%';
set @ids = '1,2,3,5,4,6,7,98,234' set @xml = cast('<i>' + replace(@ids, ',', '</i><i>') + '</i>' as xml) select sometable.* from sometable where sometable .id = x.i.value('.', 'varchar(max)');
select productid, name, tags from product where '1,2,3,' like '%' + cast(productid as varchar(20)) + ',%';
create table t ( id   int, col1 varchar(50) ) values     (1, 'param1') values     (2, 'param2') values     (3, 'param3') values     (4, 'param4') values     (5, 'param5') set @params = ',param1,param2,param3,' select * from   t where  charindex(',' + cast(col1 as varchar(8000)) + ',', @params) > 0;
select [dbo].[regexreplace] ([mycolumn], '(;.*)', '') from [dbo].[mytable];
if object_id(n'regexreplace', n'fs') is not null drop function regexreplace;
if exists (select * from sys.assemblies where [name] = 'stringutils') drop assembly stringutils;
set @samplepath = 'c:\users\gotqn\desktop\stringutils\stringutils\stringutils\bin\debug\' create assembly [stringutils] from @samplepath + 'stringutils.dll' create function [regexreplace] (@input nvarchar(max), @pattern nvarchar(max), @replacement nvarchar(max)) as external name [stringutils].[regularexpression].[replace];
select 1, 'some text; some more text' union all select 2, 'text again; even more text' union all select 3, 'text without a semicolon' union all select 4, null -- test nulls union all select 5, '' -- test empty string union all select 6, 'test 3 semicolons; second part; third part' union all select 7, ';' -- test semicolon by itself select [dbo].[regexreplace] ([mytext], '(;.*)', '') from @mytable select * from @mytable;
select case when charindex(';', mytext) > 0 then from mytable;
set mytext = left(mytext+';', charindex(';',mytext+';')-1);
update mytable set mytext = substring(mytext, 1, charindex(';', mytext) - 1) where charindex(';', mytext) > 0;
update mytable set mytext = left(mytext, charindex(';', mytext) - 1) where charindex(';', mytext) > 0;
select 1, 'some text; some more text' union all select 2, 'text again; even more text' union all select 3, 'text without a semicolon' union all select 4, null -- test nulls union all select 5, '' -- test empty string union all select 6, 'test 3 semicolons; second part; third part;' union all select 7, ';' -- test semicolon by itself update @mytable set mytext = left(mytext, charindex(';', mytext) - 1) where charindex(';', mytext) > 0 select * from @mytable;
select coalesce(nullif(null  ,''),'0')     |                 '0' select coalesce(nullif(''    ,''),'0')     |                 '0' select coalesce(nullif('foo' ,''),'0')     |                 'foo';
update pt.incentive_channel set   pt.incentive_marketing = null where pt.incentive_marketing = '';
update pt.incentive_channel set   pt.incentive_advertising = null where pt.incentive_marketing = '';
update pt.incentive_channel set   pt.incentive_channel = null where pt.incentive_marketing = '';
where convert(varchar, date1, 101) = convert(varchar, date2, 101);
where convert(varchar(8), date1, 112) = where convert(varchar(8), date2, 112);
select * from ( select (((row_number() over(order by myfield) - 1) / 500) + 1) as pagenum from mytable where pagenum = 4;
select * from mytable;
select * from mytable set @currentsetnumber = @currentsetnumber + 1;
select * from sales.salesorderdetail;
select * from table order by [some_column];
select * from ( select row_number() over (order by (select 1)) as rawkey, * from [alzh].[dbo].[dm_thd_trans_fy14] where rawkey between 17210400 and 17210500;
select * from ( select row_number() over (order by clusteredindexfield) as rownumber, * from mytable where rownumber between @lowestrownumber and @highestrownumber;
select * from ( select row_number() over (order by field1 asc, field2 asc, field3 asc) as rownumber, clusteredindexfield from mytable where rownumber between @lowestrownumber and @highestrownumber;
@page int = 15619;
select @recordcount as recordcount, @pagecount as pagecount, @offset as offset, @lowestrownumber as lowestrownumber, @highestrownumber as highestrownumber;
select * from ( select row_number() over (order by field1 asc, field2 asc, field3 asc) as rownumber, clusteredindexfield from mytable where rownumber between @lowestrownumber and @highestrownumber;
select * from ( select row_number() over(order by (select 0)) rownum,* from your_table where tmp.rownum between 20 and 30 -- any numbers you need;
select id,value from xxx limit 2 , 0 select id,value from xxx limit 2 offset 2 select id,value from xxx;
select * from (select top (n) * from (select top (m + n - 1) from table order by mycolumn) qasc mycolumn desc) qdesc mycolumn;
select top n b.primarykeycolumn from top m primarykeycolumn from mytable where a.primarykeycolumn is null;
select top 100 * from tablename where primarykeyfield not in(select top 24 primarykeyfield from tablename);
select top(m + n - 1) * from tablename select top(n - 1) * from tablename;
( select id, value, row_number() over (order by id) as rownumber from mytable ) select id, value from numberedmytable where rownumber between @from and @to;
select id, value from (select row_number() over(order by id) as rownum, id,value from mytable) as sub where sub.rownum between @start and @start+@records;
select top numberyouwanttotake from yourtable where youridcolumn not in ( select top numberyouwanttoskip from yourtable );
select top(m+n-1) * from table into temp tmp_final with no log;
select top(n-1) * from tmp_final order by id desc;
create table if not exists `foo` ( `id` varchar(128), primary key (`id`(4)) );
create table foo ( foocode varchar(16), -- short code or shortcut, but with some meaning. );
alter table dbo.yourtable add id int identity(1,1);
alter table dbo.yourtable add constraint pk_yourtable primary key(id);
select row_number() over (order by col1, col2, col3, etc.) as id, * from original_table;
select top(150) cols.[name] as [column], t2.[name] as [referenced table], c2.[name] as [referenced column], constr.[name] as [constraint] from sys.tables t;
select tab.name as [table] from sysobjects as tab and (ic.index_id=cast(i.index_id as int) and ic.object_id=i.object_id) where tab.xtype = 'u';
select c.*, (select definition from sys.default_constraints where object_id = c.object_id) as dk_definition, (select definition from sys.check_constraints where object_id = c.object_id) as ck_definition, (select name from sys.objects where object_id = d.referenced_object_id) as fk_table, (select name from sys.columns where column_id = d.parent_column_id and object_id = d.parent_object_id) as fk_col from sys.objects as c where c.parent_object_id = (select object_id from sys.objects where type = 'u' and name = 'table name here');
select tablename = t.name, columnname = c.name, dc.name, dc.definition from sys.tables t;
select [oj].[name] [tablename], [ac].[name] [columnname], [dc].[name] [defaultconstraintname], [dc].[definition] from sys.default_constraints [dc], sys.all_objects [oj], sys.all_columns [ac] where ( ([oj].[type] in ('u')) and );
select schemaname = s.name, tablename = t.name, columnname = c.name, defaultname = dc.name, defaultdefinition = dc.definition from sys.schemas                s join sys.tables                 t   on  t.schema_id          = s.schema_id join sys.default_constraints    dc  on  dc.parent_object_id  = t.object_id join sys.columns                c   on  c.object_id          = dc.parent_object_id and c.column_id          = dc.parent_column_id;
select users.userid from users select userid, ip, datetime from ipaddresses select userid, max(datetime) as maxdate from ipaddresses;
select username, ip, time_stamp from ( select username, ip, time_stamp, row_number() over (partition by username order by time_stamp desc) rn from users;
delete from ( select product_id, id, date_checked, row_number() over (partition by product_id order by date_checked desc) rn from lowest_offers;
select u.[username] from [users] as u select [username] from [users] and u.time_stamp = q.time_stamp;
select * from user u1 where time_stamp = ( select max(time_stamp) from user where username = u1.username);
select * from a where id not in (select a_id from b);
select a.* from a where b.a_id is null;
select <columnns> from a where id not in (select a_id from b);
select * from a where b.a_id is null;
select * from a where not exists (select * from b where b.a_id = a.id);
select * from a left outer join b on a.id = b.a_id where b.a_id is null;
select a.* from a where b.id is null;
select id from a select a_id from b;
select a.* from a where a.id not in(select distinct a_id from b where a_id is not null) and a.id not in(select distinct a_id from c where a_id is not null);
select a.* from a where a.id  not in (select b.ida from b);
select a.* from a left outer join b on a.id = b.ida where b.ida is null;
select count(*) from product a left outer join compatible c on a.id=c.idprod where c.idprod is null;
alter procedure [dbo].[getleagueplayers] ( @idleague int, @pagenumber int, @pagesize int, @total int output ) as  ( select row_number() over (order by p.name) as rownumber, count(1) over () as recordcount, p.id, p.name, t.name as team from players p where l.id=@idleague ) select rownumber, cast(ceiling(cast(recordcount as float) / cast(@pagesize as float)) as int) pagecount, recordcount, id, name from cteplayers c where rownumber > @pagesize*(@pagenumber-1) and rownumber < @pagesize*@pagenumber;
alter procedure [dbo].[getleagueplayers] ( @idleague int, @pagenumber int, @pagesize int, @total int output ) as with cteplayers as ( select p.id, p.name, t.name as team from players p inner join teams t on p.idteam=t.id inner join leagues l on l.id=t.idleague where l.id=@idleague totalcount as ( select count(*) as total from cteplayers final_result as ( select row_number() over (order by p.name) as rownumber, p.id, p.name, t.name as team, (select total from totalcount) as total from cteplayers ) select id, name, @total = total from final_results c where rownumber>@pagesize*(@pagenumber-1) and rownumber<@pagesize*@pagenumber;
( select r.reminderid,r.isverificationrequired from remindertbl r      -- main table filetaskcounttemptbl   as ( select  count(t.reminderid) as filetaskcount                     -- getting first result from tasktbl t followupcounttemptbl  as ( select count(f.followupid)  as total                             -- getting second result from followuptbl f              --cte not used here machineryregulartaskcounttemptbl as ( select  count(t.reminderid) as totalcount                        -- getting third result from tasktbl t finalresulttemptbl as ( select count(t.reminderid)  as machinerytaskcount,               -- getting fourth result from tasktbl t ) select * from finalresulttemptbl;
alter procedure [dbo].[getleagueplayers] ( @idleague int, @pagenumber int, @pagesize int, @total int output ) as with cteplayers as ( select row_number() over (order by p.name) as rownumber, p.id, p.name, t.name as team from players p inner join teams t on p.idteam=t.id inner join leagues l on l.id=t.idleague where l.id=@idleague totalcounter(totalrecords) as select id, name, totalrecords(select totalrecords from totalcounter) into #tmp from cteplayers c where rownumber>@pagesize*(@pagenumber-1) and rownumber<@pagesize*@pagenumber;
set @total = ( select totalrecords from #tmp) select id, name from $tmp drop table #tmp;
select @total = count(*) from players p where l.id=@idleague;
select [type], [total sales] from before union all select 'total', sum([total sales]) from before;
select [type], [total sales] from (select [type], [total sales], 0 [key] from before union all select 'total', sum([total sales]), 1 from before) sq;
select  case else [type] end as [type] from    before [type] with rollup;
select [type] = coalesce([type], 'total'), [total sales] = sum([total sales]) from dbo.before;
select type = isnull(type, 'total'), totalsales = sum(totalsales) from atable;
select type = case grouping(type) when 1 then 'total' else type end, totalsales = sum(totalsales) from atable;
select type = isnull(type, 'total'), someintcolumn = isnull(someintcolumn, 0), totalsales = sum(totalsales) from atable;
select * from tempdb..sysobjects select * from tempdb.sys.objects;
select left(name, charindex('_',name)-1) from tempdb..sysobjects where charindex('_',name) > 0 and;
create table #foo___bar;
select name = substring(t.name, 1, charindex('___', t.name)-1), t.id from tempdb..sysobjects as t where t.name like '#%[_][_][_]%' and t.id =;
select left(name, charindex('_', name) - 1) from tempdb..sysobjects where name like '#%' and name not like '##%' and upper(xtype) = 'u' and not object_id('tempdb..' + name) is null;
select distinct a, b from pairs;
select a, b from pairs group by a, b;
select distinct a, b from pairs;
select distinct (case a > b then (a,b) else (b,a) end) from pairs;
select distinct case when a > b then a else b end as a, case when a > b then b else a end as b from pairs;
select count(distinct a,b) from pairs;
select id, height/2.54 as height, -- cm -> in case when height>175 then 'tall' else '' end as comment from people;
select cost_1, quantity_1, cost_2, quantity_2, total_1, total_2, total_1 + total_2 as total_3 from data;
select cost_1, quantity_1, cost_2, quantity_2, cost_1 * quantity_1 as total_1, cost_2 * quantity_2 as total_2, (cost_1 * quantity_1 + cost_2 * quantity_2) as total_3 from data;
select cost_1 from data;
select cost1, quantity_1, cost_2, quantity_2 from ( select cost_1, quantity_1, cost_2, quantity_2, (cost_1 * quantity_1) as total_1, (cost_2 * quantity_2) as total_2 from data;
select a.created_at, (select count(b.email) from subscriptions b where b.created_at <= a.created_at) as count from subscriptions a;
select s1.created_at, count(s2.email) as cumul_count from subscriptions s1;
select cast('2011-04-04' as date) union all select adate + 1 from serialdates where adate < cast('2011-04-07' as date) ) select d.adate, ( select count(distinct email) from subscriptions where created_at between date_trunc('month', d.adate) and d.adate ) from serialdates d;
select created_at, sum(count(email)) over (order by created_at) from subscriptions;
select created_at, sum(count(email)) over (order by created_at) from ( select distinct on (email) created_at, email from subscriptions order by email, created_at;
create table subscriptions as select date '2000-04-04' + (i/10000)::int as created_at, 'foofoobar@foobar.com' || (i%700000)::text as email from generate_series(1,1000000) i;
create index on subscriptions (email, created_at);
select * from "employee" where "employee_name"='elina';
select replace(convert(char(10), getdate(), 110),'-','');
select convert(datetime,stuff(stuff(@dt,3,0,'/'),6,0,'/'),3);
select try_convert(datetime,@datestring) set @datestring ='invalid date' select try_convert(datetime,@datestring);
set @date = '12312009' select convert(datetime, substring(@date,5,4) + substring(@date,1,2) + substring(@date,3,2),112);
set @d = '06082020'    /* mmddyyyy means june 8. 2020 */ select cast(format (cast (@d as int), '##/##/####') as datetime);
select convert(datetime,'12312009');
set @date='12312009' select convert(datetime,right(@date,4)+left(@date,2)+substring(@date,3,2));
@day char(2), @year char(4), @output datetime set @input = '10022009'   --today's date select @mon = left(@input, 2), @day = substring(@input, 3,2), @year = right(@input,4) select @output = @year+@mon+@day select @output end;
set @input = '10022009' --today's date select @output = right(@input,4) + substring(@input, 3,2) + left(@input, 2) select @output end;
select ',' + columnname ... for xml path('');
( select ',' + cast(t2.value as varchar(10)) from #t t2 where t1.id = t2.id );
select pg_typeof(your_variable);
select pg_typeof('{}'::text[]); //returns text[];
create function isdigits(text) returns boolean as ' select $1 ~ ''^(-)?[0-9]+$'' as result;
select id, case when value is null then 0 else (another_query) end from test;
create database foo;
create schema yourschema;
select * from information_schema.schemata;
alter database one rename to "one-two";
select max(cpe.createdon) as maxdate, cpe.fmgcms_cpeclaimid, max(cpe.fmgcms_claimid) as fmgcms_claimid from filteredfmgcms_claimpaymentestimate cpe where cpe.createdon < 'reportstartdate';
select x.a, x.b, y.c from ( select x.a as a, sum (b) as sum_b from name_table x;
create table #products ( product_name varchar(max), code varchar(3), list_price [numeric](8, 2) not null select distinct x.code, x.sum_price, product_name from (select code, sum(list_price) as sum_price from #products drop table #products;
select * from ( select mypk, fmgcms_cpeclaimid, createdon, rank() over (partition by fmgcms_cpeclaimid order by createdon desc) as rank from filteredfmgcms_claimpaymentestimate where createdon < 'reportstartdate' where rank = 1;
select cpe1.pk, cpe2.maxdate, cpe1.fmgcms_cpeclaimid from filteredfmgcms_claimpaymentestimate cpe1 ( select max(createdon) as maxdate, fmgcms_cpeclaimid from filteredfmgcms_claimpaymentestimate and cpe1.createdon = cpe2.maxdate where cpe1.createdon < 'reportstartdate';
select cpe.* from filteredfmgcms_claimpaymentestimate cpe (yourquery) as lookup and lookup.fmgcms_cpeclaimid = cpe.fmgcms_cpeclaimid;
( select *, row_number() over (parition by fmgcms_cpeclaimid order by createdon desc) as sequence_id from filteredfmgcms_claimpaymentestimate where createdon < 'reportstartdate' ) select * from sequenced_data where sequence_id = 1;
create table dbo.some_claims_table ( claim_id     int      not null , group_id     int      not null , date_created datetime not null ,  constraint some_table_pk primary key ( claim_id                ) , constraint some_table_ak01 unique    ( group_id , claim_id     ) , constraint some_table_ak02 unique    ( group_id , date_created ) ,  );
select group_id , date_created = max( date_created ) from dbo.claims_table;
select * from dbo.claims_table t join ( select group_id , date_created = max( date_created ) from dbo.claims_table and x.date_created = t.date_created;
where username = '{$mysql['username']}' and password = '{$mysql['password']}'";
if ($result->num_rows) {;
%(key)s must be used as the placeholder.;
set "a"    set "b";
select * from a left join b on aa = bb;
select * from a right join b on aa = bb;
select * from a full join b on aa = bb;
select * from a inner join b on aa = bb;
select * from a cross join b;
select * from a natural join b;
select 'a string', 5, idtable2 idtable2 from table2 where ...;
select 'a string', 5, idtable2 from table2 where ...;
select "a string", 5, idtable2 from table2 where ...;
select "a string", 5, thenameofthefieldintable2 from table2 where ...;
numericcolumn = 5, selectcolumn  = (select idtable2 from table2 where ...);
set unique_checks=0;
set foreign_key_checks = 0;
drop table if exists `f1_pool`;
create table `f1_pool` ( `id` int(11) not null, `name` varchar(45) not null, `description` varchar(45) default null comment 'optional', `ownerid` int(11) not null, `lastmodified` timestamp not null default current_timestamp() on update current_timestamp();
-> title varchar (50), -> dept_name varchar(20), -> credits numeric(2,0), -> primary key(course_id), -> foreign key (dept_name) references department) engine innodb;
alter table schoolpersons add index fkef5ab5e532c8fbfa (student_id), add constraint fkef5ab5e532c8fbfa;
set @@foreign_key_checks=0;
alter table  `table1` add constraint `table1_fk1` foreign key (`coloumn`) references `table2` (`id`) on delete cascade;
constraint vendor_tbfk_1 foreign key (v_code) references vendor (v_code) on update cascade;
alter table department modify dept_name varchar(20) character set utf8;
alter table course modify dept_name varchar(20) character set utf8;
create table course ( course_id varchar(7), title varchar(50), dept_name varchar(20), credits numeric(2 , 0 ), primary key (course_id), foreign key (dept_name);
as (select *, row_number() over (order by a) as rn from   foo) select a, b, c, rn from   t;
select some_field from some_table where exists;
select a, b, c from foo ) select t.* from t;
select * from remotedb.dbo.atable;
select pass1.* from from table_a as tbla order by 2) as pass1 union all select pass2.* from from table_b as tblb order by 2) as pass2;
select concat(name, '(',substr(occupation, 1, 1), ')') as f1 from occupations union select temp.str as f1 from;
select  * from ( select * from table_a union all select * from table_b;
select  * from ( select *, 1 sortby from table_a union all select *, 2 sortby from table_b;
select 'shambhu' as shambhunewsfeed,note as [news fedd],notificationid from notification with(nolock) where designationid=@designation union all select 'shambhu' as shambhunewsfeed,note as [notification],notificationid from notification with(nolock) where designationid=@designation;
select *, 1 as rn from table_a union all select *, 2 as rn from table_b;
select ads.*, location.county from ads where ads.published = 1 and ads.type = 13 and ( ads.county_id = 2 or ads.county_id = 5 or ads.county_id = 7 or ads.county_id = 9 );
select ads.*, location.county from ads where ads.published = 1 and ads.type = 13 and ads.county_id in (2, 5, 7, 9);
select ads.*, location.county from ads where ads.published = 1 and ads.type = 13 and ads.county_id in (2,5,7,9);
select ads.*, location.county from ads where ads.published = 1 and ads.type = 13 and ads.county_id in (2,5,7,9);
set ansi_nulls on;
set quoted_identifier on;
alter procedure [dbo].[sys_scriptalltriggers] as begin @text            nvarchar(4000), @blankspaceadded int, @basepos         int, @currentpos      int, @textlength      int, @lineid          int, @maxid           int, @addonlen        int, @lfcr            int, @definedlength   int, @syscomtext      nvarchar(4000), @line            nvarchar(1000), @username        sysname, @objid           int, @oldtrigid       int;
set @definedlength = 1000;
set @blankspaceadded = 0;
set @scriptmode = isnull(@scriptmode, 0);
@triggers (username, trigname, objid) select distinct object_schema_name(b.id), b.name, b.id from dbo.sysobjects b, dbo.syscomments c where b.type = 'tr' and b.id = c.id and c.encrypted = 0;
if exists(select c.* from syscomments c, sysobjects o where o.id = c.id and o.type = 'tr' and c.encrypted = 1) @script select distinct '[' + object_schema_name(b.id) + '].[' + b.name + ']' --, b.id from dbo.sysobjects b, dbo.syscomments c where b.type = 'tr' and b.id = c.id and c.encrypted = 1;
select t.objid, c.text from @triggers t, dbo.syscomments c where t.objid = c.id c.colid select @lfcr = 2;
select @lineid = 1;
set @oldtrigid = -1;
select @basepos = 1;
select @currentpos = 1;
select @textlength = len(@syscomtext);
if @objid <> @oldtrigid set @lineid = 1;
set @oldtrigid = @objid;
select @currentpos = charindex(char(13) + char(10), @syscomtext, @basepos);
if @currentpos != 0 select @addonlen = @definedlength - (isnull(len(@line), 0) + @blankspaceadded );
values ( @objid, @lineid, isnull(@line, n'') + isnull(substring(@syscomtext, @basepos, @addonlen), n''));
select @line = null, @lineid = @lineid + 1, @basepos = @basepos + @addonlen, @blankspaceadded = 0;
select @line = isnull(@line, n'') + isnull(substring(@syscomtext, @basepos, @currentpos - @basepos + @lfcr), n'');
select @basepos = @currentpos + 2;
values ( @objid, @lineid, @line );
select @lineid = @lineid + 1;
select @line = null;
else --else carriage return not found if @basepos <= @textlength select @addonlen = @definedlength - ( isnull(len(@line), 0 ) + @blankspaceadded );
values ( @objid, @lineid, isnull(@line, n'') + isnull(substring(@syscomtext, @basepos, @addonlen), n''));
select @line = null, @lineid = @lineid + 1, @basepos = @basepos + @addonlen, @blankspaceadded = 0;
select @line = isnull(@line, n'') + isnull(substring(@syscomtext, @basepos, @textlength - @basepos+1 ), n'');
if len(@line) < @definedlength and charindex(' ', @syscomtext, @textlength + 1) > 0 select @line = @line + ' ', @blankspaceadded = 1;
if @line is not null values ( @objid, @lineid, @line );
if @scriptmode = 2 select 'if exists(select * from sysobjects where id = object_id(''[' + username + '].[' + trigname + ']'')' from @triggers;
if @scriptmode = 0 update @trigtext set linetext = replace(linetext, 'create trigger', 'alter trigger') where upper(left(replace(ltrim(linetext), char(9), ''), 14)) = 'create trigger' end  select t.username, t.objid, max(d.lineid) from @triggers t, @trigtext d where t.objid = d.objid t.username, t.objid select '-- text of the trigger' = case lineid else linetext end from @trigtext where objid = @objid select script from @script order by id end;
set nocount on exec @return_value = [dbo].[sys_scriptalltriggers] @incldrop = 1 select 'return value' = @return_value;
select [definition],'go' from sys.sql_modules m where obj.type ='tr';
select text from syscomments where text like '%create trigger%';
select object_name(parent_obj) as table_name,sysobj.name as trigger_name, [definition],'go' from sys.sql_modules m where sysobj.type = 'tr' and sysobj.name like 'name_of_trigger';
select a.field1 from (<br> or  select distinct a.field1 from (<br>;
select distinct least(sub.foo, sub.bar) as value_1 from (select from table a join table b and a.bar = b.foo) sub;
select foo,bar from my_table group by foo,bar;
select distinct least(foo, bar) as value1 from table;
select distinct a.foo,a.bar from table a where b.foo is null and b.bar is null;
select distinct foo, bar from table where;
select distinct t1.foo, t1.bar from `table` t1 where t2.foo is null or t1.foo <= t1.bar;
select foo, bar from tablex where foo <= bar union select bar, foo from tablex where bar < foo;
set wrap off set trimout on set trimspool on set serveroutput on set pagesize 0 set long 20000000 set longchunksize 20000000 set linesize 4000;
set long 50000 set linesize 130 select dbms_metadata.get_ddl('tablespace','lm_thin_data') x from dual;
select substr(dbms_metadata.get_ddl('tablespace','lm_thin_data'),80) from dual;
select substr(dbms_metadata.get_ddl('tablespace','lm_thin_data'),160) from dual;
select substr(dbms_metadata.get_ddl('tablespace','lm_thin_data'),240) from dual;
set linesize 15000;
set termout off set verify off set trimspool on set linesize 200 set longchunksize 200000 set long 200000 set pages 0 column txt format a120;
set serveroutput on end loop;
set long 20000000 set linesize 32767 column your_column_name format a32767 select your_column_name from your_table;
set lin[esize] 200;
set linesize 200;
column col_name format ax;
select timeevent from tbevents where convert(varchar,starthour,108) >= '01:01:01';
select timeevent from tbevents where convert(varchar(8), starthour, 8) >= convert(varchar(8), @starthour, 8);
create function dbo.f_trimdate (@dat datetime) returns datetime as begin end;
select @dat = '20080201 02:25:46.000' select dbo.f_trimdate(@dat);
where convert(time(0), starthour) >= convert(time(0), @starttime);
timeevent   int      identity, starthour   datetime ) set @starttime = dateadd(mi, 65, getdate()) select timeevent, convert(time(0), starthour)  as 'starthour', convert(time(0), @starttime) as '@starttime' from @tbevents where convert(time(0), starthour) >= convert(time(0), @starttime);
set @first = '2009-04-30 19:47:16.123' set @second = '2009-04-10 19:47:16.123' select (cast(@first as float) - floor(cast(@first as float))) - as difference;
set @mydate = '2009-04-30 19:47:16.123';
set @myfloat = cast(@mydate as float) select @myfloat;
set @myfloat = @myfloat - floor(@myfloat) select @myfloat;
set @mytime = convert(datetime,@myfloat) select @mytime;
select convert(varchar(32),@mytime,108);
select dateadd(day,-datediff(day,0,yourdatetime),yourdatetime) as newtime from table;
select @t1 = '19000101 23:55:00', @t2 = '20001102 23:55:00' select cast(@t1 as float) - floor(cast(@t1 as float)), cast(@t2 as float) - floor(cast(@t2 as float));
select   @date1 = convert(varchar(20),convert(datetime, '2011-02-11 08:00:00'), 114) select   @date2 = convert(varchar(20),getdate(), 114);
if @date1 <= @date2 else print '@date1 more then @date2';
if (cast('2012-06-20 23:49:14.363' as time) between;
create function [dbo].[msfromstartofday] ( @datetime datetime ) as begin ( datepart( ms , @datetime ) ) + ) end;
set @first = '1900-01-01 23:59:39.090' set @second = '2000-11-02 23:56:39.090' select dbo.msfromstartofday( @first ) select dbo.msfromstartofday( @second );
set @first = '1900-01-01 23:59:39.556' set @second = '2000-11-02 23:56:39.556';
select timeevent from tbevents where convert(time, starthour) >= convert(time, @starthour);
where field = func(value);
case case-expression end;
case when boolean-when-expression-1 then value-1 end;
or the boolean-when-expression == true;
select a, case when a=1 then 'one' else 'other' end from test;
select a, case a when 1 then 'one' else 'other' end from test;
case { simple_case_expression | searched_case_expression } end;
case <case operand> end  case <searched when clause>... end ;
case when v1=v2 then null else v1 end case when v1 is not null then v1 else v2 end case when v1 is not null then v1 else coalesce (v2, . . . ,n ) end  in which each <searched when clause> specifies a <search then the value of the <case expression> is the value of the;
case when search_condition then expression end;
case expression end;
select disaster, case when disaster = "earthquake" then "stand in doorway" then "hide in basement" then "hide with chuck norris" else then "ask mom" end from endoftheworld;
case column else '' end;
case when column=value1 then 1 else '' end;
case when some_condition then return_some_value else return_some_other_value end;
select datename(dw,getdate()) --thursday select datepart(dw,getdate()) --2;
select ( datename(dw, cast(datepart(m, getdate()) as varchar) );
select datename( dw, datefromparts( @year, @month, @day ) );
select datename( dw, convert( date, concat( @day, '/' , @month, '/', @year ), 103 ) );
select datename(dw,getdate());
select case when (extract (weekday from date)=0) then 'sunday';
select datename(dw,convert(varchar(20),getdate(),101));
exec clientreport;
select @sql = bulkcolumn from openrowset exec (@sql);
from #scripts if ((@@fetch_status <> -2) and (@result = 0)) set @commandstring = 'osql -s ' + @@servername + ' -e -n -b -d ' + @dbname + ' -i "' + @dir + @name + '"' exec @result = master.dbo.xp_cmdshell @commandstring, no_output if (@result = 0) set @seconds = datediff(s, @lasttime, getdate()) set @minutes = @seconds / 60 set @seconds = @seconds - (@minutes * 60) set @lasttime = getdate() end else begin set @errmessage = 'error applying ' + @name + '! the database is in an unknown state and the schema may not match the version.' set @errmessage = @errmessage + char(13) + 'to find the error restore the database to version ' + @startingversion set @errmessage = @errmessage + ', set @uptoversion = the last version successfully applied, then run ' + @name set @errmessage = @errmessage + ' manually in query analyzer.' end if @name = (@uptoversion + '.sql') end fetch endt from osql_cursor into @name end;
select `product`.*, `customer1`.`name1`, `customer2`.`name2` from `product`;
select pid, cid, pname, name1, name2 from customer1 c1, product p where p.cid=c1.cid union select pid, cid, pname, name1, name2 from customer2 c2, product p where p.cid=c2.cid;
select p.pid, p.cid, c1.name,c2.name from product p;
select p.pid, p.cid, p.pname, c1.name1, c2.name2 from product p;
select p.pid, p.cid, p.pname, c1.name1, c2.name2 from product as p;
select pid, cid, pname, name1, null from product p customer1 c on p.cid = c.cid union select pid, cid, pname, null, name2 from product p customer2 c on p.cid = c.cid;
select a.no_surat , a.nm_anggota , a.nrp_nip_anggota , a.tmpt_lahir , a.tgl_lahir , a.bln_lahir , a.thn_lahir , a.alamat , a.keperluan , a.nm_jabatan , b.id_polsek ,b.nm_polsek, c.id_polres ,c.nm_polres , d.id_pangkat , d.nm_pangkat, e.id_pejabat , e.nm_pejabat , f.id_ket , f.nm_ket, g.id_pejabat,g.nm_pejabat from tbl_skhp as a;
select hl.ts_datetime, hl.tagname as [id], hl.tagvalue as [value], dense_rank() over (order by ts_datetime) as rowfilter from   table1 hl;
alter table words convert to character set utf8 collate utf8_bin;
create table words ( id bigint auto_increment, word varchar(128) character set utf8 collate utf8_bin not null unique, primary key(id);
if ($thread['info'] === $query) {;
alter table `media_value_report` change col1_old col1_new varchar(10), ...;
select * from   employee;
select * from table1 [blank] outer join table2 on table1.col = table2.col;
select * from table_a;
select 1 union all select 2 union all select 3 union all select 4 select 2 union all select 3 union all select 5 select 1 union all select 2 union all select 4 select id from @temp_a union select id from @temp_b union select id from @temp_c select * from @temp_a as a;
select * from @temp_d as d;
select * from @temp_d as d select * from @temp_a as a;
select 1 id, 'a' name from dual union all select 2 id, 'b' name from dual union all select 3 id, 'c' name from dual union all select 4 id, 'd' name from dual union all select 5 id, 'e' name from dual union all select 6 id, 'f' name from dual select 1 id, 'fa' f from dual union all select 3 id, 'fb' f from dual union all select 6 id, 'f' f from dual union all select 6 id, 'fc' f from dual ) select a.*, b.f, x.f from a left join bx b on a.id = b.id;
alter table linked_list add column position integer not null default 0;
alter table linked_list add index position_index (position);
select * from linked_list order by position;
update linked_list set position = position + 1 where position >= 3;
create table tbldummy previousid     int     null, datacolumn1     varchar(50)     not null, datacolumn2     varchar(50)     not null, datacolumn3     varchar(50)     not null, datacolumn4     varchar(50)     not null, datacolumn5     varchar(50)     not null, datacolumn6     varchar(50)     not null, datacolumn7     varchar(50)     not null, nextid     int     null;
create table linked_list alter table linked_list add primary key ( list_id, position );
update linked_list set position = position + 1 where position >= 3 and list_id = 1;
values (1, 3, "some data");
create table a{ data varchar(10) not null create table b{ groupname varchat(10) not null, order varchar(max) null;
create table linkedlist00 (    );
alter table dbo.linkedlist00 add foreign key (key2) references dbo.linkedlist00(key1);
create table queue ( primary_key, queue_key data );
create table queue_addcount ( primary_key, add_count );
select if(myvalue > 0, myvalue, 'empty string') as value from mytable;
select case else col end as fruit;
select case else col end as fruit;
select coalesce(nullif(email, ''), 'user@domain.com') from users where id=1000000;
select @sqlstatement = from information_schema.tables where table_schema = 'dbo1' and table_type = 'base table';
set @schema = 'integration' --put your schema name between these quotes select @sql = coalesce(@sql,'') + 'drop table %schema%.' + quotename(table_name) + ';' + char(13) from information_schema.tables where table_schema = @schema and table_type = 'base table' select @sql = coalesce(@sql,'') + 'drop view %schema%.' + quotename(table_name) + ';' + char(13) from information_schema.tables where table_schema = @schema and table_type = 'view' select @sql = coalesce(@sql,'') + 'drop procedure %schema%.' + quotename(routine_name) + ';' + char(13) from information_schema.routines where routine_schema = @schema and routine_type = 'procedure' select @sql = coalesce(@sql,'') + 'drop function %schema%.' + quotename(routine_name) + ';' + char(13) from information_schema.routines where routine_schema = @schema and routine_type = 'function' select @sql = coalesce(replace(@sql,'%schema%',@schema), '');
select @sql = coalesce(@sql,'') + 'alter table %schema%.' + t.name + ' drop constraint ' + from sys.tables t join sys.foreign_key_columns d on d.parent_object_id = t.object_id where s.name = @schema;
set @sqllength = len(@sql) set @sqllength = @sqllength - @printmaxlength set @sqlposition = @sqlposition + @printmaxlength end if (@sqllength) < @printmaxlength and (@sqllength) > 0 end;
if exists (select * from sysobjects where type = 'p' and name = 'spdropschema') drop  procedure  spdropschema end go create procedure spdropschema(@schema nvarchar(200)) as  select @sql = @sql + 'alter table '+ quotename(@schema) + '.' + quotename(t.name) + ' drop constraint ' + quotename(f.name)  + ';' + char(13) from sys.tables t where s.name = @schema select @sql = @sql + 'drop table '+ quotename(@schema) +'.' + quotename(table_name) + ';' + char(13) from information_schema.tables where table_schema = @schema and table_type = 'base table' select @sql = @sql + 'drop view '+ quotename(@schema) +'.' + quotename(table_name) + ';' + char(13) from information_schema.tables where table_schema = @schema and table_type = 'view' select @sql = @sql + 'drop procedure '+ quotename(@schema) +'.' + quotename(routine_name) + ';' + char(13) from information_schema.routines where routine_schema = @schema and routine_type = 'procedure' select @sql = @sql + 'drop function '+ quotename(@schema) +'.' + quotename(routine_name) + ';' + char(13) from information_schema.routines where routine_schema = @schema and routine_type = 'function' select @sql = @sql + 'drop sequence '+ quotename(@schema) +'.' + quotename(sequence_name) + ';' + char(13) from information_schema.sequences where sequence_schema = @schema select @sql = @sql + 'drop type ' + quotename(@schema) + '.' + quotename(t.name) + ';' + char(13) from sys.types t where t.is_user_defined = 1 and select @sql = @sql + 'drop schema '+ quotename(@schema) + ';' + char(13);
select @sqlstatement = coalesce(@sqlstatement,'') + 'alter table '+@schema+'.' + t.name + ' drop constraint ' + from sys.tables t join sys.foreign_key_columns d on d.parent_object_id = t.object_id where s.name = @schema select @sqlstatement += from information_schema.tables where table_schema = @schema;
@schema nvarchar(20) set @schema = 'aa' select @sqlstatement = from sys.tables t join sys.foreign_key_columns d on t.object_id = d.parent_object_id where s.name = @schema;
exec master.dbo.droptablesinschema 'my_db', 'dbo;
create proc [master].[dbo].[droptablesinschema] @schema nvarchar(max) as begin exec ('select table_name from [' + @db + '].information_schema.tables where table_schema = ''' + @schema + ''' and table_type =''base table''') select @sqlstatement = from @tables end;
select @sqlstatement = from information_schema.tables where table_schema in ('schema1','schema2','schema13' );
set @dbschema = 'dbo'  -- change to your schema select @sqlstatement = from information_schema.tables where table_schema = @dbschema and table_type = 'base table' exec sp_executesql @sqlstatement;
select 'drop table [tabschema].' + quotename(table_name) + n';' from information_schema.tables where table_schema = 'tabschema' and table_type = 'base table';
exec sp_msforeachtable;
select count(*) from sys.objects obj join sys.schemas s where s.name= @schema and obj.type = 'u' and obj.is_ms_shipped = 0x0) > 0 and @index < @max_number_of_tables set @index = @index+1 select top 1 from sys.objects obj join sys.schemas s where s.name = @schema and obj.type = 'u' and obj.is_ms_shipped = 0x0 end;
select case when datepart(month, getdate()) between 1 and 9 then '0' else '' end + cast(datepart(month, getdate()) as varchar(2));
select left(convert(char(20), getdate(), 101), 2);
select right('00' + cast(datepart(mm, @date) as varchar(2)), 2);
select right ('0'+convert(nvarchar(2), datepart(mm, getdate())),2 );
select right('0' + rtrim(month('12-31-2012')), 2);
select substring(convert(nvarchar(6),getdate(), 112),5,2);
select convert(char(2), cast('2015-01-01' as datetime), 101) -- month with 2 digits select convert(char(6), cast('2015-01-01' as datetime), 112) -- year (yyyy) and month (mm);
select right('0' + cast(month(@date) as nvarchar(2)), 2);
select replace(convert(varchar, month(getdate()) * 0.01), '0.', '');
select pm.id from r2r.partmaster pm where pm.id not in where pd.part_num is not null);
select id from partmaster left join product_details on (...) where product_details.part_num is null;
select where x not in (select);
select pm.id from r2r.partmaster pm where pm.id not in (select pd.part_num from wpsapi4.product_details pd);
create temporary table select  from ;
create index `columnid` on `database1`.`newrows`(`columnid`);
delete from `database1`.`newrows` where  select `columnid` from `database1`.`product_details` where `columnid`=`database1`.`newrows`.`columnid` );
select group,max(date) as max_date from table where checks>0;
select group,max_date,checks from table t (select group,max(date) as max_date from table where checks>0;
select *, max_date = max(date) over (partition by <i>group</i>) from <i>table</i>;
select <i>group</i>, date, checks from ( select *, max_date = max(date) over (partition by <i>group</i>) from <i>table</i> where date = max_date;
select * from (select msisdn from insert_log where play_file_name not in('prompt1','conclusion_prompt_1','silent') join (select max(date_played) as date_played from insert_log group by callid) t2;
select group, date, checks from table where checks > 0;
select distinct group, max_date = max(date) over (partition by group), checks from table;
select * from table_name sample(1);
select  * from    ( select  * from    mytable sample (0.01) dbms_random.value ) where rownum <= 1000;
select * from mytable sample (0.01);
select * from table_name sample(50);
select * from table_name sample(1);
select * from t_your_table where your_column = 'abc' ) select * from cte1 sample (5);
select * from table_name where primary_key in (select primary_key from ( select primary_key, sys.dbms_random.random from table_name ) where rownum <= 10 );
select * from emp sample(25);
select * from ( select job, sal, row_number() partition by job order by job ) where samplecount <= 10;
select dbms_random.random as ran_number, colmn1, colm2, colm3 from table1, table2 where table1.id = table2.id select tab1.col2, tab1.col4, tab1.col5, from summary s where s.rank <= 2;
select  * from    ( select  * from    mytable dbms_random.value ) where rownum <= 1000;
if (dset.tables["cust_registrations"].rows.count > 0);
if (textbox2.text = nothing) then else cmd.parameters("@department").value = textbox2.text end if;
select format ( @d, 'd', 'en-us' ) as 'us english result' select format ( @d, 'd', 'en-us' ) as 'us english result';
select format (getdate(), 'dd/mmm/yy') as date;
select format(@date,'dd/mm/yyyy') as [dd/mm/yyyy] // output: 22/10/2020 select format(@date,'dd-mm-yyyy') as [dd-mm-yyyy] // output: 22-10-2020 select format(cast('25/jun/2013' as date),'dd/mm/yyyy') as stringtodate // output: 25/06/2013;
select format(cast('25/jun/2013' as date),'dd/mmm/yyyy') select format(cast('25/jun/2013' as date),'dd/mm/yyyy') select format(cast('25/jun/2013' as date),'dd/mmmm/yyyy');
select replace(convert(nvarchar, getdate(), 106), ' ', '/');
select replace(convert(varchar(11),getdate(),6), ' ','/');
select replace(convert(varchar(11),getdate(),106), ' ','/');
select convert(varchar, getdate(), 106);
set language russian select replace(convert(nvarchar, getdate(), 106), ' ', '/');
select replace ( convert(varchar,getdate(),106),' ','/');
select convert(varchar,getdate(),100);
select date '2012-06-29' + i from generate_series(1, (select date '2012-07-3' - date '2012-06-29')) i;
values (date '2012-06-29', date '2012-07-3') select end_date - start_date as duration from min_max ) select start_date + i from min_max;
select to_char(date_column,'dd mon yyyy') from some_table where date_column between '29 jun 2012' and '3 jul 2012';
create or replace function getdatelist(date1 date, date2 date) end loop;
drop table tbl ;
create table tbl (zdate date not null );
select min(zdate)::timestamp as mi from tbl ) select generate_series( mima.mi, mima.ma, '1 day':: interval):: date from mima;
select current_date + i from generate_series(date '2012-06-29'- current_date, date '2012-07-03' - current_date ) i;
select i::date from generate_series('2012-06-29', '2012-07-03', '1 day'::interval) i;
select generate_series('2012-06-29', '2012-07-03', '1 day'::interval);
select (generate_series('2012-06-29', '2012-07-03', '1 day'::interval))::date;
select generate_series('2012-06-29', '2012-07-03', '1 day'::interval)::date;
update accounts set balance = balance - 100.00 where name = 'alice';
select accounts where name = 'alice';
update products set price_including_vat = price * 1.05 where product_type = 'food';
select price_including_vat as price_including_vat__before, price * 1.05 as price_including_vat__after, * from products where product_type = 'food';
( select price_including_vat as price_including_vat__before, price * 1.05 as price_including_vat__after, * from products where product_type = 'food' ) select * from updated where price_including_vat__before = price_including_vat__after;
create table data(id int, text text);
select * from data;
update data set text = 'modified' where id > 2 select * from data;
select  datalength(hashbytes('md2', 'testing')) as [md2length], datalength(hashbytes('md4', 'testing')) as [md4length], datalength(hashbytes('md5', 'testing')) as [md5length], datalength(hashbytes('sha', 'testing')) as [shalength], datalength(hashbytes('sha1', 'testing')) as [sha1length], /* 2012 only: */ datalength(hashbytes('sha2_512', 'testing')) as [sha2_512length];
select convert(varchar(33), datecolumn, 126) from mytable;
select convert(nvarchar(30), getdate(), 126);
select format(getutcdate(),'yyyy-mm-ddthh:mm:ssz');
select convert(char(10), getdate(), 126) -- iso yyyy-mm-dd select convert(char(8), getdate(), 112) -- iso yyyymmdd (safest);
select convert(datetime,@extendeddate,126) ,convert(datetime,@basicdate,126) select * from @table select convert(datetime2,@extendeddate,126) ,convert(datetime2,@basicdate,126) select * from @table;
select datepart(iso_week,'2020-11-13') as iso_8601_weeknr;
end  alter table distributors add constraint zipchk check (char_length(zipcode) = 5) no inherit;
end dir.down do alter table distributors drop constraint zipchk end end  end end;
create table cars_users2 as select distinct * from cars_users;
drop table cars_users;
alter table cars_users2 rename to cars_users;
select nvl(sum(price), 0) as totalprice from inventory where (dateadded between @startdate and @enddate);
select coalesce(sum(price),0) as totalprice from inventory where (dateadded between @startdate and @enddate);
select coalesce(sum(column_id),0) as totalprice from sys.columns where (object_id between -1 and -2);
select isnull(sum(price), 0) as totalprice from inventory where (dateadded between @startdate and @enddate);
select isnull(sum(price), 0) as totalprice from inventory where (dateadded between @startdate and @enddate);
select 0+coalesce(sum(price),0) as totalprice from inventory where (dateadded between @startdate and @enddate);
select isnull(sum(isnull(price, 0)), 0);
select coalesce( (select sum(price) as totalprice from inventory where (dateadded between @startdate and @enddate));
where datefield = {d '2008-12-20'};
where datefield between {ts '2008-12-20 00:00:00'} and {ts '2008-12-20 23:59:59'};
where datetime_column >= '20081220 00:00:00.000' and datetime_column < '20081221 00:00:00.000';
select * from tblerrorlog where errordate between '12/20/2008' and dateadd(day, 1, '12/20/2008');
select * from tblerrorlog where errordate = '20081220';
select * from tblerrorlog where day(errordate) = 20 and month(errordate) = 12 and year(errordate) = 2008;
alter table tblerrorlog add errorday as day(errordate) persisted alter table tblerrorlog add errormonth as month(errordate) persisted alter table tblerrorlog add erroryear as year(errordate) persisted;
select * from tblerrorlog where errormonth = 5 and erroryear = 2009;
select * from tblerrorlog where convert(date,errordate,101) = '12/20/2008';
where int_column = '1';
where expires_at <= str_to_date('2010-10-15 10:00:00', '%y-%m-%d %h:%i:%s');
exec dbo.dbsearch 'your_table_name';
select view_name from information_schema.view_table_usage where table_name = 'your table';
select type, * from sys.objects where object_definition(object_id) like '%' + @objectname + '%' and type in ('v');
select referencing_object_name = o.name, referencing_object_type_desc = o.type_desc, referenced_object_name = referenced_entity_name, referenced_object_type_desc =so1.type_desc from sys.sql_expression_dependencies sed where referenced_entity_name = 'person';
select * from   information_schema.views where  view_definition like '%yourtablename%';
select top 25 type, id from searchterms where term like @term", new { term });
from remitentes where nombre like @n", new { n = "%" + nombre + "%" });
update employee set attributevalue = attributename, attributename = attributevalue;
update employee set attributevalue = attributename, attributename = attributevalue;
update employee set attributevalue = attributename, attributename = attributevalue;
select * from employees;
update employees set    @temp = fname, fname = lname, lname = @temp where  deptno = 10;
select * from employees;
select * from student update set std.first_name = tmp.first_name, std.last_name = tmp.last_name;
select * from student;
update registration set attributename = attributevalue , attributevalue = attributename where id in (1,2,3);
alter table "amplitude" alter table "amplitude" alter table "amplitude";
if object_id('yoursp') is null exec ('create procedure dbo.yoursp as select 1') alter procedure dbo.yoursp as ...;
if exists ( select 1 from information_schema.routines where routine_schema = 'dbo' and routine_name   = '<procname' and routine_type   = 'procedure' ) drop procedure <procname> end go create procedure <procname> as begin end go;
if exists (select * from sysobjects where type = 'p' and name = '<name>') drop procedure <name> end go create procedure <name>;
exec utils.passureexistance 'schema.pstoredproc' alter procecure schema.pstoredproc;
exec utils.passureexistance 'schema.ffunction' alter function schema.ffunction;
exec utils.passureexistance 'schema.ffunction', 'tablevaluedfunction';
create or alter;
create or alter procedure dbo.myproc as begin select * from dbo.mytable;
alter table yksus1 set schema firma1;
alter function .. set schema ...;
$expr->in( 'o.id', $em->createquerybuilder() 'i2', \doctrine\orm\query\expr\join::with, $expr->andx( $expr->eq('i2.order', 'o2'), $expr->eq('i2.id', '?1') ) ) ) );
select lpad(' ',2*(level-1)) || to_char(child) s from test_connect_by;
create or replace function example_subtree (integer) select into results * from example where parent_id = $1;
if found then where parent_id = $1 end loop;
select sum(value) as value_sum from example_subtree(1234);
create function fn_hierarchy (parent int) as $$ select  example from    example where   id = $1 union all select  fn_hierarchy(id) from    example where   parentid = $1 select  * from    fn_hierarchy(1);
select id, value from example where id = :selectedid union all select c.id, c.value from sumthis p ) select sum(val) from sumthis;
where id = :selectedid;
select id, game, min(point) from t;
select * from table where (id,point) in (select id,min(point) from table group by id);
select tbl.* from tablename tbl ( select id, min(point) minpoint from tablename where tbl1.minpoint = tbl.point;
select * from room ( select distinct hotelno, min(price) minprice from room;
select id, game, point from ( select id, game, point, row_number() over (partition by game order by point) as rn from games where rn = 1;
select * from table t ( select id, min(point) minpoint from table t;
select * from ( select row_number() over (partition by id order by point) as rownum, * from table where rownum = 1;
select colminpointid from ( select game from table select top 1 id as colminpointid from table as rstinner where rstinner.game = rstouter.game;
select distinct first_value(id) over (partition by game order by point) as id, game, first_value(point) over (partition by game order by point) as point from #t;
select t.* from table t where not exists(select 1 from table ti where ti.attr > t.attr);
update users set votes= votes + 1 where id= '44';
select ucase(mycolumn) as upper, lcase(mycolumn) as lower from mytable;
select upper(firstname) from person select lower(firstname) from person;
select lower(first name) abc from person;
select lower('this is test string');
select upper('this is test string');
from sqlalchemy import func;
create table #testing ( id int identity, somedate datetime default getdate() ) default values;
values ('val1','val2') select mytableid from @inserted;
create table mytable ( mytableid int not null identity (1, 1), mytablecolone varchar(50) not null, mytablecoltwo varchar(50) not null );
select distinct link,id,day,month from posted where ad='$key' order by day, month;
select link,id,day,month from posted where ad='$key' order by day, month;
select other_columns from posted where link in ( select distinct link from posted where ad='$key' );
select * from posted where link in;
select distinct link,id,day,month from posted where ad='$key' order by day, month;
select link, id, day, month from posted where (link, id) in;
select * from posted where link not in;
select distinct;
select col1, col2 from mytable group by col2;
select link, min(datecolumn) from posted where ad='$key' order by day, month;
select * from datatable where data_text = 'test' group by data_name order by data_name asc;
select data_id, data_text, data_name from datatable where data_text = 'test' group by data_name order by data_name asc;
select * from tbl;
select a.* from orders a inner join (select course,max(id) as id from orders where admission_id=".$id." group by course ) as b on a.course = b.course and a.id = b.id;
select distinct * from posted where ad='$key' group by link order by day, month;
select id, link, day, month from posted where id in( select min(id) from posted group by link);
select * from ( select row_number() over(partition by link order by day, month) row_id from posted where ad='$key' where x.row_id = 1;
in [33]: s1 = pd.merge(df1, df2, how='left', on=['year', 'week', 'colour']);
in [39]: df = pd.merge(s1, df3[['week', 'colour', 'val3']], how='left', on=['week', 'colour']) in [40]: df;
update tblkit set number = replace(number, 'kit', 'ch') where number like 'kit%';
update tblkit set number = replace(number, 'kit', 'ch');
if exists(select 1 from table where id = 4);
update b set code = isnull(a.value, 123) from #b b where b.id = yourid;
update tableb set (select max(value) from tablea where id = b.id), 123) from tableb b;
as ( select [id] [id] from table_a ) update table_b set table_b.code = case when cte_table_a.[value] is not null then cte_table_a.[value] else 124 end from table_b;
select * from orderarchive where orderdate <= date '2015-12-31';
select * from orderarchive where orderdate <= to_date('31 dec 2014', 'dd mon yyyy', 'nls_date_language = american');
select * from orderarchive where orderdate <= to_date('31-dec-2014','dd-mon-yyyy');
select * from orderarchive where orderdate <= to_date('31 dec 2014','dd mon yyyy');
select * from orderarchive where orderdate <= to_date('2014-12-31','yyyy-mm-dd');
select * from orderarchive where to_date(orderdate,'yyyy-mm-dd') <= to_date('2014-12-31','yyyy-mm-dd');
select d.date, count(se.id) from (select to_char(date_trunc('day', (current_date - offs)), 'yyyy-mm-dd') as date from generate_series(0, 365, 1) as offs;
select d.date, count(se.id) from ( select to_char(date_trunc('day', (current_date - offs)), 'yyyy-mm-dd') as date from generate_series(0, 365, 1) as offs select * from sharer_emailshare where showroom_id=5;
select sequential_dates.date, count(*) as call_count from (select current_date - sequential_dates.date as date from generate_series(0, 9) as sequential_dates(date)) sequential_dates;
select series.number from generate_series(0, 9) as series(number);
select current_date + sequential_dates.date as date from generate_series(0, 9) as sequential_dates(date);
select sequential_dates.date, count(calendar_items.*) as calendar_item_count from (select current_date + sequential_dates.date as date from generate_series(0, 9) as sequential_dates(date)) sequential_dates;
select created::date as date_column from sharer_emailshare where showroom_id=5 ) select series_table.date, count(dates_table.date_column), sum(count(dates_table.date_column)) over (order by series_table.date) from ( select (last_date - b.offs) as date from ( select generate_series(0, last_date - first_date, 1) as offs, last_date from ( select max(date_column) as last_date, (max(date_column) - '1 year'::interval)::date as first_date from dates_table;
where column1 = column2;
where postcode = '1234';
select mgt.attrib_a   as attrib_a from   main_grain_table  mgt where  mgt.sta_join_col  = sta.sta_join_col and    mgt.stb_join_col  = stb.stb_join_col and    mgt.bus_logic_col = 'tight';
select c.fullname, c.customercode, o.orderdate, o.ordertotal, od.extendedshippingnotes from customer c and c.customerstatus = 'preferred' and o.ordertotal > 1000.0 where o.orderid = od.orderid;
select 1 from departments c join employees a join jobs b;
select distinct born_on.name from   born_on b where  floor(('2012-01-30'::date - b.dob) / 365.25) <= ( select floor((max(d1.dod - b1.dob)/365.25)) from   born_on b1 join   died_on d1 using (name) ) and not exists ( select * from   died_on d2 where  d2.name = b.name;
select firstname + lastname + email as vitals from members;
select isnull(firstname, '') + isnull(lastname, '') + isnull(email, '') as vitals from members;
select isnull(firstname,'')+isnull(lastname,'')+isnull(email,'') as vitals from members;
select {fn concat(isnull(firstname,''), isnull(lastname,''), isnull(email,''))} as vitals from members;
set concat_null_yields_null off;
if(nullif(firstname, '') is null, null, firstname), if(nullif(lastname, '') is null, null, usr_lastname), if(nullif(email, '') is null, null, email));
create or replace type temp_data force as object ( temporary_data nvarchar2(4000) ) create or replace type temp_data_table force as table of temp_data;
create or replace function my_agg_func (p_temp_data_table in temp_data_table, p_delimiter in nvarchar2) if i != p_temp_data_table.first then end if;
end my_agg_func;
cast( collect( temp_data(column_to_aggregate) '#any_delimiter#' );
select rtrim(xmlagg(xmlelement(e,colname,',').extract('//text()') order by colname).getclobval(),',') as list from tablename;
2  order by null) select listagg(text, ',') within group ( *;
thirty,thirty-one,thirty-two,thirty-three,thirty-four,thirty-five,thirty-six,thi two hundred twenty-three,two hundred twenty-four,two hundred twenty-five,two hun;
union select 2 id, rpad('a2',4000,'*') col1, rpad('b2',4000,'*') col2 from dual ) select id, rtrim(xmlagg(xmlelement(e,col1,',').extract('//text()') ).getclobval(), ',') as very_long_text from data;
create table tab as select trunc(rownum/10) x, 'grp'||to_char(mod(rownum,4)) y, mod(rownum,10) z from dual connect by level < 100;
select x, listagg(y, '; ') within group (order by y) y_lst from tab;
select x,y,z, row_number() over (partition by x,y order by y) rn from tab ) select x, listagg( case when rn = 1 then y end, '; ') within group (order by y) y_lst, sum(z) z from rn;
from my_table) select listagg(my_column,',') within group(order by floor(rownum/max_field_length), my_column) from my_table, precalc;
select pid, listagg(desc, ' ' on overflow truncate ) within group (order by seq) as desc from b group by pid;
select lt.c_o_nbr as lt_co_num, rt.c_o_nbr as rt_co_num, lt.std_ln_itm_nbr, rt.non_std_ln_itm_nbr, rt.non_std_prj_nbr, lt.std_prj_nbr, nvl(lt.prpsl_ln_nbr, rt.prpsl_ln_nbr) as prpsl_ln_nbr, lt.std_co_expl_txt as std_txt, lt.std_co_expln_t, lt.std_co_expl_sn, rt.non_std_co_expln_t, listagg(rt.rmrks_txt_fld, '') from ... where rt.rmrks_sn between 0 and 15 lt.c_o_nbr, rt.c_o_nbr, ...;
select listagg(rt.rmrks_txt_fld, '');
where rt.rmrks_sn between 31 and 45;
update target as t select s.id, count(*) as count from source_grouped as s set t.count = aggregate.count;
update catalog_product_entity_varchar as `v` inner join (select `value`,`entity_id` from `catalog_product_entity_varchar` where `attribute_id`=86) as `j` on `j`.`entity_id`=`v`.entity_id set `v`.`value`=j.`value` where `v`.attribute_id = 85 and `v`.`entity_id`=`j`.`entity_id`;
update competition set competition.numberofteams = from pickspoints where usercompetitionid is not null and competitionid =  competition.competitionid;
select id, count(*) group by id;
select count(*);
update competition as c select competitionid, count(*) as numberofteams from pickspoints as p where usercompetitionid is not null set c.numberofteams = ifnull(a.numberofteams, 0);
update competition as c select competitionid, count(*) as numberofteams from pickspoints as p where usercompetitionid is not null set c.numberofteams = a.numberofteams;
case when search_condition then statement_list end case;
select id, action_heading, case when else null end as expense_amt, case when else null end as income_amt from tbl_transaction;
select id, heading, if(action_type='income',action_amount,0) as income, if(action_type='expense',action_amount,0) as expense;
select id from tbl_transaction;
select id, action_heading, case when action_type = 'income' then action_amount else null end as income_amt, case when action_type = 'expense' then action_amount else null end as expense_amt from tbl_transaction;
select id, action_heading, if(action_type='income',action_amount,0) income, if(action_type='expense', action_amount, 0) expense from tbl_transaction;
set -e set -u if [ $# != 2 ]; then if [ $psql_exit_status != 0 ]; then;
if the command string contains multiple sql commands, they are processed in a single transaction, unless there are explicit begin/commit commands select * from foo;
select 1 where @stringtocompare;
select  [a].[input], cast([a].[input] as [uniqueidentifier]) from   ( select '5d944516-98e6-44c5-849f-9c277833c01b' collate latin1_general_100_bin as [input] union all select '{5d944516-98e6-44c5-849f-9c277833c01b}' union all select '5d944516-98e6-44c5-849f-9c277833c01bxxxxxxxxxxxxxxxxxxxxxxxxxxxxx' union all select '{5d944516-98e6-44c5-849f-9c277833c01b}ssssssssss' union all select 'd944516-98e6-44c5-849f-9c277833c01b' union all select 'fish' where   patindex('[^0-9a-f-{}]%', [a].[input]) = 0;
select userid from [membership].[userinfo] where try_convert(uniqueidentifier, firstname) is not null;
create function [dbo].[isguid] (@input varchar(50)) case when @input like '[0-9a-fa-f][0-9a-fa-f][0-9a-fa-f][0-9a-fa-f][0-9a-fa-f][0-9a-fa-f][0-9a-fa-f][0-9a-fa-f]-[0-9a-fa-f][0-9a-fa-f][0-9a-fa-f][0-9a-fa-f]-[0-9a-fa-f][0-9a-fa-f][0-9a-fa-f][0-9a-fa-f]-[0-9a-fa-f][0-9a-fa-f][0-9a-fa-f][0-9a-fa-f]-[0-9a-fa-f][0-9a-fa-f][0-9a-fa-f][0-9a-fa-f][0-9a-fa-f][0-9a-fa-f][0-9a-fa-f][0-9a-fa-f][0-9a-fa-f][0-9a-fa-f][0-9a-fa-f][0-9a-fa-f]' then 1 else 0 end end go select [dbo].[isguid]('123') -- returns 0 select [dbo].[isguid]('ebd8aebd-7ea3-439d-a7bc-e009dee0eae0') -- returns 1 select * from sometable where dbo.isguid(tablefield) = 0 -- returns table with all non convertable items!;
create function dbo.isuniqueidentifier (@ui varchar(50)) end go;
select something from table1 where column1 like '[0-9a-fa-f][0-9a-fa-f][0-9a-fa-f][0-9a-fa-f][0-9a-fa-f][0-9a-fa-f][0-9a-fa-f][0-9a-fa-f]-[0-9a-fa-f][0-9a-fa-f][0-9a-fa-f][0-9a-fa-f]-[0-9a-fa-f][0-9a-fa-f][0-9a-fa-f][0-9a-fa-f]-[0-9a-fa-f][0-9a-fa-f][0-9a-fa-f][0-9a-fa-f]-[0-9a-fa-f][0-9a-fa-f][0-9a-fa-f][0-9a-fa-f][0-9a-fa-f][0-9a-fa-f][0-9a-fa-f][0-9a-fa-f][0-9a-fa-f][0-9a-fa-f][0-9a-fa-f][0-9a-fa-f]';
select something from table1 where column1 like replace('00000000-0000-0000-0000-000000000000', '0', '[0-9a-fa-f]');
select 1 where @stringtocompare like;
select something from   your_table where  try_convert(uniqueidentifier, your_column) is not null;
select cast('{5d944516-98e6-44c5-849f-9c277833c01b}ssssssssss' as uniqueidentifier);
select cast('5d944516-98e6-44c5-849f-9c277833c01bxxxxxxxxxxxxxxxxxxxxxxxxxxxxx' as uniqueidentifier);
like '[a-za-z0-9]';
as (select '5d944516-98e6-44c5-849f-9c277833c01b' union all select '{5d944516-98e6-44c5-849f-9c277833c01b}' union all select '5d944516-98e6-44c5-849f-9c277833c01bxxxxxxxxxxxxxxxxxxxxxxxxxxxxx' union all select '{5d944516-98e6-44c5-849f-9c277833c01b}ssssssssss' union all select 'd944516-98e6-44c5-849f-9c277833c01b' union all select 'fish') select case or c like '{' + expression + '}%' then cast(c as uniqueidentifier) end from   t where  c like expression + '%' or c like '{' + expression + '}%';
select coalesce(mycolumn, 0);
select ifnull(column_name, 0) from table_name;
update `table` set `somefield`=0 where `somefield` is null;
select * from yourtable replace(find_in_set(currency,'usd,bht,jpy,myr'),0,'z');
case when currency in ('usd', 'cad') then '000'||currency then 'zzz'||currency else currency end;
select <columns> from <tablename>;
select meas_code, to_number(regexp_replace(meas_code, replace('(meas1,meas2,meas3)', ',', '|'), instr(replace('(meas1,meas2,meas3)', ',', '|'), meas_code))) ordr from (select cast(column_value as varchar2(10)) as meas_code from xmltable('''meas1'',''meas2'',''meas3'''));
case when currency = 'usd' then 1 else 5 end;
case when currency = 'usd' then '001' else currency end;
select <columns> from <tablename>;
case when currency = 'usd' then 1 else 2 end;
select id from a where id not in (select id from b);
select id from a except select id from b;
delete from a where id not in (select id from b);
select a.* from a where id not in(select id from b);
select a.* from a where not exists(select 1 from b where b.id=a.id);
select * from tablea where not exists ( select null from tableb where tableb.id = tablea.id ) select * from tablea where id not in ( select id from tableb ) select tablea.* from tablea where tableb.id is null;
select id from a where id not in ( select id from b);
select id from a a where not exists ( select 1 from b b where b.id = a.id);
select a.id from a a where b.id is null;
delete from a where id not in ( select id from b);
select id from tablea where id not in (select id from tableb);
delete from tablea where id not in (select id from tableb);
select id from a where not exists( select 1 from b where b.id = a.id );
select column_name as found from user_tab_cols where table_name = '__table_name__' and column_name = '__column_name__';
select * from information_schema.columns c information_schema.tables t where c.column_name = 'columnname' and t.table_name = 'tablename';
select * from all_tab_columns where table_name = 'tablename' and column_name = 'columnname';
select count(*) into v_column_exists from user_tab_cols where upper(column_name) = 'add_tms' and upper(table_name) = 'emp';
if (v_column_exists = 0) then end if;
alter table t1 add col1 date;
alter table t1 add col2 date;
alter table t1 add col3 date;
alter session set nls_date_format='yyyy-mm-dd';
alter system set nls_date_format='yyyy-mm-dd';
select case when totalcount >0 then 'true' else 'false' end from ( select [some column], count(*) totalcount from incidents where [some column] = 'target data';
select @totalcount = totalcount from ( select [some column], count(*) totalcount from incidents where [some column] = 'target data' if @totalcount > 0 else -- insert statement 2 goes here;
select case when totalcount >= 0 and totalcount < 11 then '0-10' else '>100' end as newcolumn from ( select [some column], count(*) totalcount from incidents where [some column] = 'target data';
if exists (select 1 from incidents  where [some column] = 'target data') end else begin end;
select @hasexistingrows = count(*) else 0 -- false from incidents where {your criteria};
if @hasexistingrows = 0 -- no existing rows end else -- existing rows are found end;
if exists ({select query}) end else begin end;
if exists (select * from table where column = 'some value') else --insert something else;
select @retval = count(*) from table where column = 'some value' if (@retval > 0) end else begin end;
if exists (select * from table_1 where col1 = 'value') end else -- zero;
from dog in dogs from puppy in puppies select new puppy = puppy;
from p1 in dog1.puppies from p2 in dog2.puppies from p3 in dog3.puppies select new {p1, p2, p3};
{p11, p21, p32}, {p12, p21, p31}, {p12, p21, p32};
{p11, p21, p32}, {p12, p21, p31}, {p12, p21, p32};
where @stringvar like '%thisstring%';
if @stringvar like '%thisstring%';
if (charindex(@find, @full) > 0);
if charindex('texttosearch',@textwhereisearch, 0) > 0 => text exists if patindex('texttosearch', @textwhereisearch) > 0 => text exists;
end try end catch;
select col1, col2, ..., [coln] from [tables etc.] where 0 = 1;
select datefromparts(@year, @month, @day);
select cast(cast(@year*10000 + @month*100 + @day as varchar(255)) as date);
select cast(concat(cast(@year as varchar(4)), '-',cast(@month as varchar(2)), '-',cast(@day as varchar(2))) as date);
set @date = cast(rtrim(@year * 10000 + @month * 100 + @day) as datetime) select replace(convert(varchar(10), @date, 102), '.', '-') as expectdate;
select cast(rtrim(@year * 10000 +'-' +  @month * 100+ '-' + @day) as date) as expectdate;
@tomonth int=null, @fromyear int=null, @toyear int=null set @fromdate=dateadd(day,0, dateadd(month, @frommonth - 1,dateadd(year, @fromyear-1900, 0))) set @todate=dateadd(day,-1, dateadd(month, @tomonth - 0,dateadd(year, @toyear-1900, 0)));
select datefromparts (@year, @month, @day);
select convert(date,convert(varchar(50),(@year*10000 + @month*100 + @day)),112);
select convert(date,convert(varchar(50),(@year*10000 + @month*100 + @day)),104);
select case when convert(date,'01-02-1900',110) = convert(date,'01-02-1900',105) then 1 else 0 end;
select convert(date,convert(varchar(50),(@year*10000 + @month*100 + @day)),112);
select datefromparts (@year, @month, @day);
select convert(date,convert(varchar(50),(@year*10000 + @month*100 + @day)),112);
select convert(date,right('000' + convert(varchar(50),(@year*10000 + @month*100 + @day)),8),112);
select `name` from `products` `p` where not `backorder` <=> '2';
select `name` from `products` `p` where !(`backorder` <=> '2');
select name from   products p where  coalesce(backorder,1)  <> 2;
select name from   products p where  backorder is null or backorder <> 2;
select name from `products` p where backorder != '2';
select rowint, value, coalesce( ( select top 1 value from mytable mi where mi.rowint > m.rowint rowint from  mytable m rowint;
select [current].rowint, [current].value, isnull([next].value, 0) - [current].value from sourcetable       as [current] sourcetable       as [next];
select rowint, value, lead(value, 1, 0) over (order by rowint) - value from sourcetable;
select  id = row_number() over (order by rowint), rowint, value from    mytable ) select  t1.rowint, t1.value, diff = isnull(t2.value, 0) - t1.value from    (   select  id = row_number() over (order by rowint), * from    mytable ) t1;
select   rowint, value, value - lag(value) over (order by rowint) diff from     mytable;
select t1.rowint,t1.value,t2.value-t1.value as diff from (select * from mytable) as t1, (select * from mytable where rowint!=1 union all select top 1 rowint=count(*)+1,value=0 from mytable) as t2 where t1.rowint=t2.rowint-1;
select column name, datediff( (select max(date) from table name where column name < b. column name), column name) as days_since_last from table name as b;
select * into #tmp from ( select 2  as rowint,      23 as value union select 3,       45 union select 17,      10 union select 9,       0 select rowint, value, lead(value) over (order by rowint) - value from #tmp;
create function [dbo].[numdifference] @p2 float ) as begin if @p1 > @p2 set @diff = @p1 - @p2 else set @diff = @p2 - @p1 end;
select a, b, dbo.numdifference(a, b) from yourtable;
create or replace function test( p_test text[] ) select id from unnest( p_test ) as id;
select store_id as storeid, count(*) as _count from storeproduct having count(*) > 0;
select a as b, b as a from table where b = '5';
select storeid, _count from (select store_id as storeid, count(*) as _count from storeproduct where _count > 0;
from storeproduct select storeid, _count from t where _count > 0;
select store_id as asdf from storeproduct where asdf = 42;
select * from ( select store_id as storeid, count(*) as storecount from storeproduct where data.storecount > 0;
set hive.groupby.orderby.position.alias=true;
select store_id as storeid, count(*) as _count from storeproduct;
create table commentable ( id serial primary key create table comments ( comment_id serial primary key, foreign_id int not null, ...;
create table blogposts ( blogpost_id int primary key, -- notice this is not auto-generated create table userpictures ( userpicture_id int primary key, -- notice this is not auto-generated;
select email from ( values where email not in from users );
select email from users u where u.email = checking.email ) then 'exists' else 'not exists' end as status from ( values;
select email, case when exists(select * from   users u where  e.email = u.email) then 'exist' else 'not exist' end as [status] from   (values('email1'), ('email2'), ('email3'), ('email4')) e(email);
from ( select 'email1' union all select 'email2' union all select 'email3' union all select 'email4';
select email from   (values('email1'), ('email2'), ('email3'), ('email4')) e(email) select email from users;
select e.email, case when u.email is null then 'not exists' else 'exists' end status from emailstocheck e;
select    u.name else 'exists' end as 'existence' from      users u union all select 'email2' union all select 'email3') a;
select  e.accesscode , case when c.accesscode is not null then 'exist' else 'not exist' end as [status] from    ( select    '60552' as accesscode union all select    '80630' union all select    '1611' union all select    '0000';
select u.* from users as u select email, [status] from ( values ('email1', 'exist'), ('email2', 'exist'), ('email3', 'not exist'), ('email4', 'exist') where temptablename.email in ('email1','email2','email3');
select isnull(m.movieid,0) as movieid, isnull(g.genreid,0) as genreid, isnull(mg.moviegenreid,0) as moviegenreid, isnull(g.genre,'') as genre from --rest of your query...;
alter procedure usp_getmoviegenrebymovieid as begin select m.movieid, coalesce(g.genreid,0) genreid, coalesce(mg.moviegenreid,0) moviegenreid, coalesce(g.genre, 'not applicable') genre from movie as m where m.movieid = @movieid end try end catch end;
moviegenreid = reader.isdbnull(moviegenreidindex) ? null : reader.getint32(moviegenreidindex), genreid = reader.isdbnull(genreidindex) ? null : reader.getint32(genreidindex);
column global_name new_value gname set termout off select lower(user) || '@' || global_name||chr(10)||'sql> ' as global_name from   global_name;
set sqlprompt '&gname' set termout on;
set feedback off verify off heading off pagesize 0;
set termout off set serveroutput on size unlimited set pagesize 50000 set linesize 135 set long 50000 set trimspool on set tab off column global_name new_value gname select lower(user) || '@' || from (select global_name,instr(global_name,'.') dot from global_name);
set sqlprompt '&gname> ' alter session set nls_date_format = 'dd-mm-yyyy hh24:mi:ss' select sid, serial#, audsid from   v$session where  audsid = sys_context('userenv','sessionid');
select par.value || case when par.value like '%/%' then '/' else '\' end || from   v$process   pro where  se.audsid = v_audsid and    pro.addr = se.paddr and    par.name = 'user_dump_dest';
if :sid is null then select sid from   v$mystat where  rownum = 1;
set termout on set feedback off exec dbms_output.put_line('sessie: ' || :sid || case when :serial# is null then ' (no access to v$ tables)' else ',' || :serial# end) exec if :tracefile is not null then dbms_output.put_line('eventueel trace-bestand: ' || :tracefile); end if set feedback on;
select u . * from room u join facilities_r fu on fu.id_uc = u.id_uc and (fu.id_fu = '4' or fu.id_fu = '3') where 1 and vizibility = '1';
where a='1' and (b='123' or b='234');
select u.* from rooms as u join facilities_r as fu where vizibility='1';
select u.* from room u join facilities_r fu1 on fu1.id_uc = u.id_uc and fu1.id_fu = '4' join facilities_r fu2 on fu2.id_uc = u.id_uc and fu2.id_fu = '3' where 1 and vizibility='1';
select u.* from room u join facilities_r fu on fu.id_uc = u.id_uc and u.id_fu in(4,3) where 1 and vizibility = 1 group by id_uc order by u_premium desc , id_uc desc;
select id from rows;
create table testing ( cola int not null, colb char(1) not null create unique index uix_testing_a on testing(colb);
select * from testing;
update testing set colb = case cola when 1 then 'a' end where cola in (1,2);
select * from testing;
update    docdata set       lnum = case lnum end where     (pid = 10) and     (lnum in (0, 1, 2));
select top 0 * into #tmp_data_table from data_table update data_table set name = #tmp_data_table.name from data_table join #tmp_data_table on (data_table.id = #tmp_data_table.id);
drop table ztable cascade;
create table ztable select * from ztable;
update ztable t1 set payload=t2.payload from ztable t2 where t1.id in (2,3) and t2.id in (2,3) and t1.id <> t2.id select * from ztable;
alter table ztable add constraint omg_wtf unique (payload) update ztable t1 set payload=t2.payload from ztable t2 where t1.id in (2,3) and t2.id in (2,3) and t1.id <> t2.id select * from ztable;
drop table notice:  create table / primary key will create implicit index "ztable_pkey" for table "ztable" create table insert 0 3 update 2 alter table update 2;
set constraint emp_no_fk_par deferred;
select * from xx,abc;
5     non_existent_table b;
select * from user_tables a, non_existent_table b where a.table_name = b.table_name;
select * from where dummy = 'x';
select "users".* from "users" where ("users"."kind" = 'author' or "users"."kind" = 'admin');
select "users".* from "users"  where (("users"."kind" = 'admin' or "users"."kind" = 'author'));
where foo like '%bar^%%' escape '^' and foo like '%baz^_%' escape '^';
delete   from table_with_dups t1 where  t1.ctid    < t2.ctid       -- delete the "older" ones and  t1.name    = t2.name       -- list columns that define duplicates and  t1.address = t2.address and  t1.zipcode = t2.zipcode;
select * from table_with_dups t1 where  t1.ctid    < t2.ctid       -- select the "older" ones and  t1.name    = t2.name       -- list columns that define duplicates and  t1.address = t2.address and  t1.zipcode = t2.zipcode;
and coalesce(t1.col_with_nulls, '[null]') = coalesce(t2.col_with_nulls, '[null]');
create table thenames;
alter table thenames add column seq serial not null primary key delete from thenames del where exists( select*from thenames x where x.name=del.name and x.address=del.address and x.zipcode=del.zipcode and x.seq < del.seq alter table thenames add unique (name,address,zipcode);
delete from tablename where id in (select id from (select id, row_number() over (partition by column1, column2, column3 order by id) as rnum from tablename) t where t.rnum > 1);
create table some_name_for_new_table as;
delete from mytable where exists (select 1 from mytable t2 where t2.name = mytable.name and;
delete from mytable where id not in ( select min(id) from mytable );
delete from mytable d using ( select min(id), name, address, zip from mytable where d.id <> k.id and d.name=k.name and d.address=k.address and d.zip=k.zip;
delete from tab where id in (select id from (select row_number() over (partition by column_with_duplicate_values), id from tab) x where x.row_number > 1);
delete from tab where ctid = any(array(select ctid from (select row_number() over (partition by column_with_duplicate_values), ctid from tab) x where x.row_number > 1));
delete from tbl where  ctid not in ( select min(ctid)                    -- ctid is not null by definition from   tbl;
not in (select ...);
add foreign key;
create this foreign key;
select name, subject, student_id, result from table1;
select name, subject, student_id, result from table1;
select r.name from roles r where id in ( select role_id , system_user_id from role_members m where r.id = m.role_id and m.system_user_id = intidsystemuser );
select r.name from roles r where id in ( select role_id from role_members m where r.id = m.role_id and m.system_user_id = intidsystemuser );
select * from tmp_table;
create temp table tmp_table as select * from newsletter_subscribers;
select count(*) from tmp_table;  -- just to be sure select distinct on (email) * from tmp_table select count(*) from newsletter_subscribers;  -- paranoid again;
distinct on (email);
create temp table tmp_table as select * from main_table select distinct on (pk_field) * from tmp_table;
create table as;
select * from log l where not exists (select 1 from log l2 where l2.user_id = l.user_id and;
create index log_combo_idx;
create index log_combo_covering_idx;
create index log_combo_covering_idx;
desc nulls last;
(                                -- parentheses required select user_id, log_date, payload from   log where  log_date <= :mydate limit  1 ) union all select l.* from   cte c select l.user_id, l.log_date, l.payload from   log l where  l.user_id > c.user_id  -- lateral reference and    log_date <= :mydate    -- repeat condition limit  1 ) table  cte;
(                                           -- parentheses required select l as my_row                          -- whole row from   log l where  log_date <= :mydate limit  1 ) union all select (select l                            -- whole row from   log l where  l.user_id > (c.my_row).user_id and    l.log_date <= :mydate        -- repeat condition limit  1) from   cte c where  (c.my_row).user_id is not null       -- note parentheses ) select (my_row).*                              -- decompose row from   cte where  (my_row).user_id is not null;
create table users ( user_id  serial primary key;
select u.user_id, l.log_date, l.payload from   users u select l.log_date, l.payload from   log l where  l.user_id = u.user_id         -- lateral reference and    l.log_date <= :mydate limit  1;
join lateral ... on true;
create temp table combo (log_date date, payload int);
select user_id, (combo1).*              -- note parentheses from ( select u.user_id from   log l where  l.user_id = u.user_id and    l.log_date <= :mydate limit  1) as combo1 from   users u;
select u.user_id, l.log_date, l.payload from (select user_id from users order by user_id) u, lateral (select log_date, payload from log where user_id = u.user_id -- lateral reference and log_date <= :mydate limit 1) l;
create table orders ( orderid int not null, productname varchar(50) not null, orderdate datetime not null default now(), primary key (orderid) );
create or replace function timestamp_diff(a timestamp, b timestamp) return number is;
select round (totalseconds / (24 * 60 * 60), 1) totaltimespendin_days, round (totalseconds / (60 * 60), 0) totaltimespendin_hours, round (totalseconds / 60) totaltimespendin_minutes, round (totalseconds) totaltimespendin_seconds from (select round ( extract (day from timediff) * 24 * 60 * 60 from (select to_timestamp ( to_char (date2, 'yyyy-mm-dd hh24:mi:ss') to_timestamp ( to_char (date1, 'yyyy-mm-dd hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') from tablexyz));
select round (totalseconds / (24 * 60 * 60), 1) totaltimespendin_days, round (totalseconds      / (60 * 60), 0) totaltimespendin_hours, round (totalseconds      / 60) totaltimespendin_minutes, round (totalseconds) totaltimespendin_seconds from (select round ( extract (day from timediff) * 24 * 60 * 60 + extract (hour from timediff) * 60 * 60 + extract (minute from timediff) * 60 + extract (second from timediff)) totalseconds from (select to_timestamp(to_char( date2 , 'yyyy-mm-dd hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') - to_timestamp(to_char(date1, 'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss') timediff from tablename );
create or replace function timestamp_diff ( start_time_in timestamp ) as l_days number;
select extract(day from end_time_in-start_time_in) from dual;
select timestamp_diff (to_timestamp('12.04.2017 12:00:00.00', 'dd.mm.yyyy hh24:mi:ss.ff'), to_timestamp('12.04.2017 12:00:01.111', 'dd.mm.yyyy hh24:mi:ss.ff')) as milliseconds from dual;
select extract ( day from (end_timestamp - start_timestamp) )*86400 from table_name;
select to_char (end_timestamp - start_timestamp) from table_name;
create or replace function return_elapsed_time (start_ in timestamp, end_ in timestamp default systimestamp, syntax_ in number default null) return varchar2 is if (syntax_ is null) then else if (syntax_ = 0) then else precision_ := 0;
select extract(day from (end_ - start_)) into d1_ from dual;
select extract(hour from (end_ - start_)) into h1_ from dual;
select extract(minute from (end_ - start_)) into m1_ from dual;
select extract(second from (end_ - start_)) into s1_ from dual;
if (precision_ = 4) then if (d1_ = 1) then else day_ := ' days';
if (h1_ = 1) then else hour_ := ' hours';
if (m1_ = 1) then else minute_ := ' minutes';
if (s1_ = 1) then else second_ := ' seconds';
if (h1_ = 1) then else hour_ := ' hours';
if (m1_ = 1) then else minute_ := ' minutes';
if (s1_ = 1) then else second_ := ' seconds';
if (m1_ = 1) then else minute_ := ' minutes';
if (s1_ = 1) then else second_ := ' seconds';
if (s1_ = 1) then else second_ := ' seconds';
else ms_ := ((((((d1_ * 24) + h1_) * 60) + m1_) * 60) + s1_) * 1000;
if (ms_ = 1) then else msecond_ := ' milliseconds';
end return_elapsed_time;
select (extract(day from ( interval '+18500 09:33:47.263027' day(5) to second --replace line with desired interval --maximum value: interval '+694444 10:39:59.999999999' day(6) to second(9) or up to 3871 year interval '+18500 09:33:47.263027' day(5) to second --replace line with desired interval;
create table diff_timestamp ( f1 timestamp select cast(f2 as date) - cast(f1 as date) from diff_timestamp;
select numtodsinterval(date1-date2,'day') time_difference from dates;
select (extract(day from time2-time1)*24*60*60)+;
select date1 - (date2 - 1) * 24 * 60 *60 * 1000 from table;
2         extract( hour from diff ) hours, 3         extract( minute from diff ) minutes, 4         extract( second from diff ) seconds;
select t.*, a+b as total_sum from ( select sum(column1) as a, sum(column2) as b from table;
update person set id = (select newguid() from createguid) update person set cityid = (select cityid from cities where person.cityname = cities.cityname);
if cells(nrow, ncol).value = empty then else if ncommit = ncommitcount then else ncommit = ncommit + 1 end if if cells(nrow, ncol).value = empty then else if ncol > 1 then                        'add a preceeding comma for all bar the first column end if if right(left(cells(nrow, ncol).value, 3), 1) = "/" then 'format for dates else 'format for text, including apostrophes end if end if end if end function;
select * from profiles where last_login < now() - interval '30 days';
select * from profiles where to_timestamp(last_login) < now() - interval '30 days';
select * from profiles where last_login < valueofunixtime30daysago;
select * from profiles where last_login < (extract(epoch from now())-2592000);
select 'test name', iif(foo = 'result', 1, 0) from bar where baz = (some criteria);
select 'testname', case when foo = 'result' then 1 else 0 end as testresult from bar where baz = @criteria;
select 'test name', case when foo = 'result' then 1 else 0 end from bar where baz = (some criteria);
select 'test name' [col1], case foo else 0 end as [col2] from bar where baz = (some criteria);
select 1 as rn, cast('name1' as nvarchar(4000)) collate database_default as nm union all select rn + 1, nm = cast('name' + cast((rn + 1) as nvarchar(255)) as nvarchar(4000)) collate database_default from cte a where rn < 10) select * from cte;
select x,x_name from (values (1,cast('' as nvarchar(max)))) as     test(x,x_name) union all select x + 1 x, concat(x_name,x+1)  from cte where x < 10 ) select * from cte;
as (  select newsid, left(headertext, charindex(',',headertext+',')-1), stuff(headertext, 1, charindex(',',headertext+','), '') from currentnews union all  select newsid, left(headertext, charindex(',',headertext+',')-1), stuff(headertext, 1, charindex(',',headertext+','), '') from tmp1 where headertext > '' ) select newsid, dataitem from tmp1;
select 1 as nr, cast('1' as varchar(max)) as trail union all select nr+1, cast(concat(trail, '/', nr+1) as varchar(max)) from rcte where nr < 5 ) select * from rcte;
select 1 as nr, cast('1' as varchar(max)) as trail union all select nr+1, concat(trail, '/', nr+1) from rcte where nr < 5 ) select * from rcte;
( select 1 as rn, cast('name1' as varchar(259)) as nm union all select rn+1,nm = 'name' + cast((rn+1) as varchar(255)) from cte a where rn<10) select * from cte;
( select  1 as rn, cast('name1' as varchar(255)) as nm union all select  rn+1, nm = cast('name' + cast((rn+1) as varchar(255)) as varchar(255)) from cte a where rn<10) select * from cte;
( select 1 as rn, 'name' + cast(1 as varchar(255)) as nm union all select rn+1,nm = 'name' + cast((rn+1) as varchar(255)) from cte a where rn<10) select * from cte;
select ... group by timestampadd(hour, hour(columname), date(columname));
select count( id ), ... from quote_data;
select count( id ) , date_format( your_date_column, '%y-%m-%d %h' ) as my_date from  your_table;
select [activity_dt], count(*) as [count] from (select dateadd(hh, datediff(hh, '20010101', [activity_dt]), '20010101') as [activity_dt] from table) abc;
select [activity_dt], count(*) from table1;
select [activity_dt], count(*) from table1;
select [activity_dt], count(*) from table1;
select state, count(customer_id) from ( select p.customer_id from product p where p.productid = 101);
select a.state, count(c.customerid) from product p and a.addressid = ( select max(addressid) from address z where z.customerid = a.customerid ) where p.productid = 101;
select local_tcp_port from sys.dm_exec_connections where local_tcp_port is not null;
select cast(array_to_json(array[:myarrayparameter]) as varchar) in ('[null]', '[""]');
if array_ndims(ids_patrocinador_red_0) > 0 then else ids = 0 ;
if array_length(id_clients, 1) > 0 then end if;
update prices set interfaceid  = @i , @i = @i + 1 where interfaceid is null;
select p.*, (coalesce(max(interfaceid) over (), 0) + from prices ) update p set interfaceid = newinterfaceid where interfaceid is null;
select p.*, (coalesce(max(interfaceid) over (), 0) + from prices ) update p set interfaceid = newinterfaceid where interfaceid is null;
set @incrementvalue = 0 update samples set qty = @incrementvalue,@incrementvalue=@incrementvalue+1;
update table set interfaceid=rownum where condition;
set @a  = 50000835 ;
update `civicrm_contact` set external_identifier = @a:=@a+1 where external_identifier is null;
set @counter = 0 update [table] set [column] = @counter, @counter = @counter + 1```;
update a set a.interfaceid = b.sequence from prices a ( select row_number() over ( order by b.priceid ) + ( select max( interfaceid ) + 1 from prices ) as sequence, b.priceid from prices b where b.interfaceid is null;
alter table table_name add field_name serial primary key;
from sqlalchemy.sql import func;
id column(integer, primary_key=true);
from sqlalchemy.orm import load_only values = [record[0] if len(record) == 1 else record for record in records] #list of distinct values;
set @i = 1 set @startdate = '20100101' set @startdate = dateadd(day,1,@startdate) set @i = @i + 1 end select * from @myvar;
create table #myvar(val datetime) set @i = 1 set @startdate = '20100101' set @startdate = dateadd(day,1,@startdate) set @i = @i + 1 end select * from #myvar;
set @num = 1 set @num = @num + 1 end  select val from @results;
select i+1 i from cte where i < 5) select dateadd(d, i-1, '2010-01-01') from cte;
select 1 union all select 1 + n from numbers where n < 500 ) select n from numbers;
select @myvar select dateadd (dd,number,@myvar) from master.dbo.spt_values where type='p' and number between 0 and 4;
as begin select @startyear = value from   rat.configuration where name = 'report_start_year';
select @endyear = value from   rat.configuration where name = 'report_end_year';
( --selecting the year select @startyear [year] union all -- doing the loop in years table select year+1 year from [years] where year < @endyear );
set @counter = 0 set @date = cast(1+@counter as varchar)+'/01/2013' select  cast(1+@counter as varchar)+'/01/2013' as date set @counter = @counter + 1 end;
select * from (select * from ( select id, client_id, create_time, row_number() over(partition by client_id order by create_time desc) rn from order ) where rn=1 where rownum <= 100;
select top 2 * from customers; //but not supported in oracle;
where rownum <= 100;
select * from ( select * from ( select id, client_id, create_time, row_number() over(partition by client_id order by create_time desc) rn from order ) where rn=1;
select * from ( select id, client_id, create_time, row_number() over(partition by client_id order by create_time desc) rn from order ) where rn = 1;
select * from customers where customer_id <= select * from customers where customer_id >=;
select id, client_id from order where rownum <= 100;
( select table_schema, table_name, column_name from information_schema.columns where column_name in ( 'field1', 'field2' ) ) end loop;
alter table tbl alter col1 drop not null, alter col2 drop not null, ;
select a.attname from pg_catalog.pg_attribute a where attrelid = 'tbl'::regclass and a.attnum > 0 and not a.attisdropped and a.attnotnull;
create or replace function dropnull(varchar) returns integer as $$ select a.attname from pg_catalog.pg_attribute a where attrelid = $1::regclass and a.attnum > 0 and not a.attisdropped and a.attnotnull and a.attname not in(  select pg_attribute.attname from pg_index, pg_class, pg_attribute where pg_class.oid = $1::regclass and and indisprimary) end loop;
update pg_attribute set    attnotnull = false where  attrelid = 'tbl_b'::regclass  -- schema-qualify if needed! and    attnotnull and    not attisdropped and    attnum > 0;
select 'alter table tbl_b alter ' from   pg_catalog.pg_attribute where  attrelid = 'tbl_b'::regclass and    attnotnull and    not attisdropped and    attnum > 0 end $$;
create table tbl_b (like tbl_a including defaults);
drop {database | schema} [if exists] db_name;
drop database whatever_%;
drop database whatever_<name>;
drop database `any-database_name`;
drop procedure if exists droplike;
create procedure droplike(pattern varchar(20)) set group_concat_max_len = 65535;
select @drop:= concat( 'drop table ', group_concat(table_name) , ';' ) from information_schema.tables where table_schema = "database_name" and table_name like pattern;
select b.age, a.name from employees a, employeeuni b where a.id = b.id(+);
select b.age, a.name from employees a;
select table1.category1, table1.category2, count(*) as total, count(table2.stat) as stat from table1;
select @jobid = job_id from msdb.dbo.sysjobs where (name = n'name of your job') if (@jobid is not null) exec msdb.dbo.sp_delete_job @jobid end  exec @returncode =  msdb.dbo.sp_add_job @job_name=n'name of your job';
select @returncode = 0 select @jobid = job_id from  msdb.dbo.sysjobs where (name = n'my test job') if (@jobid is not null) if (exists (select * from msdb.dbo.sysjobservers where (job_id = @jobid) and (server_id <> 0))) end else -- delete the [local] job select @jobid = null end;
if exists (select job_id from msdb.dbo.sysjobs_view where name = n'your job name') exec msdb.dbo.sp_delete_job @job_name=n'your job name';
create table `politicas` ( `id` int(11) not null auto_increment, `nombre` varchar(250) character set utf8 not null, -------------------------------------^here!!!!!!!!!!!;
select o.id ,  count(p.cat) from orders o having count(p.cat) > 3;
select o.id, count(p.cat) cnt from orders o;
select a.order_item_product_price, count(distinct where a.order_item_product_price = b.order_item_product_price having a.order_item_product_price > appx_median(b.order_item_product_price);
select * into #temporarytable from yourtablename alter table #temporarytable drop column columnwhichyouwanttoremove select * from #temporarytable drop table #temporarytable;
create temporary table temp_tb select * from orig_tb;
alter table temp_tb drop col_x;
select * from temp_tb;
select * from viewname;
select * from sys.columns where object_id = object_id('dbo.tablename') and [name] <> 'columnname' set @sql = 'select ' select @sql += [name] + ', ' from sys.columns where object_id = object_id('dbo.tablename') and [name] <> 'columnname' select @sql += ' from dbo.tablename';
select @temp = @temp + column_name + ', ' from information_schema.columns where table_name ='person' and column_name not in ('id') set @sql = 'select ' + substring(@temp, 0, len(@temp)) +' from [person]';
select * from <your_table>;
select `(ds|hr)?+.+` from sales;
select * from ( select column_name from information_schema.columns where table_name = n'tablename' where allcolumns.column_name not in ('unwantedcol1', 'unwantedcol2');
select array_to_string(array_agg(distinct concat(u.firstname, ' ', u.lastname)), ', ') from log_has_item logitem where logitem.company_id = 1;
select * from table_name_1 left outer join table_name_2 on id_1 = id_2 union select * from table_name_2 left outer join table_name_1 on id_1 = id_2;
select a.flightnumber, a.offblocktime, a.airspacecount, a.departure, a.arrival from d2flights a where b.flightnumber is null union select a.flightnumber, a.offblocktime, a.airspacecount,  a.departure, a.arrival from d1flights a where b.flightnumber is null;
select employee.*, department.* from   employee union all select employee.*, department.* from   department where  employee.departmentid is null;
select  col1, col2 from    mytable;
select  col1, col2 from    mytable where   (col1, col2) = ( select  col3, col4 from    othertable );
:conditions => ['important = ?', true] end;
select "people".* from "people" select "notes".* from "notes" where "notes"."important" = ? and "notes"."person_id" in (1, 2);
select "people"."id" as t0_r0, "people"."name" as t0_r1, "people"."created_at" as t0_r2, "people"."updated_at" as t0_r3, "notes"."id" as t1_r0, "notes"."person_id" as t1_r1, "notes"."important" as t1_r2 from "people";
create table a1 tableseat int(3), tableseatid int(6), name varchar(10));
values (001,001,001001,'bob'), (001,002,001002,'joe'), (001,003,001003,'dan'), (002,001,002001,'mark');
create table a2 tableseat int(3), meal varchar(10));
values (001,001,'chicken'), (001,002,'steak'), (001,003,'salmon'), (002,001,'steak');
select x.*, y.meal from a1 as x join a2 as y on (x.weddingtable = y.weddingtable) and (x.tableseat = y. tableseat);
select one.*, two.meal from table1 as one;
select criteria1, criteria2, metric1 as metric from table1 union all select criteria1, criteria2, metric2 as metric from table2;
select criteria1, criteia2, sum(metric) as metric from ( select criteria1, criteria2, metric1 as metric from table1 union all select criteria1, criteria2, metric2 as metric from table2 );
select  aa.*, bb.meal from    table1 aa ( select  a.tableseat from    table1 a where b.meal in ('chicken', 'steak') having count(distinct b.meal) = 2;
create procedure usp_silentexecutionproc as begin set nocount on;
set @strsql = '';
set @strsql = 'select top 10 * ';
if @silentexecution = 1 set @strsql = @strsql + 'into #tmpdevnull ';
set @strsql = @strsql + end go;
exec dbo.usp_silentexecutionproc @silentexecution = 1;
select @@rowcount;
set @counter = 10 select  @counter-- (simulating the effect of stored proc returning some resultset) set @counter = @counter - 1 end;
exec procedureb select * from @tmpnewvalue;
create procedure [dbo].[insertsomedata] (@myparam int) as exec selectoutput end go create procedure selectoutput as set @reply = '<xml><big /><outputs /></xml>' select @reply end;
create table #tmp(xmlreply varchar(2048)) select top 1 record from updatetable where processed = 0 end drop table #tmp;
where "column_name" = 'value1;
select * from dim_employees t where t.identity_number = '123456789';
select * from dim_employees t where t.identity_number in('123456789');
select * from emps where empid in (1) select * from emps where empid=1;
( select salesorderid, orderdate, ...;
( select salesorderid, orderdate, ...;
select [id], [someid] from [dbo].[people] where @@rowcount > 0 and [id] = scope_identity();
select  date_format(orderdate,'%m %y') as ordermonth, count(orderid) as totalorders, sum(ordertotal) as totalamount,  z.ordercustomerfk, z.customername, z.ordertotal as customertotal from orders from orders;
select concat(o.order_month, ' ', o.order_year), o.total_orders, o.total_amount, x.sum_order_total, x.ordercustomerfk, x.customername from (select month(t.orderdate) as order_month, year(t.orderdate) as order_year sum(t.ordertotal) as total_amount from orders t join (select month(t.orderdate) as ordermonth, year(t.orderdate) as orderyear t.ordercustomerfk, c.customername from orders t join customers c on c.customerid = o.ordercustomerfk and x.order_year = o.order_year;
select a.`y`, ( select @c:=null ) as `temp`, ( select @d:=null ) as `temp`, ( select from `b` limit 1 ) as `temp`, @c as c, @d as d from `a`;
values ('common', 1, 1), ('membership', 1, 1), ('role manager', 1, 1);
create table one as select 1 as one from any_table_in_your_database limit 1;
create table my_table as select stack(3 from one;
select stack(2 from one;
create table test(stu_name string,stu_id int,stu_marks int);
select * from ( select stack( 3,                 # generating new table with 3 records );
create table students (name varchar(64), age int, gpa decimal(3, 2));
values ('fred flintstone', 35, 1.28), ('barney rubble', 32, 2.32);
create table table2 as select * from table1 where 1=1;
create table table2 as select * from table1;
create table table2( col1 string, col2 string, col3 string);
set hive.support.concurrency =true;
set hive.enforce.bucketing =true;
set hive.exec.dynamic.partition.mode =nonstrict set hive.compactor.initiator.on = true;
set hive.compactor.worker.threads= 1;
set hive.txn.manager = org.apache.hadoop.hive.ql.lockmgr.dbtxnmanager;
create table table_name (col1 int,col2 string, col3 int) clustered by col1 into 4;
select * from table a where a.val in (1,2,3) and not exists(select null from table b where b.id = a.id and b.val not in (1, 2, 3));
set @sql = concat(@sql, n';
if object_id('tempdb..#printbig') is not null drop procedure #printbig create procedure #printbig ( @text nvarchar(max) ) as  select @len = case when len(@text) - @off - 1 <= @maxlen then len(@text) else @maxlen end print substring(@text, @off, @len) set @off += @len + len(@linesep) end;
set @query = cast('' as nvarchar(max))--force implicit conversion to nvarchar(max);
set @query = 'select...' -- some of the query gets set here set @query2 = '...' -- more query gets added on, etc. exec (@query + @query2);
set @query = 'select ....' [up to 4,000 characters, then rest of statement as below] set @query = @query + [rest of statement];
exec ( @query );
set @n = replicate(convert(nvarchar(max), 'a'), 4500) set @n = 'select ''' + @n + '''' select @n  -- up to max exec sp_executesql @n;
set @query = replicate('a',4000) set @query = @query + replicate('b',4000) set @query = @query + replicate('c',4000) set @query = @query + replicate('d',4000) select len(@query) select @query /*won't contain any "d"s*/ select @query as [processing-instruction(x)] for xml path /*not truncated*/;
select r.table_name from information_schema.constraint_column_usage u and u.constraint_schema = fk.unique_constraint_schema and u.constraint_name = fk.unique_constraint_name and r.constraint_schema = fk.constraint_schema and r.constraint_name = fk.constraint_name where u.column_name = 'a' and u.table_catalog = 'b' and u.table_schema = 'c' and u.table_name = 'd';
select rc.constraint_catalog, rc.constraint_schema||'.'||tc.table_name as table_name, kcu.column_name, match_option, update_rule, delete_rule from information_schema.referential_constraints as rc join information_schema.table_constraints as tc using(constraint_catalog,constraint_schema,constraint_name) join information_schema.key_column_usage as kcu using(constraint_catalog,constraint_schema,constraint_name) where unique_constraint_catalog='catalog' and unique_constraint_schema='schema' and unique_constraint_name='constraint name';
select rc.constraint_catalog, rc.constraint_schema||'.'||tc.table_name as table_name, kcu.column_name, match_option, update_rule, delete_rule from information_schema.referential_constraints as rc join information_schema.table_constraints as tc using(constraint_catalog,constraint_schema,constraint_name) join information_schema.key_column_usage as kcu using(constraint_catalog,constraint_schema,constraint_name) join information_schema.key_column_usage as ccu on(ccu.constraint_catalog=rc.unique_constraint_catalog and ccu.constraint_schema=rc.unique_constraint_schema and ccu.constraint_name=rc.unique_constraint_name) where ccu.table_catalog='catalog' and ccu.table_schema='schema' and ccu.table_name='name' and ccu.column_name='column';
select (select r.relname from pg_class r where r.oid = c.conrelid) as table, (select array_agg(attname) from pg_attribute where attrelid = c.conrelid and array[attnum] <@ c.conkey) as col, (select r.relname from pg_class r where r.oid = c.confrelid) as ftable from pg_constraint c where c.confrelid = (select oid from pg_class where relname = 'target_table_name');
where c.conrelid = (select oid from pg_class where relname = 'target_table_name');
select (select r.relname from pg_class r where r.oid = c.conrelid) as table, (select array_agg(attname) from pg_attribute where attrelid = c.conrelid and array[attnum] <@ c.conkey) as col, (select r.relname from pg_class r where r.oid = c.confrelid) as ftable from pg_constraint c where c.confrelid = (select oid from pg_class where relname = 'target_table_name') and where attname = 'target_column_name' and attrelid = c.confrelid);
select constraint_name, table_name from information_schema.table_constraints where table_schema='public' and constraint_type='foreign key';
select confrelid::regclass, af.attname as fcol, conrelid::regclass, a.attname as col from pg_attribute af, pg_attribute a, (select conrelid,confrelid,conkey[i] as conkey, confkey[i] as confkey from (select conrelid,confrelid,conkey,confkey, generate_series(1,array_upper(conkey,1)) as i from pg_constraint where contype = 'f') ss) ss2 where af.attnum = confkey and af.attrelid = confrelid and and confrelid::regclass = 'my_table'::regclass and af.attname = 'my_referenced_column';
select main_table.table_name            as main_table_table_name, main_table.column_name           as main_table_column_name, main_table.constraint_name       as main_table_constraint_name, info_other_table.table_name      as info_other_table_table_name, info_other_table.constraint_name as info_other_table_constraint_name, info_other_table.column_name     as info_other_table_column_name from information_schema.constraint_column_usage main_table where main_table.table_name = 'main_table_name';
create schema utils;
create type utils.referenced_table_t as ( constraint_name name, schema_name name, table_name name, column_name name[], foreign_schema_name name, foreign_table_name name create function utils.get_referenced_tables (schema_name name, table_name name, column_name name) select * from ( -- get human-readable names for table properties by mapping the oid's stored on the pg_constraint select -- constraint name - we get this directly from the constraints table -- schema_name ( select pg_namespace.nspname from pg_namespace where pg_namespace.oid = pg_constraint.connamespace -- table_name ( select pg_class.relname from pg_class where pg_class.oid = pg_constraint.conrelid -- column_name ( select array_agg(attname) from pg_attribute where attrelid = pg_constraint.conrelid and array[attnum] <@ pg_constraint.conkey -- foreign_schema_name ( select pg_namespace.nspname from pg_namespace where pg_namespace.oid = ( select pg_class.relnamespace from pg_class where pg_class.oid = pg_constraint.confrelid ) -- foreign_table_name ( select pg_class.relname from pg_class where pg_class.oid = pg_constraint.confrelid from pg_constraint where confrelid in ( select oid from pg_class where relname = get_referenced_tables.table_name and relnamespace = ( select oid from pg_namespace where nspname = get_referenced_tables.schema_name ) ) and confkey @> ( select array_agg(attnum) from pg_attribute where attname = get_referenced_tables.column_name and attrelid = pg_constraint.confrelid ) schema_name, table_name, column_name, foreign_table_name, foreign_schema_name;
but in cases where merging would violate a unique or exclusion constraint, the secondary person's create function utils.merge_person (primary_person_id bigint, secondary_person_id bigint) set constraints all deferred;
$sql$ update %s.%s set %s = $1 where %s = $2 $sql$, _referenced_table.schema_name, _referenced_table.table_name, _col, _col $sql$ delete from %s.%s where %s = $1 $sql$, _referenced_table.schema_name, _referenced_table.table_name, _col end loop;
select * from people.person where id = primary_person_id into _primary_person;
end $$ language plpgsql volatile;
set constraints all deferred;
alter table settings.contact_preference drop constraint contact_preference_person_id_fkey, drop constraint person_id_current_address_id_fkey, add constraint contact_preference_person_id_fkey add constraint person_id_current_address_id_fkey;
select -- unique reference info ref.table_schema     as ref_schema, ref.table_name       as ref_table, ref.column_name      as ref_column, refd.constraint_type as ref_type, -- e.g. unique or primary key fk.table_schema  as fk_schema, fk.table_name    as fk_table, fk.column_name   as fk_column, map.update_rule  as fk_on_update, map.delete_rule  as fk_on_delete from information_schema.referential_constraints as map and ref.constraint_schema = map.unique_constraint_schema and ref.constraint_name = map.unique_constraint_name and refd.constraint_schema = ref.constraint_schema and refd.constraint_name = ref.constraint_name and fk.constraint_schema = map.constraint_schema and fk.constraint_name = map.constraint_name and fk.position_in_unique_constraint = ref.ordinal_position --important!;
create table foo ( a int, b int, primary key (a,b) create table bar ( c int, d int, foreign key (c,d) references foo (b,a) -- i flipped a,b to make a point later.;
select * from information_schema.table_constraints where table_name in ('foo','bar');
select * from information_schema.referential_constraints where constraint_name in ('bar_c_d_fkey');
select * from information_schema.key_column_usage where table_name in ('foo','bar');
select format(getdate(), 'dd');
set @day = right('0'+ cast(day(getdate())as nvarchar(2)),2);
select format(getdate(),'mmdd');
select format(getdate(),'yyyymmdd');
select format(getdate(),'mm');
select    month(getdate());
select convert(varchar(2), getdate(), 101) as monthleadingzero  -- date style 101 = mm/dd/yyyy;
select convert(varchar(2), getdate(), 101);
select right('0' from   table;
set @day = right('00' + convert(nvarchar(2), datepart(day, getdate())), 2);
select replicate('0',2 - datalength(convert(varchar(2),datepart(day, getdate()))) + convert(varchar(2),datepart(day, getdate());
select right(replicate('0', 2) + cast(datepart(day, '2012-12-09') as varchar(2)), 2) as leftpadded_day;
select convert(char(2), cast('2012-12-09' as datetime), 103) as convert_day;
exec ( 'grant execute on [dbo].[fn_diagramobjects] to [' + @rolename + '];' );
create procedure [dbo].[grantaccess] as declare @approlename as sysname select approlename from [dbo].[rolelist];
exec ( 'grant execute on [dbo].[fn_diagramobjects] to [' + @approlename + '];' ) exec ( 'grant execute on [dbo].[sp_alterdiagram] to [' + @approlename + '];' ) exec ( 'grant execute on [dbo].[sp_creatediagram] to [' + @approlename + '];' ) exec ( 'grant execute on [dbo].[sp_dropdiagram] to [' + @approlename + '];' ) exec ( 'grant execute on [dbo].[sp_helpdiagramdefinition] to [' + @approlename + '];' ) exec ( 'grant execute on [dbo].[sp_helpdiagrams] to [' + @approlename + '];' ) exec ( 'grant execute on [dbo].[sp_renamediagram] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[all_columns] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[all_objects] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[all_parameters] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[all_sql_modules] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[all_views] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[allocation_units] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[assemblies] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[assembly_files] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[assembly_modules] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[assembly_references] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[assembly_types] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[asymmetric_keys] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[certificates] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[change_tracking_tables] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[check_constraints] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[column_type_usages] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[column_xml_schema_collection_usages] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[columns] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[computed_columns] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[conversation_endpoints] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[conversation_groups] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[conversation_priorities] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[crypt_properties] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[data_spaces] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[database_audit_specification_details] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[database_audit_specifications] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[database_files] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[database_permissions] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[database_principal_aliases] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[database_principals] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[database_role_members] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[default_constraints] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[destination_data_spaces] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[event_notifications] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[events] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[extended_procedures] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[extended_properties] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[filegroups] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[foreign_key_columns] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[foreign_keys] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[fulltext_catalogs] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[fulltext_index_catalog_usages] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[fulltext_index_columns] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[fulltext_index_fragments] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[fulltext_indexes] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[fulltext_stoplists] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[fulltext_stopwords] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[function_order_columns] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[identity_columns] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[index_columns] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[indexes] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[internal_tables] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[key_constraints] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[key_encryptions] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[message_type_xml_schema_collection_usages] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[module_assembly_usages] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[numbered_procedure_parameters] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[numbered_procedures] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[objects] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[parameter_type_usages] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[parameter_xml_schema_collection_usages] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[parameters] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[partition_functions] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[partition_parameters] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[partition_range_values] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[partition_schemes] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[partitions] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[plan_guides] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[procedures] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[remote_service_bindings] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[routes] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[schemas] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[service_contract_message_usages] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[service_contract_usages] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[service_contracts] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[service_message_types] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[service_queue_usages] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[service_queues] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[services] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[spatial_index_tessellations] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[spatial_indexes] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[sql_dependencies] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[sql_modules] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[stats] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[stats_columns] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[symmetric_keys] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[synonyms] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[syscolumns] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[syscomments] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[sysconstraints] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[sysdepends] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[sysfilegroups] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[sysfiles] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[sysforeignkeys] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[sysfulltextcatalogs] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[sysindexes] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[sysindexkeys] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[sysmembers] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[sysobjects] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[syspermissions] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[sysprotects] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[sysreferences] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[system_columns] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[system_objects] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[system_parameters] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[system_sql_modules] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[system_views] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[systypes] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[sysusers] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[table_types] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[tables] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[transmission_queue] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[trigger_events] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[triggers] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[type_assembly_usages] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[types] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[views] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[xml_indexes] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[xml_schema_attributes] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[xml_schema_collections] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[xml_schema_component_placements] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[xml_schema_components] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[xml_schema_elements] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[xml_schema_facets] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[xml_schema_model_groups] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[xml_schema_namespaces] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[xml_schema_types] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[xml_schema_wildcard_namespaces] to [' + @approlename + '];' ) exec ( 'grant select on [sys].[xml_schema_wildcards] to [' + @approlename + '];' ) end ;
select  sdp.state_desc , sdp.permission_name , ssu.[name] as "schema" , sso.[name] , sso.[type] from    sys.sysobjects sso sso.[name];
select * from your_table order by id asc limit 0, 1;
select tb1.* from table tb1 where id = (select max(tb2.id) from table tb2);
select max("field name") as ("primary key") from ("table name");
select max(brand) as brandid from brand_tbl;
select * from t limit 1;
select * from table_name limit 1;
select   * from     table limit    0, 1;
select if(isnull(processed_timestamp), 'null', 'not null') as myfield, count(*) from mytable;
select decode(field,null,'null','not null'), count(*) from table;
select 'null    ' as type, count(*)   as quant from       tbl where      tmstmp is null union all select 'not null' as type, count(*)   as quant from       tbl where      tmstmp is not null;
select case when field is null then 'null' else 'not null' end fieldcontent, count(*) fieldcount from thetable case when field is null then 'null' else 'not null' end;
select case when processed_timestamp is null then 'null' else 'not null' end as a, count(*) as n from logs;
as ( select count(*) where [processed_timestamp] is not null ) select count(*) as nulls, countof from table, nullrows where [processed_timestamp] is null;
select [case], count(*) tally from ( select case when [processed_timestamp] is null then 'null' else 'not null' end [case] from mytable;
select count([processed_timestamp]) as notnullrows, count(*) - count([processed_timestamp]) as nullrows from table;
select sum(case when processed_timestamp is null then 1 else 0 sum(case when processed_timestamp is not null then 1 else 0 count(1)                                                                total from table;
select count(*), count(time_stamp_column) from table;
select count(*) - count(time_stamp_column) nul_count, count(time_stamp_column) non_nul_count from table;
select iif(isdate(processed_timestamp) = 0, 'null', 'non null'), count(*) from mytable;
select  count(case when t.timestamps is null then 1 else null end) nullrows, count(case when t.timestamps is not null then 1 else null end) notnullrows from mytable t;
select count(*) as total from ..;
alter table dbo.mytable drop column oldcomputedcolumn alter table dbo.mytable add oldcomputedcolumn as othercolumn + 10;
alter <table> drop column <column> alter function <function> ( <parameters> ) end  alter <table> add <column> as dbo.<function>(parameters);
set identity_insert a on;
update b set newid = a.id from b inner join a;
update b set newid = newid();
select fname, lname from b select * from @output;
create table [dbo].[mytable] ( [id]   [int] identity(1, 1) not null, [text] [varchar](10) null ) ( newids int ) values      ('aa'),('bb'),('cc') select * from   @tblnewinserted;
select 1 select 2 select 3;
select 'will not run' select 'will not run' select 'will not run';
select 1 select 2 select 3 select 4 select 5 select 6;
create proc dbo.prsess_ins ( @ssessid    varchar( 32 ) ) as begin set nocount on select  @id=    idsess from    tbsess where   ssessid = @ssessid if  @idsess > 0 return  -- exit sproc here select  @idsess=    scope_identity( ) end;
if  @idsess is null select  @idsess=    scope_identity( ) end;
set parseonly on;
select 'this will not exec';
set parseonly off;
set @runscript = 0;
if @runscript != 1 end ;
if object_id('tempdb..#vars') is not null drop table #vars end  create table #vars (continuescript bit) set nocount on set nocount off if ((select continuescript from #vars)=1) begin if (1=1) begin set nocount on update #vars set continuescript=0 set nocount off end  end go if ((select continuescript from #vars)=1) begin end go;
if object_id('tempdb..#vars') is not null drop table #vars end  create table #vars (continuescript bit) set nocount on set nocount off if ((select continuescript from #vars)=1) begin if (1=0) begin set nocount on update #vars set continuescript=0 set nocount off end  if (1=0) begin set nocount on update #vars set continuescript=0 set nocount off end  set nocount on select 1/1 as test set nocount off end try set nocount on select error_number() as errornumber update #vars set continuescript=0 set nocount off end catch;
end go if ((select continuescript from #vars)=1) begin if (1=0) begin set nocount on update #vars set continuescript=0 set nocount off end  if (1=0) begin set nocount on update #vars set continuescript=0 set nocount off end  set nocount on select 1/1 as test set nocount off end try set nocount on select error_number() as errornumber update #vars set continuescript=0 set nocount off end catch;
end go if @@trancount > 0 begin if ((select continuescript from #vars)=1) begin end else begin end end;
if (1=0) end print 'but it will here';
select * from books where returned_date > current_date - interval '7 days';
select * from books where current_date - integer '7';
select * from books where returned_date > current_date - 7;
where returned_date >= current_date - 7 and   returned_date <  current_date;
where returned_date between current_date - 7 and     current_date - 1;
where returned_date between date_trunc('week', now())::date - 7 and     date_trunc('week', now())::date - 1;
between ... and ...;
select to_char(sysdate, 'month') from dual;
select to_char(to_date('15-11-2010', 'dd-mm-yyyy'), 'month') from dual;
select to_char(sysdate,'dd') from dual; -> 08 (date) select to_char(sysdate,'mm') from dual; -> 02 (month in number) select to_char(sysdate,'yyyy') from dual; -> 2013 (full year);
select to_char(sysdate,'month') from dual;
select to_char(sysdate,'fmmonth') from dual;
select extract(month from [field_name]) from [table_name];
select to_char(sysdate,'month') from dual;
select to_char(sysdate,'mon') from dual;
select 1 from information_schema.tables where table_schema = 'public' and table_name=%s limit 1;
from string import letters which will take care of the values. case sensitive; instead it is ensured that no dangerous chars ...               table='fozzie') check the given name for being syntactically valid, and usable without quoting if not isinstance(tablename, basestring): if invalid: if not s:;
from psycopg2.extensions import asis;
from psycopg2 import sql sql.sql("insert into {} values (%s, %s)") [10, 20]);
select * from ( select * from `core_username` limit 1);
select personid, parentid, name from mytable;
select personid, name from mytable left join mytable t on t.personid=mytable.parentid;
exec sp_helplogins;
exec sp_helplogins @loginnamepattern='fred';
select * from master..sysusers where issqluser = 1;
select name from master..sysxlogins where sid is not null;
select * from master.syslogins;
select * from master.sys.sql_logins;
select * from master.sys.sysusers;
select 1 union all select 1 + n from nbrs where n < 500 ) select n from nbrs;
( select 1 union all select 1 + n from tally where n < 1000000 ) select n from tally create table #tally2 (n int);
values (@index);
set @index = @index + 1;
select top (1000000) from master.sys.all_columns ac1 e02(n) as (select 1 from e00 a, e00 b), e04(n) as (select 1 from e02 a, e02 b), e08(n) as (select 1 from e04 a, e04 b), e16(n) as (select 1 from e08 a, e08 b), e32(n) as (select 1 from e16 a, e16 b), ctetally(n) as (select row_number() over (order by n) from e32) select n from ctetally where n <= 1000000;
drop table #tally1, #tally2, #tally3, #tally4;
select 1 union all select 1 union all select 1 union all select 1 union all select 1 union all select 1 union all select 1 union all select 1 union all select 1 union all select 1 ), e01 (n) as (select a.n from e00 a cross join e00 b), e02 (n) as (select a.n from e01 a cross join e01 b ), e03 (n) as (select a.n from e02 a cross join e02 b limit 11000  -- end record  11,000 good for 30 yrs dates select n from tally;
create view dbo.numbers as with int1(z) as (select 0 union all select 0) select row_number() over (order by z) as n from int32;
as (select 0 union all select 1 union all select 2 union all select 3 union all select 4 union all select 5 union all select 6 union all select 7 union all select 8 union all select 9) select hundredthousand.digit * 100000 + tenthousand.digit * 10000 + thousand.digit * 1000 + hundred.digit * 100 + ten.digit * 10 + one.digit as number from numbers_cte as one cross join numbers_cte as ten cross join numbers_cte as hundred cross join numbers_cte as thousand cross join numbers_cte as tenthousand cross join numbers_cte as hundredthousand;
select rn = cast([key] as int) from openjson(concat('[1', replicate(cast(',1' as varchar(max)),@max-1),']'));
select num from table where ( num % 2 ) = 0;
select num from table where mod (num, 2) = 0;
select city from station as st where st.id % 2 = 0 in order to fetch the odd records with id as odd number. select city from station as st where st.id % 2 <> 0;
select * from games where title collate utf8_general_ci like 'age of empires iii%';
select * from games where lower(title) like 'age of empires iii%';
select * from games where (lower(title) like 'age of empires iii%');
select * from games where (lower(title) like 'age of empires iii');
select * from games where (lower(title) like '%age of empires iii%');
select * from games where lower(title) like 'age of empires iii%';
if ($key === false) {;
if ($key === false) {;
select productid, sum(orderquantity) as totalorderquantity from orderdetails group by productid ) select distinct orderdetails.productid, orderdetails.productname, orderdetails.orderquantity,cte_sum.totalorderquantity from orderdetails inner join cte_sum;
select max(id) as id, nume, max(intrare) as intrare, max(iesire) as iesire, max(intrare-iesire) as stoc, max(data) as data from produse;
select productid, productname, orderquantity, sum(orderquantity) from orderdetails where(orderquantity) in(select sum(orderquantity) from orderdetails group by orderdetails) group by productid, productname, orderquantity;
select productid, group_concat(distinct productname) as names, sum(orderquantity) from orderdetails group by productid;
from orderdetails select distinct(orderdetails.productid), orderdetails.productname, cte_test.total from orderdetails;
from sch_dta.t_value select sch_dta.t_value.*, cte_test.quantity from sch_dta.t_value;
select productid max(enc.pnameandoq), 1, charindex(';', max(enc.pnameandoq)) - 1 max(enc.pnameandoq), charindex(';', max(enc.pnameandoq)) + 1, 9999 from ( select concat (productname, ';', cast(orderquantity as varchar(10))) as pnameandoq, productid from orderdetails;
create table tablename( [msgid] [int] not null, [userid] [int] not null, [username] [varchar](70) not null, [message] [varchar](5000) not null );
select m.userid, (select top 1 username from table where userid = m.userid order by msgid desc) as username, count(*) as messages from tablename m;
select productid,productname,sum(orderquantity) from orderdetails group by productid, productname;
(3004,'ytp',15),(4001,'aze',19),(1001,'abc',7);
select productid, productname, sum(orderquantity) as total from @orderdetails;
select od.productid, od.productname, calq.orderquantity from (select distinct productid, productname from orderdetails) od from orderdetails;
create table demo ( ts datetime ) select ts from demo;
select table1.a, table1.b, table1.timestamp from table1;
select table1.a, table1.b, null from table1;
select stuff( (select from (select id from sysobjects where xtype = 'u' and name = @tablename) tables where columns.xtype <> 189;
select productid, name, productnumber, makeflag, finishedgoodsflag, color, safetystocklevel, reorderpoint, standardcost, listprice, size, sizeunitmeasurecode, weightunitmeasurecode, weight, daystomanufacture, productline, class, style, productsubcategoryid, productmodelid, sellstartdate, sellenddate, discontinueddate, rowguid, modifieddate from db1.dbo.product;
create table wtf ( id int, leet timestamp ) select * from wtf;
select * from foo where id in (select id from foo2);
select foo.* from foo join foo2 on foo.id=foo2.id;
select * from foo where id not in (select id from foo2);
select foo.* from foo;
select u1.name as username from message m1, user u1 where u1.uid = m1.userfromid group by u1.name having count(m1.userfromid)>3;
select a.* from a join ( select a.alias, max(a.year) as max_year from a;
create view v_max_year as select alias, max(year) as max_year from a create view v_latest_info as select a.* from a join v_max_year b;
select col from ( select distinct col, order_by_col from table );
from django.conf import settings from django.db import connection, reset_queries if reset:;
in [1]: user.objects.all() in [2]: num_queries() in [3]: user.objects.filter(company=company.objects.first()).all() in [4]: num_queries();
from django.db import connections,connection,reset_queries from django.conf import settings;
select st.columnname1, jt.columnname2, sjt.columnname3 from sourcetable st where st.sourcetableid = x and jt.columnname3 = y and jt.column3 = sjt.column4;
select st.columnname1, jt.columnname2, sjt.columnname3 from sourcetable st and jt.column3 = sjt.column4 where st.sourcetableid = x and jt.columnname3 = y;
columnname1, columnname2, columnname3) values ( @value1, @value2, @value3);
select st.columnname1 from sourcetable     st where st.sourcetableid    =   x and jt.columnname3      =   y and jt.column3          =   sjt.column4;
select my_column from my_table where my_id in ( select my_id from some_other_table where some_other_column in (1, 4, 7) );
case when my_column = 1 then 'one' else 'who knows' end;
select st.columnname1, jt.columnname2, sjt.columnname3 from sourcetable st and st.sourcetable2id = sjt.sourcetable2id where st.sourcetableid = x and jt.columnname3 = y and jt.column3 = sjt.column4 st.columnname1;
select a.col1                  as [column1] from table1 a where a.col     = x and b.col = y;
select st.columnname1, jt.columnname2, sjt.columnname3 --leave all selected columns on the same line from sourcetable st and jt.column3 = sjt.column4 where st.sourcetableid = x and jt.columnname3 = y;
select  st.column_name_1, jt.column_name_2, sjt.column_name_3 from    source_table as st and jt.column_3 = sjt.column_4 where   st.source_table_id = x and     jt.column_name_3 = y;
update  target_table set     column_name_1 = @value, column_name_2 = @value2 where   condition_1 = @test;
column_name_3) values  (@value1, @value2, @value3);
select  term, student_id, case when ((ft_credits > 0 and credits >= ft_credits) or (ft_hours_per_week > 3 and hours_per_week >= ft_hours_per_week)) then 'f' else 'p' end as status from    ( select  term, student_id, pm.credits as ft_credits, pm.hours as ft_hours_per_week, sum(credits) as credits, sum(hours_per_week) as hours_per_week from    ( select  e.term, e.student_id, nvl(o.credits, 0) credits, case when nvl(o.weeks, 0) > 5 then (nvl(o.lect_hours, 0) + nvl(o.lab_hours, 0) + nvl(o.ext_hours, 0)) / nvl(o.weeks, 0) else 0 end as hours_per_week from    enrollment as e where   e.registration_code not in ('a7', 'd0', 'wl') ) where   sh.eff_term = ( select  max(eff_term) from    student_history as shi where   sh.student_id = shi.student_id and     shi.eff_term <= term) );
select st.columnname1 from sourcetable st jointable jt secondjointable sjt and st.sourcetable2id = sjt.sourcetable2id where st.sourcetableid = x and jt.columnname3 = y and jt.column3 = sjt.column4;
select term then 'f' else 'p' end as status from (select term from (select e.term then (nvl(o.lect_hours, 0) + nvl(o.lab_hours, 0) + nvl(o.ext_hours, 0)) / nvl(o.weeks, 0) else 0 end as hours_per_week from enrollment as e offering as o using (term, offering_id) program_enrollment as pe and e.term = pe.term and e.offering_id = pe.offering_id where e.registration_code not in ('a7', 'd0', 'wl') ) student_history as sh using (student_id) program_major as pm where sh.eff_term = (select max(eff_term) from student_history as shi where sh.student_id = shi.student_id and shi.eff_term <= term) );
select st.columnname1, jt.columnname2, sjt.columnname3 from sourcetable st join jointable jt on jt.sourcetableid = st.sourcetableid join secondjointable sjt on where st.sourcetableid = x and jt.columnname3 = y;
select st.columnname1, jt.columnname2, sjt.columnname3 from  and jt.column3 = sjt.column4 where  and jt.columnname3 = ( select somecolumn from sometable );
select col1, col2, col3 else 'answer2' end , col4, col5, col6, col7 from table1 t1 where t1.col5 = 19 and t1.col7 = 'bill gates';
select st.columnname1, jt.columnname2, sjt.columnname3 from sourcetable st inner join secondjointable sjt on st.sourcetableid = sjt.sourcetableid and jt.column3 = sjt.column4 where (st.sourcetableid = x) and (jt.columnname3 = y);
update targettable set columnname2 = @value2 where (condition1 = @test);
( columnname1, columnname2, columnname3 ) values ( @value1, @value2, @value3;
select st.columnname1, jt.columnname2, sjt.columnname3 from <schema>.sourcetable as st where st.sourcetableid = x and;
select term, student_id, case when (ft_credits > 0 and credits >= ft_credits) or (ft_hours_per_week > 3 and hours_per_week >= ft_hours_per_week) then 'f' else 'p' end as [status] from ( select a.term, a.student_id, pm.credits as ft_credits, pm.[hours] as ft_hours_per_week, sum(a.credits) as credits, sum(a.hours_per_week) as hours_per_week from ( select e.term, e.student_id, nvl(o.credits, 0) credits, case when nvl(o.weeks, 0) > 5 then else 0 end as hours_per_week from enrollment as e where e.registration_code not in ('a7', 'd0', 'wl') where sh.eff_term = ( select max(eff_term) from student_history as shi where shi.student_id = sh.student_id and ) a.term, a.student_id, pm.credits, pm.[hours] term, student_id;
select st.columnname1, jt.columnname2, sjt.columnname3 from sourcetable st and jt.column3 = sjt.column4 where st.sourcetableid = x and jt.columnname3 = y;
select column1, column2, column3, ect...;
cola1 int, cola2 int, colb1 int, colb2 nvarchar(255), colb3 nvarchar(255), colb4 int, colb5 bit, computed int  select        st.cola1, sot.cola2 from          sometable st   select        colb1, colb2, colb3, colb4, colb5, computed =    case end from          athirdtable tt join         afourthtable ft and tt.key2 = ft.key2 and tt.key3 = ft.key3 ) cola1, cola2, cola2, colb1, colb2, colb3, colb4, colb5, computed ) select      cola1, cola2, colb1, colb2, colb3, colb4, colb5, computed from        getsomedata data1 join        getsomeotherdata data2;
select        st.cola1, sot.cola2 from          sometable st;
select st.columnname1, jt.columnname2, sjt.columnname3 from sourcetable st jointable jt secondjointable sjt where st.sourcetableid = x and jt.columnname3 = y and jt.column3 = sjt.column4;
select st.columnname1 from   sourcetable st join   jointable jt on jt.sourcetableid = st.sourcetableid join   secondjointable sjt on sstt.sourcetableid = sjt.sourcetableid and jt.column3 = sjt.column4 where  st.sourcetableid = x and jt.columnname3 = y;
select st.columnname1, jt.columnname2, sjt.columnname3, case when condition1 = true and condition2 = true then dosomething else dosomethingelse end columnname4 from sourcetable as st join jointable as jt join secondjointable as sjt and jt.column3 = sjt.column4 join (select column5 from table4 pfield2 where st.sourcetableid = x and jt.columnname3 = y;
select      st.columnname1 from        sourcetable       st join        jointable         jt  on  jt.sourcetableid  =  st.sourcetableid join        secondjointable  sjt  on  st.sourcetableid  =  sjt.sourcetableid and jt.column3        =  sjt.column4 where       st.sourcetableid  =  x and         jt.columnname3    =  y;
create procedure [dbo].[usp_getallpostbookmarksbyuserid] @startindex int, @endindex int as begin set nocount on select      * from (   select      row_number() over ( order by p.created_date ) as row_num, p.post_id, p.title, p.points, p.estimated_read_time, p.view_count, count(1) as "total_attempts" -- todo from        [dbo].[bookmarked] b where       b.user_id = 1 and p.is_active = 1 where       row_num >= @startindex and         row_num < @endindex end;
select st.columnname1, jt.columnname2, sjt.columnname3 from sourcetable st and jt.column3 = sjt.column4 where st.sourcetableid = x and jt.columnname3 = y;
select st.columnname1 from sourcetable st and jt.column3      = sjt.column4 where st.sourcetableid   = x and jt.columnname3 = y;
select st.columnname1 from sourcetable st jointable jt secondjointable sjt and jt.column3      = sjt.column4 where st.sourcetableid   = x and jt.columnname3 = y;
select p.name as productname from production.product as p join production.productmodel as pm where p.color in ('blue', 'red') and p.listprice < 800.00 and pm.name like '%frame%' currencycode ) values ( 'xbt' ) update p set p.listprice = p.listprice * 1.05 from production.product p where p.sellenddate is null and p.sellstartdate is not null delete cc from sales.creditcard cc where cc.expyear < '2003' and cc.modifieddate < dateadd(year, -1, getutcdate());
create table foo ( id int primary key not null, int1 int, int2 int, int3 int ) create table fruits ( id int primary key not null, name varchar(30) ) create table foofruits ( fruitid int references fruits (id), fooid int references foo(id), constraint pk_foofruits primary key (fruitid, fooid) );
select 5, id from fruits where name = 'apple';
select 5, id from   fruits where  name in ('apple', 'orange');
select c.content_id, c.content_title, c.content_datepublished, m.media_id from tbl_contents c ( select top 1 * from tbl_media m where m.content_id = c.content_id c.content_datepublished asc;
select c.content_id, c.content_title, c.content_datepublished, m.media_id from tbl_contents c c.content_id, c.content_title, c.content_datepublished, m.media_id c.content_datepublished asc;
select c.content_id, c.content_title, max(m.media_id) from tbl_contents c left join;
select c.content_id, c.contt_title, (select m.media_id from tbl_media m where m.content_id = c.content_id limit 1 from tbl_contents c;
select distinct c.content_id, c.content_title, m.media_id from tbl_contents c;
select cast(@date as datetime) + cast(@time as datetime);
select @date, @time, cast(@date as datetime) + cast(@time as datetime);
db,params={"dstart":datetime(2014,6,24,16,0),"dfinish":datetime(2014,6,24,17,0)}, index_col=['timestamp']);
select * from document, documentstats where documentstats.id = document.id and documentstats.nbviews > 500;
select * from document, documentstats where documentstats.id = document.id and documentstats.nbviews > 500;
select u.id, p.photo, round(rand() * x.m_id) 'rand_ind' from users u, profiles p, (select max(t.id) 'm_id' from users t) x where p.memberid = u.id and p.photo != '' and (u.ownership=1 or u.stamp=1) limit 18;
select u.id, p.photo, floor(1 + rand() * x.m_id) 'rand_ind' from users u, profiles p, (select max(t.id) - 1 'm_id' from users t) x where p.memberid = u.id and p.photo != '' and (u.ownership=1 or u.stamp=1) limit 18;
select id from testtable;
select t.* from testtable t join (select id from `testtable` where t.isvisible = 1 limit 100;
select u.id, p.photo from users u, profiles p join (select id from users where p.memberid = u.id and p.photo != '' and (u.ownership=1 or u.stamp=1) limit 18;
select min(id) as min, max(id) as max from table;
select g.* from table g join (select from table where rand() < (select from table) limit 4) as z on z.id= g.id;
select g.* from table g limit 4;
select distinct t.id, t.photo from (select  u.id, p.photo, rand() as rand from users u, profiles p where p.memberid = u.id and p.photo != '' and (u.ownership=1 or u.stamp=1) limit 18;
select * from users where users.ownership = 1 or users.stamp = 1;
select * from ( select * from users where users.ownership = 1 or users.stamp = 1 where rand() <= $limitcount / (select count(*) from users where users.ownership = 1 or users.stamp = 1);
from ( select * from users where users.ownership = 1 or users.stamp = 1 where rand() <= $limitcount * $factor / (select count(*) from users where users.ownership = 1 or users.stamp = 1);
select * from ( select * from ( select * from users where users.ownership = 1 or users.stamp = 1 where rand() <= $limitcount * $factor / (select count(*) from users where users.ownership = 1 or users.stamp = 1) join profiles limit $limitcount;
create table `user` ( `id` int(11) not null auto_increment, `name` varchar(45) default null, primary key (`id`);
create table `account` ( `id` int(11) not null auto_increment, `name` varchar(45) default null, primary key (`id`);
create table `user2account` ( `user_id` int(11) not null, `account_id` int(11) not null, primary key (`user_id`,`account_id`), unique key `fk_account_idx` (`account_id`), unique key `fk_user_idx` (`user_id`), constraint `fk_account` foreign key (`account_id`) references         `account` (`id`), constraint `fk_user` foreign key (`user_id`) references `user` (`id`);
from [dbo].[tablename] as [extent1].where(c => ...;
from [dbo].[tablename] as [extent1] where ([extent1]...;
if (parameterid.hasvalue);
if (excludebigdata) else results = context.myentity.asqueryable();
contenttype = o.contenttype, documenttypeid = o.documenttypeid, filename = o.filename, id = o.id, // etc. even with related entities here like:;
contenttype = o.contenttype, documenttypeid = o.documenttypeid, filename = o.filename, id = o.id, uploadedby = o.uploadedby == null ? null : modelfactory.create(o.uploadedby);
contenttype = o.contenttype, documenttypeid = o.documenttypeid, //...;
f.datemodification, f.fileid;
select [f].[id], [f].[report], [f].[creationdate] from [file] as [f];
select [f].[id], '' as [report], [f].[creationdate] from [file] as [f];
select new thing { another = thing.another;
select acid, acname, pldepper, repid, custcatg, hardcode, blockcust, crperiod, crlimit, billlimit, mode, pnotes, gtab82.memno from vcustomer as v1 gtab82 on gtab82.memacid = v1.acid where (acgrcode = '204' or credebt = 'true') and masked = 'false';
alter table product_product alter column code type text;
update photos set caption = replace(caption,'"','\'');
select note as note_original,  replace( replace( replace( replace( replace( replace( replace( replace( replace( replace( replace( replace( replace( replace( replace( replace( replace( replace( replace( replace( replace( replace( replace( replace( replace( replace( replace( replace( replace( replace( replace( replace(note, '\"', ''), '.', ''), '?', ''), '`', ''), '<', ''), '=', ''), '{', ''), '}', ''), '[', ''), ']', ''), '|', ''), '\'', ''), ':', ''), ';', ''), '~', ''), '!', ''), '@', ''), '#', ''), '$', ''), '%', ''), '^', ''), '&', ''), '*', ''), '_', ''), '+', ''), ',', ''), '/', ''), '(', ''), ')', ''), '-', ''), '>', ''), ' ', '-'), '--', '-') as note_changed from invheader;
select * from drivel d where exists (select * from drivel where d.id = drivel.id and drivel.start_date < '2015-02-05' and '2015-02-05' < drivel.end_date) or exists (select * from drivel where d.id = drivel.id and drivel.start_date < '2015-02-05' and '2015-02-05' < drivel.end_date) or exists (select * from drivel where d.id = drivel.id and '2015-02-05' < drivel.start_date and drivel.end_date < '2015-02-05';
select * from drivel d where exists (select * from drivel where d.id = drivel.id and drivel.start_date < '2015-02-05' and '2015-02-05' < drivel.end_date) or exists (select * from drivel where d.id = drivel.id and drivel.start_date < '2015-02-05' and '2015-02-05' < drivel.end_date) or exists (select * from drivel where d.id = drivel.id and '2015-02-05' < drivel.start_date and drivel.end_date < '2015-02-05');
int pid ) if (sess != null && pid > 0) "rawtypes" ) "{call getholdingsforpf(:pid)}").addentity(rep_holdings.class);
"rawtypes" ) if (result != null) if (result.size() > 0);
alter procedure [dbo].[getholdingsforpf] as begin set nocount on;
set @totalpfinv =  ( select  sum(totalinvestment) from holdings where pid = @pid );
select hid, pid, sccode, numunits, avgppu, adjppu, totalinvestment, cast ( (totalinvestment/@totalpfinv)*100 as decimal(10,1)) as perpf, totaldiv, cast ( (totaldiv/totalinvestment)*100 as decimal(10,1)) as divy from holdings where pid = @pid end;
select salesid, count(*) from axdelnotesnotracking having count(*) > 1;
select  *, row_number() over (partition by salesid order by salesid) as [num] from    axdelnotesnotracking ) select  * from    cte where   cte.num > 1;
select * from axdelnotesnotracking where salesid in from axdelnotesnotracking having count(*) > 1 );
select salesid,count (salesid) from axdelnotesnotracking group by salesid having count (salesid) >1;
select salesid from axdelnotesnotracking group by salesid having count(*) > 1;
having count(*) > 1 and count(*) < 5;
select * from table1, table2 where table1.yr =* table2.yr -1;
select * from table2;
where t.column =* s.column;
where table1.yr =* table2.yr -1;
select * from table1, table2 where table1.yr =* table2.yr -1;
select * from table2;
where table1.yr (+)= table2.yr;
select * from users limit 5;
select * from users fetch first 5 rows only;
select title from post id desc;
select title from post id desc limit 50;
insert into distributors values (default, 'xyz widgets'), (default, 'abc widgets') ) select count(*) from rows;
update distributors set dname = 'jkl widgets' where did <= 10 ) select count(*) from rows;
create temporary table orders_temp1 (select id, dayofyear(`date`)  as d, count(*) as total from  `orders` where  `haspaid` > 0 group by d order  by d);
create temporary table orders_temp2 (select * from orders_temp1);
select d, total, (select sum(t2.total) from orders_temp2 t2 where t2.id<=t1.id) as running_total from orders_temp1 t1;
select dayofyear(`date`) as d, count(*), sum(count(*)) over (order by dayofyear(`date`)) from `orders` where `haspaid` > 0;
select dayofyear(`date`) as d, count(*) from `orders` where `haspaid` > 0 ) select d, c, sum(c) over (order by d);
select q1.d, q1.c, (@runtot := @runtot + q1.c) as rt from (select count(*) as c from  `orders` where  `haspaid` > 0;
select dayofyear(o.`date`)  as d, count(*), (select count(*) from `orders` where  dayofyear(`date`) <= d and   `haspaid` > 0) from `orders` as o where o.`haspaid` > 0;
select sql_calc_found_rows t3.id, a,bunch,of,other,stuff from t1, t2, t3 where (associate t1,t2, and t3 with each other) limit 10,20;
select found_rows(); -- for most recent query;
select sql_calc_found_rows t3.id, a,bunch,of,other,stuff from t1, t2, t3 where (associate t1,t2, and t3 with each other) limit 10,20;
select found_rows();
select count(distinct t3.id);
select count(*) from ( <your query here>;
select count(*) from ( select t3.id, a,bunch,of,other,stuff from t1, t2, t3 where (associate t1,t2, and t3 with each other) ) as temp;
select sum(1) as counttotal from ( your query with group by operator;
select author.aname,count(book.author_id) as "number_of_books" from author;
select books.*, count(orders.book_id) as number_of_orders from books books.book_id;
select books.book_id, books.author, books.genre, books.price, books.publication_date, count(orders.book_id) as number_of_orders from books books.book_id, books.author, books.genre, books.price, books.publication_date;
select b.book_id, b.author, b.genre, b.price, b.publication_date, coalesce(oc.count, 0) as number_of_orders from books b select book_id, count(*) as count from order;
select tbl.col.value('idinvernadero[1]', 'smallint'), tbl.col.value('idproducto[1]', 'smallint'), tbl.col.value('idcaracteristica1[1]', 'smallint'), tbl.col.value('idcaracteristica2[1]', 'smallint'), tbl.col.value('cantidad[1]', 'int'), tbl.col.value('folio[1]', 'varchar(7)') from   @xml.nodes('//row') tbl(col);
select tbl.col.value('@idinvernadero', 'smallint'), tbl.col.value('@idproducto', 'smallint'), tbl.col.value('@idcaracteristica1', 'smallint'), tbl.col.value('@idcaracteristica2', 'smallint'), tbl.col.value('@cantidad', 'int'), tbl.col.value('@folio', 'varchar(7)') from   @xml.nodes('//row') tbl(col);
set @xml = '<rows><row> exec @preparexmlstatus= sp_xml_preparedocument @handle output, @xml select  * from    openxml(@handle, '/rows/row', 2) idinvernadero int, idproducto int, idcaracteristica1 int, idcaracteristica2 int, cantidad int, folio int ) exec sp_xml_removedocument @handle;
exists (select a except select b);
not exists (select a except select b);
select 1 as pk, 21 as c, null  as  b select 1 as pk, 21 as c, 2 as b select * from tab1 a join tab2 b on a.pk = b.pk where exists(select a.c, a.b select b.c, b.b);
not (a is not distinct from b);
( ((a) is null and (b) is not null) or ((a) is not null and (b) is null) or ((a) <> (b)) ) ( ((a) is null and (b) is null) or ((a) = (b)) );
not exists(select a intersect select b);
select * from tablea a where not exists( select a.col1, a.col2, a.col3 select b.col1, b.col2, b.col3);
case when [a] is     null and [b] is     null then false else                                          true end;
where coalesce(@input, x) = coalesce(column, x);
where @input = column or (@input is null and column is null);
case when (a = b) or (a is null and b is null) then 1 else 0 end = 0 case when (a = b) or (a is null and b is null) then 1 else 0 end = 1;
select * from [target_database].dbo.[table] as _target;
select * from [linked_server_name].[database].[schema].[table];
select * from opendatasource ('sqlncli', 'data source=192.168.6.69;initial catalog=anotherdatabase;persist security info=true;user id=sa;password=anotherdbpassword;multipleactiveresultsets=true;' ).humanresources.department.mytable;
exec sp_addlinkedserver @server = 'test';
select * from [server].[database].[schema].[table];
select * from [test].[testdb].[dbo].[table];
exec sp_addlinkedserver @server='pwa_projectserver', @srvproduct='', @provider='sqloledb', @datasrc='servername\pwa_projectserver';
select * from [server].[database].[schema].[table];
select top 6 * from [pwa_projectserver].[pwa_projectserver_reporting].[dbo].[msp_adminstatus];
from x in db.sometable where new[] {2,3,4,5}.contains(x);
where idlist.contains(x.id) select x;
where conditionlist.contains(test) select test);
where contains(x, 2, 3, 4, 5) select x;
if (valuestosearch == null) if (searchvalue.equals(valuestosearch[i]));
join image in dbcontext.images on reqasset.imageid equals image.id where reqassetsdatastringrep.contains(reqasset.id + "_" + image.id) select reqasset;
select ic.table_name, ic.column_name, ic.data_type, ifnull(character_maximum_length,'') as `max`, ic.numeric_precision as `precision`, ic.numeric_scale as scale, ic.character_maximum_length as varcharsize, ic.is_nullable as nulls, ic.ordinal_position as ordinalpos, ic.column_default as coldefault, ku.ordinal_position as pk, kcu.constraint_name, kcu.ordinal_position, tc.constraint_type from information_schema.columns ic and ku.column_name = ic.column_name and kcu.table_name = ic.table_name;
select * from information_schema.tables;
select * from information_schema.tables;
select column_comment from information_schema.columns where table_name = 'mytable' and column_name = 'mycolumnname';
select concat('drop table ', table_name, ';') from information_schema.tables where table_schema = '*name_of_your_database*' and table_name like 'wp_old_%';
select count(*) as total from (select table_name as tab, tables.* from information_schema.tables where table_schema='database_name' group by tab) tables;
select table_name as table, tables.* from information_schema.tables where table_schema='database_name' group by table;
create procedure `showfromtables`() select table_name from information_schema.tables where table_name like 'wp_1%';
if v_finished = 1 then end if;
set @s=concat("select * from ",c_table,";");
end loop get_data;
select iif(b.[stat] is null, c.[event date]+10, '-') as [date];
case when b.[stat] is null then (c.[event date]+10)   -- type datetime else '-'                                         -- type varchar end as [date];
case isnull(b.[stat],0) end;
then convert(varchar(10), c.[event date]+10, 121) else '-';
case when (10 > 0) then 1  else 0 end (it can be used in select query) select case when (10 > 0) then 1  else 0 end as my_boolean_column from dual;
select case when (10 > 0) then 'true' else 'false' end as my_boolean_column from dual;
select get_something('name', sys.diutil.int_to_bool(1)) from dual;
select bool('''abc''<''bfg''') from dual;
create or replace function bool(p_str in varchar2) return varchar2 else :v_res :=  0;
end if; end;' using out v_res;
where (:parampickuporders = 0 and ordh.pickup_flag = 'n' or :parampickuporders = 1 and ordh.pickup_flag = 'y' );
or (parameters!paramfilterorderswithnoload.value=true and fields!loadnumber.value=0);
ignore_notfound in varchar2) return varchar2;
select get_something('name', 'true') from dual;
select get_something('name', 1 = 1) from dual;
end get_something_;
select get_something_('name', 1) from dual;
select * from mytable where rowname = 'a'';drop table mytable where 1=1''';
alter table public.accounts alter column pwd_history set default array[]::varchar[];
alter table public.accounts alter column pwd_history set default '{}';
select column_name, case when data_type in ('varchar', 'char', 'nchar', 'nvarchar', 'binary') then convert(varchar(max), character_maximum_length) then convert(varchar(max), numeric_precision) then convert(varchar(max), 1) then convert(varchar(max), concat(concat(numeric_precision, ', '), numeric_scale)) then '' end as datalen, data_type from information_schema.columns where table_name = '';
select * into my_new_table from ( select old_col1, my_new_col, old_col2, old_col3 from my_old_table;
alter table mytable add column  new_column <type>;
"line %d: lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.", i));
select from table where ancestors like "%6,2,1";
select from table where ancestors like "1,2,6%";
select p.name, s.orderqty from product p (select productid, sum(orderqty) as orderqty from salesorderdetail group by productid having sum(orderqty) >1000) s;
select date_trunc('hour', created_at) + date_part('minute', created_at)::int / 5 * interval '5 min' as minute from orders;
select to_timestamp( floor(extract(epoch from ht.time) / extract(epoch from interval '5 min'));
select date_trunc('hour', ht.time) from huge_table as ht limit 4000000;
select * from table where upper(table.name) like upper('ignorecase');
select * from table where lower(table.name) like lower('ignorecase');
select * from table where upper(table.name) like upper('ignorecase');
create index upper_index_name on table(upper(name));
alter session set nls_comp=linguistic;
alter session set nls_sort=binary_ci;
alter session set nls_comp=ansi;
alter session set nls_sort=binary_ci;
select * from table where upper(table.name) like tablename;
select * from table where regexp_like (table.name,'ignorecase','i');
select * from table where table.name collate binary_ci like 'ignorecase';
select email, cast( concat( '[', group_concat( json_object( 'name', name, 'phone', phone ) from table1;
select email, group_concat(concat('{name:"', name, '", phone:"',phone,'"}')) list from table1 email;
select email,concat('{name:"',ur_name_column,'",phone:"',ur_phone_column,'"}') as list from table1 group by email;
select email, concat( '[', coalesce( group_concat( concat( '{', '\"name\": \"', hex(name), '\", ', '\"phone\": \"', hex(phone), '\"', '}') ''), ']') as bdata from table;
json_object( 'name', name, 'phone', phone );
'[', group_concat( json_object( 'name', name, 'phone', phone ) ']';
select email, json_arrayagg( json_object( 'name', name, 'phone', phone ) from table1;
select top 10 p.id from(select distinct p.id  from tablename)tablename;
select top 14 a, b, c from mydatabase where exists ( select distinct[a] from mydatabase );
select top 10 p.id, pl.nm, pl.val, pl.txt_val from dm.labs pl join mas_data.patients p on pl.id = p.id where pl.nm like '%ldl%' and val is not null select p.id, pl.nm, pl.val, pl.txt_val from #yourtemptable where id in (select distinct id from #yourtemptable);
select top(1)  t.id from (select distinct top(3) st.id  from table1 as t1 , table2 as t2 where t1.id=t2.id order by (t2.id) desc ) t order by(t.id) asc;
create table #names ([name] varchar(10)) select distinct top 5 [name] from #names select top 5 * from (select distinct [name] from #names) subquery drop table #names;
select distinct top 10 myid from sometable;
select distinct * from (  select top 10 p.id, pl.nm, pl.val, pl.txt_val from dm.labs pl join mas_data.patients p where pl.nm like '%ldl%' and val is not null );
select top 10 * from ( select distinct p.id, .... );
select distinct top 10 p.id, pl.nm -- , pl.val, pl.txt_val from dm.labs pl join mas_data.patients p where pl.nm like '%ldl%' and val is not null;
select top 10 p.id, max( p1.nm ), max (p1.val), ... from ...;
select top 10 max(pl.nm), max(pl.val), max(pl.txt_val) from dm.labs pl join mas_data.patients p where pl.nm like '%ldl%' and val is not null p.id;
select top 10 pl.nm, pl.val, pl.txt_val, rank() over(partition by p.id order by p.id) as rank from dm.labs pl join mas_data.patients p where pl.nm like '%ldl%' and val is not null and rank = 1;
( select distinct top 10 id from dm.labs ) select tti.id, pl.nm, pl.val, pl.txt_val from toptenids tti dm.labs pl on pl.id = tti.id mas_data.patients p on pl.id = p.id where pl.nm like '%ldl%' and val is not null;
select distinct id from  (select id, row_number() over (order by  id) as rownum from table where fid = 64) t;
select id from  (select id, row_number() over (partition by  id order by  id) as rownum from table where fid = 64) t where t.rownum=1;
select *, row_number() over (order by id) as rownum from;
select distinct id from table where fid = 64 ) select *, row_number() over (order by id) as rownum from base;
select distinct id, row_number() over (partition by id order by id) as rownum from table where fid = 64;
select distinct id, description, row_number() over (partition by id, description order by id) as rownum from table where fid = 64;
select distinct id from table where fid = 64 ) select id, row_number() over (order by  id) as rownum from cte where fid = 64;
select  distinct id from    table where   fid = 64 ) select  id, row_number() over (order by  id) as rownum from    distinctvals;
select distinct id, dense_rank() over (order by  id) as rownum from @mytable where fid = 64;
select distinct id, dense_rank() over (order by  id) as rownum from table where fid = 64;
select id from table where fid = 64;
select distinct;
select distinct v, row_number() over (order by v) row_number from t;
select distinct v, dense_rank() over (order by v) row_number from t;
select distinct;
select v, row_number() over (window) row_number, rank()       over (window) rank, dense_rank() over (window) dense_rank from t;
select  distinct [col1,col2,col3,..] from    tablename where   [my condition] serialize as ( select row_number() over (partition by [colnameasneeded] order by  [colnameneeded]) as sr,* from    distinctrecords ) select * from serialize;
alter table <old_table> owner to <new_user>;
select field1, field2, field3 from <old_table>;
create table temp1 (like mytable);
drop table temp1;
drop table temp1;
create database targetdb with template sourcedb;
create database targetdb;
create or replace function send_data( varchar ) {autocommit=>0,raiseerror=>1,printerror=>1,pg_enable_utf8=>1,} if ( $error ) { $dbh-> rollback() } else {  $dbh-> commit() };
select send_data( 'insert into jm (jm) values (''zzzzzz'')' );
select dateadd( day, 1 - datepart( day, [date] ), [date] ), count(*) from [table] dateadd( day, 1 - datepart( day, [date] ), [date] );
select dateadd( day, 1 - datepart( day, [date] ),  convert( date, [date] ) ), count(*) from [table] dateadd( day, 1 - datepart( day, [date] ),  convert( date, [date] ) );
select itemid, userid, dateadd(month, datediff(month, 0, created),0) [month], ispaid, sum(amount) from live l where userid = 16178 and paymentdate > @start;
select convert(nvarchar(10), paymentdate, 120) [month], sum(amount) [totalamount] from payments;
select datepart(year, paymentdate) year, datepart(month, paymentdate) month, sum(amount) [totalamount] from payments;
alter table dbo.payments add paymentmonth as month(paymentdate) persisted;
select itemid, ispaid, (select sum(amount) from payments where year = 2010 and paymentmonth = 1 and userid = 100) as 'jan', (select sum(amount) from payments where year = 2010 and paymentmonth = 2 and userid = 100) as 'feb', .... and so on ..... from live l where userid = 16178;
select sum( case when datediff(m, paymentdate, @start) = 0 then amount else 0 end ) as "apr", sum( case when datediff(m, paymentdate, @start) = 1 then amount else 0 end ) as "may", sum( case when datediff(m, paymentdate, @start) = 2 then amount else 0 end ) as "june", sum( case when datediff(m, paymentdate, @start) = 3 then amount else 0 end ) as "july", sum( case when datediff(m, paymentdate, @start) = 4 then amount else 0 end ) as "aug", sum( case when datediff(m, paymentdate, @start) = 5 then amount else 0 end ) as "sep", sum( case when datediff(m, paymentdate, @start) = 6 then amount else 0 end ) as "oct", sum( case when datediff(m, paymentdate, @start) = 7 then amount else 0 end ) as "nov", sum( case when datediff(m, paymentdate, @start) = 8 then amount else 0 end ) as "dec", sum( case when datediff(m, paymentdate, @start) = 9 then amount else 0 end ) as "jan", sum( case when datediff(m, paymentdate, @start) = 10 then amount else 0 end ) as "feb", sum( case when datediff(m, paymentdate, @start) = 11 then amount else 0 end ) as "mar" from payments i join live l where year = 2010 and userid = 100;
select convert(nvarchar(7),paymentdate,120) [month], sum(amount) [totalamount] from payments;
alter table mytable add mytableid int not null identity (1,1) primary key;
alter table mytable add mytableid int not null identity (1,1), constraint pk_mytable primary key clustered (mytableid);
create table temptable ( id int not null identity(1, 1) primary key );
select idfaena,fechahora,demora, demora/60 as minutos,comentario from registrofaena where fecha>='2018-10-17' and comentario <> '';
select field1, field2, '' as newfield from table1;
select field1, field2, 'example' as tempfield from table1;
select field1, field2, 'example' as newfield from table1;
select field1, field2, 'example' as newfield from table1;
select field1, field2, newfield = 'example' from table1;
select getutcdate() select convert(datetime, getutcdate() at time zone 'utc' at time zone 'central european standard time') select convert(datetime, getutcdate() at time zone 'utc' at time zone 'india standard time');
datetime, switchoffset( convert( datetimeoffset, convert( datetime, [time_stamp_end_of_interval], 120 ) datename( tzoffset, convert( datetime, [time_stamp_end_of_interval], 120 ) ) ) as good_pst;
select switchoffset(cast('2008-12-19 17:30:09.0000000 +11:00' as datetimeoffset),'+00:00');
select convert(datetime, switchoffset(@mydate, datepart(tz,sysdatetimeoffset())));
select convert(datetime, cast('2008-12-19 17:30:09.0000000 +11:00' as datetimeoffset), 126) as utc;
select convert(datetime2, cast('2008-12-19 17:30:09.1234567 +11:00' as datetimeoffset(7)), 126) as utc;
set @createdon = '2008-12-19 17:30:09.1234567 +11:00' select convert(datetime2, @createdon, 1) select convert(datetimeoffset,convert(datetime2, @createdon, 1));
table size: 110gb index size: 7gb;
'database'    => sub { ...your database code... };
select count_big(*) from similarities where t1similarity = 0 or t2similarity = 0;
select count_big(*) from similarities where t1similarity = 0 or t2similarity = 0;
select city,length(city) from station group by city order by length(city) asc limit 1;
select city,length(city) from station group by city order by length(city) desc limit 1;
select top 1 cr, datalength(cr) from tbl;
length(city) as chr_len from   station city limit  1) union (select city, length(city) as chr_len from   station city limit  1);
select column, length(column) from table order by length(column) asc limit 1;
select city, length(city) from station order by length(city) desc limit 1;
select prefix, cr, length(cr) from table1 order by length(cr) desc limit 1;
select column from table where char_length(column) = (select max(char_length(column)) from table );
select max(char_length(column)) as max_length_string from table;
select col1 from table1 where length(col1) = (select max(length(col1)) from table1);
select cr from table1 where len(cr) = (select max(len(cr)) from table1);
select distinct cr from ...;
select top 1 cr from table t;
select top 1 cr from tbl;
where (from c in mysession.query(of cciudad)() from cs in mysession.query(of cciudadsucursal)() where cs.id_ciudad is c where cs.id_sucursal is s where c.id = idciudad where s.accion <> "e" andalso s.accion <> nothing where cs.accion <> "e" andalso cs.accion <> nothing select c.descripcion).single() is nothing where s.accion <> "e" andalso s.accion <> nothing select s.id, s.descripcion;
from s in context.shift where !context.employeeshift.any(es=>(es.shiftid==s.shiftid)&&(es.empid==57)) select s;
select * from shift where shift.shiftid not in (select employeeshift.shiftid from employeeshift where employeeshift.empid = 57);
select top 3 'hardcode' from tablewithlotsofrows;
select top 3 'test-b'+convert(varchar, row_number() over (order by primarykey)) from tablewithlotsofrows;
select 'test-a1' as name1, 'test-a2' as name2 union all select 'test-b1', 'test-b2' union all select 'test-c1', 'test-c2';
select 'test-a1' as name1, 'test-a2' as name2 from dual union all select 'test-b1', 'test-b2' from dual union all select 'test-c1', 'test-c2' from dual;
create table #tmpaaa (name1 varchar(10), name2 varchar(10)) values ('test_a', 'test_b'), ('test_c', 'test_d'), ('test_e', 'test_f'), ('test_g', 'test_h'), ('test_i', 'test_j');
select * from #tmpaaa;
select * from select 2007 as year union select 2008 as year union;
select dategenerator.datevalue from ( select dateadd(day, - (a.a + (10 * b.a) + (100 * c.a) + (1000 * d.a)), convert(date, getdate()) ) as datevalue from (select a.a from (values (0),(1),(2),(3),(4),(5),(6),(7),(8),(9)) as a(a)) as a where dategenerator.datevalue between 'mar 1 2009' and 'aug 1 2009';
select @mod_date_from as reqdate union all select dateadd(day,1,reqdate) from cte_dates where dateadd(day,1,reqdate) < @mod_date_to ) select * from cte_dates;
select dateadd(day, (thousands+hundreds+tens+units) , @startdatetime) d from ( select 0 thousands union all select 1000 union all select 2000 union all select 3000 union all select 4000 union all select 5000 union all select 6000 union all select 7000 union all select 8000 union all select 9000 select 0 hundreds union all select 100 union all select 200 union all select 300 union all select 400 union all select 500 union all select 600 union all select 700 union all select 800 union all select 900 select 0 tens union all select  10 union all select  20 union all select  30 union all select  40 union all select  50 union all select  60 union all select  70 union all select  80 union all select  90 select 0 units union all select   1 union all select   2 union all select   3 union all select   4 union all select   5 union all select   6 union all select   7 union all select   8 union all select   9 where dateadd(day, (thousands+hundreds+tens+units), @startdatetime)  <= @enddatetime;
select top 10000 identity(int,1,1) as number from sys.objects s1 alter table numbers add constraint pk_numbers primary key clustered (number);
select @start+number-1 from numbers where number<=datediff(day,@start,@end)+1;
select @start = 'mar 1 2009', @end = 'aug 1 2009' select @start+number-1 from numbers where number<=datediff(day,@start,@end)+1 select * from @alldates;
select date_add(@start, interval tmp_int day) as the_date from int_table;
set @dt = getdate() set @dtend = dateadd(day, 100, @dt) select dateadd(day, number, @dt) from (select number from master.dbo.spt_values where [type] = 'p' where dateadd(day, number, @dt) < @dtend;
select distinct number from master.dbo.spt_values where name is null;
where [type]='[magic code]';
select cast('2009-01-01' as datetime) 'date' union all select dateadd(dd, 1, t.date) from dates t where dateadd(dd, 1, t.date) <= '2009-02-01') select ... from table t join dates d on d.date = t.date --etc.;
select @start = 'mar 1 2009', @end = 'aug 1 2009';
nbrs_2( n ) as ( select 1 from nbrs_3 n1 cross join nbrs_3 n2 ), nbrs_1( n ) as ( select 1 from nbrs_2 n1 cross join nbrs_2 n2 ), nbrs_0( n ) as ( select 1 from nbrs_1 n1 cross join nbrs_1 n2 ), nbrs  ( n ) as ( select 1 from nbrs_0 n1 cross join nbrs_0 n2 ) select @start+n-1 as date from ( select row_number() over (order by n) from nbrs ) d ( n ) where n <= datediff(day,@start,@end)+1 ;
dataaccess = dataaccesskind.none, fillrowmethodname = "fnutlgetdaterangeintable_fillrow", isdeterministic = true, isprecise = true, systemdataaccess = systemdataaccesskind.none, tabledefinition = "d datetime")];
set @bd = getdate()-50 set @ed = getdate()+5 select dateadd(dd, 0, datediff(dd, 0, data)) --date format without time from ( select (getdate()- datediff(dd,@bd,getdate())) --filter on the begin date from [table_with_lot_of_rows] where data < (@ed + 1) --filter on the end date;
select top 100000 dateadd(d,incr,'2010-04-01') as dt from ( select a.object_id, a.column_id from  sys.all_columns a cross join sys.all_columns b;
create function dbo.generate_series ( @start bigint ) as begin if @step = 0 return if @start > @stop and @step > 0 return if @start < @stop and @step < 0 return set @stop = @stop - @step set @maxresults = case when @maxresults < 0 then 0 else @maxresults end ( --start at the beginning select @start union all --increment in steps select n + @step from mycte where (@maxresults=0 or i<@maxresults) and ( (@step > 0 and n <= @stop) or (@step < 0 and n >= @stop) ) ) select n from mycte end;
select cast(n as datetime) from dbo.generate_series(cast(@start as bigint), cast(@end as bigint), default, default) select cast(n/24.0 as datetime) from dbo.generate_series(cast(@start as float)*24, cast(@end as float)*24, 24, default) select cast(n/24.0 as datetime) from dbo.generate_series(cast(@start as float)*24, cast(@end as float)*24, default, default);
set @dt = getdate() set @dtend = dateadd(day, 1095, @dt) select dateadd(day, number, @dt) as date, datename(dw, dateadd(day, number, @dt)) as day_name into #generated_dates from (select distinct number from master.dbo.spt_values where name is null where dateadd(day, number, @dt) < @dtend select * from #generated_dates where day_name in ('saturday', 'friday') drop table #generated_dates;
select * from dbo.rangedate(getdate(), dateadd(d, 365, getdate()));
create function dbo.rangedate ( @date1 date = null ) as return ( select d = dateadd(d, a.n, case when @date1 <= @date2 then @date1 else @date2 end) from dbo.rangesmallint(0, abs(datediff(d, @date1, @date2))) a create function dbo.rangesmallint ( @num1 bigint = null ) as return ( with numbers(n) as ( select n from(values ) select top ( case when @num1 is not null and @num2 is not null then abs(@num1 - @num2) + 1 else 0 end ) from numbers a where abs(@num1 - @num2) + 1 < 65537;
select routine_type, routine_name, routine_definition from information_schema.routines where routine_schema='dbname';
select routine_definition from information_schema.routines where routine_schema = 'db_name' and routine_name = 'sp_name';
select routine_definition from information_schema.routines where routine_name = 'procedure_name' and routine_schema = 'databasename';
drop table #tmpguardian create table #tmpguardian( last_name nvarchar(30), frst_name nvarchar(30)) select last_name,frst_name from tbl_people;
create table #tmpguardian( last_name nvarchar(30), frst_name nvarchar(30)) select last_name,frst_name  from tbl_people;
drop table #tmpguardian;
last_name nvarchar(30), frst_name nvarchar(30) );
if object_id('tempdb..#mycooltemptable') is not null drop table #mycooltemptable end;
create procedure [dbo].[usptemptablesupersafeexample] as begin set nocount on;
if object_id('tempdb..#mycooltemptable') is not null drop table #mycooltemptable end  create table #mycooltemptable ( mycooltemptablekey int identity(1,1), myvalue varchar(128) ) select left(@@version, 128) union all select top 10 left(name, 128) from sysobjects select mycooltemptablekey, myvalue from #mycooltemptable if object_id('tempdb..#mycooltemptable') is not null drop table #mycooltemptable end  set nocount off;
select lft.id + 1 as missing_ids from tbl as lft left outer join tbl as rght on lft.id + 1 = rght.id where rght.id is null and lft.id between 1 and (select max(id)-1 from tbl);
drop procedure if exists proc_missing || create procedure proc_missing() set @minid = (select min(`id`) from `tbl_name` where `user_id`=13);
set @maxid = (select max(`id`) from `tbl_name` where `user_id`=13);
set @tableid = (select `id` from `tbl_name` where `id` = @minid);
if (@tableid is null) then end if;
set @minid = @minid + 1;
select sno as missing from(select @row := @row + 1 as sno from select 5 union all select 6 union all select 6 union all select 7 union all select 8 union all select 9) t,(select 0 union all select 1 union all select 3 union all select 4 union all select 5 union all select 6 union all select 6 union all select 7 union all select 8 union all select 9) t2,(select 0 union all select 1 union all select 3 union all select 4 union all select 5 union all select 6 union all select 6 union all select 7 union all select 8 union all select 9) t3, (select 0 union all select 1 union all select 3 union all select 4 union all select 5 union all select 6 union all select 6 union all select 7 union all select 8 union all select 9) t4, (select @row:=0) as b where @row<1000) as a where a.sno  not in (select @mn:=0,@mx:=0) as x order by no) as b) and;
select a.id+1 missing_id from tablename a where a.id+1 not in (select id from tablename b where b.id=a.id+1) and a.id!=(select id from tablename c order by id desc limit 1);
select distinct number from master..spt_values where number between 1 and (select max(id) from mytable) and number not in (select id from mytable);
set @test_id = 1 -- start compare with this id set @last_id = 100 -- end compare with this id select @id = (select <column> from <table> where <column> = @test_id) if @id is null end set @test_id = @test_id + 1 end;
set @id = 1 select @maxid = max(id) from tbl create temporary table idseq ( id int ) set @id = @id + 1 end  select s.id from idseq s where t.id is null drop table idseq;
set @id = 1 select @maxid = max(id) from tbl create table #idseq ( id int ) set @id = @id + 1 end  select s.id from #idseq s where t.id is null drop table #idseq;
as ( select 1 as missnum, (select max(id) from @tt) union all select missnum + 1, maxid from missing where missnum < maxid ) select missnum from missing where tt.id is null;
select level id           -- generate 1 .. 19 from dual select id                 -- everything that is currently in the from table                -- actual table;
select rownum idnumber from dual connect by rownum <= 1000000) select * from listids where idnumber not in (select id from table where id <=1000000);
select all_ids as missing_ids from generate_series((select min(id) from your_table), (select max(id) from your_table)) all_ids select id from your_table;
select 1 missnum, (select max(id) from :yourtable) maxid from dual union all select m.missnum + 1,m.maxid from missing m where m.missnum < m.maxid ) select missnum from missing where tt.id is null;
if  [[ "$line" != "$i" ]] ; then \ if [[ $i -lt 1 ]] ; then break; fi; \ if  [[ $line -gt 1 ]] ; then \ else \;
drop procedure if exists dorepeat;
create procedure dorepeat() set @id = 1;
set @maxid = 1573736;
drop table if exists idseq;
create temporary table idseq ( id int set @id = @id + 1;
select s.id from idseq s where t.id is null;
drop table if exists idseq;
select a.id+1 as start, min(b.id) - 1 as end from tablename as a, tablename as b where a.id < b.id having start < min(b.id);
select distinct id +1 from mytable where id + 1 not in (select distinct id from mytable);
select seqid as missingseqid from (select row_number() over (order by column_id) seqid from sys.columns) lkup where t.id is null and seqid < @maxid;
select distinct id -1 from users where id != 1 and id - 1 not in (select distinct id from users);
from tbltetmeeting as tmmin) as missnum, (select max(tmmax.tetmeetingid) from tbltetmeeting as tmmax) as maxid union all select missnum + 1, maxid from missing where missnum < maxid) select missnum as tetmeetingid, tt.dateid, tt.weekno, tt.tetid from missing left join tbltetmeeting tt on tt.tetmeetingid = missing.missnum where tt.tetmeetingid is null union select tt.tetmeetingid, tt.dateid, tt.weekno, tt.tetid from tbltetmeeting as tt;
select * from mytable m where exists ( select * from ( select "1234-567" group_id, 2 group_type union all select "4321-765", 3 union all select "1111-222", 5) [t] where m.group_id = t.group_id and m.group_type = t.group_type);
select '1234-567' as group_id, 2 as group_type union all select '4321-765', 3 union all select '1111-222', 5 ) select * /* todo - pick appropriate columns */ from mytable m where exists ( select * from tuples t where m.group_id = t.group_id and m.group_type = t.group_type);
select * from mytable where (group_id = '1234-567' and group_type = 2) or (group_id = '4321-765' and group_type = 3) or (group_id = '1111-222' and group_type = 5);
select * from mytable as t where exists (select * from (values ('1234-567', 2), ('4321-765', 3), ('1111-222', 5)) as v(group_id, group_type) where t.group_id = v.group_id and );
select * from mytable where (group_id, group_type) in ( values ('1234-567', 2), ('4321-765', 3), ('1111-222', 5);
select * from table_name where 1=1 and (column_a, column_b) in ((28,1),(25,1));
select t.* from mytable t and tuple.col.value('./@group-type', 'integer') = t.group_type;
select * from mytable m join ( select "1234-567" group_id, 2 group_type union all select "4321-765", 3 union all select "1111-222", 5 and m.group_type = t.group_type;
from person p where p.name="joe" union from person p join p.children c where c.name="joe";
from person p where p.id in (select p1.id from person p1 where p1.name="joe") or p.id in (select p2.id from person p2 join p2.children c where c.name="joe");
select p.* from person p where p.id in (select p1.id from person p1 where p1.name = "joe") or p.id in (select p2.id from person p2 join children c on p2.id = c.parent where c.name="joe") \g;
select i , j from a a  , (select i , j from b union select i , j from c) d where a.i = d.i;
select i , j from a a  join (select i , j from b union select i , j from c) d on a.i = d.i;
name  ="pixel_all", query = "" + );
select dbo.getbusinessdays(a.opendate,a.closedate) as businessdays from account a;
select * from dbo.udf_generate_inlist_to_table('1,2,3,4');
set @query = 'restore filelistonly from disk = ' + quotename(@backupfile , '''') create table #restoretemp ( logicalname nvarchar(128) ) set @errorstat = @@error if @errorstat <> 0 if @rueckgabe = 0 set @rueckgabe = 6 end print @rueckgabe;
drop table tbltable1 select * into tbltable1 from tbltable1_link;
val1 varchar(max) );
val1 varchar(max), val2 varchar(max) );
val1 varchar(max), val2 varchar(max) );
create table foo ( field1 as int create table copyoffoo ( field1 as int select * from foo;
select * from blah2;
select cola, colb, colc from blah2;
[databasename] nvarchar(128) not null, [fileid] [smallint] not null, [file_size_mb] int not null default (0), [space_used_mb] int null default (0), [free_space_mb] int null default (0), [logicalname] sysname not null, [drive] nchar(1) not null, [filename] nvarchar(260) not null, [file_type] nvarchar(260) not null, [the_autogrowth_in_kb] int not null default(0) ) select @sql ='select [databasename], [fileid], [file_size_mb], [space_used_mb], [free_space_mb], [logicalname], [drive], [filename], [file_type], [the_autogrowth_in_kb] exec sp_executesql @sql [databasename], [fileid], [file_size_mb], [space_used_mb], [free_space_mb], [logicalname], [drive], [filename], [file_type], the_autogrowth_in_kb, [filegroup], maxsize ) exec sp_executesql @sql;
select count(*) from tableb";
select count(*) from tablea select count(*) from tableb select count(*) from tablec");
create table if not exists `albums` (`id` integer not null auto_increment , `album_belongsl_artist` integer, `artist_hasmany_albums` integer, primary key (`id`));
create table if not exists `albums` (`id` integer not null auto_increment , `artist_id` integer, primary key (`id`)) engine=innodb;
create  or replace function f2(istr  varchar);
create function f2(istr varchar) end $func$ language plpgsql;
select * from author au join ( select max(id) as max_id, author_id from book bk join bk;
from book bk select * from author au join last_book lb join bk;
select book_id, author_id, author_name, last_book from ( select b.id as book_id from author a join book b where rn = 1;
select distinct on (author.id) from author book on book.author_id = author.id;
select * from ( select distinct on (author.id) from author book on book.author_id = author.id;
select book.id, author.id, author.name, book.title as last_book from book ( select author.id as author_id, max(book.id) as book_id from author book on author.id = book.author_id author on book.author_id = author.id;
select bk.id, au.id, au.name, bk.title as last_book from author au join book bk on bk.author_id = au.id where not exists ( select * from book nx where nx.author_id = bk.author_id and nx.book_id > bk.book_id );
select mr.id as room_id, mr.created_at as room_created, lastmess.content as lastmessage_content, lastmess.datetime as lastmessage_when from message.room mr select content, datetime from message.list where room_id = mr.id limit 1) lastmess on true;
select book.id, author.id, author.name, book.title as last_book from author auth1 join book book on (book.author_id = auth1.id and book.id = (select max(b.id) from book b where b.author_id = auth1));
create temp table book_1 as ( select id from book)  distributed by ( id );
select author.id,b.id, author.id, author.name, b.title as last_book from author;
if (mysql_errno()) if ($row[2] != "primary") if (preg_match("/^varchar\((\d+)\)$/i", $type, $mat)) else if (!strcasecmp($type, "char")) else if (!strcasecmp($type, "tinytext")) else if (!strcasecmp($type, "mediumtext")) else if (!strcasecmp($type, "longtext")) else if (!strcasecmp($type, "text")) if ($set) if ($index["unique"]) else {;
set foreign_key_checks = 0;
set foreign_key_checks = 1;
select concat('alter table `', t.`table_schema`, '`.`', t.`table_name`, '` convert to character set utf8 collate utf8_general_ci;') as stmt from `information_schema`.`tables` t where 1 and t.`table_schema` = 'database_name';
select table_name from information_schema.tables;
'social_message', 'social_facebook', 'social_facebook_message', 'social_facebook_page', 'social_google', 'social_google_mesage', 'social_twitter', 'social_twitter_message', );
if ( isset($index['column_name']) && $index['column_name'] == $result['field']){ if ( preg_match( "/^varchar\((\d+)\)$/i", $result['type'], $mat ) ) { if ( !$is_there_an_index["non_unique"] ) {;
if ($(this).html() != 'utf8_general_ci') { if (i == lastid) {;
if (mysqli_errno($conn)) { "varchar" => "varbinary", "char" => "binary(1)", "tinytext" => "tinyblob", "mediumtext" => "mediumblob", "longtext" => "longblob", "text" => "blob" if (preg_match("/^varchar\((\d+)\)$/i", $type, $mat)) else if (!strcasecmp($type, "char")) else if (array_key_exists(strtoupper($type), $mysql_type_to_binary_type_map)) if ($row[2] != "primary") { if ($index["name"] == $row[2]) { if ($binary_typename != "") { if ($index["unique"]) else $query = "create index `{$index["name"]}` on `{$tab}` ({$joined_col_str})";
update client set medicalgroupid = null;
"dbo.decisionaccesses", c => new name = c.string(nullable: false, maxlength: 50), }) "dbo.decisionpersonstatus", c => new name = c.string(nullable: false, maxlength: 50), });
select * from `titles` where title like 'test\\' escape '|';
select * from `table` where `field` like '%\\\%';
select replace(column_name, "\\'", "'") from table where column_name  like "%\\\%";
update  messages set status=10 where id in (select top (10) id from table where status=0;
( select  top 10 * from    messages where   status = 0 priority desc ) update  q set     status = 10;
set rowcount 10 update messages set status = 10 where status = 0 set rowcount 0;
select top 10 id from messages where status = 0 update messages set status = 10 where id in (select id from @t);
update messages set where id in (select top (10) id from table where status=0 order by priority desc);
update m set [status]=10 from ( select top (10) * from messages where [status]=0;
select      getdate(), 'today' union all select      dateadd(day,  10, getdate()), '10 days later' union all select      dateadd(day, 10, getdate()), '10 days earlier' union all select      dateadd(month,  1, getdate()), 'next month' union all select      dateadd(month, 1, getdate()), 'previous month' union all select      dateadd(year,  1, getdate()), 'next year' union all select      dateadd(year, 1, getdate()), 'previous year';
select dateadd(day,-30,date) as before30d;
select dateadd(dd, -30, cast(substring ('fri, 14 nov 2014 23:03:35 gmt', 6, 21) as datetime));
select ~preventedit from sourcetable select 1 ^ preventedit from sourcetable;
select 1 - preventedit from sourcetable;
select ~@bitvalue, ~@intvalue select 1 ^ @bitvalue, 1 ^ @intvalue select 1 - @bitvalue, 1 - @intvalue select @bitvalue = 0, @intvalue = 0 select ~@bitvalue, ~@intvalue select 1 ^ @bitvalue, 1 ^ @intvalue select 1 - @bitvalue, 1 - @intvalue;
select  * from    gifts g sentgifts sg;
select  * from    gifts g sentgifts sg select  * from    gifts g sentgifts sg where   sg.giftid is null;
select * from table1 t1 where t1.name = 'john';
select * from table1 t1 and t1.name = 'john';
select top 50 * from(select coalesce(object_name(s2.objectid),'ad-hoc') as procname, execution_count,s2.objectid, (select top 1 substring(s2.text,statement_start_offset / 2+1 , ( (case when statement_end_offset = -1 then (len(convert(nvarchar(max),s2.text)) * 2) else statement_end_offset end)- statement_start_offset) / 2+1)) as sql_statement, substring( s3.query_plan,charindex('<parameterlist>',s3.query_plan), charindex('</parameterlist>',s3.query_plan) + len('</parameterlist>') - charindex('<parameterlist>',s3.query_plan) last_execution_time from sys.dm_exec_query_stats as s1 s1.statement_end_offset) as s3 where sql_statement not like 'select top 50 * from(select %';
select deqs.last_execution_time as [time], dest.text as [query] from sys.dm_exec_query_stats as deqs;
select top 50 * from(select coalesce(object_name(s2.objectid),'ad-hoc') as procname, execution_count,s2.objectid, (select top 1 substring(s2.text,statement_start_offset / 2+1 , ( (case when statement_end_offset = -1 then (len(convert(nvarchar(max),s2.text)) * 2) else statement_end_offset end)- statement_start_offset) / 2+1)) as sql_statement, last_execution_time from sys.dm_exec_query_stats as s1 where sql_statement not like 'select top 50 * from(select %';
select decode('deadbeef', 'hex');
select * from mytable where testcol = (decode('013d7d16d7ad4fefb61bd95b765c8ceb', 'hex'));
select * from my_table where myhexfield =;
create table mytable (testcol bytea);
mytable (testcol) values (decode('013d7d16d7ad4fefb61bd95b765c8ceb', 'hex'));
end try select @errormessage = error_message(), @errorseverity = error_severity(), @errorstate = error_state();
end try select @errormessage  = error_message(), @errorseverity = error_severity(), @errorstate    = error_state();
set sql_mode='pipes_as_concat';
set sql_mode='pipes_as_concat';
select * from tableone;
select * from tableone;
select ..., concat( 'category_id=', tableone.category_id) as query2  from tableone;
set unique_checks=0;
set foreign_key_checks=0;
select * from sampletable where sampledata like '\[%' escape '\';
select * from mytest where mycol like '%[^a-za-z0-9]%';
select * from mytest where mycol like '%[^a-za-z0-9\[\]]%' escape '\';
select p.*, if(count(ms.propertyid) > 0,1,0) as contacted, pm.mediaid, date_format(p.availablefrom, '%d %b %y') as 'availablefrom', astext(pg.geometry) as geometry from (property p, propertygeometry pg) join shortlist sl on sl.propertyid = p.id and sl.memberid = 384216 where p.paused = 0 and p.propertygeometryid = pg.id;
select cust_id, name, sum(paid), c.custtypeid from customer c, custtype ct;
select custtype.id, custtype.code;
from property p, ( propertygeometry pg join shortlist sl on sl.propertyid = p.id and sl.memberid = 384216 );
select p.*, if(count(ms.propertyid) > 0,1,0) as contacted, pm.mediaid, date_format(p.availablefrom, '%d %b %y') as 'availablefrom', astext(pg.geometry) as geometry from property p join propertygeometry pg on p.propertygeometryid = pg.id join shortlist sl on sl.propertyid = p.id and sl.memberid = 384216 where p.paused = 0;
select t1.date1, t1.date2, t1.date3 from t1 where id='x';
select v_date1 = t1.date1, v_date2 = t1.date2, v_date3 = t1.date3 from t1 where id='x';
if (selection != null && selection.timeout != rowselection.novalue);
null, false, sessionimp.enabledfilters, sessionimp.factory);
sessionimp.factory);
sessionimp.enabledfilters, sessionimp.factory);
alter schema newschema transfer oldschema.object;
set @oldschema = 'dbo' set @newschema = 'stackoverflow' set @sql = 'create schema [' + @newschema + ']' + @newline select @sql = @sql + 'go' + @newline select @sql = @sql + 'alter schema [' + @newschema + '] transfer [' + table_schema + '].[' + table_name + ']' from information_schema.tables where table_schema = @oldschema set @sql = @sql + 'drop schema [' + @oldschema + ']' if (0=1) exec (@sql);
set @oldschema = 'computerlearn' set @newschema = 'basic' set @sql = 'create schema [' + @newschema + ']' + char(13) + char(10) select @sql = @sql + 'alter schema [' + @newschema + '] transfer [' + sys.schemas.name + '].[' + sys.procedures.name + ']' from sys.procedures,sys.schemas where sys.procedures.schema_id=sys.schemas.schema_id and sys.schemas.name = @oldschema set @sql = @sql + 'drop schema [' + @oldschema + ']' if (0=1) exec (@sql);
set @oldschema = 'dbo' set @newschema = 'stackoverflow' select table_schema, table_name from information_schema.tables where table_schema = @oldschema select @sql = 'alter schema [' + @newschema + '] transfer [' + @oldschema + '].[' + @obj + ']' end  select sys.schemas.name, sys.procedures.name from sys.procedures,sys.schemas where sys.procedures.schema_id=sys.schemas.schema_id and sys.schemas.name = @oldschema select @sql = 'alter schema [' + @newschema + '] transfer [' + @schema + '].[' + @obj + ']' end ;
if object_id ( 'dbo.renameschema', 'p' ) is not null drop procedure dbo.renameschema;
create procedure dbo.renameschema @newname  varchar(500) as /*check for oldschema exist or not */ if not exists (select 1 from sys.schemas where name =  @oldname) end  if not exists (select 1 from sys.schemas where name = @newname) end  select ' alter schema ' + @newname + ' transfer '+ schema_name(schema_id)+'.'+ name as altsql from sys.objects where type in ('u','v','p','fn') and exec (@sql) if @oldname <> 'dbo' and  @oldname <> 'guest' end go;
create schema stg;
alter schema stg transfer dbo.populationbycountrystg;
alter schema stg transfer dbo.countryregionstg;
set @oldschema = 'old' set @newschema = 'dbo' select @table = name from sys.tables where object_id in(select min(object_id) from sys.tables where  schema_name(schema_id)  = @oldschema) set @sql = 'alter schema [' + @newschema + '] transfer [' + @oldschema + '].[' + @table + ']' end;
alter table example add newcol varchar(200) after othercol;
alter table mytable add mynewcolumn varchar(255) after myothercolumn;
alter table name alter column position new_position;
select d1.short_code from domain1 d1 where d2.short_code is null;
select  d1.short_code from    domain1 d1 domain2 d2 where   d2.short_code is null;
select  short_code from    domain1 select  short_code from    domain2;
select d1.shortcode from domain1 d1 where not exists from domain2 d2 where d2.shortcode = d1.shortcode );
create table #test ( id int) ;
select id from #test where id = 1002 and row_number() over(order by id) = 1;
if ( id = 1002 ) is first, then if ( row_number() over(order by id) = 1 );
if ( row_number() over(order by id) = 1 ), then check if ( id = 1002 );
select id from #test where id = 1002;
where   having  distinct   limit;
select id, sales_person_id, product_type, product_id, sale_amount from ( select id, sales_person_id, product_type, product_id, sale_amount, row_number() over(partition by sales_person_id, product_type, product_id order by sale_amount desc) rn from sales_log where rn = 1;
select row, id, sales_person_id, product_type, product_id, sale_amount from ( select row_number() over(partition by sales_person_id, product_type, product_id order by sale_amount desc) as row, id, sales_person_id, product_type, product_id, sale_amount from sales_log where row = 1;
( select p.personname from @person p join @orders o on p.personid = o.personid ) select * from a where rnk >= 2 -- only orders after the first one.;
select * from   sales_log sl where  sl.id = ( select top 1 id from   sales_log sl2 where  sales_person_id = sl.sales_person_id and product_type = sl.product_type and product_id = sl.product_id );
create table t1 ( col1 char(1) primary key );
select col1 from t1 where row_number() over (order by col1) <= 3 and col1 > 'b';
select distinct top list from  join on / apply / pivot / unpivot where group by  with cube / with rollup having order by offset-fetch;
select (vg.id, name) from v_groups vg where p2vg.people_id =0;
select (vg.id, name) from v_groups vg where p2vg.people_id = 0;
select vg.id, vg.name from v_groups vg inner join where p2vg.people_id = 0;
select (1+1) as result from dual;
select (1+1) result from dual;
select 'hi' from dual d;
select (1+1) as "result" from dual;
select (1+1) "result" from dual;
select 'hi' from dual "d";
select {t / t} from (select 1 as t from dual); -- correct select "test" from (select 1 as "test" from dual); -- correct select {"test" / test} from (select 1 as "test" from dual ); -- incorrect select test_value as "doggy" from test order by "doggy"; --correct select test_value as "doggy" from test where "doggy" is not null; --you can not do this, column alias not supported in where & having select * from test "doggy" where "doggy".test_value is not null; -- do not use as preceding table alias;
select employee_id,department_id as "department id" from employees;
select employee_id,department_id as department from employees;
select employee_id,department_id as "department" from employees;
alter table book add bookid integer not null identity;
alter table book add constraint pk_book primary key (bookid);
update - updates existing data within a table delete - deletes records from a table, the space for the records remain;
select `user_metrics`.* from `user_metrics` force index (index_user_metrics_on_user_id) where (`user_metrics`.user_id in (n,n,n,n,n,n,n,n,n,n,n,n));
select * from tests where (test in ('test 1', 'test 2', 'test 3', 'test 4', 'test 5', 'test 6', 'test 7', 'test 8', 'test 9'));
select `user_metrics`.* from `user_metrics` um join (select `user_metrics`.`user_id` in (n, n, n, n) ) as temp;
select `jxm_character`.* from jxm_character where information_date in (select distinct from jxm_character where information_date >= date_sub('2016-12-2', interval 7 day)) and `jxm_character`.`ranking_type` = 1 and `jxm_character`.`character_id` = 3146089;
select * from jxm_character jc join (select distinct from jxm_character where information_date >= date_sub('2016-12-2', interval 7 day)) as temp and jc.ranking_type = 1 and jc.character_id = 3146089;
create function fullmonthsseparation ( @datea datetime, @dateb datetime ) as begin set @datex = @datea set @datey = @dateb end else begin set @datex = @dateb set @datey = @datea end  set @result = ( select case when datepart(day, @datex) > datepart(day, @datey) then datediff(month, @datex, @datey) - 1 else datediff(month, @datex, @datey) end ) end go select dbo.fullmonthsseparation('2009-04-16', '2009-05-15') as monthsep -- =0 select dbo.fullmonthsseparation('2009-04-16', '2009-05-16') as monthsep -- =1 select dbo.fullmonthsseparation('2009-04-16', '2009-06-16') as monthsep -- =2;
set @start = '11/1/07' set @end = '2/29/08' select datediff(month, @start, @end + 1);
select datediff(day, '2009-04-16', '2009-05-15')/30;
select 12 * (year(end_date) - year(start_date)) +;
to_date ('2009/04/16', 'yyyy/mm/dd'));
to_date ('2009/04/16', 'yyyy/mm/dd')));
select case when datepart(d,end_date) >=datepart(d,star_date) then ( case when datepart(m,end_date) = datepart(m,star_date) and datepart(yyyy,end_date) = datepart(yyyy,star_date) then 0 else datediff(m,star_date,end_date)end ) else datediff(m,star_date,end_date)-1 end;
select 1 as n, dateadd(day, -1, dateadd(month, 1, @startdate)) as month_hence then 1 else 0 end  as [isfull] union all select n+1, --dateadd(month, 1, month_hence) as month_hence -- no, causes propagation of short month discounted days then 1 else 0 end  as [isfull] from months_since where month_hence<( @lastduedate --where period= 1 ) select coalesce((select max(n) from months_since where isfull = 1),1) as full_months_over_all_terms, (select max(n) from months_since ) as months_over_all_terms, coalesce((select [remainingdays] from months_since where isfull = 0),0) as days_in_incomplete_month;
set @time1 = '12/14/2015' set @time2 = '12/15/2016';
select linear_yearmonths = (centuries.century + decades.decade + years.[year] + months.[month]), 1 as value from (select '18' [century] union all select '19' union all select '20') centuries select '1' union all select '2' union all select '3' union all select '4' union all select '5' union all select '6' union all select '7' union all select '8' union all select '9') decades select '2' union all select '3' union all select '4' union all select '5' union all select '6' union all select '7' union all select '8' union all select '9' union all select '0') years select '-02' union all select '-03' union all select '-04' union all select '-05' union all select '-06' union all select '-07' union all select '-08' union all select '-09' union all select '-10' union all select '-11' union all select '-12') [months];
select time1 = @time1, [yyyy-mm of time1] = case then (cast(year(@time1) as varchar) + '-' + '0' + cast(month(@time1) as varchar)) else (cast(year(@time1) as varchar) + '-' + cast(month(@time1) as varchar)) time2 = @time2, [yyyy-mm of time2] = case then (cast(year(@time2) as varchar) + '-' + '0' + cast(month(@time2) as varchar)) else (cast(year(@time2) as varchar) + '-' + cast(month(@time2) as varchar)) end into #datepoints;
select d.*, months_between = (select (sum(l.value) - 1) from #linear_months l where l.[linear_yearmonths] between d.[yyyy-mm of time1] and d.[yyyy-mm of time2]) from #datepoints d;
select d.*, months_between = (select (sum(l.value) - 1) from az_vbp.[my].[edg_linear_yearmonths] l where l.[linear_yearmonths] between d.[yyyy-mm of time1] and d.[yyyy-mm of time2]) then -1 else 0 from #datepoints d;
select cast(datediff(month, startdate, enddate) as float) -;
select @first as [first], @last as [last], datediff(month, @first, @last) as [datediff thinks], case when dateadd(month, datediff(month, @first, @last) +1, @first) <= @last then datediff(month, @first, @last) +1 end as [actual months apart];
select  (  case  else 0 end  ) as numberofmonths;
select @monthdiff - case when format(@startdate,'dd') > format(@enddate,'dd') then 1 else 0 end;
select name, (select case when then datediff(month, '2016-08-28',  '2016-09-29') - 1 else datediff(month, '2016-08-28',  '2016-09-29') end) as numberofmonths from tableexample;
create function getdurationinmonthanddays(@first_date datetime,@second_date datetime) as  select 1,'jan',31 union select 2,'feb',28 union select 3,'mar',31 union select 4,'apr',30 union select 5,'may',31 union select 6,'jun',30 union select 7,'jul',31 union select 8,'aug',31 union select 9,'sep',30 union select 10,'oct',31 union select 11,'nov',30 union select 12,'jan',31 select @first_year=year(@first_date) select @second_year=year(@second_date)+1 select @first_month=month(@first_date) select @second_month=month(@second_date) select @days=29-day(@first_date) end  else  select @days=28-day(@first_date) end  end  else  select @days=(select month_days from @months where month_id=@first_month)-day(@first_date) end  select @first_month=@first_month+1 set @first_month=1 end  select @days=@days+day(@second_date) end  else  select @month=@month+1 end  end  else  select @month=@month+1 end  set @first_month=@first_month+1 end  set @first_year  = @first_year  + 1 end  select @month=@month+(@days/30) select @days=@days%30 select @result=cast(@month as varchar)+' month '+cast(@days as varchar)+' days ' end  else  select @result=cast(@month as varchar)+' month ' end  end  else  select @result='error' end  end;
select dateadd(dd,number,dateadd(yy, datediff(yy,0,getdate()), 0)) as gun from master..spt_values where type = 'p' and year(dateadd(dd,number,dateadd(yy, datediff(yy,0,getdate()), 0)))=year(dateadd(yy, datediff(yy,0,getdate()), 0));
create function uffullmonthdif (@dstart date, @dend date) as begin @dend2 date set @dif = datediff(month, @dstart, @dend) set @dend2 = dateadd (month, @dif, @dstart) if @dend2 > @dend set @dif = @dif - 1 end go select dbo.uffullmonthdif ('2009-04-30', '2009-05-01') select dbo.uffullmonthdif ('2009-04-30', '2009-05-29') select dbo.uffullmonthdif ('2009-04-30', '2009-05-30') select dbo.uffullmonthdif ('2009-04-16', '2009-05-15') select dbo.uffullmonthdif ('2009-04-16', '2009-05-16') select dbo.uffullmonthdif ('2009-04-16', '2009-06-16') select dbo.uffullmonthdif ('2019-01-31', '2019-02-28');
create table [dbo].[user]( [id] [bigint] not null, [name] [varchar](20) not null;
create table [user] ... select * from [user];
select t1."reference" from mytable t1;
values ('2012/03/17', 'aa'), ('2012/03/17', 'bb'), ('2012/03/17', 'cc'), ('2012/03/17', 'dd');
select r.name, group_concat(a.name separator ',') from resources r join applicationsresources ar on ar.resource_id = r.id join applications a on a.id = ar.app_id;
select r.name, stuff((select ','+ a.name from applications a join applicationresources ar on ar.app_id = a.id where ar.resource_id = r.id from resources r;
select r.name, listagg(a.name separator ',') within group (order by a.name) from resources r join applicationsresources ar on ar.resource_id = r.id join applications a on a.id = ar.app_id;
select @employeelist = coalesce(@employeelist + ', ', '') + from salescallsemployees where salcal_uniqueid = 1 select @employeelist;
select r.id, r.name, resources = stuff( (select ','+a.name from dbo.applications a where ar.resource_id = r.id from dbo.resources r;
select r.name, group_concat(a.name separator ',') from resources r join applicationsresources ar on ar.resource_id = r.id join applications a on a.id = ar.app_id;
select r.name, stuff((select ','+ a.name from applications a join applicationresources ar on ar.app_id = a.id where ar.resource_id = r.id from resources r;
select r.name, string_agg(a.name, ',') from resources r join applicationsresources ar on ar.resource_id = r.id join applications a on a.id = ar.app_id;
select a.name as a_name, r.name as r_name from applicationsresource ar, applications a, resources r where a.id = ar.app_id and r.id = ar.resource_id;
select r.name as resname, a.name as appname from resouces as r, applications as a, applicationsresources as ar where ar.app_id = a.id and ar.resource_id = r.id;
create function dbo.ufngetemployeemultiple(@departmentid int) select @employeelist = coalesce(@employeelist + ', ', '') + e.loginid from humanresources.employee e where h.departmentid = @departmentid end  select d.name as department, dbo.ufngetemployeemultiple (d.departmentid)as employees from humanresources.department d select distinct (d.name) as department, dbo.ufngetemployeemultiple (d.departmentid) as from humanresources.department d;
select @liststr = coalesce(@liststr+',' ,'') + convert(nvarchar(8),departmentid) from table select @liststr;
select itemname, group_concat(departmentid) from table_name group by itemname;
create table [dbo].[item_dept]( [itemname] char(20) null, [departmentid] int null );
select itemname, stuff((select ',' + rtrim(convert(char(10),departmentid)) from   item_dept b where  a.itemname = b.itemname from   item_dept a;
select r.name, string_agg(a.name, ',') from   resources r join applicationsresources ar join applications a;
select count(*) from ( select distinct component from `multiple_sample_assay_abc` where labref = 'ndqa201303001';
select count(distinct component) as totalrows from xyz where labref = 'ndqa201303001';
if ($result = $mysqli->query("select distinct component, count( component ) from `xyz` where labref = 'ndqa201303001';
select component, count(*) over() as number_of_components from `xyz` where labref = 'ndqa201303001';
array('unsigned' => true, 'primary' => true));
$installer->gettable('modulekey/model'), 'column_name', array( 'type'      => varien_db_ddl_table::type_integer, 'length'    => null, 'unsigned'  => true, 'nullable'  => true, 'comment'   => 'foreign key' ) $installer->getfkname( 'modulekey/model',  'column_name', 'modulekey/foreign_model',  'foreign_column_name' $installer->gettable('modulekey/model'), 'column_name', $installer->gettable('modulekey/foreign_model'), 'foreign_column_name', varien_db_ddl_table::action_set_null, varien_db_ddl_table::action_set_null;
select * from parameters where name like '%\n%';
select * from parameters where name like '%'+char(13)+'%' or name like '%'+char(10)+'%';
select * from parameters where name like '%' || char(13) || '%' or name like '%' || char(10) || '%';
select * from parameters where name regexp '\n';
where charindex(char(13), name) <> 0 or charindex(char(10), name) <> 0;
or charindex(char(9), name) <> 0;
select translate(string_with_nl_cr, char(10) || char(13), '  ') from dual;
select replace(replace(name,char(10),''),char(13),'');
create function dbo.[check_existance_of_carriage_return_line_feed] ( @string varchar(max) ) n2 (n) as (select 1 from n1 as x, n1 as y), n3 (n) as (select 1 from n2 as x, n2 as y), n4 (n) as (select row_number() over(order by x.n) from n3 as x, n3 as y) select @return_boolean =count(*) from n4 nums where nums.n<=len(@string) and ascii(substring(@string,nums.n,1)) in (13,10) end go;
select column_name, dbo.[check_existance_of_carriage_return_line_feed] (column_name) as [boolean] from [table_name];
) select column_name from information_schema.columns where  table_schema = @schema and table_name =  @tablename and data_type like '%char%' select column_name from information_schema.columns where table_schema = @schema and table_name =  @tablename and data_type like '%char%' select @cmd = 'select ''' +@colname+    ''',  charindex(char(10),  '+  @colname +') , '+ @colname + ' from '+@schema + '.'+@tablename +' where charindex(char(10),  '+  @colname +' ) > 0 or charindex(char(13), '+@colname +') > 0' exec sp_executesql @cmd end close looper select * from  @newline;
alter table a add constraint fk_b foreign key (b_id) references b(id);
alter table <table_name> add <constraint_name> foreign key <column_name2> ) <column_name2>);
create table master ( masterid int identity(1,1) primary key, stuff varchar(10) ) create table detail ( detailid int identity(1,1) primary key, masterid int references master, --use 'references';
select count(*) into cnt from people where person_id = my_person_id;
if cnt > 0 then end if;
if <b>exists</b> (select 1 from people p where p.person_id = my_person_id) then end if;
if exists (<b>select from</b> people p where p.person_id = my_person_id) then ...;
select * from table order by random() limit x;
select * from table order by random() limit 1;
select * from table where id in (select id from table order by random() limit x);
select * from table where abs(cast(random() as real))/9223372036854775808 < 0.5;
select * from table limit 1 offset abs(random() % (select count(*) from table));
select  c.name as colname, t.name as tablename from sys.columns c join sys.tables t on c.object_id = t.object_id where c.name like '%batchno%';
select      t.table_name, c.column_name from        information_schema.columns c where       table_type = 'base table' and column_name = 'colname';
select owner, table_name from all_tab_columns where column_name = 'colname';
select t.name as table_name, schema_name(schema_id) as schema_name, c.name as column_name,* from sys.tables as t where c.name like '%your_column%';
select table_name from information_schema.columns where column_name = 'mycolumn';
select distinct table_schema, table_name from information_schema.columns where column_name = 'id';
select * from information_schema.columns where column_name = 'colname';
select * from table1 where and emppu not like '%ece%' and emppu not like '%eee%';
select * from table1 where emppu not like '%cse%' and emppu not like '%ece%' and emppu not like '%eee%';
select * from table1 where emppu not like '%cse%' and emppu not like '%ece%' and emppu not like '%eee%';
as ( select '%cse%' as match union all select '%ece%' as match union all select '%eee%' as match ) select * from table1 mydata where mydata.match is null;
as ( select '%cse%' as match union all select '%ece%' as match union all select '%eee%' as match ) select * from table1 where not exists (select * from mydata where table1.emppu like match);
select * from table1 where not exists ( select null from ( select '%cse%' as column1 union all select '%ece%' union all select '%eee%' where table1.emppu like tbl.column1 );
select * from table1 where emppu not in ('%cse%', '%ece%', '%eee%');
select * from table1 where emppu not like '%cse%' and  emppu not like '%ece%' and emppu not like '%eee%';
select * from table1 where or emppu not like '%ece%' or emppu not like '%eee%');
select * from table1 select * from table1 where emppu like '%cse%' or emppu like '%ece%' or emppu like '%eee%';
select * from table1 where emppu not regexp 'cse|ece|eee';
select * from table1 where emppu regexp 'cse|ece|eee';
select u.id,opd.orderdate from orderspaid opd where 1=1 and opd.orderdate between dateadd(m,-6,getdate()) and dateadd(m,-3,getdate()) select u.id,opd.orderdate from orderspaid opd where 1=1 and opd.orderdate between dateadd(m,-3,getdate()) and getdate();
select distinct a.userid from @6to3monthsusers a where b.userid is null;
select distinct a.userid from @6to3monthsusers a where a.userid not in (select b.userid from @last3monthsusers b);
( test ) select 1 union all select 2 ( test ) select 1 union all select 3 select  a.* from    @table1 a where   b.test is null -- this then excludes that which exist in both a and b;
select l.* from @testleft l @testright r on where r.id is null;
select column1 from tablea a where not exists ( select column1 from tableb b where a.column1 = b.column1 );
select f.* from first_table f left join second_table s on f.key=s.key where s.key is null;
select a.id, a.other_column, ..., (select count(*) from b where b.a_id = a.id) as b_count from a;
select a.*, (select count(*) from b where b.a_id = a.id) as tot from a;
select a.id, a.xxx, count(*) from a join b on (b.a_id = a.id);
select a.id, qty.quantity from a (select count(b.a_id) as quantity, b.a_id from b group by b.a_id) as qty;
select a.id, count(b.a_id) as quantity from a;
select a.*, count(b.id) as b_count from a where a.id > 50 and b.id < 100 -- example of filtering joined tables, optional having count(b.id) > 10 -- example of filtering calculated column, optional;
... cte2 as ( ... cte3 as ( ... ) select ... from 'cte3' where ...;
union all select ...)  -- recursive term select ... from cte3 where ...;
select * from tablea where startdate >= to_timestamp('12-01-2012 21:24:00', 'dd-mm-yyyy hh24:mi:ss') and startdate <= to_timestamp('12-01-2012 21:25:33', 'dd-mm-yyyy hh24:mi:ss');
update  abbonamento set     punti = if(tipo = 'punti', punti - 1, punti), bonus = if(tipo <> 'punti', bonus - 1, bonus) where   id = 17;
update  abbonamento set     punti = case when tipo = 'punti' then punti - 1 else punti end, bonus = case when tipo <> 'punti' then bonus - 1 else bonus end where   id = 17;
delete from wp_posts where post_date < date_sub(now(), interval '1' hour) and post_status = 'publish';
select now() - interval 1 hour;
delete from wp_posts where post_date < now() - interval 1 hour and post_status = 'publish';
select subdate(current_timestamp, interval 1 hour);
select isnull(a, b);
set @iamnotnull = 'not null' select isnull(@iamnull, @iamnotnull) select coalesce(@iamnull, @iamnullalso, @iamnotnull);
select coalesce ( programid , interimprogramid ) as 'programid';
select programid from a_table where programid is not null union select interimprogramid as programid from a_table where programid is null;
select ifnull(programid,interimid) as programid;
select nvl(column_a, column_b) from 'schema'.'table_name';
set @excludedlist = '3' + ', ' + '4' + ' ,' + '22' select * from a where id not in (@excludedlist);
select * from a where id not in ('3', '4', '22');
select * from a where id not in (3, 4, 22);
create procedure myproc @excludedlist integer_list_tbltype readonly as select * from a where id not in (@excludedlist);
exec myproc @excludedlist;
set @excludedlist = 3 + ',' + 4 + ',' + '22' set @sql = 'select * from a where id not in (@excludedlist) ' exec sp_executesql @sql '@excludedlist varchar(max)' @excludedlist end;
set @excludedlist = '3,4,22,6014' set @sql='select * from [a] where id not in ('+@excludedlist+')' exec sp_executesql @sql;
set @idquery = 'select id from sometable where condition=something' select * from a where id not in (@excludedlist);
create function dbo.udf_splitvariable ( @list varchar(8000), @spliton varchar(5) = ',' ) ( id int identity(1,1), value varchar(8000) ) as begin set @list = (replace(@list, '''', '')) if ltrim(rtrim(@list)) = 'emptynull' set @list = '' end  select value = ltrim(rtrim(substring(@list, 1, charindex(@spliton, @list)-1))) set @list = substring(@list, charindex(@spliton,@list) + len(@spliton), len(@list)) end  select value = ltrim(rtrim(@list)) end;
select * from a where f.id is null;
select * from a;
select * from a;
values ('value1'),('value2376') select * from your_table where your_column in ( select list from @your_list );
select * from your_table where your_column in ('value','value2376' );
set @xml = cast(('<a>'+replace('3,4,22,6014',',' ,'</a><a>')+'</a>') as xml) select @xml select a.value('.', 'varchar(max)') as [column] from @xml.nodes('a') as fn(a);
select * from foo f where f.id in (2, 3, 1);
select * from votes order by find_in_set(votetypeid, '13,1,12,2,11,3,10,4,9,5,8,6,7');
select * from votes order by field(votetypeid, 13,1,12,2,11,3,10,4,9,5,8,6,7);
select * from votes order by find_in_set(votetypeid, '13,1,12,2,11,3,10,4,9,5,8,6,7');
select * from votes order by field(votetypeid, 13,1,12,2,11,3,10,4,9,5,8,6,7);
select * from foo f where f.id in (2, 3, 1);
select * from information_schema.triggers;
select event_object_table from  information_schema.triggers where event_object_table = 'tablename' -- your table name comes here;
select relname as table_with_trigger from pg_class where pg_class.oid in ( select tgrelid from pg_trigger );
select tgname from   pg_trigger where  tgrelid = 'myschema.mytbl'::regclass; -- optionally schema-qualified;
select    tgname join    pg_class    on    (pg_class.oid=pg_trigger.tgrelid) join    pg_namespace    on    (nspowner=relowner);
d = trigger is disabled, r = trigger fires in "replica" mode, a = trigger fires always.;
select coalesce(max(column), 0) myalias from mytable;
select coalesce(max(column), 0) from mytable;
select coalesce(max(foo),0) from bar;
select sysdate,systimestamp from dual;
select current_date,current_timestamp from dual;
alter session set time_zone = '+3:0';
select * from ( select a.*, row_number() over (partition by a.id order by date desc) r from table a where id in $list ) where r=1;
select * from table a join (select id, max(date) maxdate from table where id in $list;
select a.id, (select max(t.date) from table t where t.id = a.id) as lastdate from table2;
create table a_latest date tstamp not null, primary key (id, max_time) );
select a.* from table a, table a_latest;
select distinct on (a.id) * from a;
create index b_id_date on b (id, date desc) select distinct on (b.id) * from a;
select distinct on (sort_column, a.id) * from a;
select date(from_unixtime(mytimestamp)) as fordate, count(*) as numposts from   mypoststable;
select * from ( select date(from_unixtime(mytimestamp)) as fordate, row_number() over (partition by date(from_unixtime(mytimestamp)) order by mytimestamp) as postrowid, * from   mypoststable ) as sequenced_daily_posts where fordate = <whatever date(s) you want> and postrowid <= 2;
select date(timestamp) as fordate, count(*) as numposts from   user_messages;
select 'insert into dbo.destinationtable(col1, col2, col3) select ' + convert(varchar(12), col1) + ',' from dbo.sourcetable;
select col1, col2, col3 from dbo.sourcetable;
select <fields> from <table1> and <other criteria for join> and <other criteria for join>;
select * from cd;
create table aa (sht int) create table cc (sht int) create table cd (sht int) create table ab (sht int) select * from cd select * from cc;
select tickets.*, group_concat(solutions.solution) as combinedsolutions from tickets;
select t.*, x.combinedsolutions from tickets t group_concat(s.soution) as combinedsolutions from solutions s;
select t.*, (select group_concat(s.soution) from solutions s where s.ticket_id = t.ticket_id) as combinedsolutions from tickets t;
select     ah.whateverfield1 as 'ah_field1', ah.whateverfield2 as 'ah_field2', l.whateverfield3 as 'l.field3', [....] from       class_alerts_holding ah;
select ah.*, l.*, u.*, pi.* from ...;
select ah.*, ':', l.*, ':', u.*, ':', pi.* from ...;
set @sql = null;
select concat( 'select ',group_concat(c.table_name,'.',c.column_name,' as `',c.table_name,'.',c.column_name,'`'),' from class_alerts_holding ) from information_schema.columns c where c.table_name in ('class_alerts_holding','class_listings', 'class_users','class_prodimages');
set session group_concat_max_len = 1000000;
select '--table_aaa:--', table_aaa.*, '--table_bbb:--', table_bbb.*, '--table_ccc:--', table_ccc.*, '--table_ddd:--', table_ddd.* from ...;
select a.* use prefix,b.* use postfix '_b' from table_a a inner join table_b b on a.id=b.id;
select * except large_binary_data_field,another_notneeded_field,etc from my_table;
if type(excluding)==str: excluding=excluding.split(',') if not (cur.description is none):;
where t.is_active=true and f.is_active=true and f.task=t.id and t.train_dataset=d.id get_table_fields('tasks','t',prefix='ts_'), get_table_fields('features_sets','f',prefix='fs_'), get_table_fields('datasets','d',prefix='ds_',excluding='data') );
select t.id ts_id,t.project ts_project,t.name ts_name,***, fs_id,f.task fs_task,f.name fs_name,f.description fs_description,***, d.id ds_id,d.project ds_project,d.name ds_name,*** from tasks t,features_sets f,datasets d where t.is_active=true and f.is_active=true and f.task=t.id and t.train_dataset=d.id;
where c.table_schema='your_schema_name' and c.table_name in (....);
set @col = select stuff( (select ', ' + column_name + '.' + table_name from information_schema.columns where table_name in ( 'table1', 'table2' ...) for xml select ' + @col + ' from table1 exec sp_executesql @query;
select concat(table_name, ".", column_name, " as ", char(34), table_name, ".", column_name, char(34)) field_names from information_schema.columns where table_schema = "my_database" and table_name in( "table_1", "table_2";
select replace(replace('hello world','world','earth'),'hello','hi');
select replace(london_english,'hello','hi') as warwickshire_english from ( select replace('hello world','world','earth') as london_english;
select group_concat(newword separator ' ') from ( select 'hello' as oldword union all select 'world' select 'hello' as oldword, 'hi' as newword union all select 'world', 'earth';
select txt, regexp_replace(replace(txt, ' ', '-'), '[^a-za-z0-9-]+', '') as `reg_replaced` from test;
select txt, reg_replace(replace(txt, ' ', '-'), '[^a-za-z0-9-]+', '', true, 0, 0 from test;
replace( replace(replace_field, "1", "one"), "2", "two"), "3", "three");
update table1 set column1 = replace(replace(replace(column1, '\r\n', ''), '<br />',''), '<\r>','');
select preg_replace('/(\\.|com|www)/','','www.example.com');
create function if not exists num_as_word (name text) returns text return ( select replace( replace( replace( replace( replace( replace( replace( replace( replace(ifnull(name, ''), '1', 'one'), '2', 'two'), '3', 'three'), '4', 'four'), '5', 'five'), '6', 'six'), '7', 'seven'), '8', 'eight'), '9', 'nine');
select top (@topparam) * from table1;
set @inum = 10 select top (@inum) tablecolumnid from tablename;
create procedure topnrecords as set rowcount @inttop select * from sometable set rowcount 0;
create table dbo.t (id  int constraint my_unique_constraint unique (id));
select [constraint]=name from sys.key_constraints where parent_object_id = object_id('dbo.t');
select name, index_id, type_desc from sys.indexes where object_id = object_id('dbo.t') and index_id > 0;
create table dbo.t2 (id int );
create unique index my_unique_constraint on dbo.t2 (id);
select [constraint]=name from sys.key_constraints where parent_object_id = object_id('dbo.t2');
select name, index_id, type_desc from sys.indexes where object_id = object_id('dbo.t2') and index_id > 0;
select table_name, constraint_name, column_name, ordinal_position from information_schema.key_column_usage;
create unique nonclustered index [uf_employee_userid] on [dbo].[employee] ( [userid] asc--not all employees have a userid to log into the system. ) where ([userid] is not null)--enforce uniqueness when not null.;
create unique nonclustered index ix_uq_bar bar ) select foo_other_column from foo where bar = 'test';
alter table dbo.foo add constraint uq_bar unique(bar);
create unique index ix_uq_bar on dbo.foo(bar);
where col is not null;
from tbl where b=? and c=? ''';
unique = "%parameter%" where item = ? and storage = ? and fiscalyear = ? and balanceyear = ? and balance = ? and balancemonth = ?""" values = (1,2,"asdasd",12331, "aas)",1);
alter table history add primary key (id) alter table history drop constraint userid drop constraint name;
alter table history drop constraint pk_history alter table history add constraint pk_history primary key (id);
select * from information_schema.table_constraints where table_name = 'history';
if 0 < ( select count(*) from information_schema.tables where table_type = 'base table' and table_schema = 'dbo' and table_name = 't_sys_language_forms' ) if 0 = (select count(*) from t_sys_language_forms where lang_uid is null) alter table t_sys_language_forms alter column lang_uid uniqueidentifier not null if 1 >= (select top 1 count(*) as cnt from t_sys_language_forms group by lang_uid order by cnt desc) if 0 = ( select count(*) from information_schema.table_constraints where constraint_type = 'primary key' and table_schema = 'dbo' and table_name = 't_sys_language_forms' ) alter table t_sys_language_forms add constraint pk_t_sys_language_forms primary key clustered (lang_uid asc) if 0 = (select count(*) from information_schema.referential_constraints where constraint_name = 'fk_t_zo_sys_language_forms_t_sys_language_forms') alter table t_zo_sys_language_forms with nocheck add constraint fk_t_zo_sys_language_forms_t_sys_language_forms foreign key(zolang_lang_uid) references t_sys_language_forms(lang_uid);
end -- end uniqueness check else print 'fsck, this column has duplicate keys, and can thus not be changed to primary key...' end -- end null check else print 'fsck, need to figure out how to update null value(s)...' end;
select 'update [table name] set [xml field name] = ''' +;
update thetable set thedata = '<root><name>bob</name></root>' where thekey = 1;
select 'update [table name] set [xml field name] = ''' +;
if exists (select * from sysobjects where name = 'tabletoupdate') drop table tabletoupdate if exists (select * from sysobjects where name = 'vw_tabletoupdate') drop view vw_tabletoupdate create table tabletoupdate( id int not null constraint pk_tabletoupdate primary key clustered identity(1,1), xmldata xml null ) create view dbo.vw_tabletoupdate as select id, convert(varchar(max), xmldata) as xmltext, xmldata from dbo.tabletoupdate create trigger tr_tabletoview_update as  set nocount on @xmltext varchar(max) select id, xmltext from inserted update tabletoupdate set xmldata = convert(xml, @xmltext) where id = @id end  update vw_tabletoupdate set xmltext = '<node1a/>' select * from tabletoupdate;
select xmldata from [yourtable] where id = @someid;
update [yourtable] set xmldata = '<row><somefield1>somedata</somefield1> where id = @someid;
from other sources;
from microsoft query;
set wb = activeworkbook set c = wb.connections end sub;
( table_qualifier varchar(30), table_owner varchar(30), table_name varchar(50), column_name varchar(30), key_seq int, pk_name varchar(50) ) select * from @tbl;
if (object_id('example.pk_item') is null) alter table [example].foobar add constraint end;
select object_id from sys.objects where parent_object_id = object_id(n'facounty') and [type] = n'pk';
select kcu.* from information_schema.key_column_usage kcu information_schema.table_constraints tc tc.table_name, tc.constraint_name, kcu.ordinal_position;
select * from information_schema.table_constraints tc join information_schema.constraint_column_usage ccu where tc.table_name = 'tablename' and;
exec sp_pkeys @tablename;
exec [sys].[sp_primary_keys_rowset] @table_name= 'tablename';
select ccu.column_name, ccu.constraint_name from information_schema.table_constraints as tc where tc.table_catalog = 'your_catalog'    -- replace with your catalog and tc.table_schema = 'dbo'            -- replace with your schema and tc.table_name = 'your_table'       -- replace with your table name and tc.constraint_type = 'primary key';
select schema_name(ta.schema_id)  schemaname from sys.tables ta and indcol.index_id = ind.index_id and col.column_id = indcol.column_id where ind.is_primary_key = 1 ta.name;
if (string.isnullorempty(value) || string.isnullorempty(pattern));
if (matches.count > 0) {;
sqlite3_context context, int argc, sqlite3_value[] argv ) if ( npat > db.alimit[sqlite_limit_like_pattern_length] ) if ( argc == 3 ) if ( zesc == null ) if ( sqlite3utf8charlen( zesc, -1 ) != 1 ) "escape expression must be a single character", -1 );
if ( za != null && zb != null ) string zpattern,            /* the glob pattern */ ) if ( !prevescape && c == matchall ) if ( c == matchone && sqlite3utf8read( zstring, ref zstring ) == 0 ) if ( c == 0 ) else if ( c == esc ) if ( c == 0 ) else if ( c == matchset ) if ( nocase ) if ( 0 == ( ( c ) & ~0x7f ) ) if ( 0 == ( ( c2 ) & ~0x7f ) ) else { if ( c2 == 0 ) if ( patterncompare( zpattern, zstring, pinfo, esc ) ) else if ( !prevescape && c == matchone ) if ( sqlite3utf8read( zstring, ref zstring ) == 0 ) else if ( c == matchset ) if ( c == 0 ) if ( c2 == '^' ) if ( c2 == ']' ) if ( c == ']' ) if ( c2 == '-' && zpattern[0] != ']' && zpattern[0] != 0 && prior_c > 0 ) if ( c >= prior_c && c <= c2 ) else { if ( c == c2 ) if ( c2 == 0 || ( seen ^ invert ) == 0 ) else if ( esc == c && !prevescape ) else { if ( nocase ) if ( c < 0x80 ) if ( c2 < 0x80 ) if ( c != c2 );
if (lbl.text.startwith("hr")==true ) {};
string source, string pattern, comparemethod compareoption );
if (expectedresult != result) else { iswildcardon = false, ischarwildcardon = false, ischarseton = false, isnotcharseton = false, endofpattern = false;
if (!endofpattern) if (!iswildcardon && p == '%') if (patternindex >= pattern.length) p = '\0';
else p = pattern[patternindex];
else if (p == '_') else if (p == '[') if (pattern[++patternindex] == '^') else ischarseton = true;
if (pattern[patternindex + 1] == '-' && pattern[patternindex + 3] == ']') if (start <= end) if (iswildcardon) if (char.toupper(c) == char.toupper(p)) else if (ischarwildcardon) else if (ischarseton || isnotcharseton) if ((isnotcharseton && charmatch) || (ischarseton && !charmatch)) if (lastwildcard >= 0) patternindex = lastwildcard;
else { else { if (char.toupper(c) == char.toupper(p)) else { if (lastwildcard >= 0) patternindex = lastwildcard;
else { if (ismatch && !endofpattern) if (pattern[i] != '%') if (isonlywildcards) endofpattern = true;
if ("bla bli blu".contains("blu")){......};
where val.contains("pattern") select val); // like '%pattern%' where val.startswith("pattern") select val);// like 'pattern%' where val.endswith ("pattern") select val);// like '%pattern';
where fb.barid = 1000 select new { fooid = fb.fooid, barid = fb.barid }) from f in foo where fids.haskey(f.fooid) select f;
from f in foo where f.fooid == ( from fb in foobar where fb.barid == 1000 select fb.fooid ) select f;
where <conditions for table2> select t2.keyfield where t2s.contains(t1.keyfield) select t1;
where <conditions for table2> select t2.keyfield where t2s.any(t1.keyfield) select t1;
where fb.barid = 1000 select new { fooid = fb.fooid, barid = fb.barid }) from f in foo where fids.haskey(f.fooid) select f;
from f in foo where fids.haskey(f.fooid) select f;
from f in foo where f.fooid equals model.foobar.singleordefault(fbar => fbar.barid = 1000).fooid select new;
create function [dbo].[getvaluebetweentwostrings](@inputstring as begin select @retval = substring ( @inputstring, patindex(@stringtosearchfromsearchpattern, @inputstring) + len(@stringtosearchfrom), (case @stringtosearchto, @inputstring, patindex(@stringtosearchfromsearchpattern, @inputstring) + len(@stringtosearchfrom)) then len(@inputstring) + 1 else charindex( @stringtosearchto, @inputstring, patindex(@stringtosearchfromsearchpattern, @inputstring) + len(@stringtosearchfrom)) ) end;
select dbo.getvaluebetweentwostrings('images/test.jpg','/','.') as myresult;
select substring(col, charindex ('/', col) + 1, charindex ('.', col) - charindex ('/', col) - 1);
select left((right(a.name,((charindex('/', name))+1))),((charindex('.', (right(a.name, ((charindex('/', name))+1)))))-1)) splitstring, a.name from (select 'images/test.jpg' as name)a;
select substring ('abcde/wxyz',0,charindex('/','abcde/wxyz')+1);
select substring('abcde/wxyz',charindex('/','abcde/wxyz'),len('abcde/wxyz'));
select replace(right(@test,charindex('/',reverse(@test))-1),'.jpg','');
select @test as column_name;
select substring(column_name,0, charindex('-',column_name))  as 'new_name' from [abc].;
select substring(parentbgbu,0,charindex('/',parentbgbu,0)) from dbo.tblhcmmaster;
select substring(parentbgbu,charindex('-',parentbgbu)+1,len(parentbgbu)) from dbo.tblhcmmaster;
create function [fn].[searchtextgetbetweenstartandstop](@string varchar(max),@searchstringtostart varchar(max),@searchstringtostop varchar(max)) set @string =    case or charindex(@searchstringtostop,right(@string,len(@string) - charindex(@searchstringtostart,@string) + 1 - len(@searchstringtostart))) = 0 then null else substring(@string ) end  end;
select substring( @a, patindex(@keysvaluetosearchpattern, @a) + len(@keysvaluetosearch), charindex( @untilthischarappears, @a, patindex(@keysvaluetosearchpattern, @a) + len(@keysvaluetosearch) );
select substring(col, len(substring(col, 0, len(col) - charindex ('/', col))) + 1, len(col) - len(substring(col, 0, len(col) - charindex ('/', col))) - len(substring( col, charindex ('.', col), len(col))));
select substring(col, len(left(col, charindex ('/', col))) + 1, len(col) - len(left(col, charindex ('/', col))) - len(right(col, len(col) - charindex ('.', col))) - 1);
( col varchar(20) ) select 'images/test1.jpg' union all select 'images/test2.png' union all select 'images/test3.jpg' union all select 'images/test4.jpeg' union all select 'images/test5.jpeg' select substring( left(col,charindex('.',col)-1),charindex('/',col)+1,len(left(col,charindex('.',col)-1))-1 ) from @t;
create type number_tab is table of number;
select * from table (number_tab(1,2,3,4,5,6));
select column_value from table (number_tab(1,2,3,4,5,6));
2    select '1,2,3,a,b,c,d' str from dual;
select column_value from table(sys.dbms_debug_vc2coll('one', 'two', 'three', 'four'));
select column_value from table(sys.dbms_debug_vc2coll(1,2,3,4));
select distinct column_value from table(sys.odcinumberlist(1,1,2,3,3,4,4,5));
select trim(column_value) str from xmltable(('"'||replace('a1, b2, a2, c1', ',', '","')||'"'));
select index_name from user_indexes where table_name = :table;
select index_name from user_ind_columns where table_name = :table;
select count(*) from information_schema.table_constraints;
select * from sys.indexes where object_id = (select object_id from sys.objects where name = 'mytable');
select name from sys.tables where objectproperty(object_id,'isindexed') = 0;
create procedure _listindexes(@tablename nvarchar(200)) as begin exec _listindexes '<your table name>' select db_name(db_id()) as dbname,sch.name + '.' + tbl.name as tablename,idx.name as indexname, idx.type_desc as indextype,col.name as columnname,ic.* from sys.tables as tbl where tbl.name = @tablename end;
set @thetable = 'theschema.thetable';
select i.* from sys.indexes i where i.object_id = object_id(@thetable) and i.name is not null;
select * from sys.objects where type = 'u' order by name;
select c.name from sys.index_columns ic where ic.object_id = 4 and c.object_id = 4;
select a.table_catalog as db_name,a.table_schema as tbl_schema, a.table_name as tbl_name,a. constraint_name as constraint_name,b.constraint_type from information_schema.constraint_column_usage a join information_schema.table_constraints b on;
select sum(qty), name from ( select count(m.owner_id) as qty, o.name from transport t,owner o,motorbike m where t.type='motobike' and o.owner_id=m.owner_id and t.type_id=m.motorbike_id union all  select count(c.owner_id) as qty, o.name, from transport t,owner o,car c where t.type='car' and o.owner_id=c.owner_id and t.type_id=c.car_id;
select count(owner_id), name from ( select m.owner_id, o.name, t.type from transport as t, owner as o, motorbike as m where t.type = 'motorbike' and o.owner_id = m.owner_id and t.type_id = m.motorbike_id union all  select c.owner_id, o.name, t.type from transport as t, owner as o, car as c where t.type = 'car' and o.owner_id = c.owner_id and t.type_id = c.car_id );
set xact_abort on; -- roll back everything if error occurs in script;
select @id select @id;
update employee set age = case when (age < 20) then 15 else 20 end;
update employee set age = case when age < 20 then 15 else 20 end;
select service_level, fixpack_num from table as instanceinfo;
select * from sysibmadm.env_inst_info;
select getvariable('sysibm.version') from sysibm.sysdummy1;
select * from table(sysproc.env_get_inst_info());
select * from table(sysproc.env_get_prod_info());
select * from table(sysproc.env_get_sys_info());
select * from table(sysproc.env_get_inst_info());
select getvariable(('sysibm.version') from sysibm.sysdummy1;
select getvariable('sysibm.version') from sysibm.sysdummy1;
select getvariable('sysibm.version') from sysibm.sysdummy1;
select * from table(sysproc.env_get_inst_info());
select * from sysibmadm.env_inst_info;
select current application compatibility from sysibm.sysdummy1;
select getvariable('sysibm.version') as version, getvariable('sysibm.newfun')  as compatibility from sysibm.sysdummy1;
set @str = 'ponies!!...pon1es!!...p0n1es!!' if patindex('%[0-9]%', @str) > 0 else print 'no, the string does not have numbers';
select * from table where column like '%[0-9]%';
select case when 'fdajlk' like '%[0-9]%' then 'true' else 'false' end;  -- false select case when 'fdaj1k' like '%[0-9]%' then 'true' else 'false' end;  -- true;
select shade, s_index = row_number() over(partition by [shade] order by [shade]), t_index = dense_rank() over (order by [shade]) from dbo.yourtablenamehere;
values ( 1, 2, 3 ) , ( 3, 4, 5 ) , ( 6, 7, 8 );
values (11, 12, 13) , (21, 22, 23) , (31, 32, 33);
values (unnest(array[11,21,31]), unnest(array[12,22,32]), unnest(array[13,23,33]));
values (unnest(?), unnest(?), unnest(?));
update "table" set value = data_table.new_value from (select unnest(?) as key, unnest(?) as new_value) as data_table where "table".key = data_table.key;
create table tmp ( id serial not null primary key, name text, age integer values ('keith', 43),('leslie', 40),('bexley', 19),('casey', 6);
update tmp set age = data_table.age from (select unnest(array['keith', 'leslie', 'bexley', 'casey']) as name, unnest(array[44, 50, 10, 12]) as age) as data_table where tmp.name = data_table.name;
... ] update mytable set myvalue = q.myvalue from ( select (value->>0)::integer as id, (value->>1)::decimal as myvalue from json_array_elements(%s) where mytable.id = q.id [json.dumps(big_list_of_tuples)] );
select * from table where dt::date = '2011-01-01' -- this should be iso-8601 format, yyyy-mm-dd;
select * from table where cast(dt as date) = '2011-01-01' -- this should be iso-8601 format, yyyy-mm-dd;
select * from mytable where date_trunc('day', dt) = 'yyyy-mm-dd';
create index date_trunc_dt_idx on mytable ( date_trunc('day', dt) );
create index date_trunc_dt_idx on mytable ( date_trunc('day', dt at time zone 'australia/sydney') );
select * from mytable where date_trunc('day', dt at time zone 'australia/sydney') = 'yyyy-mm-dd';
select compose('do' || unistr('\0304' || 'tttt')) from dual;
select *,row_number() over ( partition by productid,vendorid from productvendorassoc ) select productid, vendorid, productname, vendorname, isactive from numbered where rn=1;
select productid, vendorid, productname, vendorname, isactive from ( select *, row_number() over (partition by productid, vendorid order by productid) rownumber from production.product where rownumber = 1;
select ... case when isnumeric(value) = 1 then convert(int, value) else 9999999 -- or something huge value;
select field from table isnumeric(field) desc, case isnumeric(test) else null field;
select field1, field2... from table1 isnumeric(field1) desc, case when isnumeric(field1) = 1 then cast(field1 as int) else null end, field1;
select your_column from your_table case when isnumeric(your_column) = 1 then your_column else 999999999 end, your_column;
select mycolumn from mytable case isnumeric(mycolumn) else mycolumn end;
select *, convert(int, your_column) as your_column_int from your_table;
select *, cast(your_column as int) as your_column_int from your_table;
sr.codice +0 ) asc;
select cast([yourvarchar] as bigint);
where isnumeric([yourvarchar] +'e0') = 1;
select * from table order by isnumeric([yourvarchar] +'e0') desc;
select * from table order by isnumeric([yourvarchar] +'e0') desc;
select * from table order by isnumeric([yourvarchar] +'e0') desc then right('00000000000000000000' + [yourvarchar], 20) asc else ltrim(rtrim([yourvarchar])) end asc;
select *, row_number()over(order by case when isnumeric (id)=1 then convert(numeric(20,2),substring(id, patindex('%[0-9]%', id), len(id)))end desc)rn ---- numerical from (  select '1'id union all select '25.20' id union all select 'a115' id union all select '2541' id union all select '571.50' id union all select '67' id union all select 'b48' id union all select '500' id union all select '147.54' id union all select 'a-100' id case when isnumeric (id)=0                                /* alphabetical sort */ then case when patindex('%[0-9]%', id)=0 then left(id,patindex('%[0-9]%',id)) else left(id,patindex('%[0-9]%',id)-1) end end desc;
select *, (case when isnumeric(column_name) = 1 then 0 else 1 end) isnum from table_name;
select * from tab;
select count(*) from table into number_rows (etc.) if number_rows > 0 -- then obtain my_value with a query or constant, etc. end if;
select final_grade from enrollment where student_id = v_student_id and section_id = v_section_id;
case -- outer case;
create temp table temp1 like ...;
create table as;
create temp table temp1 <b>as</b> select dataid from   rawdata.egauge where  register_type like '%gen%';
create table as;
create table like (...);
create table y ( id serial not null, email text not null unique select 'some.name'||n||'@foobar.com' from generate_series(1,100000) as i(n);
create index ix_y on y using gin (email gin_trgm_ops);
create table x ( id serial not null, email citext not null unique select email from y;
select * from y where email ilike any (array['some.name420@foobar.com','some.name42@foobar.com']);
index cond: (email ~~* any ('{some.name420@foobar.com,some.name42@foobar.com}'::text[]));
select * from x where email = any (array['some.name420@foobar.com','some.name42@foobar.com']);
index scan using x_email_key on x  (cost=0.42..5.85 rows=2 width=29) (actual time=0.111..0.203 rows=2 loops=1) index cond: (email = any ('{some.name420@foobar.com,some.name42@foobar.com}'::citext[]));
create table data ( group_id serial primary key, name text create table data_ci ( group_id serial primary key, name citext select 'data'||i.n from generate_series(1,1000) as i(n), generate_series(1,1000) as i2(n);
select group_id, name from data;
create index ix_data_gin on data using gin (name public.gin_trgm_ops);
create index ix_data_ci on data_ci (name);
select * from data where name ilike any (array['data1', 'data2', 'data3']);
index cond: (name ~~* any ('{data1,data2,data3}'::text[]));
select * from data_ci where name = any (array['data1', 'data2', 'data3']);
select pg_size_pretty(pg_total_relation_size('ix_data_gin')) as gin_index_size, pg_size_pretty(pg_total_relation_size('ix_data_ci')) as citex_index_size;
end else begin end;
create table y ( id serial not null, email text not null unique select n from generate_series(1,1000) as i(n);
-- unique constraint on email already makes an index. where email ilike;
create function lower(t text[]) returns text[] as $$ select lower($1::text)::text[] create unique index ix_y_2 on y(lower(email));
where lower(email) =;
index cond: (lower(email) = any ((lower(('{isteve.jobs@apple.com,linus.torvalds@linux.com}'::text[])::text))::text[]));
create table x ( id serial not null, email citext not null unique select n from generate_series(1,1000) as i(n);
-- unique constraint on email already makes an index. where email =;
index cond: (email = any ('{isteve.jobs@apple.com,linus.torvalds@linux.com}'::citext[]));
create extension if not exists citext with schema public;
create table emails ( user_id int references users(user_id) select * from emails where email in ('linus.torvalds@linux.com','isteve.jobs@apple.com');
set search_path = public;
create type citext;
create or replace function citextin(cstring) as 'textin' create or replace function citextout(citext) as 'textout' create or replace function citextrecv(internal) as 'textrecv' create or replace function citextsend(citext) as 'textsend' create type citext ( input          = citextin, output         = citextout, receive        = citextrecv, send           = citextsend, internallength = variable, storage        = extended, -- make it a non-preferred member of string type category preferred      = false create or replace function citext(bpchar) as 'rtrim1' create or replace function citext(boolean) as 'booltext' create or replace function citext(inet) as 'network_show' create cast (citext as text)    without function as implicit;
create cast (citext as varchar) without function as implicit;
create cast (citext as bpchar)  without function as assignment;
create cast (text as citext)    without function as assignment;
create cast (varchar as citext) without function as assignment;
create cast (bpchar as citext)  with function citext(bpchar)  as assignment;
create cast (boolean as citext) with function citext(boolean) as assignment;
create cast (inet as citext)    with function citext(inet)    as assignment;
create or replace function citext_eq( citext, citext ) as '$libdir/citext' create or replace function citext_ne( citext, citext ) as '$libdir/citext' create or replace function citext_lt( citext, citext ) as '$libdir/citext' create or replace function citext_le( citext, citext ) as '$libdir/citext' create or replace function citext_gt( citext, citext ) as '$libdir/citext' create or replace function citext_ge( citext, citext ) as '$libdir/citext' create operator = ( leftarg    = citext, rightarg   = citext, commutator = =, negator    = <>, procedure  = citext_eq, restrict   = eqsel, join       = eqjoinsel, hashes, merges create operator <> ( leftarg    = citext, rightarg   = citext, negator    = =, commutator = <>, procedure  = citext_ne, restrict   = neqsel, join       = neqjoinsel create operator < ( leftarg    = citext, rightarg   = citext, negator    = >=, commutator = >, procedure  = citext_lt, restrict   = scalarltsel, join       = scalarltjoinsel create operator <= ( leftarg    = citext, rightarg   = citext, negator    = >, commutator = >=, procedure  = citext_le, restrict   = scalarltsel, join       = scalarltjoinsel create operator >= ( leftarg    = citext, rightarg   = citext, negator    = <, commutator = <=, procedure  = citext_ge, restrict   = scalargtsel, join       = scalargtjoinsel create operator > ( leftarg    = citext, rightarg   = citext, negator    = <=, commutator = <, procedure  = citext_gt, restrict   = scalargtsel, join       = scalargtjoinsel create or replace function citext_cmp(citext, citext) as '$libdir/citext' create or replace function citext_hash(citext) as '$libdir/citext' create operator class citext_ops default for type citext using btree as operator    2   <= (citext, citext), operator    3   =  (citext, citext), operator    4   >= (citext, citext), operator    5   >  (citext, citext), function    1   citext_cmp(citext, citext);
create operator class citext_ops default for type citext using hash as function    1   citext_hash(citext);
create or replace function citext_smaller(citext, citext) as '$libdir/citext' create or replace function citext_larger(citext, citext) as '$libdir/citext' create aggregate min(citext)  ( sfunc = citext_smaller, stype = citext, sortop = < create aggregate max(citext)  ( sfunc = citext_larger, stype = citext, sortop = > create or replace function texticlike(citext, citext) create or replace function texticnlike(citext, citext) create or replace function texticregexeq(citext, citext) create or replace function texticregexne(citext, citext) create operator ~ ( procedure = texticregexeq, leftarg   = citext, rightarg  = citext, negator   = !~, restrict  = icregexeqsel, join      = icregexeqjoinsel create operator ~* ( procedure = texticregexeq, leftarg   = citext, rightarg  = citext, negator   = !~*, restrict  = icregexeqsel, join      = icregexeqjoinsel create operator !~ ( procedure = texticregexne, leftarg   = citext, rightarg  = citext, negator   = ~, restrict  = icregexnesel, join      = icregexnejoinsel create operator !~* ( procedure = texticregexne, leftarg   = citext, rightarg  = citext, negator   = ~*, restrict  = icregexnesel, join      = icregexnejoinsel create operator ~~ ( procedure = texticlike, leftarg   = citext, rightarg  = citext, negator   = !~~, restrict  = iclikesel, join      = iclikejoinsel create operator ~~* ( procedure = texticlike, leftarg   = citext, rightarg  = citext, negator   = !~~*, restrict  = iclikesel, join      = iclikejoinsel create operator !~~ ( procedure = texticnlike, leftarg   = citext, rightarg  = citext, negator   = ~~, restrict  = icnlikesel, join      = icnlikejoinsel create operator !~~* ( procedure = texticnlike, leftarg   = citext, rightarg  = citext, negator   = ~~*, restrict  = icnlikesel, join      = icnlikejoinsel create or replace function texticlike(citext, text) create or replace function texticnlike(citext, text) create or replace function texticregexeq(citext, text) create or replace function texticregexne(citext, text) create operator ~ ( procedure = texticregexeq, leftarg   = citext, rightarg  = text, negator   = !~, restrict  = icregexeqsel, join      = icregexeqjoinsel create operator ~* ( procedure = texticregexeq, leftarg   = citext, rightarg  = text, negator   = !~*, restrict  = icregexeqsel, join      = icregexeqjoinsel create operator !~ ( procedure = texticregexne, leftarg   = citext, rightarg  = text, negator   = ~, restrict  = icregexnesel, join      = icregexnejoinsel create operator !~* ( procedure = texticregexne, leftarg   = citext, rightarg  = text, negator   = ~*, restrict  = icregexnesel, join      = icregexnejoinsel create operator ~~ ( procedure = texticlike, leftarg   = citext, rightarg  = text, negator   = !~~, restrict  = iclikesel, join      = iclikejoinsel create operator ~~* ( procedure = texticlike, leftarg   = citext, rightarg  = text, negator   = !~~*, restrict  = iclikesel, join      = iclikejoinsel create operator !~~ ( procedure = texticnlike, leftarg   = citext, rightarg  = text, negator   = ~~, restrict  = icnlikesel, join      = icnlikejoinsel create operator !~~* ( procedure = texticnlike, leftarg   = citext, rightarg  = text, negator   = ~~*, restrict  = icnlikesel, join      = icnlikejoinsel create or replace function regexp_matches( citext, citext ) returns text[] as $$ select pg_catalog.regexp_matches( $1::pg_catalog.text, $2::pg_catalog.text, 'i' );
create or replace function regexp_matches( citext, citext, text ) returns text[] as $$ select pg_catalog.regexp_matches( $1::pg_catalog.text, $2::pg_catalog.text, case when pg_catalog.strpos($3, 'c') = 0 then  $3 || 'i' else $3 end );
create or replace function regexp_replace( citext, citext, text ) returns text as $$ select pg_catalog.regexp_replace( $1::pg_catalog.text, $2::pg_catalog.text, $3, 'i');
create or replace function regexp_replace( citext, citext, text, text ) returns text as $$ select pg_catalog.regexp_replace( $1::pg_catalog.text, $2::pg_catalog.text, $3, case when pg_catalog.strpos($4, 'c') = 0 then  $4 || 'i' else $4 end);
create or replace function regexp_split_to_array( citext, citext ) returns text[] as $$ select pg_catalog.regexp_split_to_array( $1::pg_catalog.text, $2::pg_catalog.text, 'i' );
create or replace function regexp_split_to_array( citext, citext, text ) returns text[] as $$ select pg_catalog.regexp_split_to_array( $1::pg_catalog.text, $2::pg_catalog.text, case when pg_catalog.strpos($3, 'c') = 0 then  $3 || 'i' else $3 end );
create or replace function regexp_split_to_table( citext, citext ) returns setof text as $$ select pg_catalog.regexp_split_to_table( $1::pg_catalog.text, $2::pg_catalog.text, 'i' );
create or replace function regexp_split_to_table( citext, citext, text ) returns setof text as $$ select pg_catalog.regexp_split_to_table( $1::pg_catalog.text, $2::pg_catalog.text, case when pg_catalog.strpos($3, 'c') = 0 then  $3 || 'i' else $3 end );
create or replace function strpos( citext, citext ) returns int as $$ select pg_catalog.strpos( pg_catalog.lower( $1::pg_catalog.text ), pg_catalog.lower( $2::pg_catalog.text ) );
create or replace function replace( citext, citext, citext ) returns text as $$ select pg_catalog.regexp_replace( $1::pg_catalog.text, pg_catalog.regexp_replace($2::pg_catalog.text, '([^a-za-z_0-9])', e'\\\\\\1', 'g'), $3::pg_catalog.text, 'gi' );
create or replace function split_part( citext, citext, int ) returns text as $$ select (pg_catalog.regexp_split_to_array( $1::pg_catalog.text, pg_catalog.regexp_replace($2::pg_catalog.text, '([^a-za-z_0-9])', e'\\\\\\1', 'g'), 'i'))[$3];
create or replace function translate( citext, citext, text ) returns text as $$ select pg_catalog.translate( pg_catalog.translate( $1::pg_catalog.text, pg_catalog.lower($2::pg_catalog.text), $3), pg_catalog.upper($2::pg_catalog.text), $3);
select * where email ilike 'me@example.com';
where email ilike replace(replace(replace($1, '~', '~~'), '%', '~%'), '_', '~_') escape '~';
where email ilike any(array['adamb@a.com', 'evea@b.com']);
create table bankaccount ( bankaccountid   int            primary key, employercode    varchar(20)    not null, amount          money          not null, constraint fk_bankaccount_employer );
select foo, bar, due_date from tablename;
select * from mytable where ...;
select * from mytable where ...;
select * from request order by -date desc;
where mod(value, 2) = 1;
where value % 2 = 1;
select * from table where value % 2 = 1;
select * from table where len(colname) mod 2 = 1;
where column % 2 = 1;
where mod(column, 2) = 1;
select last_name, salary,department_id from employees where salary in (select min(salary) from employees;
select employee_id, last_name, salary, job_id from employees where salary <any from employees where job_id = 'it_prog') and job_id <> 'it_prog';
select employee_id,last_name, salary,job_id from employees where salary <all from employees where job_id = 'it_prog') and job_id <> 'it_prog';
select s1 from t1 where s1 > any (select s1 from t2);
where x > any(a, b, c);
where x > any(select ... from ...);
select  * from    mytable where   x <= any ( select  y from    othertable );
select  * from    mytable m where   exists ( select  null from    othertable o where   m.x <= o.y );
select * from dest where id in(select id from source) select * from dest where id not in(select id from source);
select * from dest where isnull(id,-2)  in(select isnull(id,-1) from source) select * from dest where isnull(id,-2) not in(select isnull(id,-1) from source);
select * from tbl1 where ([textcol] not like '%tax%') and ([textcol] not like '%tax%');
select * from tbl1 where [textcol] not like '%tax%' or [textcol] is null;
select * from tbl1 where coalesce([textcol],'-1') not like '%tax%';
select * from tbl1 where [textcol] not like '%tax%' or [textcol] is null;
where age >= 18;
where [textcol] not like '%tax%' or [textcol] is null;
values (default,'lol');
select top (10000) dbo.users.login, dbo.users.phone, geophone.country from  dbo.users cross apply from    dbo.geophone where dbo.users.phone <= dbo.geophone.[end]) geophone union all select top (10000) dbo.users.login, dbo.users.phone, null as country from  dbo.users where dbo.users.phone is null;
if '$(deploytestdata)' = 'true' end go -- moved from data.sql;
if ('$(configsetting)' = 'configuration1') end;
if ('$(configsetting)' <> 'configuration1') set noexec on set noexec off;
if ('$(configsetting)' = 'configuration1') end else begin end go;
if 'debug' = '$(buildconfiguration)' end;
create trigger clearcamcdr after insert on `asteriskcdrdb`.`cdr` set @inc = (select sip_inc from trunks limit 1);
if new.billsec >1 and new.channel like @inc and new.dstchannel not like "" then insert into `asteriskcdrdb`.`filtre` (id_appel,date_appel,source,destinataire,duree,sens,commentaire,suivi) values (new.id,new.calldate,new.src,new.dstchannel,new.billsec,"entrant","","");
drop table if exists foo;
create table foo ( i serial primary key drop trigger if exists bar // create trigger bar after insert on foo set x = new.i;
set @a = x; -- set user variable outside trigger set @a = 0;
select @a; -- returns 0 select @a; -- returns 1, the value it got during the trigger;
create trigger bar after insert on foo set x = (select age from users where name = 'bill');
create trigger bar after insert on foo set x = (select max(age) from users where name = 'bill');
set @exist_composite_key = (select count(*) from patientrecords where rridprefix = new.rridprefix and rrid = new.rrid);
if @exist_composite_key > 0 then  set new.legacyduperrid = new.rrid;
set new.rrid = null;
set new.rrid = ( select if(new.rrid is null and new.legacyduperrid is null, ifnull(max(rrid), 0) + 1, new.rrid) from patientrecords where rridprefix  = new.rridprefix end;
select id into yourvar  from table where ...;
create table bar (....);
select * from foo;
select @minid = min(keycolumn) from table where condition select @maxid = max(keycolumn) from table where condition select @potentialrows = (@maxid - @minid) / @iterations set @breakid = @minid + @potentialrows select columns from table with (nolock, ...) where condition and keycolumn between @minid and @breakid set @minid = @breakid + 1 end;
select count(*);
select `userid` from    `openendedresponses` as `oe` where `oe`.`questionid` = 3 -- zip code and (replace( replace( `oe`.`value`, ' ', '' ), '-', '' ) in ( '30071', '30106', '30122', '30134', '30135', '30168', '30180', '30185', '30187', '30317', '30004' ));
select @sql = 'osql -s' +@@servername +' -e -q "exec dbname..sprocname "' exec master..xp_cmdshell @sql;
set @variable = function();
select * from function();
if exists (select * from master..sysservers where srvname = 'loopback') exec sp_dropserver 'loopback' exec sp_addlinkedserver @server = n'loopback', @srvproduct = n'', @provider = n'sqloledb', @datasrc = @@servername create function testit() as begin select @res=count(*) from openquery(loopback, 'exec sp_who');
end go select dbo.testit();
create procedure [dbo].[usp_functionbuilder];
set @innersql = 'your sql';
set @outersql = 'create function [dbo].[fn_generatedfunction] ( @param varchar(10)) as return;
where p.user = u.id;
select u.username, c._postcount from user u select p.user, count(*) as _postcount from posting p where u.joindate < '2009-10-10';
select u.username, c._postcount from user u select p.user, count(*) as _postcount from posting p where p.user = u.id where u.joindate < '2009-10-10';
select u.username, (select count(*) from posting where user = u.id) as _postcount from user u where u.joindate < '2009-10-10';
select u.id as userid,u.username, c._postcount from user u select p.user, count(*) as _postcount from posting p where p.user = userid where u.joindate < '2009-10-10';
select u.username, c._postcount from user u select p.user, count(*) as _postcount from posting p where u.joindate < '2009-10-10' and c.user = u.id -- ####add this####;
select u.username, c._postcount from user u, lateral ( select p.user, count(*) as _postcount from posting p where p.user = u.id where u.joindate < '2009-10-10';
select u.username, c._postcount from user u, lateral ( select count(*) as _postcount from posting p where p.user = u.id where u.joindate < '2009-10-10';
create table aafest_bestelling_new like aafest_bestelling;
alter table `aafest`.`aafest_bestelling_new`;
select klantid, datum, bestellingtypeid from aafest_bestelling;
aafest_bestelling_new to aafest_bestelling;
set session sql_mode='no_auto_value_on_zero';
set session sql_mode='';
alter table ... change column `id` `id` int(11) not null auto_increment, auto_increment = 123456;
alter table `aafest`.`aafest_bestelling` change column `id` `id` int(11) not null auto_increment;
update foo set id = 100 where id = 0;
alter table foo modify column id int(11) not null auto_increment;
alter table foo auto_increment = 101;
update foo set id = 0 where id = 100;
where is_deleted='0';
where deleted_at is null;
select * from table_name where is_deleted = 1;
where ... and is_deleted=0;
delete from [table_name] where [id] in ( select max([id]) from [table_name] having count(*) > 1 ) select max([id]),[table_name], count(*) as dupecount from [table_name] having count(*) > 1;
( select col1,col2,col3, row_number() over(partition by col1,col2,col3 order by (select 0)) as rn from mytable ) delete from dups where rn > 1;
delete dup from ( select row_number() over (partition by clientid order by clientid ) as val from clientmaster where dup.val > 1;
delete from 'test' where test.id>vtable.id and test.common_column=vtable.common_column;
delete sub from from employee) sub where sub.cnt > 1;
as (select *, row_number() over (partition by empid,empssn order by empid,empssn) as duplicate from employee) delete from duplicates where duplicate > 1 ;
select distinct * into newtablename from oldtablename;
select t1.* from employee t1, employee t2 where t1.empid=t2.empid and t1.empname = t2.empname and t1.salary = t2.salary;
( select  count(*) from tblemp where empno in (select empno  from tblemp group by empno having count(empno)>1)) > 1 delete top(1) from tblemp where empno in (select empno  from tblemp group by empno having count(empno)>1);
delete from dbo.tbl1 where id not in ( select min(id) as namecount from tbl1 );
select distinct;
delete from employee;
select t1.empid, t1.empssn, count(*) from employee as t1 having count(*) > 1;
alter table employee add employeeid int identity(1,1) primary key;
delete from employee where employeeid in ( select min(employeeid) as [deleteid] from employee having count(*) > 1 ) end;
delete from employee a where row_number() <> ( select min( row_number() ) from employee b where a.empid  = b.empid and a.empssn = b.empssn );
select top 1 @id = empid from employee having count(*) > 1 delete top(1) from employee where empid = @id end;
create table dbo.egg ( id int identity(1,1) not null, chicken int null, constraint [pk_egg] primary key clustered ([id] asc) on [primary] create table dbo.chicken ( egg int not null, constraint [pk_chicken] primary key clustered ([egg] asc) on [primary] alter table dbo.egg  with nocheck add  constraint [fk_egg_chicken] foreign key([chicken]) references [dbo].[chicken] ([egg]) alter table dbo.chicken  with nocheck add  constraint [fk_chicken_egg] foreign key([egg]) references [dbo].[egg] ([id]) alter table dbo.egg with nocheck add constraint [uq_egg_chicken] unique([chicken]) alter table dbo.chicken with nocheck add constraint [uq_chicken_egg] unique([egg]);
create table [employee] ( [id]    int primary key create table [salary] ( [employeeid]    int unique not null alter table [salary] add constraint fk_salary_employee foreign key([employeeid]);
[id] ) values (1, 'ram') [employeeid] ) values (1, 2000);
select * from [employee];
select * from [salary];
[employeeid] ) values (1, 3000);
create table dbo.[address] ( id int identity not null, city nvarchar(255) not null, street nvarchar(255) not null, constraint pk_address primary key (id) ) create table dbo.[person] ( id int identity not null, addressid int not null, firstname nvarchar(255) not null, lastname nvarchar(255) not null, constraint pk_person primary key (id), constraint fk_person_address foreign key (addressid) references dbo.[address] (id) );
create table person ( pk_person_id int primary key, name varchar(255), emailid varchar(255), );
create table passportdetails ( pk_passport_id int primary key, passport_number varchar(255), fk_person_id int not null unique, foreign key(fk_person_id) references person(pk_person_id);
alter database test set single_user with rollback immediate;
if exists (select name from master.dbo.sysdatabases where name = n'test') drop database [test] create database [test];
select spid, hostname, [program_name], open_tran, hostprocess, cmd from master.dbo.sysprocesses where dbid = db_id('your_database_name');
alter database test1 set single_user with rollback immediate alter database test1 set offline;
drop database test1;
drop table [dbo].[administrateur] set ansi_nulls on set quoted_identifier on create table [dbo].[administrateur]( [administrateurid] [int] identity(1,1) not null, [name] [nvarchar](max) not null, [surname] [nvarchar](max) null, [phone] [nvarchar](max) not null, [username] [nvarchar](max) not null, [password] [nvarchar](max) not null, [sexe] [nvarchar](max) not null,  constraint [pk_administrateur] primary key clustered ( [administrateurid] asc;
drop table [dbo].[administrateur] set ansi_nulls on set quoted_identifier on create table [dbo].[administrateur]( [administrateurid] [int] identity(1,1) not null, [name] [nvarchar](max) not null, [surname] [nvarchar](max) null, [phone] [nvarchar](max) not null, [email] [nvarchar](max) not null, [username] [nvarchar](max) not null, [password] [nvarchar](max) not null, [image] [nvarchar](max) not null, [sexe] [nvarchar](max) not null, [salt] [nvarchar](max) not null, constraint [pk_administrateur] primary key clustered ( [administrateurid] asc;
drop databse "databsename";
set @databasename = 'yourdatabasename' set @resource_type_to_kill = 'database' ( processidtokill int, databasename varchar(100), request_mode varchar(100), hostname varchar(100), logintime varchar(100), loginname varchar(100), status varchar(100), reads varchar(100), writes varchar(100) select distinct session_id, name, request_mode, host_name, login_time, login_name, status, reads, writes from    sys.dm_exec_sessions where   resource_type = @resource_type_to_kill and name = @databasename select @processidtokill = processidtokill from @tempsession set @sql = 'kill ' + cast(@processidtokill as varchar(4)) exec (@sql) set @dropsql = 'drop database ' + @databasename exec (@dropsql);
select col1, col2, col3 from your_table where 1=1 and col2 in ( select val1 as fake from dual union select val2 as fake from dual union select val3 as fake from dual );
select val from table where val in (1,2,3,...) or val in (7,8,9,....);
select  foo from    bar where bar.stuff in;
select  b.foo from    ( select  distinct stuff from    asdf ) a join    bar b;
select  @r from    ( select  @r := min(id) - 1 from    t_source2 t_source2 where   (@r := @r + 1) <> id id limit   1;
select  id from    mytable mo where   ( select  id + 1 from    mytable mi where   mi.id < mo.id mi.id desc limit 1 id, limit   1;
select t1.id + 1 from thetable t1 where not exists ( select * from thetable t2 where t2.id = t1.id + 1 ) limit 1;
select auto_increment from information_schema.tables where table_name='the_table_you_want';
select auto_increment from information_schema.tables where table_name='the_table_you_want' and table_schema='the_database_you_want';
select (max(id) + 1), field1, field2, field3, etc from table1 where condition_here_if_needed );
select max(id) + 1 from table;
select last_insert_id();
select u.id + 1 as firstavailableid from users u where u1.id is null limit 0, 1;
select case when min(myid) is null or min(myid)>1 then 1 else -- find next gap from mytable t (updlock) where not exists (select null from mytable n where n.myid=t.myid+1)) end as nextid from mytable;
select auto_increment as id from information_schema.tables where table_name = 'table_name' and table_schema = 'database_name';
select if(res.nextid, res.nextid, @r) as nextid from (select @r := 30) as vars, ( select min(t1.id + 1) as nextid from test t1 where t1.id >= @r and t2.id is null and exists ( select id from test where id = @r ) limit 1 limit 1;
select id+1 "nextid" from ( select id from table1 where id>100 order by id where not exists ( select 1 from table1 t2 where t2.id=x.id+1 ) limit 1;
delete from customer where id=1;
delete from customer where id=2;
select    @date;
alter function [dbo].[roundoffdatetime] ( @incdate    datetime, @increment  int ) as begin end;
select  dateadd(minute,datediff(minute,0,dateadd(second,30*@rounddirection*@roundinterval,@time))/@roundinterval*@roundinterval,0);
select case when (datepart(minute, @dt) % @round) * 60 + datepart(second, @dt) < (30 * @round) then dateadd(minute, datediff(minute,0, @dt) / @round * @round, 0) else dateadd(minute, (datediff(minute,0, @dt) / @round * @round) + @round, 0) end;
select dateadd(minute, round(datediff(minute, 0, getdate()) / 15.0, 0) * 15, 0);
( select @sequencestart as [time] union all select dateadd(minute, 5, [time]) from timesequence where [time] <= @sequenceend ) select [time] = cast([time] as time(0)) from timesequence option ( maxrecursion 1000);
create function roundquarterhour ( @dt datetime as begin set @date = convert(varchar(16),@dt,121) --sin segundos, ni milisegundos end ;
select dateadd(mi,case when @m >=8 then 15-@m else -1*@m end,@t) select dateadd(mi,iif(@m >=8,15-@m,-1*@m),@t);
create function [dbo].[roundtime] (@time datetime, @roundto float) returns datetime as begin set @multiplier = 24.0 / @roundto set @roundedtime= round(cast(cast(convert(varchar, @time, 121) as datetime) as float) * @multiplier, 0) / @multiplier end  select dbo.roundtime('13:15', 0.5);
create function roundquarterhour ( @dt datetime ) as begin set @mm=datepart(minute,@dt) set @result = dateadd(minute,-@mm + (round(@mm/cast(15 as float),0)*15) , @dt ) end go select dbo.roundquarterhour('2009-may-5 20:00') , '00' union all select dbo.roundquarterhour('2009-may-5 20:01') , '01' union all select dbo.roundquarterhour('2009-may-5 20:07') , '07' union all select dbo.roundquarterhour('2009-may-5 20:08') , '08' union all select dbo.roundquarterhour('2009-may-5 20:22') , '22' union all select dbo.roundquarterhour('2009-may-5 20:23') , '23' union all select dbo.roundquarterhour('2009-may-5 20:37') , '37' union all select dbo.roundquarterhour('2009-may-5 20:38') , '38' union all select dbo.roundquarterhour('2009-may-5 20:52') , '52' union all select dbo.roundquarterhour('2009-may-5 20:53') , '53' union all select dbo.roundquarterhour('2009-may-5 20:59') , '59';
select dateadd(minute, datediff(minute,0,getdate()) / 15 * 15, 0);
select dateadd(second, round(datediff(second, '2010-01-01', getdate()) / 30.0, 0) * 30, '2010-01-01');
create function dbo.floortimetoquarters ( @dt as datetime ) as  set @timeasint = ( cast( @dt as float ) * 96 ) end;
set @dt = getdate() select dateadd(minute, 15 * ((60 * datepart(hour, @dt) + case when datepart(second, @dt) < 30 then 7 else 8 end) / 15), dateadd(day, datediff(day, 0, @dt), 0));
select sysdate + interval '1' day from dual;
select sysdate + interval '20' day from dual;
select sysdate + interval '15' minute from dual;
select ( sysdate + n ) from dual;
select (sysdate+2) as new_date from dual;
select trunc(sysdate) + numtodsinterval(:x, 'day') tag from dual;
select enabled&1 from my_table;
select id, hex(enabled) as enabled from my_table;
select enabled+0 from my_table;
select ord(`enabled`) as `enabled` from `my_table`;
values (1,b'1'),(2,b'0');
select id, cast(enabled as unsigned) as enabled from my_table;
if countdata > 999:;
from django.db import connection;
from django.db import connection;
if (count > 0) else {;
select case when columnname is null then 'false' else 'true' end from tablename;
case when columnname is not null then 'true' else 'false' end;
select s.id, s.[name], case when s.achieveddate is not null then 'true' else 'false' end [isachieved] from schools s;
select s.id, s.[name], case when s.achieveddate is not null then 1 else 0 end [isachieved] from schools s;
create function isdatepopulated(@datecolumn as datetime) as begin select @returnbit = case when @datecolumn is null then 0 else 1 end  end;
create view testview as select dbo.isdatepopulated(datedeleted) as [isdeleted] from company;
select realcolumn, cast(0 as bit) as fakebitcolumn from tbltable;
select case when tablename.columnname is null then cast(0 as bit) else cast(1 as bit) end as columnlabel from tablename;
select count(*) as total, sum(iif(name = 'system', 1, 0)) as systemtotal from customertable;
select userid, count('x') as totalcaseid, count(case when name = 'system' then 'x' else null end) as totalrecordswithsystem from customertable;
select count(*),  --total from mytable;
select userid, count(*) as totalcaseid, --total from mytable;
select exp(sum(iif(abs([num])=0,0,log(abs([num])))))*iif(min(abs([num]))=0,0,1)*(1-2*(sum(iif([num]>=0,0,1)) mod 2)) as p from table1;
select exp (sum (ln (table.price))) from table ...;
select grpid, case when minval = 0 then 0 else exp(absmult) end from ( select grpid, --log of +ve row values --count of -ve values. even = +ve result. --anything * zero = zero from mytable grpid;
select @multiplier = isnull(@multiplier, '1') * value from @floats select @multiplier;
select group_concat(table.price) from table group by table.sale;
select unnest(array[2,5,7,8]) select t.c, row_number() over () from t select c, n from r where n = 1 union all select r.c * p.c, r.n from p join r on p.n + 1 = r.n ) select c from p where n = (select max(n) from p);
select 'multiplication', 2 union select 'multiplication', 5 union select 'multiplication', 7 union select 'multiplication', 8 union select 'trivial', 1 union select 'trivial', 8 union select 'negatives work', -2 union select 'negatives work', -3 union select 'negatives work', -5 union select 'look ma, zero works too!', 1 union select 'look ma, zero works too!', 0 union select 'look ma, zero works too!', 2 select t.sale, t.price, row_number() over (partition by sale), count(1) over (partition by sale) from t select sale, price, n, maxn from r where n = 1 union all select p.sale, r.price * p.price, r.n, r.maxn from p join r on p.sale = r.sale and p.n + 1 = r.n ) select sale, price from p where n = maxn;
select unnest(array[2,5,7,8]) select array_agg(c) from t union all select p.a[2:] from p ) select count(*) from p where cardinality(a) = 0;
create table x ( y int not null primary key );
set xact_abort off ; -- > really important to set that to off select @any_error = @@error if @any_error<> 0 and @any_error<>2627 goto errorhandler select @any_error = @@error if @any_error<> 0 and @any_error<>2627 goto errorhandler select @any_error = @@error if @any_error<> 0 and @any_error<>2627 goto errorhandler if @any_error = 0 or @any_error=2627 end else begin end end;
select n.* from union all select 'possibledupeliteral', 'otherfieldvalue2' ) where k.keyfield is null;
create table x( col1.....) constraint [pk_x] primary key clustered ( )with (pad_index  = off, statistics_norecompute  = off, ignore_dup_key = off, allow_row_locks  = on, allow_page_locks  = on, fillfactor = 70) on [primary];
select valueid, valuename where  not exists from   t1 as t2 where  t2.id = valueid and t2.name = valuename);
values (1, 2), (1, 3), (1, 4), (2, 5) select rta.[roleid], rta.[pageid] from @roletoadds rta where not exists;
create table t_random as select s, md5(random()::text) from generate_series(1,5) s;
create table randomtable(id serial primary key, description text);
create or replace function getnarrays(el text[], count int) returns text as $$ select string_agg(el[random()*(array_length(el,1)-1)+1], ' ') from generate_series(1,count) g(i);
select (string_to_array(pg_read_file('words.list')::text,e'\n')) ) select getnarrays(t.ray, 3) from t, generate_series(1,10000);
select [column] from [origindb].[schema].[table];
select * from sometable;
select * from sometable;
select databasepropertyex('master', 'collation');
select serverproperty('collation');
select databasepropertyex('adventureworks', 'collation') sqlcollation;
select table_name, column_name, collation_name from information_schema.columns where table_name = @table_name;
create table mytable ( mycolumn varchar(10) ) set nocount on select mycolumn from mytable where mycolumn='case' select mycolumn from mytable where mycolumn='case' select mycolumn from mytable where mycolumn='case';
select mycolumn from mytable where mycolumn collate latin1_general_cs_as = 'case' select mycolumn from mytable where mycolumn collate latin1_general_cs_as = 'case' select mycolumn from mytable where mycolumn collate latin1_general_cs_as = 'case' select databasepropertyex('<database name>', 'collation');
exec sp_help 'mytable';
alter table mytable alter column mycolumn varchar(10) select mycolumn from mytable where mycolumn='case' select mycolumn from mytable where mycolumn='case' select mycolumn from mytable where mycolumn='case';
alter table mytable alter column mycolumn varchar(10);
select mycolumn from mytable where select mycolumn from mytable where select mycolumn from mytable where;
select name, case when description like '%case-insensitive%' then 0 end iscasesensitive from sys.fn_helpcollations() ) select * from collations where name = convert(varchar, databasepropertyex('yourdatabasename','collation'));
select mycolumn from mytable where mycolumn collate sql_latin1_general_cp1_ci_as = 'case';
select serverproperty('collation');
select databasepropertyex('adventureworks', 'collation') sqlcollation;
select table_name, column_name, collation_name from information_schema.columns where table_name = @table_name;
select name from customer order by name collate latin1_general_cs_ai;
select * from fn_helpcollations();
sqlcommand, new sqlconnection(connectionstring)));
@errnum int, @errseverity int, @errstate int, @errline int, @errproc nvarchar(200) select @errnum = error_number(), @errseverity = error_severity(), @errstate = error_state(), @errline = error_line(), @errproc = isnull(error_procedure(), '-') set @errmsg = n'errline: ' + rtrim(@errline) + ', proc: ' + rtrim(@errproc) + ', message: '+ error_message();
if (@@trancount) > 0 end else begin end  end catch;
end try end catch;
end try select error_number() as errornumber if @@trancount > 0 end catch;
if @@trancount > 0;
create table #temp ( id tinyint not null );
end try @errorseverity int, @errorstate int;
select @errormessage = error_message(), @errorseverity = error_severity(), @errorstate = error_state();
@errormessage, @errorseverity, @errorstate end catch set nocount on select id from #temp drop table #temp;
update dbo.account set balance = balance + cast('ten thousand' as money) where accountid = 1 end try end catch select * from dbo.account with(nolock);
select * from transaction where (card_no='123') and (transaction_date = convert(varchar(10),getdate(),101));
select sum(transaction_amount) from transactionmaste where card_no = '123' and transaction_date = convert(varchar(10),getdate(),111);
select sum(transaction_amount) from transactionmaste where card_no = '123' and transaction_date = convert(varchar(10), getdate(), 120);
select sum(transaction_amount) from transactionmaster where card_no=' 123' and transaction_date =convert(varchar(10), getdate(), 102);
select cast(tstamp as date);
select sum(transaction_amount) from mytable where card_no='123' and cast(transaction_date as date) = target_date;
select sum(transaction_amount) from transactionmaster where card_no ='123' and convert(varchar(10),getdate(),111);
select * from emp where hiredate between to_date (to_char(sysdate, 'yyyy') ||'/09/01', 'yyyy/mm/dd') and to_date (to_char(sysdate, 'yyyy') + 1|| '/08/31', 'yyyy/mm/dd');
select * from t23 where trunc(start_date) between trunc(to_date('01/15/2010','mm/dd/yyyy')) and trunc(to_date('01/17/2010','mm/dd/yyyy'));
select * from <tablename> where start_date between to_date('2010-01-15','yyyy-mm-dd') and to_date('2010-01-17', 'yyyy-mm-dd');
select * from <tablename> where start_date between to_date('15-jan-10','dd-mon-yy') and to_date('17-jan-10','dd-mon-yy');
where trunc(start_date) between to_date('15-jan-10') and to_date('17-jan-10');
where start_date between to_date('15-jan-10') and to_date('17-jan-10') + (86399/86400);
where start_date >= to_date('15-jan-10') and start_date < to_date('18-jan-10');
select * from mytable where start_date between to_timestamp('15-jan-10') and to_timestamp('17-jan-10')+.9999999;
select database_principal_id('role') if database_principal_id('role') is null;
if not exists (select 1 from sys.database_principals where name='role' and type = 'r') create role role end;
select col1, col2, col3 from some_table tabl1 where col1 = 'some' and ( col2 = 'condition' or  col2 = 'other' );
select column1 from tablename where column1 = 'bar' column1;
select t1.col1, t1.col2, t2.col3 from table1 t1 where t1.col1 = 'xxx' and t2.col3 = 'yyy';
select c.id from campaign c join campaign_stats cs join (select _c.id from campaign _c where _c.type = 9) t_c where c.id in (1,2,3) and cs.num_videos > 10;
create proc [dbo].[proctable_sel] as set nocount on select [column1] = t1.[col1] from [dbo].[table] t1 where t1.[col1] = 'xxx' and t2.[col3] = 'yyy' set nocount off;
create proc [dbo].[proctable_upd] as set nocount on update t1 set from [dbo].[table1] t1 where t1.[col1] = 'xxx' and t2.[col3] = 'yyy' set nocount off;
create proc [dbo].[proctable_ins] as set nocount on [column1] ) values ( @value1 ) set nocount off;
create proc dbo.proctable_ins as set nocount on [column1] ) select [column1] = t1.col1 from dbo.table1 t1 where t1.[col1] = 'xxx' and t2.[col3] = 'yyy' set nocount off;
create proc dbo.proctable_del as set nocount on delete from [dbo].[table1] t1 where t1.[col1] = 'xxx' and t2.[col3] = 'yyy' set nocount off;
select company.id as company_id, company.client_name, company.website, office.office_name from company_office with(nolock) where end;
create table #temptable ( col1 int, col2 int, col3 int ) #temptable ( col1, col2, col3 ) select col1, col2, col3 from table3 where col1 = 5 select col2, case when col1 = 3 then 'something' else 'somethingelse' end from #temptable where col1 = 5 and ( col2 = 5 or col3 in ( select field from table2 where somecol = 2 and othercol = 5 ) );
select column1, column2, column3, coalesce(column4, 'foo') as column4 from tablename where column1 = 'bar' column2;
select   column1, column2, column3, coalesce(column4, 'foo') as column4 from     tablename where    column1 = 'bar' column2;
from d in context.dc_tpatient_bookingd join bookingm in context.dc_tpatient_bookingm from m in bookingmgroup.defaultifempty() join patient in dc_tpatient from p in patientgroup.defaultifempty() where d.processid == 6 && select new { d.labid, d.processid, p.prid, p.prno, m.bookingid // need for grouping select g;
from m in data.movies join ma in data.movieactor on m.id equals ma.movieid into mma from ma in mma.defaultifempty() join p in data.people on (ma == null ? 0 : ma.actorid) equals p.id into pma from p in pma.defaultifempty() select new { actor = p != null ? p.name + " as " + ma.name : "" new movie{ id = 2, name= "blade runner", year = 1982}, new movie{ id = 3, name= "star wars: episode iv - a new hope", year = 1977}, new movie{ id = 4, name= "total recall", year = 1990}, new movie{ id = 5, name= "the fugitive", year = 1993}, new movie{ id = 6, name= "men in black", year = 1997}, new movie{ id = 7, name= "u.s. marshals", year = 1998}, new movie{ id = 8, name= "batman", year = 1989}, new movie{ id = 9, name= "a few good men", year = 1992}, new movie{ id = 10, name= "tropic thunder", year = 2008}, new movie{ id = 11, name= "minority report", year = 2002}, new movie{ id = 12, name= "the fifth element", year = 1997}, new movie{ id = 13, name= "district 9", year = 2009}, new movie{ id = 14, name= "12 monkeys", year = 1995}, }, people = new list<person>{ new person{ id = 2, name = "tommy lee jones"}, new person{ id = 3, name = "will smith"}, new person{ id = 4, name = "michael keaton"}, new person{ id = 5, name = "will smith"}, new person{ id = 6, name = "jack nicholson"}, new person{ id = 7, name = "tom cruise"} movieactor = new list<movieactor>{ new movieactor{ movieid = 2, actorid = 1, name = "rick deckard"}, new movieactor{ movieid = 3, actorid = 1, name = "han solo"}, new movieactor{ movieid = 5, actorid = 1, name = "dr. richard kimble"}, new movieactor{ movieid = 5, actorid = 2, name = "samuel gerard"}, new movieactor{ movieid = 6, actorid = 2, name = "kay"}, new movieactor{ movieid = 7, actorid = 2, name = "samuel gerard"}, new movieactor{ movieid = 6, actorid = 3, name = "jay"}, new movieactor{ movieid = 8, actorid = 4, name = "batman / bruce wayne"}, new movieactor{ movieid = 8, actorid = 6, name = "joker / jack napier"}, new movieactor{ movieid = 9, actorid = 6, name = "col. nathan r. jessep"}, new movieactor{ movieid = 9, actorid = 7, name = "lt. daniel kaffee"}, new movieactor{ movieid = 10, actorid = 7, name = "les grossman"}, new movieactor{ movieid = 11, actorid = 7, name = "chief john anderton"};
select date_trunc('day', user_logs.timestamp) "day", count(*) views from user_logs where user_logs.timestamp >= %(timestamp_1)s and user_logs.timestamp <= %(timestamp_2)s;
select * from mytable where dob > '1980-01-01';
select * from mytable where datediff(dob, now()) > 30;
select dateofbirth from customer where dateofbirth  between date('1004-01-01') and date('1980-12-31');
select dateofbirth from customer where date(dateofbirth)>date('1980-12-01');
select * from customer where date(dateofbirth) < date('now','-30 years');
select * from customer where dateofbirth < date('now','-30 years');
select * from mytable where dob < date('now','-30 years');
select sur.* from surname sur;
select sur.* from surname sur;
( 2, 0 ), ( 2, 1 ), ( 4, 1 ), ( 4, 0 ), ( 4, 1 ) select sur.persid, sur.name, sum( cast( bo.bool as int ) ) as [sum], case sum( cast( bo.bool as int ) ) else 0 end as [only one] from @surname as sur left outer join;
select sur.* from surname sur;
select * from all_triggers where table_name = 'your_table';
select * from dba_triggers;
select * from user_triggers;
select * from user_objects where object_type='trigger';
select top 0 * from [dbo].[tablename];
select null where false;
select * from (select null as col0) as inner0 where col0 is not null;
select * from (select null) where 0;
select null limit 0;
select * from (select 1) as tbl where 2=3;
select 1 from dual where false;
select 'myname' as emptycolumn from dual where 'me' = 'funny';
( select idcolumn, somefield, datefield, row_number() over (order by datefield) as rownum from mytable ) select * from cteresults where rownum between 10 and 20;
val varchar(50) ) @page int select  @pagesize = 10, @page = 2 select val, row_number() over(order by val) id from    @table ) select  * from    pagenumbers where   id  between ((@page - 1) * @pagesize + 1) and (@page * @pagesize);
create table #employee (empid int identity, name varchar(20)) set @id = @id + 1 end;
select * from (  select *, pagenumber =  ceiling(cast(empid as float)/@pagesize) from #employee where myquery.pagenumber = 1;
set @rowsperpage=25;
set @pagenum=10;
select top(@rowsperpage * @pagenum) row_number() over (order by id asc) as resultnum, * from employee ) select * from sqlpaging with (nolock) where resultnum > ((@pagenum - 1) * @rowsperpage);
select distinct id,participantid,activitydate,isapproved, isdeclined,isdeleted,submissiondate,    isresubmitted,    row_number() over(order by id desc)   as rownum from activitydate,isapproved, isdeclined,isdeleted, submissiondate, isresubmitted,    row_number() over(order by id desc)   as rownum from asn.participantid,asn.activitydate, asn.isapproved,asn.isdeclined, asn.isdeleted,asn.submissiondate, case when (select count(*) from fds_activitysubmission where parentid=asn.id)>0 then convert(bit, 1) else convert(bit, 0) end isresubmitted,    from fds_activitysubmission asn with (nolock) fds_activitycategory ac with (nolock) fds_approverdetails fdsa fds_activityjobrole faj  users u with (nolock) where isdeclined=@isdeclined and isapproved=@isapproved    and asn.isdeleted=0 and isnull(u.id,0)=isnull(@approverid,0) and isnull(asn.isdeleted,0)<>1)p)t where t.rownum between and t.isdeclined=@isdeclined and t.isapproved=@isapproved and t.isdeleted = 0 and (isnull(t.id,0)=isnull(@submissionid,0)or isnull(@submissionid,0)<=0);
create table vlt ( id int identity(1,1), name nvarchar(50), tel varchar(20) ) values ('name' + convert(varchar(10),@@identity),'famil' +     convert(varchar(10),@@identity));
select data.id, data.name, data.tel from ( select row_number() case when @sortbyfield = 1 and @sortorder = 'asc' then vlt.id end asc, case when @sortbyfield = 1 and @sortorder = 'desc' then vlt.id end desc, case when @sortbyfield = 2 and @sortorder = 'asc' then vlt.name end asc, case when @sortbyfield = 2 and @sortorder = 'desc' then vlt.name end asc, case when @sortbyfield = 3 and @sortorder = 'asc' then vlt.tel end asc, case when @sortbyfield = 3 and @sortorder = 'desc' then vlt.tel end asc from vlt where ( -- we apply the filter logic here case when @filtertype = 'none' then 1 and ( -- in this case, when the filter value is empty, we want to show everything. or @filtervalue = '' and ( -- in this case, when the filter value is empty, we want to show everything. or @filtervalue = '' and vlt.id = @filtervalue then 1 and vlt.id <> @filtervalue then 1 and ( -- in this case, when the filter value is empty, we want to show everything. or @filtervalue = '' and ( -- in this case, when the filter value is empty, we want to show everything. or @filtervalue = '' and vlt.name = @filtervalue then 1 and vlt.name <> @filtervalue then 1 and ( -- in this case, when the filter value is empty, we want to show everything. or @filtervalue = '' and ( -- in this case, when the filter value is empty, we want to show everything. or @filtervalue = '' and vlt.tel = @filtervalue then 1 and vlt.tel <> @filtervalue then 1 end ) = 1 where data.rownum > @pagesize * (@pagenumber - 1) and data.rownum <= @pagesize * @pagenumber;
as ( select row_number() case when @sortbyfield = 1 and @sortorder = 'asc' then vlt.id end asc, case when @sortbyfield = 1 and @sortorder = 'desc' then vlt.id end desc, case when @sortbyfield = 2 and @sortorder = 'asc' then vlt.name end asc, case when @sortbyfield = 2 and @sortorder = 'desc' then vlt.name end asc, case when @sortbyfield = 3 and @sortorder = 'asc' then vlt.tel end asc, case when @sortbyfield = 3 and @sortorder = 'desc' then vlt.tel end asc from vlt where ( -- we apply the filter logic here case when @filtertype = 'none' then 1 and ( -- in this case, when the filter value is empty, we want to show everything. or @filtervalue = '' and ( -- in this case, when the filter value is empty, we want to show everything. or @filtervalue = '' and vlt.id = @filtervalue then 1 and vlt.id <> @filtervalue then 1 and ( -- in this case, when the filter value is empty, we want to show everything. or @filtervalue = '' and ( -- in this case, when the filter value is empty, we want to show everything. or @filtervalue = '' and vlt.name = @filtervalue then 1 and vlt.name <> @filtervalue then 1 and ( -- in this case, when the filter value is empty, we want to show everything. or @filtervalue = '' and ( -- in this case, when the filter value is empty, we want to show everything. or @filtervalue = '' and vlt.tel = @filtervalue then 1 and vlt.tel <> @filtervalue then 1 end ) = 1 ) select data.id, data.name, data.tel from data_cte as data where data.rownum > @pagesize * (@pagenumber - 1) and data.rownum <= @pagesize * @pagenumber;
create table test(id integer);
select * from ( select top 2 * from ( select  top (4) * from test;
select * from tablename where  rownum >= 1 and rownum < 20;
select s.token, flag from   tbl t, unnest(string_to_array(t.subject, ' ')) s(token) where  flag = 2;
select unnest(string_to_array(subject, ' ')) as "token", flag from test;
set @sql = 'select 1 union select 2' set @rowcount = @@rowcount select @rowcount;
select 1 from dbo.comm_services;
from dbo.comm_services where companyid = ' + cast(@companyid as char) + ' and ' + @condition;
create proc sp_count @codition sysname as set nocount on create table #ctr select    @vcsql = ' insert #ctr from dbo.comm_services where companyid = '+@companyid+' and '+@condition+')' exec      (@vcsql) if @@error = 0 select    @intcount = numrows from #ctr drop table #ctr end else begin drop table #ctr end go;
exec sp_executesql n'select @rowcount=count(*) from anytable', n'@rowcount int output', @rowcount output;
exec (n'select count(*) from anytable');
update "user" set balance = 15000.000000000 where id = 11203;
update "user" set balance = 15000.000000000 where id = 11203;
@table_id int, @col_id int set @sql = 'select ' select @table_id = id from sysobjects where name = 'my_table' select @col_id = min(colid) from syscolumns where id = @table_id and name <> 'description' select @sql = @sql + name from syscolumns where id = @table_id and colid = @col_id select @col_id = min(colid) from syscolumns where id = @table_id and colid > @col_id and name <> 'description' if (@col_id is not null) set @sql = @sql + ',' end  set @sql = @sql + ' from my_table' exec @sql;
set @sql = 'select ' set @table = 'table_name' select @sql = @sql + '[' + column_name + '],' from   information_schema.columns where  table_name = @table and column_name <> 'omitted_column_name' set    @sql = substring(@sql,1,len(@sql)-1) + ' from ' + @table exec (@sql);
create table t1 c2 char(10) implicitly hidden, c3 timestamp) in db.ts;
select @sql = coalesce(@sql + ', ', ' ' ) + name from sys.columns where name <> 'colname' and object_id = (select id from sysobjects where name = 'tblname') select @sql = 'select ' + @sql + ' from ' + 'tblname' exec sp_executesql  @sql;
alter procedure [dbo].[usp_selectallexcept] ( @tblname sysname ) as  select @sql = coalesce(@sql + ', ', ' ' ) + name from sys.columns where name <> @exception and object_id = (select id from sysobjects where name = @tblname) select @sql = 'select ' + @sql + ' from ' + @tblname exec sp_executesql @sql;
alter procedure [dbo].[_getlineexceptcol] @schema sysname, @lineid int, @exception varchar(500) as  set nocount on;
select @sql = coalesce(@sql + ', ', ' ' ) + name from sys.columns where name <> @exception and object_id = (select object_id from sys.objects where name like @table and schema_id = (select schema_id from sys.schemas where name like @schema)) select @sql = 'select ' + @sql + ' from ' + @schema + '.' + @table + ' where id = ' + cast(@lineid as nvarchar(50)) end go;
select * into #temptable from table  alter table #temptable drop column [columnname] select * from #temptable;
"foobar12" as item_name, 800 as quantity) select * except (order_id) from orders;
create package skip_col_pkg as col        dbms_tf.columns_t) type_name varchar2, flip      varchar2 default 'false') type_name        varchar2, flip             varchar2 default 'false') end skip_col_pkg;
create package body skip_col_pkg as col        dbms_tf.columns_t) as new_cols dbms_tf.columns_new_t;
type_name        varchar2, flip             varchar2 default 'false') as typ constant varchar2(1024) := upper(trim(type_name));
case upper(substr(flip,1,1)) else          dbms_tf.column_type_name(tab.column(i).description) end /* case */;
end skip_col_pkg;
select * from skip_col_pkg.skip_col(scott.dept, 'number');
select * from skip_col_pkg.skip_col(scott.dept, 'number', flip => 'true') select * from skip_col_pkg.skip_col(scott.emp, columns(comm, hiredate, mgr)) where deptno = 20;
select 5 as order_id, "sprocket" as item_name, 200 as quantity ) select * except (order_id) from orders;
select * except (col1, col2, ...);
select `(ds|hr)?+.+` from sales;
update your_table set likes = null;
update your_table set likes = '';
update your_table set likes = null where 1 = 1;
update your_table set likes = null where likes is not null;
select a.col1, b.col2, a.col3, b.col4, a.category_id from items_a a, items_b b where a.category_id = b.category_id;
select coalesce(a.col1, b.col1) as col1, coalesce(a.col2, b.col2) as col2, coalesce(a.col3, b.col3) as col3, a.category_id from items_a a, items_b b where a.category_id = b.category_id;
select category_id, col1, col2, col3 from items_a union select category_id, col1, col2, col3 from items_b;
select category_id, col1, col2, col3 from items_a union select category_id, col_1 as col1, col_2 as col2, col_3 as col3 from items_b;
select a.col1, b.col2, a.col3, b.col4, a.category_id from ( select category_id from a union select category_id from b;
select col1, col2 from (select rownum x,col_table1 from table1) t1 (select rownum y, col_table2 from table2) t2;
select * from crosstab( $$select user_id, user_name, rn, email_address from  ( select u.user_id, u.user_name, e.email_address from   usr u where  rn < 4;
select <select_list> from tablea a where a.key not in (select b.key from tableb b);
and self1.type = self2.type;
select trecord from `tbl` where (trecord regexp '^ala[0-9]');
where regexp_like(column, 'regex.*');
select * from reservations where arrival >= '2012-01-01' and arrival < '2013-01-01';
create index arrival_year on reservations ( extract(year from arrival) );
select * from reservations where extract(year from arrival) = 2012;
select * from "tablename" e where timestamp >= '2020-08-08t13:00:00' and timestamp < '2020-08-08t17:00:00';
create procedure export_dynamic(in file_name char(64)) set @myvar = concat('select * into outfile ',"'",file_name,"'",' from table1') ;
create procedure backupcsv() select * into outfile '/home/sites/example.com/www/files/backup.csv' from ( ....;
select * into outfile '/home/sites/example.com/www/files/backup.csv';
select fielda, fieldb from table;
select fielda, fieldb from ( select fielda, fieldb, row_number() over (order by fielda) rowrank from table_name ) where rowrank between 5 and 14;
select t.* from ( select t.*, rownum as rowindex from ( select fielda, fieldb, from table_name where rowindex > 0 and rowindex <= 20;
select fielda,fieldb from table;
select fielda, fieldb from (select fielda, fieldb, row_number() over (order by fielda) rnk from table_name) where rnk between 5 and 14;
( studentid ) ( studenttypeid );
exec sp_addtype t_myudt_tmp, 'numeric(18,5)', null select 'alter table dbo.' + table_name + from information_schema.columns where domain_name = 't_myudt' exec sp_droptype t_mydut exec sp_rename 't_myudt_tmp', 't_myudt', 'userdatatype';
set nocount on set @udt = 'name' -- existing uddt set @udtschema = 'dbo' -- schema of the uddt set @newudtdatatype = 'varchar' -- data type for te new uddt set @newudtdatasize = 500 -- lenght of the new uddt set @newudtschema = 'dbo' -- schema of the new uddt set @otherparameter = ' null' -- other parameters like null , not null @datasize smallint @tablename varchar(50), @filedname varchar(50) create table #udtflds ( schemaname varchar(50), tablename varchar(50), filedname varchar(50) ) select top 1 @datasize = character_maximum_length from    information_schema.columns where   domain_name = @udt and domain_schema = @udtschema set @varchardatatype = @datatype if @datatype like '%char%' and @datasize is not null and ( @newudtdatatype <> 'varchar(max)' or @newudtdatatype <> 'nvarchar(max)' ) set @varchardatatype = @varchardatatype + '(' end  select  table_schema, table_name, column_name from    information_schema.columns where   domain_name = @udt and domain_schema = @udtschema tablename, filedname from    #udtflds set @exec = 'alter table ' + @schemaname + '.' + @tablename ) end  set @exec = 'drop type [' + @udtschema + '].[' + @udt + ']' exec ( @exec ) set @varchardatatype = @newudtdatatype if @newudtdatatype like '%char%' and @newudtdatasize is not null and ( @newudtdatatype <> 'varchar(max)' or @newudtdatatype <> 'nvarchar(max)' ) set @varchardatatype = @varchardatatype + '(' end  set @exec = 'create type [' + @newudtschema + '].[' + @udt + '] from ' exec ( @exec ) set @exec = 'alter table ' + @schemaname + '.' + @tablename ) end  select  * from    #udtflds drop table #udtflds;
exec sp_rename 'prizetype', 'prizetypeold', 'userdatatype';
create type [dbo].[prizetype] as table( [type] [nvarchar](50) not null, [description] [nvarchar](max) not null, [imageurl] [varchar](max) null select specific_name from information_schema.routines where routine_type = 'procedure' exec sp_refreshsqlmodule @sprocname end close sprocs drop type prizetypeold;
exec recreate_type @schema='dbo', @typ_nme='typ_foo', @sql='as table([bar] varchar(10) not null)';
create procedure [dbo].[recreate_type] as declare @typ_id     bigint, @temp_nme   varchar(1000), @msg        varchar(200) select @scid = [schema_id] from sys.schemas where upper(name) = upper(@schema);
if (@scid is null) begin set @msg = 'schema ''' + @schema + ''' not found.';
select @typ_id = system_type_id from sys.types where upper(name) = upper(@typ_nme);
set @temp_nme = @typ_nme + '_rcrt'; -- temporary name for the existing type if (@typ_id is not null) begin exec sp_rename @objname=@typ_nme, @newname= @temp_nme, @objtype='userdatatype' set @sql = 'create type ' + @schema + '.' + @typ_nme + ' ' + @sql;
exec sp_sqlexec @sql;
if (@typ_id is not null) begin exec recompile_prog;    -- then recompile all stored procs (that may have used the type) exec sp_droptype @typename=@temp_nme;   -- and drop the temporary type which is now no longer referenced end  create procedure [dbo].[recompile_prog] as begin set nocount on;
@v(spname) select '[' + s.[name] + '].[' + items.name + ']' from (select sp.name, sp.schema_id, sp.is_ms_shipped from sys.procedures sp union select so.name, so.schema_id, so.is_ms_shipped from sys.objects so where so.type_desc like '%function%') items where is_ms_shipped = 0;
select @cnt = 1;
select @tot = count(*) from @v;
select @spname = spname from @v where recid = @cnt;
exec sp_refreshsqlmodule @spname end try end catch set @cnt = @cnt + 1;
select  id from   [external_table] select data from     [external_table] where id = @outerid end close my_cursor;
create table #temp1 ( id int identity(1,1), name varchar(50), profession varchar(50) );
create table #temp2 ( id int identity(1,1), name varchar(50), profession varchar(50) );
select 'shekhar','it';
select [data] from [external_table];
from [external_table];
values (s.[col1]);
select [data] from [external_table] source;
select map.destid, source.[more data] from [external_table] source;
else into dept_west(deptno, dname, loc) values(deptno, dname, loc) select deptno, dname, loc from dept;
create table [dbo].[table1] ( [id] [int] identity(1,1) not null, [data] [varchar](255) not null, constraint [pk_table1] primary key clustered ([id] asc), joinguid uniqueidentifier null ) create table [dbo].[table2] ( [id] [int] identity(1,1) not null, [table1_id] [int] null, [data] [varchar](255) not null, constraint [pk_table2] primary key clustered ([id] asc), joinguid uniqueidentifier null ) update b set table1_id = a.id from table1 a join table2 b on a.joinguid = b.joinguid where b.table1_id is null update table1 set joinguid = null update table2 set joinguid = null;
select convert(nvarchar(6), getdate(), 112);
select left(convert(varchar, getdate(),112),6);
select format(getdate(),'yyyymm');
select yyyymm = (year(getdate()) * 100) + month(getdate());
select right('0000' + cast(datepart(year, getdate()) as varchar(4)), 4);
select time_to_sec(timediff('2010-09-01 03:00:00', '2010-09-01 00:10:00' )) / 3600;
select time_format(timediff(onedateinstring,anotherdateinstring),'%h:%i:%s');
select abs(time_to_sec(timediff('2010-09-01 03:00:00', '2010-09-01 00:10:00')) / 3600);
select (unix_timestamp(end)-unix_timestamp(start))/3600 as difference_in_hours from table;
select b.`start_date`, b.`end_date`, timestampdiff(hour, b.`start_date`, b.`end_date`) as `hours` from my_table b;
select timestampdiff(second,'2010-09-01 00:10:00', '2010-09-01 03:00:00')/3600;
select timestampdiff(hour, '2010-11-29 13:13:55', '2010-11-29 13:16:55') as newtable;
"@surgerydate", somedate == null ? dbnull.value : (object)somedate;
if (somedate == null);
if (value == null) else return collection.addwithvalue(parametername, value);
if (enddate != null);
alter sequence ps_log_seq restart start with 20071;
select  level, sequence.nextval from  dual;
create or replace procedure set_seq_to(p_name in varchar2, p_val in number) as l_num   number;
if (p_val - l_num - 1) != 0 then execute immediate 'alter sequence ' || p_name || ' increment by ' || (p_val - l_num - 1) || ' minvalue 0';
create or replace procedure set_seq_to_data(seq_name in varchar2, table_name in varchar2, col_name in varchar2) as nextnum   number;
alter sequence mysequence increment by 100;
select mysequence.nextval from dual;
alter sequence mysequence increment by 1;
select max(pk_val) into last_used from your_table;
select your_seq.nextval into curr_seq from dual;
if curr_seq >= last_used then exit;
alter table tbl modify ("id" number(13,0) generated by default on null as identity minvalue 1 maxvalue 9999999999999999999999999999 increment by 1 start with 3580 not null enable);
end transaction;
select * from table-that-does-not-exist;
select * from good-table;
select * from table-that-does-not-exist select * from good-table;
create procedure spmyproc as declare @myotherparam int = 5 update tmytable set myvar = @myprocparam, mysecondvar = @myotherparam;
create table test=> select * from moo;
select * from table_name where "foo" is null;
select '"' || attname || '"', char_length(attname) from pg_attribute where attrelid = 'table_name'::regclass and attnum > 0;
create table test=# select * from t where alpha is null;
create table your_table ( "foo " -- ... );
select ... from your_table where "foo " is not null;
select anid from test;
table "public.test" column |       type        | modifiers;
alter table test add column "anid" integer;
alter table test alter column "anid" set not null;
select * from table_name where "foo" is null;
select id, "foo" from table_name;
select * from users where email = "user@gmail.com";
select * from users where email = 'user@gmail.com';
select 1 from dual;
select v.name from information_schema.views iv join sys.views v on v.name = iv.table_name where iv.table_catalog = 'your database name';
select s.name +'.'+v.name from sys.views v inner join sys.schemas s on s.schema_id = v.schema_id;
select schema_name(schema_id) as schema_name from sys.views;
select sm.definition from sys.sql_modules sm where so.type = 'v';
select sch.name as view_schema from sys.all_views as sysv where (1=1) and (sysv.type = 'v') -- seems unnecessary, but who knows and sysv.is_ms_shipped = 0 and not exists ( select * from sys.extended_properties as syscrap where syscrap.major_id = sysv.object_id and syscrap.minor_id = 0 and syscrap.class = 1 and syscrap.name = n'microsoft_database_tools_support' ) view_schema;
select  * from    sys.objects where   type = 'v';
select table_name, row_number() over(order by table_name) as 'rownumber' from information_schema.views where table_catalog = 'databasename';
select table_name, row_number() over(order by table_name) as 'rownumber' from information_schema.views;
select * from sys.views;
select 1 from a select 0 from a select * from a;
select 1 from a will give you select 0 from a will give you select * from a will give you ( assume two columns x and y is in the table );
select count(y) from a;
select col_a from table;
select count(col_a) from table;
select count(*) from table;
select count(*) from t;
select count(1) from t;
select t.ctn_no from your_table t having count(t.ctn_no) > 1;
select t.ctn_no from your_table t where t.s_ind = 'y' having count(t.ctn_no) > 1;
select x.* from your_table x join (select t.ctn_no from your_table t having count(t.ctn_no) > 1) y on y.ctn_no = x.ctn_no;
select * from ( select sum(1) over(partition by ctn_no) cnt, a.* from table1 a where s_ind ='y' ) where cnt > 2;
select col1 as o, e = case when o < getdate() then o else getdate() end from table1;
select *, case when a = 'test' then 'yes' end as value from ( select col1 as a from table;
select col1 as a, case when a = 'test' then 'yes' end as value from table;
select case when a = 'test' then 'yes' end as value from (select col1 as a from table);
select t.col1 as a, case when t.col1 = 'test' then 'yes' end as value from table t;
select c1, c2, c3, c4, ((c2-c4)*(3))+c1 as "complex" from realtable1) select case complex when 0 then 'empty' else 'not empty' end as formula1, complex * complex as formula2 from localview1) select * from localview2;
select col1 as a, case when col1 = 'test' then 'yes' end as value from table;
select col1 as a, (case when col1 = 'test' then 'yes' end) as value from table;
select a as [blabla a], b [blabla b], case c else 'unknown' end as [my alias], d as [blabla d] from mytable;
select * from from table) as tmp_table case when @sortby  = 1 then tmp_table.alias_col end asc;
select t.col1 as a, case when t.col1 = 'test' then 'yes' end as value from table t;
select xmlcolumnname.value('(xmlpathoftag)[1]', 'varchar(max)') as xmltagalias from table;
select columnnameshow = (case tipoventa else 'no result';
create view widget_sb as select * from widget where column = cast(current_setting('mydomain.myparam') as int) set mydomain.myparam = 0 select * from widget_sb set mydomain.myparam = 1 select * from widget_sb;
select   p.param_label, p.param_graphics_label from   parameters p where exists ( select 1 from parameter_links pl where pl.parameter_id = p.id and exists (select 1 from regions r where r.region_id = pl.region_id;
create or replace function label_params(parm1 text, parm2 text) as $body$ select ... where region_label = $1 and model_id = (select model_id from models where model_label = $2);
select * from label_params('foo', 'bar');
and model_id = (select model_id from models where model_label = $2);
and model_id in (select model_id from models where model_label = $2);
create or replace function param_labels(_region_label text, _model_label text) select p.param_label, p.param_graphics_label from   parameters      p join   parameter_links l using (param_id) join   regions         r using (region_id) join   models          m using (model_id) where  p.active and    r.region_label = $1 and    m.model_label = $2;
select distinct p.param_graphics_label, p.param_label;
where  p.active = 'true';
where  p.active;
select * from my_table where to_char(my_table.my_date_col,'mm/dd/yyyy') = '8/3/2010';
select * from t1 where to_date(date_column)='8/3/2010';
where your_date >= to_date('2010-08-03', 'yyyy-mm-dd') and your_date <  to_date('2010-08-04', 'yyyy-mm-dd');
where your_date between to_date('2010-08-03', 'yyyy-mm-dd') and to_date('2010-08-03 23:59:59', 'yyyy-mm-dd hh24:mi:ss');
where trunc(your_date) = to_date('2010-08-03', 'yyyy-mm-dd');
create index trunc_date_idx on t1(trunc(your_date));
select * from t1 where date(col_name)="8/3/2010";
select * from   t1 where  date between trunc( :somedate )          -- 00:00:00 and     trunc( :somedate ) + .99999 -- 23:59:59;
select extract(month from date_created), sum(num_of_pictures) from pictures_table;
select to_char(date_created, 'yyyy-mm'), sum(num_of_pictures) from pictures_table;
select extract(year from date_created) as yr, extract(month from date_created) as mon, sum(num_of_pictures) from pictures_table;
select  cast(datepart(month, datetyme) as varchar) +'/'+;
select fk_items,sum(poiquantity) quantity  from purchaseorderitems poi;
select year(date_created) [year], month(date_created) [month], datename(month,date_created) [month name], sum(num_of_pictures) [pictures count] from pictures_table datename(month, date_created);
select * from (select year(date_created) [year], datename(month, date_created) [month], sum(num_of_pictures) [pictures count] from pictures_table datename(month, date_created)) as montlysalesdata [june],[july],[august],[september],[october],[november], [december])) as mnamepivot;
create table [dbo].[phone] ( phone1 varchar(500) collate sql_latin1_general_cp1_ci_as constraint uq1 unique, phone2 varchar(500) collate latin1_general_ci_as constraint uq2 unique, );
select phone1 from [dbo].[phone] where phone1 = n'5554474477';
select phone2 from [dbo].[phone] where phone2 = n'5554474477';
select * from [dbo].[phone] where phone = n'5554474477';
select * from [dbo].[phone] where cast(phone as nvarchar) = n'5554474477';
select * from [dbo].[phone] where phone = '5554474477';
select * from [dbo].[phone] where phone = cast(n'5554474477' as varchar(20));
where columnname like '%'+columnname+'%';
select * from list1 l, list2 ll where l.name like "%"||ll.alias||"%";
select * from table1 t1, table2 t2 where t1.a like ('%' || t2.b || '%');
where table1.x like table2.y + '%';
select * from table1,table2 where table1.x like table2.y + '%';
select * from table1,table2 where table1.x like concat(table2.y, '%');
set @lkeselect = (select top 1 <column> from <table> where <column> = 'value') set @lkeval = '%' + @lkeselect select * from <table2> where <column2> like(''+@lkeval+'');
set nocount on exec xp_fileexist @fullpath, @isexists out if @isexists = 1 else print @fullpath + char(9) + char(9) + 'file does not exists' end close cur;
create proc getfilestatus as set nocount on create table #tempfilestatus(filepath varchar(300),filestatus varchar(30)) exec xp_fileexist @fullpath, @isexists out if @isexists = 1 else insert into #tempfilestatus values(@fullpath,'file does not exists') end close cur select * from #tempfilestatus drop table #tempfilestatus end;
exec getfilestatus;
set @count=1 set @inputfile =(select filepath from yourtable where id=@count) exec master.dbo.xp_fileexist @inputfile , @isexists output select @count,@inputfile ,case @isexists else 'no' end as isexists set @count=@count+1 end;
create function dbo.fn_fileexists(@path varchar(512)) as begin exec master.dbo.xp_fileexist @path, @result output;
select * from dbo.mytable where isexists = 1;
select id, filename, dbo.fn_fileexists(filename) as isexists from dbo.mytable;
set nocount on select @filename = n'logisetup.log' select @filefullpath = n'c:\logisetup.log' create table #dir select @cmd = 'dir ' + @filefullpath exec master.dbo.xp_cmdshell @cmd if exists (select * from #dir where output like '%'+ @filename +'%') end else begin end  drop table #dir;
sqlalchemy.column('id', sqlalchemy.integer, primary_key=true), sqlalchemy.column('name', sqlalchemy.string(100)), sqlalchemy.column('email', sqlalchemy.string(100)), sqlalchemy.column('enrolled', sqlalchemy.date) );
:adapter => "mysql", :database => "database_name", :username => "root", :password => "", :host => "localhost" );
:database => 'database_name', :username => 'root', :password => '', :host     => 'localhost' :database => 'db/development.sqlite3' end  end  end;
select json_object('id', id, 'book', book) from books;
"book": "book1" { "book": "book2" { "book": "book3";
from contextlib import closing from datetime import datetime if isinstance(thing, datetime):;
select json_array( group_concat(json_object( name, email)) from .... where ...;
"email": "someone@somewhere.net" { "email": "something@someplace.com";
:host => 'your_host', `enter code here` :username => 'your_username', :password => 'your_password') end };
select     * from         vw_view;
select * from vw_view convert(datetime, eventdate,101)  desc;
where isdate(eventdate) = 1;
case when isdate(eventdate) = 1 then convert(datetime, eventdate,101) else null end desc;
update `tbl1` as `dest`, (select * from tbl2) as `src` set dest.field=src.field, dest.field=if (length(src.field)>0,src.field,dest.field) /* or anything like that*/ where `dest`.id = `src`.id;
if (typeof str != 'string') case "\0": case "\x08": case "\x09": case "\x1a": case "\n": case "\r": case "\"": case "'": case "\\": case "%": // and double/single quotes;
case "\0": case "\x08": case "\x09": case "\x1a": case "\n": case "\r": case "\"": case "'": case "\\": case "%": // and double/single quotes;
case "\0": case "\n": case "\r": case "\b": case "\t": case "\x1a": case "'": case '"':;
update t set columnx = columnx + 1;
select max(col) from tablename;
create trigger stmt_level_trigger update highschooler set grade = null where grade = 13;
create trigger row_level_trigger update highschooler set grade = null where new.id = highschooler.id;
update tbl x set    tbl_id = 23 from   tbl y                -- using the from clause where  x.tbl_id = y.tbl_id  -- must be unique not null and    x.tbl_id = 3;
unique not null;
update tbl x set    tbl_id = 24 from  (select tbl_id, name from tbl where tbl_id = 4 <b>for update</b>) y where  x.tbl_id = y.tbl_id;
unique not null;
update users set email = 'new@gmail.com' where id = 1;
select email from users where id = 1 ) update users set email = 'new@gmail.com' where id = 1;
select tbl_id, name from tbl where tbl_id = 3  -- assuming unique tbl_id ) update tbl set name = 'new guy' where tbl_id = 3 ) select s.tbl_id as old_id, s.name as old_name from   sel s, upd u;
select chargenum, categoryid, sum(hours) from knownhours union all select chargenum, 'unknown' as categoryid, sum(hours) from unknownhours;
select  chargenum, categoryid, sum(hours) from    ( select  chargenum, categoryid, hours from    knownhours union select  chargenum, 'unknown' as categoryid, hours from    unknownhours;
majorname       varchar(50) not null, subname        varchar(50) not null, detailedname    varchar(50) not null, universityid    smallint not null, statisticvalue  decimal(9,3), primary key (majorname, subname, detailedname, universityid);
select col1, listagg(col2, ', ') within group (order by col2) "names" from table_x;
create or replace function get_comma_separated_value (input_val  in  number) end loop;
select col1, get_comma_separated_value(col1) from table_name;
select col1, group_concat(col2) from table_name group by col1;
exec sp_addextendedproperty @level0type = n'schema',   @level0name = 'yourschema', @level1type = n'table',    @level1name = 'yourtable', @level2type = n'column',   @level2name = 'yourcolumn';
exec sys.sp_addextendedproperty @name = n'ms_description', @value = n'extended description', @level0type = n'schema', @level0name = n'dbo', @level1type = n'table', @level1name = n'table_1', @level2type = n'column', @level2name = n'asdf';
exec sys.sp_addextendedproperty;
select top 1 * from table1;
create procedure ... as begin select ... from a where ... end;
alter table <tablename> rename <oldcolumn> to <newcolumn>;
alter table <tablename> alter column <columnname> type <newtype>;
alter table <tablename> alter column <columnname> type <newtype>;
alter table <tablename> alter [ column ] column [ set data ] type data_type [ collate collation ] [ using expression ];
update p set p.extrasprice = t.sumprice from bookingpitches as p ( select pitchid, sum(price) sumprice from bookingpitchextras where [required] = 1 where p.bookingid = 1;
update p set extrasprice = sub.totalprice from (select pitchid, sum(price) totalprice from  dbo.bookingpitchextras where [required] = 1 where p.bookingid = 1;
update p set extrasprice = e.totalprice from dbo.bookingpitches as p from bookingpitchextras as bpe where bpe.[required] = 1 where p.bookingid = 1;
update p set extrasprice = t.totalprice from bookingpitches as p inner join ( select pitchid, sum(price) totalprice from bookingpitchextras;
update t1 set t1.extrasprice = (select sum(t2.price) from bookingpitchextras t2 where t2.pitchid = t1.id) from bookingpitches t1;
update bookingpitches as p set extrasprice = t.sumprice from ( select pitchid, sum(price) sumprice from bookingpitchextras where [required] = 1 where t.pitchid = p.id and p.bookingid = 1;
select pitchid, sum(price) someprice from bookingpitchextras where [required] = 1 update p set p.extrasprice=cte.someprice from bookingpitches p inner join cte on p.id=cte.pitchid where p.bookingid=1;
select status, * from workitems t1 where  exists (select 1 from workitems t2 where t1.textfield01=t2.textfield01 and (boolfield05=1) ) and timestamp=(select max(t2.timestamp) from workitems t2 where t2.textfield01=t1.textfield01) and timestamp>'2009-02-12 18:00:00' union  select 'deleted', * from workitems t1 where  exists (select 1 from workitems t2 where t1.textfield01=t2.textfield01 and (boolfield05=1) ) and timestamp=(select max(t2.timestamp) from workitems t2 where t2.textfield01=t1.textfield01) and timestamp>'2009-02-12 18:00:00' and not (boolfield05=1);
select 'test1', * from table where ccc='d' and ddd='x' and exists(select ...) union select 'test2', * from table where ccc<>'d' and ddd='x' and exists(select ...);
select case when ccc='d' and ddd='x' and exists(select ...) then 'test1' * from table where (ccc='d' and ddd='x' and exists(select ...)) or;
select case when ccc='d' then 'test1' else 'test2' end, * from table where (ccc='d' and ddd='x') or (ccc<>'d' and ddd='x');
select case when boolfield05 = 1 then status else 'deleted' end as mystatus, t1.* from workitems t1 where (textfield01, timestamp) in( select textfield01, max(timestamp) from workitems t2 ) and timestamp > '2009-02-12 18:00:00';
select * from ( select case when boolfield05 = 1 then status else 'deleted' end as mystatus, t1.*, row_number() over (partition by textfield01 order by timestamp desc) as rn from workitems t1 where rn = 1;
( select 'ok', * from workitems t1 where exists(select 1 from workitems t2 where t1.textfield01=t2.textfield01 and (boolfield05=1) ) and timestamp=(select max(t2.timestamp) from workitems t2 where t2.textfield01=t1.textfield01) and timestamp>'2009-02-12 18:00:00' and (boolfield05=1) ) union ( select 'del', * from workitems t1 where exists(select 1 from workitems t2 where t1.textfield01=t2.textfield01 and (boolfield05=1) ) and timestamp=(select max(t2.timestamp) from workitems t2 where t2.textfield01=t1.textfield01) and timestamp>'2009-02-12 18:00:00' and not (boolfield05=1) );
select case when then 'ok' else 'del' * from workitems t1 where exists(select 1 from workitems t2 where t1.textfield01=t2.textfield01 and (boolfield05=1) ) and timestamp=(select max(t2.timestamp) from workitems t2 where t2.textfield01=t1.textfield01) and timestamp>'2009-02-12 18:00:00';
select t1.* from (select * from table where ccc<>'d' and ddd='x') as t2;
create type [dbo].[itemlist] as table([item] [varchar](255) null);
.direction = data.parameterdirection.input, .parametername = "@invoices", .typename = "dbo.itemlist", .value = invoices}) end with;
create type [dbo].[mydatatype] as table ( id int, name nvarchar(50) );
create procedure [dbo].[myprocedure] ( @mydata as [dbo].[mydatatype] readonly ) as  select * from @mydata end;
select e3.user_id, max(e3.purchased) as purchased, e3.spent, e.event from events e (select min(e1.created_at) as spent, e2.created_at as purchased from events e1 (select e.user_id, e.created_at from events e where e.event = 'a') e2 and e1.created_at >= e2.created_at and e1.event != 'a';
create table events (user_id int ,created_at int, event varchar(255));
create table a ( a_id integer primary key, xfr_date date not null create table b ( a_id integer not null references a (a_id), recd_date date not null, units_recd integer not null check (units_recd >= 0), primary key (a_id, recd_date) select a.a_id, a.xfr_date, sum(b.units_recd) from a;
if parser.check_syntax(sql2) != 0: if qcolumn.aliasclause: select a.a, replace(coalesce(a.b, 'x'), 'x', 'y') as jim, a.bla as sally  -- some comment from table_a as a where c > 20;
select convert(substring(score, 1, locate('-',score) - 2) using integer) as score_host, convert(substring(score, locate('-',score)+2) using integer) as score_guest from ...;
create function split_string(str varchar(255), delim varchar(12), pos int) char_length(substring_index(str, delim, pos-1)) + 1), delim, '');
select split_string('apple, pear, melon', ',', 1);
create procedure explode( pdelim varchar(32), pstr text) drop table if exists temp_explode;
create temporary table temp_explode (id int auto_increment primary key not null, word varchar(40));
set @sql := concat('insert into temp_explode (word) values (', replace(quote(pstr), pdelim, '\'), (\''), ')');
set @str  = "the quick brown fox jumped over the lazy dog";
set @delim = " ";
select id,word from temp_explode;
select concat( substring_index(score1, '-', 1), substring_index(score1,'-',-1) concat( substring_index(score2, '-', -1), substring_index(score2, '-', 1) from test having my_score1=my_score2;
create function explode_and_loop(sep varchar(),inputstring varchar()) returns varchar() set returnstring = '';
set partscnt = ((length(inputstring ) - length(replace(inputstring,sep,''))) div length(sep);
set cnt = cnt + 1;
set part = substring_index(substring_index(inputstring ,sep,cnt),sep,-1);
set returnstring = concat(returnstring,'<li>',part,'</li>') end while;
select substring_index('value1,value2', ',', 1) into @var1;
select substring_index('value1,value2', ',', -1) into @var2;
create function split_string(str varchar(255) charset utf8, delim varchar(12), pos int) returns varchar(255) charset utf8 char_length(substring_index(str, delim, pos-1)) + 1), delim, '');
substring_index(substring_index(`tblname`.`tblfield`, '|', 2), '|', -1) as gpm, substring_index(substring_index(`tblname`.`tblfield`, '|', 3), '|', -1) as liquid;
select table_key, field_1, field_2, field_3 from my_table where field_3 = 'my_field_3_value' and (comma_list = table_key or comma_list like concat(table_key, ',%') or comma_list like concat('%,', table_key, ',%') or comma_list like concat('%,', table_key));
drop function if exists test_pvreplace;
create function test_pvreplace ( str text,   -- string to do search'n'replace on ) if (right (pv, 1) <> '|') then set pv = concat (pv, '|');
select locate ('|', pv, idx0) into idx;
set len = idx - idx0;
select substring(pv, idx0, len) into spv;
select locate ('=', spv) into ipv;
if (ipv = 0) then set sp = spv;
else select substring(spv, 1, ipv-1) into sp;
select substring(spv, ipv+1) into sv;
select replace (str, sp, sv) into str;
set idx0 = idx + 1;
select locate ('|', pv, idx0) into idx;
select test_pvreplace ('%one% %two% %three%', '%one%=1|%two%=2|%three%=3');
select test_pvreplace ('%one% %two% %three%', '%one%=i|%two%=ii|%three%=iii');
select test_pvreplace ('%one% %two% %three% - %one% %two% %three%', '%one%=i|%two%=ii|%three%=iii');
select test_pvreplace ('%one% %two% %three% - %one% %two% %three%', '');
select test_pvreplace ('%one% %two% %three% - %one% %two% %three%', null);
select test_pvreplace ('%one% %two% %three%', '%one%=%two%|%two%=%three%|%three%=iii');
create table `incr` ( `id` int(11) not null auto_increment, primary key  (`id`);
create procedure dowhile() set v1 = v1 - 1;
select * from incr;
mytable ( nr ) select seq.seqvalue from ( select (hundreds.seqvalue + tens.seqvalue + ones.seqvalue) seqvalue from ( select 0  seqvalue union all select 1 seqvalue union all select 2 seqvalue union all select 3 seqvalue union all select 4 seqvalue union all select 5 seqvalue union all select 6 seqvalue union all select 7 seqvalue union all select 8 seqvalue union all select 9 seqvalue ( select 0 seqvalue union all select 10 seqvalue union all select 20 seqvalue union all select 30 seqvalue union all select 40 seqvalue union all select 50 seqvalue union all select 60 seqvalue union all select 70 seqvalue union all select 80 seqvalue union all select 90 seqvalue ( select 0 seqvalue union all select 100 seqvalue union all select 200 seqvalue union all select 300 seqvalue union all select 400 seqvalue union all select 500 seqvalue union all select 600 seqvalue union all select 700 seqvalue union all select 800 seqvalue union all select 900 seqvalue;
select (two_1.seqvalue + two_2.seqvalue + two_4.seqvalue + two_8.seqvalue + two_16.seqvalue) seqvalue from (select 0 seqvalue union all select 1 seqvalue) two_1;
select @row := @row + 1 as row from someothertable t join (select @row := 0) t2 limit 100;
select id % 12 + 1 as one_to_twelve from any_large_table one_to_twelve;
drop table if exists seq;
create table seq (i mediumint auto_increment primary key) select null as i from information_schema.columns t1 join information_schema.columns t2 join information_schema.columns t3 limit 100000; -- <- set your limit here;
alter table seq alter i drop default;
alter table seq modify i mediumint;
select min(i), max(i), count(*) from seq;
create table _numbers (num int);
select number, substr(name, num, 1) from users join _numbers on num < length(name) where user_id = 1234;
select n1.num * 10000 + n2.num from _numbers n1 join _numbers n2 where n1 < 100;
select 0 union all select 1 union all select 2 union all select 3 union all select 4 union all select 5 union all select 6 union all select 7 union all select 8 union all select 9) select units.n + tens.n*10 + hundreds.n*100 + thousands.n*1000 from digits as units, digits as tens, digits as hundreds, digits as thousands;
select x1.n + x10.n*10 + x100.n*100 + x1000.n*1000 from (select 0 as n union all select 1 union all select 2 union all select 3 union all select 4 union all select 5 union all select 6 union all select 7 union all select 8 union all select 9) x1, (select 0 as n union all select 1 union all select 2 union all select 3 union all select 4 union all select 5 union all select 6 union all select 7 union all select 8 union all select 9) x10, (select 0 as n union all select 1 union all select 2 union all select 3 union all select 4 union all select 5 union all select 6 union all select 7 union all select 8 union all select 9) x100, (select 0 as n union all select 1 union all select 2 union all select 3 union all select 4 union all select 5 union all select 6 union all select 7 union all select 8 union all select 9) x1000 where x1.n + x10.n*10 + x100.n*100 + x1000.n*1000 <= @max;
set @amount = 55; # how many numbers from zero you want to generate select `t0`.`i`+`t1`.`i`+`t2`.`i`+`t3`.`i` as `offset` from (select 0 `i` union select 1 union select 2 union select 3 union select 4 union select 5 union select 6 union select 7 union select 8 union select 9) `t0`, (select 0 `i` union select 10 union select 20 union select 30 union select 40 union select 50 union select 60 union select 70 union select 80 union select 90) `t1`, (select 0 `i` union select 100 union select 200 union select 300 union select 400 union select 500 union select 600 union select 700 union select 800 union select 900) `t2`, (select 0 `i` union select 1000 union select 2000 union select 3000 union select 4000 union select 5000 union select 6000 union select 7000 union select 8000 union select 9000) `t3` where `t3`.`i`<@amount and `t2`.`i`<@amount and `t1`.`i`<@amount and `t0`.`i`+`t1`.`i`+`t2`.`i`+`t3`.`i`<@amount;
select * into a from dbo.myview;
create table as select;
select  * from    myview;
select  top 10 from    myview id;
select * from dbo.myview;
select * into [table_a] from dbo.myview;
select * from old_source(s);
select * from dbo.myview;
select * into mynewtable from myview where 1=2;
select monthenddate med, sum(grossbalance/1000000) grossbalance, portfoliorename pr from risk_portfoliooverview;
select * from table1/view1;
create clustered index [ix_z_arch_export_dzienny_pre] on [dbo].[z_arch_export_daily_pre] ( [date] asc, [object code] asc, [from date] asc, [person_role] asc, [departure] asc, [room code] asc, [period_7_14] asc select * from export_daily_pre;
select table_owner, table_name, db_link from dba_synonyms where owner        = 'public' and synonym_name = <<synonym name>>;
create synonym s1 for s2 create synonym s2 for s3 create synonym s3 for s1;
select * from all_objects where object_name = upper('&object_name');
select * from all_synonyms where synonym_name = upper('&synonym_name');
select * from dba_synonyms where table_owner = 'user' and ( not exists ( select * from dba_tables where dba_synonyms.table_name = dba_tables.table_name ) and not exists ( select * from dba_views where dba_synonyms.table_name = dba_views.view_name ) and not exists ( select * from dba_sequences where dba_synonyms.table_name = dba_sequences.sequence_name ) and not exists ( select * from dba_dependencies where type in ( 'package' ) and dba_synonyms.table_name = dba_dependencies.name ) );
select s.owner as syn_owner, s.synonym_name as syn_name, s.table_owner as obj_owner, s.table_name as obj_name, case when o.owner is null then 'missing' else o.status end as obj_status from dba_synonyms s where o.owner is null or o.status != 'valid';
create or replace public synonym "dual" for "dual";
select * from dba_synonyms where table_name = 'dual';
alter system set "_system_trig_enabled"=false scope=memory;
create or replace public synonym dual for sys.dual;
alter system set "_system_trig_enabled"=true scope=memory;
select * from dba_tables where table_name = '&table_name';  -- no rows returned select * from dba_synonyms where synonym_name = '&synonym_name'; -- 1 row returned;
select * from all_synonyms where table_owner = 'scott' and synonym_name not like '%/%' and table_name not in ( select object_name from user_objects where object_type in ( 'table', 'view', 'package', 'sequence', 'procedure', 'function', 'type' );
select owner, synonym_name, connect_by_iscycle cycle from dba_synonyms where connect_by_iscycle > 0 and prior table_owner = owner union select 'public', synonym_name, 1 from dba_synonyms where owner = 'public' and table_name = synonym_name and (table_name, table_owner) not in (select object_name, owner from dba_objects where object_type != 'synonym');
from sqlobject import * artist="artist1", album="album1") artist="artist2", album="album2") 'artist' : song.artist, 'album' : song.album} if __name__ == "__main__":;
from sqlalchemy import column from sqlalchemy import integer from sqlalchemy import string;
select name, surname from users for json auto;
select * from users if json_str:;
from django.db import connection;
from datetime import date, datetime if isinstance(obj, (datetime, date)):;
from contextlib import closing from datetime import datetime if isinstance(thing, datetime):;
desc = list(zip(*cur.description))[0]  #to get column names;
if isinstance(obj, (datetime.date, datetime.datetime)): if __name__ == "__main__": "featcat":null, "countyfp":"001", "date":"2020-08-28";
create unique index on mmcompany((email is null)) where (email is null);
create function email_chk() returns trigger as $$ if exists ( select 1 from mmcompany where email is null and companyuniqueid <> new.id end if;
create constraint trigger after insert or update on mmcompany;
create table companyemail ( companyuniqueid int not null primary key email varchar(75) not null unique;
create unique nonclustered index idx_email where email is not null;
where [taskid] is not null";
select dateadd(minute, -30, getdate());
select * from [janus999db].[dbo].[tblcustomerplay] where dateplayed <  getdate() and dateplayed > dateadd(minute, -30, getdate());
select * from where dateplayed < current_timestamp and dateplayed >;
if p.id == id then break else current = p end end return current end  if p.id == id then break else current = p end end return current end end;
end  end  end  end;
select iif (exists (select 1 from tblgluseraccess where glusername ='xxxxxxxx'), 1, 2);
if exists (select * from tblgluseraccess where glusername ='xxxxxxxx') select 1 end else begin select 2 end;
if exists (select * from tblgluseraccess where glusername ='xxxxxxxx') set @result = 1 else set @result = 2;
if exists (select * from tblgluseraccess where glusername ='xxxxxxxx') select 1 else select 2;
select case from   tblgluseraccess where  glusername = 'xxxxxxxx') then 1 else 2 end;
if exists (select top 1 1 from tblgluseraccess where glusername ='xxxxxxxx') select 1 end else begin select 2 end;
select * from table where column like '%value%' collate utf8_general_ci;
select t.* from table t where lower(column) like '%value%';
where lower(column) like lower('%value%');
select qt.* from query_table qt where lower(column_name) like lower('%value%');
alter table `schema`.`table`;
select * from student where upper(sname) like 's%';
select * from student where lower(sname) like 's%';
select * from table where column ilike '%value%';
select * from sys.tables t where o.is_ms_shipped = 0;
select t.name from sys.tables as t where s.name = n'schema_name';
select * from information_schema.tables;
select * from information_schema.tables where table_type='base table';
select * from [schema_name].sys.tables;
select * from information_schema.tables where table_type='base table' and table_schema = 'dbo';
select t1.name as [schema], t2.name as [table] from sys.schemas t1;
select * from ( select id, year, thing, max(thing) over (partition by id) as max_thing from the_table where thing = max_thing;
select t1.id, t1.year, t1.thing from the_table t1 where t1.thing = (select max(t2.thing) from the_table t2 where t2.id = t1.id);
select t1.id, t1.year, t1.thing from the_table t1 join ( select id, max(t2.thing) as max_thing from the_table t2;
select id, max(t2.thing) as max_thing from the_table t2 ) select t1.id, t1.year, t1.thing from the_table t1 join max_stuff t2 and t1.thing = t2.max_thing;
select distinct on (1) from   tbl;
select distinct on (id) from   tbl;
select * from messages group by from_id order by timestamp desc limit 1;
select t1.* from messages t1 join (select from_id, max(timestamp) timestamp from messages group by from_id) t2;
select * from messages as m join (select to_id, from_id, max(timestamp) as most_recent from messages where to_id = 12345678 where m.to_id = 12345678;
select m1.* from messages m1 left join messages m2 where m2.id is null;
select t1.* from messages t1 join (select from_id, max(timestamp) timestamp from messages group by from_id) t2;
select t1.* from messages t1 join (select from_id, max(timestamp) timestamp from messages order by timestamp desc) t2;
select * from messages where id in (select max(id) from messages group by from_id ) order by id desc;
select * from databases;
delete from databases where id = 8;
select * from sqlite_master;
includesubdomains: true // false by default;
select id, date1, date2 from yourtable else date2 end;
select id, date1, date2 from yourtable else date2 end;
select id, date1, date2 from from yourtable) as t;
select id, date1, date2 from yourtable case when date1 < date2 or date1 is null then date1 else date2 end;
create table #datedata(id int identity, name varchar(15),startdate datetime,enddate datetime);
select * from #datedata order by (datediff(d,'17730101' ,isnull(startdate,enddate)) + datediff(d,'17730101' ,isnull(enddate,startdate));
create table #test (id int, date1 datetime, date2 datetime) select t.id, date1, date2, mindate from #test t drop table #test;
select id, date1, date2 from yourtable;
select id, date1, date2 from yourtable case when date1 is null and date2 is null then 0 else 3 end, (select min(v) from (values ([date1]), ([date2])) as value(v));
select * from atable case when date1 < date2 then date1 else date2 end, case when date1 < date2 then date2 else date1 end;
select * from atable case when date1 is null then null else date2 end else date1 end;
select * from [table] d select d.date1 t union select d.date2) q );
select * from [table] else date2 end;
select id, date1, date2 from yourtable case when date1 is null and date2 is null then 0 else 3 end, case when date1 < date2 then date1 else date2 end;
select id, x.date1, x.date2 from ( select id, date1, date2, sortcolumn = case when date1 < date2 then date1 else date2 end from yourtable;
select id, date1, date2 from yourtable;
( select aridnr from @t group by aridnr having count(*) > 1 ) select t.* from @t t --shows results from main table;
select * from ( select aridnr,liefnr,row_number() over where a.rownum >1;
select a.aridnr,a.liefnr from table a join table b and a.liefnr<> b.liefnr;
select * from yourtable where aridnr in ( select aridnr from yourtable having count(*) > 1 );
select * from yourtable where aridnr in ( select a.aridnr from yourtable a join yourtable b on b.aridnr = a.aridnr and b.liefnr <> a.liefnr );
select * from table where aridnr in ( select aridnr from table having count(distinct liefnr) > 1 );
select * from test where aridnr in having count(*) > 1);
select date_add(date_add(now(),interval -1 month), interval -4 day);
select current_timestamp + interval - 1 month + interval - 4 day;
select current_date + interval - 1 month + interval - 4 day;
select curdate() - interval 1 month - interval 4 day;
select '2014-03-27' - interval 1 month - interval 4 day;
select now() - interval 1 month - interval 4 day;
alter database tocrates set single_user with rollback immediate;
alter database statement not allowed within multi-statement transaction;
if (context.database.exists());
select substr(orderno, 1, 2) as newcolumnname from shipment;
select substr(orderno, 1, 2) as newcolumnname, column2, ... from shipment;
select substr(orderno,1,2) from shipment;
select substr(orderno, 1, 2) from shipment;
select substr('take the first four characters', 1, 4) first_four from dual;
select substr(orderno, 1, 2) from shipment;
create table qname ( qname_id integer generated by default as identity (start with 1) not null primary key, qname    varchar2(4000) not null -- constraint qname_uk unique;
create or replace trigger my_trigger select qname_id_seq.nextval into v_id from dual;
-- you can overwrite the value of :new.qname_id (qname.qname_id) with the value end my_trigger;
create sequence t1_seq;
create table t1 ( id          number default t1_seq.nextval, description varchar2(30);
create table identity_test_tab ( id          number generated by default on null as identity, description varchar2(30);
select @var1 = avg(somecolumn), @var2 = avg(othercolumn) from thetable;
select  @variableone = avg(somecolumn),  @variabletwo = avg(othercolumn) from tbltable;
select @var1 = 1, @var2 = 'zeus';
select @var1 = c.column1, @var2 = c.column2, from customers c where c.customerid = @customerid;
select distinct @var1 = column1, @var2 = column2 from mytable where columnx = @parm1;
select * from mytable where status='active' and dateadded='2010-10-01';
create index idx_lf on name(last_name, first_name);
create index idx_fl on name(first_name, last_name);
where last_name = xxx and first_name = yyy;
where last_name = xxx where last_name like 'x%' where last_name = xxx and first_name like 'y%' where last_name = xxx order by first_name;
where first_name = yyy where first_name like 'y%' where first_name = yyy and last_name like 'x%' where first_name = xxx order by last_name;
where first_name = xxx order by last_name;
set col = date(date_sub(now(), interval round(rand(1)*10) day));
update mytable set col = current_timestamp - interval floor(rand() * 14) day;
select floor(7 + (rand() * 5));
select now() - interval floor(rand() * 14) day;
update mytable set col = ( now() - interval floor(rand() * 14) day;
update mytable set col = (now() - interval floor(rand() * 14 * 24 * 60 * 60) second);
update  #temp set     dos = cnt from    #temp;
where total in (select id from #temp);
as ( select total, count(*) as dos from temp_table2010 where total in (select id from #temp) ) update t set dos=counts.dos from #temp t;
if exists (select * from table where fieldvalue='') select tableid from table where fieldvalue='' else begin select tableid from table where tableid=scope_identity() end;
if exists (select 1 from table where fieldvalue='') select tableid from table where fieldvalue='' end else begin select scope_identity() as tableid end;
set transaction isolation level serializable select @id = tableid from table where fieldvalue=@newvalue if @id is null select @id = scope_identity() end select @id;
select @id = tableid from table (nolock) where fieldvalue=@newvalue if @id is null set transaction isolation level serializable select @id = tableid from table where fieldvalue=@newvalue if @id is null select @id = scope_identity() end commit transaction end select @id;
if exists(select * from table where fieldvalue='') then begin select tableid from table where fieldvalue='' end else begin select tableid from table where tableid = scope_identity() end;
if not exists(select * from table where fieldvalue='') then begin end select tableid from table where fieldvalue='';
if exists(select * from table where fieldvalue='') then begin select tableid from table where fieldvalue='' end else begin select scope_identity() as tableid end;
tableid     int         identity, fieldvalue  varchar(20) ) if exists ( select * from @t1 where fieldvalue = '' select tableid from @t1 where fieldvalue='' end else begin select scope_identity() as tableid end  if exists ( select * from @t1 where fieldvalue = '' select tableid from @t1 where fieldvalue='' end else begin select scope_identity() as tableid end;
create schema tablename authorization dbo if object_id ('tablename.put_fieldvalue', 'p' ) is not null drop proc tablename.put_fieldvalue create proc tablename.put_fieldvalue(@fieldvalue int) as select @tableid = tableid from table where fieldvalue='' if @tableid = 0 begin select @tableid = scope_identity() end return @tableid exec @tableid = tablename.put_fieldvalue('');
create table clients ( client_id       uniqueidentifier  not null, client_name     nvarchar(250)     not null, client_country  char(2)           not null create table suppliers ( supplier_id       uniqueidentifier  not null, supplier_name     nvarchar(250)     not null, supplier_country  char(2)           not null;
select client_name, supplier_name, client_country from clients suppliers on (clients.client_country = suppliers.supplier_country) client_country;
select state, electorate from electorates postcodes on (postcodes.location.stintersects(electorates.location) = 1);
select g.name, count(cl.id) from geoshapes g crimelocations cl on g.shapefile.stintersects(cl.latlong) = 1 g.name;
select tbl1.col1, tbl2.col2 from tbl1 join tbl2 using(fk_tbl1_tbl2);
create table goods (id, name, price) create table pricerange (price, bonus);
select  * from    goods join    pricerange ( select  max(price) from    pricerange where   pricerange.price <= goods.price );
select * from db2.dbo.temptable;
select (same list of columns here) from db2.dbo.temptable;
select * from sourcedb..mysourcetable;
select * from sourcedb..mysourcetable;
set identity_insert mobileapplication1 on;
set identity_insert mob.mobileapplication1 on m.mobileplatformid) select ma.mobileapplicationid, ma.mobileplatformid from [server2].db.mob.mobileapplication2 ma;
select src-col1,src-col2 from sourcedb.dbo.sourcetable;
select columns_in_same_order from dbo.db2.temptable;
select * from db2.dbo.temptable;
select (same list of columns here) from db2.dbo.temptable;
select col1, col2, col3 from db2.user.mytable;
create or replace function run_test(_sp character varying);
select 1 ( <your query> ) as a where 1 = 0;
create table t(fa int , fb int);
alter table t add primary key(fa , fb);
set identity_insert on;
create table a (id, data) create table b (id, data) create table ab (a_id, b_id, primary key (a_id, b_id)) create table business_rule (id, a_id, b_id, foreign key (a_id, b_id) references ab) select  * from    business_rule br join    a;
create table a (id, data) create table b (id, data) create table ab (id, a_id, b_id, primary key (id), unique key (a_id, b_id)) create table business_rule (id, ab_id, foreign key (ab_id) references ab) select  * from    business_rule br join    a_to_b ab join    a;
alter table [table] alter column [column] varchar(max);
alter table [table] alter column [column] varchar(max);
set lock_timeout;
create table test (path ltree);
create index path_gist_idx on test using gist (path);
create index path_idx on test using btree (path);
select * from node where path like concat((select path from node where node_id = x), '.%');
select * where head_id = @id;
select count(city), city from table;
select count(city) as count, city from table;
select c.id, c.city from cities c join ( select city, count(*) as cnt from cities;
select c.city, c.id, (select count(*) as cnt from city c2 where c2.city = c.city) as order_col from city c;
select `firstaddressline4`, count(*) as `count` from `leads` where `status`='yes' and `broker_id`='0' limit 0, 8;
delete from foo where time < '2014-06-30' and duration > 1000 #can't delete if where clause has non time entity;
delete from foo where time > '2014-06-30' and time < '2014-06-30 15:16:01';
drop series from temperature where machine='zagbar';
create retention policy <retention_policy_name> on <database_name> duration <duration> replication <n> [default];
delete from <measurement> where time=123456;
delete from "things" where time=123123123 and tag1='val' and tag2='val';
select col1 from table1 where col2 = 'x';
set @requestresultxml = ( select 'npoit-1.0' as '@interface', ( select  'query'     as '@type', 'getbill'   as '@query', 'true'      as '@compressresult' ( select  @pin        as '@pin', @period     as '@period', @number     as '@number', @barcode    as '@barcode' ) select @requestresultxml as getbillrequest;
select ( select '@greeting' = 'hello', '@where' = 'there', '@who' = 'world';
select cast( ( select * from ( select 1 as tag union all select ... );
set @xmldata = ( select * from [dbo].[table1] ) select @xmldata as result;
set @xmldata =(select * from [dbo].[users] order by username for xml path('')) select @xmldata as result;
select m.messageid, sum((case when mp.messageid is not null then 1 else 0 end)) from message m;
select m.messageid, count(mp.messageid) from message m;
select m.messageid from message m from messagepart;
select m.messageid, count(distinct mp.messageid) from message m;
if "" & v <> "" then end if end function;
if vartype(cell) > vbarray then if vartype(subcell) <> vbempty then end if else if vartype(cell) <> vbempty then end if end if end function;
if iserror(application.match(v, array("", " ", 0), false)) then end if end function;
where user_id in (select value from string_split( @user_id_list, ',');
where ( manifestno in (select value from dbo.splitstring(@manifestnolist, ',')) );
create procedure [dbo].[get_user_names] as select last_name+', '+first_name from user_mstr where user_id in (select id from dbo.splitstring( @user_id_list, ',') );
create function [dbo].[splitstring] ( @input nvarchar(max), @character char(1) ) item nvarchar(1000) ) as begin set @startindex = 1 if substring(@input, len(@input) - 1, len(@input)) <> @character set @input = @input + @character end  set @endindex = charindex(@character, @input) select substring(@input, @startindex, @endindex - 1) set @input = substring(@input, @endindex + 1, len(@input)) end  end;
select last_name+', '+first_name from user_mstr where ',' + @user_id_list + ',' like '%,' + convert(nvarchar, user_id) + ',%';
create type userlist as table ( userid int );
create procedure [dbo].[get_user_names] @username varchar (30) output as select last_name+', '+first_name from user_mstr where user_id in (select userid from @user_id_list);
exec dbo.get_user_names @ul, @username output;
exec mystoredproc @myparam=@p1;
create function dbo.splitints ( @list      varchar(max), @delimiter varchar(255) ) as return ( select item = convert(int, item) from from ( select [xml] = convert(xml, '<i>' where item is not null;
select pg_cancel_backend(procpid);
select pg_terminate_backend(procpid);
select * from pg_stat_activity;
values = (4, "gaddafi", "adamu", "informatic");
values (%s, %s, %s, %s, %s)""";
select * from `users` where `username` = 0;
update `users` set `current_balance`='231608.09' where `user_id`=9;
update `users` set `current_balance`='231608.55' where `user_id`=9;
1618, 1619, 1620, 1951, 1952, 1953, 1954, 1955, 1972, 2022 };
if (skipduplicates) if (skipduplicates) if (valuedictionary.containskey(value)) continue;
if ((sb.length + separator.length + s.length) > maxlength) if (sb.length > 0) yield return sb.tostring();
if (sb.length > 0) sb.append(separator);
if (sb.length > 0) yield return sb.tostring();
select @turnover := (select sum(...) from ...), @cost := (select sum(...) from ...), @turnover - @cost as profit;
select calc1.turnover, calc2.cost, calc3.profit from cross apply ((select sum(...) as turnover from ...)) as calc1;
select (select sum(...) from ...) as turnover, (select sum(...) from ...) as cost, turnover - cost as profit;
select *,(myfields.turnover-myfields.cost) as profit from ( select (select sum(...) from ...) as turnover, (select sum(...) from ...) as cost;
select turnover, cost, turnover - cost from ( select (select ...) as turnover, (select ...) as cost;
select turnover, cost, turnover-cost as profit from (select 1 as fake_key, sum(a_nother_field) as cost from some_other_table) b;
select a,b, (select x from bigcorrelatedsubquery) as x, (select y from bigcorrelatedsubquery) as y, (select z from bigcorrelatedsubquery) as z from outertable;
select a,b, (select convert(varchar,x)+','+convert(varchar,x)+','+convert(varchar,x)+',' from bigcorrelatedsubquery) from bigcorrelatedquery) as xyz from outertable;
select turnover, cost, turnover - cost as profit from ( (select sum(...) from ...) as turnover, (select sum(...) from ...) as cost;
select sum(...) from ...) cost as( select sum(...) from ... ) select * select turnover.sum as sum_turnover from turnover,cost where ....;
select * select turnover.sum as sum_turnover from ( select sum(...) from ...) ( select sum(...) from ... where ....;
if (trans.connection != null) //detecting zombie transaction;
if (this.iszombied);
select top 1 @nextid = id from myqueuetable with (updlock, readpast) where statefield = 0 if @nextid is not null update myqueuetable set status = 1 where id = @nextid if @nextid is not null select * from myqueuetable where id = @nextid;
update instructions set status = '${status.instruction_inprogress}', run_id = '${buf.tostring("hex")}', mdate = datetime(datetime(), 'localtime') where id in (select id from instructions where status is not '${status.instruction_complete}' and run_id is null length(targetpath), id limit ${batchsize});
select * from instructions where run_id = '${buf.tostring("hex")}';
function(tx){ function(err){ function(){ function(err){ function(){;
select children1.id as o1, children2.id as o2, children3.id as o3, tp.property, tp.value,objects1.[depthinthetree] as o1d,objects2.[depthinthetree] as o2d,objects3. depthinthetree]  as o3d from  ... (see above);
select * from ( select children1.id as o1, children2.id as o2, children3.id as o3, tp.property, tp.value, row_number() over( partition by children1.id, children2.id, children3.id, tp.property ) as inheritancepriority from joinedresult ) where inheritancepriority = 1;
select object1, object2, object3 from triplesandproperties where value = @value and property = @property -- recursively flatten the inheritance hierarchy of object1, 2 and 3. select id, 0 as inherlevel from objects where id in (select object1 from validtrip) union all select rec.id, inherlevel + 1 from objects rec inner join o1 base on rec.parent = base.[object] o2 as ( select id, 0 as inherlevel from objects where id in (select object2 from validtrip) union all select rec.id, inherlevel + 1 from objects rec inner join o2 base on rec.parent = base.[object] o3 as ( select id, 0 as inherlevel from objects where id in (select object3 from validtrip) union all select rec.id, inherlevel + 1 from objects rec inner join o3 base on rec.parent = base.[object] ) select o1.id, o2.id, o3.id n from o1;
create table objects ( id int not null identity primary key, leftindex int not null default 0, rightindex int not null default 0 ) alter table objects add parentid int null references objects create table tp ( object1 int not null references objects, object2 int not null references objects, object3 int not null references objects, property varchar(20) not null, value varchar(50) not null ) create index ix_leftindex on objects(leftindex) create index ix_rightindex on objects(rightindex) create index ix_objects on tp(property, value, object1, object2, object3) create index ix_prop on tp(property) create view tpresultview as select o1, o2, o3, property, value from ( select children1.id as o1, children2.id as o2, children3.id as o3, tp.property, tp.value,  partition by children1.id, children2.id, children3.id, tp.property ) as idx from tp where idx = 1 create view tpintermediate as select tp.property, tp.value from tp create table dbo.multiplier (i int primary key) create view tpindexed as  select tp.object1, tp.object2, tp.object3, tp.property, tp.value, sum(isnull(case m.i when 1 then objects.leftindex else null end, 0)) as pl1, sum(isnull(case m.i when 2 then objects.leftindex else null end, 0)) as pl2, sum(isnull(case m.i when 3 then objects.leftindex else null end, 0)) as pl3, sum(isnull(case m.i when 1 then objects.rightindex else null end, 0)) as pr1, sum(isnull(case m.i when 2 then objects.rightindex else null end, 0)) as pr2, sum(isnull(case m.i when 3 then objects.rightindex else null end, 0)) as pr3, count_big(*) as id from dbo.tp or (m.i = 2 and objects.id = tp.object2) or (m.i = 3 and objects.id = tp.object3) create unique clustered index pk_tpindexed on dbo.tpindexed(property, value, object1, object2, object3) create nonclustered index ix_tpindexed on dbo.tpindexed(property, value, pl1, pl2, pl3, pr1, pr2, pr3) create view tpindexedresultview as select o1, o2, o3, property, value from ( select children1.id as o1, children2.id as o2, children3.id as o3, tp.property, tp.value,  partition by tp.property, children1.id, children2.id, children3.id ) as idx from tpindexed as tp with (noexpand) where idx = 1 create view tpindexedintermediate as select tp.property, tp.value from tpindexed as tp with (noexpand) create table tpresult ( object1 int not null references objects, object2 int not null references objects, object3 int not null references objects, property varchar(20) not null, value varchar(50) not null ) create unique index ix_result on tpresult(property, value, object1, object2, object3) select o1, o2, o3, property, value from tpresultview;
select o1, o2, o3, property, value from tpresultview where property = 'p1' and value = 'abc' select o1, o2, o3, property, value from ( select a.o1, a.o2, a.o3, a.property, a.value from tpintermediate a and a.o2 = b.o2 and a.o3 = b.o3 and a.property = b.property and ( -- find any rows with parent leftindex triplet that is greater than this one and a.pl2 < b.pl2 and a.pl3 < b.pl3) or -- find any rows with leftindex triplet that is greater than this one and a.cl2 < b.cl2 and a.cl3 < b.cl3) ) where b.o1 is null ) as x where property = 'p1' and value = 'abc' select o1, o2, o3, property, value from tpindexedresultview where property = 'p1' and value = 'abc' select o1, o2, o3, property, value from ( select a.o1, a.o2, a.o3, a.property, a.value from tpindexedintermediate a and a.o2 = b.o2 and a.o3 = b.o3 and a.property = b.property and ( -- find any rows with parent leftindex triplet that is greater than this one and a.pl2 < b.pl2 and a.pl3 < b.pl3) or -- find any rows with leftindex triplet that is greater than this one and a.cl2 < b.cl2 and a.cl3 < b.cl3) ) where b.o1 is null ) as x where property = 'p1' and value = 'abc' select object1 as o1, object2 as o2, object3 as o3, property, value from tpresult where property = 'p1' and value = 'abc';
select * from ( select children1.id as o1, children2.id as o2, children3.id as o3, tp.property, tp.value,  partition by children1.id, children2.id, children3.id, tp.property ) as inheritancepriority from ... (see above) ) where inheritancepriority = 1;
select * from ( select effective_object1, effective_object2, effective_object3, property, value, row_number() over( partition by effective_object1, effective_object2, effective_object3, property;
end sub end class;
db::raw('date(created_at) as date'), db::raw('count(*) as "views"');
db::raw('date(created_at) as date'), db::raw('count(*) as "views"');
values(1, 1), (2, 5), (3, 3), (4, 5), (5, 4), (6, 11) ) select t, a, avg(a) over (order by t rows between 1 preceding and 1 following) from data;
values(1, 1), (2, 5), (3, 3), (4, 5), (5, 4), (6, 11) ) select t, a, sum(a) over (order by t rows between unbounded preceding and current row) from data;
select convert(varchar(8), getdate(), 108);
select date_format(now(), '%h:%i:%s');
set @dt = '2012-09-10 08:25:53' select datepart(hour, @dt) -- returns 8;
set @dt = '2012-09-10 08:25:53' select cast(@dt as time) -- returns 08:25:53;
select @datetime = getdate() select right('0'+cast(datepart(hour, @datetime) as varchar(2)),2) + ':' +;
select convert(varchar(10), getdate(), 110) + ' 05:00:00';
select * from some_table t where convert(time,t.some_datetime_column) = '5pm';
select convert(datetime,convert(varchar,current_timestamp,112),112);
select start_of_day =               t.some_datetime_column from some_table t;
select five_pm = dateadd(hour,17, t.some_datetime_column ) from some_table t;
select convert(datetime,convert(float, getdate()) - convert(int,getdate())), getdate();
select dateadd(dd, -datediff(dd, 0, mydatetime), mydatetime);
select distinct convert(varchar(17), a.source_departure_time, 108) from consolidated_list as a where convert(varchar(17), a.source_departure_time, 108) between '15:00:00' and '15:45:00';
values (getdate(),convert(time,getdate()));
set @dt = convert(time,getdate());
where format(yourdatetime,'hh:mm') = '17:00';
select date_format('2004-01-20' ,'%y-%m-01');
select date_format(date_born, '%m/%d/%y' ) as my_date from date_tbl;
select date(orders.date_purchased) as date;
select cast(orders.date_purchased as date) as date_purchased;
database db = srv.databases["databasenamehere"];
database database = new sqldatabase(myconnectionstring);
select * from information_schema.parameters where specific_name='your_procedure_name';
set tablefield = tablefield + 1;
select * from production.product where productid > ? and productid < ?;
and productid < @parmmaxproductid;
set @managerid = ? set @manageremail = ? set @recordcount = ?;
select dbo.fun_functional_score('01091400003');
select  dbo.fun_functional_score('01091400003') as [er];
select dbo.function_name(parameter_name) select dbo.department_employee_count('hr');
select [dbo].[fun_functional_score]('01091400003');
select name from sys.procedures where object_definition(object_id) like '%createddate%';
select object_name(object_id), definition from sys.sql_modules where definition like '%' + 'createddate' + '%' select distinct object_name(object_id), object_definition(object_id) from sys.procedures where object_definition(object_id) like '%' + 'createddate' + '%';
select * from   sys.all_sql_modules where  definition like '%createddate%';
select distinct name from sys.procedures where object_definition(object_id) like '%createddate%';
select distinct name from sys.procedures where object_definition(object_id) like '%tbl_name%' and object_definition(object_id) like '%createddate%';
select distinct object_name(comments.id) object_name from syscomments comments where comments.id = objects.object_id and text like '%createddate%';
select object_name(object_id), definition from sys.sql_modules where definition like '%' + 'columnname' + '%';
select distinct object_name(object_id) from sys.procedures where object_definition(object_id) like '%' + 'columnname' + '%';
select referenced_id from sys.dm_sql_referenced_entities ('dbo.proc1', 'object');
if (@searchsp=1) begin ( select '['+c.table_schema+'].['+c.table_name+'].['+c.column_name+']' [schema_object], t.table_type from information_schema.columns c where column_name like @searchfor union select '['+routine_schema+'].['+routine_name+']' [schema_object], 'procedure' as table_type from information_schema.routines where routine_definition like @searchfor and routine_type='procedure' ) end else begin select '['+c.table_schema+'].['+c.table_name+'].['+c.column_name+']' [schema_object], t.table_type from information_schema.columns c where column_name like @searchfor end -- stored procedure (source listing) if (@searchsp=1) begin if (@displayspsource=1) begin select '['+routine_schema+'].['+routine_name+']' [schema.sp], routine_definition from information_schema.routines where routine_definition like @searchfor and routine_type='procedure' end end;
select f.name from f where to_upper(f.name) like '%fran%';
example).list();
set global log_slow_queries = 1;
set global slow_query_log_file = <some file name>;
set global slow_query_log = 'on';
set global log_queries_not_using_indexes = 'on';
set global slow_query_log_file ='/var/log/mysql/slow-query.log';
set global long_query_time = 20;
"dbo.events", c => new //etc;
alter table [dbo].[events] alter column [eventid] [int] not null;
select userid, 11, course, bookmark, course_date, posttest, post_attempts, post_score, post_date, complete, complete_date, exempted, exempted_date, exempted_reason, emailsent from tracking where courseid = 6 and course_date > '08-01-2008';
update mytable set complete = 1, complete_date = newdata.complete_date, post_score = newdata.post_score from ( select userid, complete_date, post_score from mytable where courseid = 6 and complete = 1 and complete_date > '8/1/2008' where courseid = 11 and userid = newdata.userid;
update c11 set c11.completed= c6.completed, c11.complete_date = c6.complete_date, -- rest of columns to be copied from courses c11 inner join courses c6 on and c11.courseid = 11 and c6.courseid = 6;
update `your_table` t1, `your_table` t2 set t1.your_field = t2.your_field where t1.other_field = some_condition and t1.another_field = another_condition and t2.source_id = 'explicit_value';
update barang set id from(select tblkatalog.tblkatalog_id from tblkatalog where tblkatalog.tblkatalog_nomor = barang.no_cat) where barang.no_cat <>'';
update your_table set new_field = sourse_field;
create table `momento_distribution` ( `momento_id`       int(11) not null auto_increment, `momento_idmember` int(11) not null, `created_at`       datetime default null, `updated_at`       datetime default null, `unread`           tinyint(1) default '1', `accepted`         varchar(10) not null default 'pending', `ext_member`       varchar(255) default null, primary key (`momento_id`, `momento_idmember`), key `momento_distribution_fi_2` (`momento_idmember`), key `accepted` (`accepted`, `ext_member`) ) default charset=latin1$$;
alter table `momento_distribution` drop primary key, add primary key (`id`);
constraint `momento_distribution_fk_1` foreign key (`momento_id`) references `momento` (`id`);
alter table momento_distribution drop foreign key momento_distribution_fk_1 alter table momento_distribution drop foreign key momento_distribution_fk_2;
alter table  `momento_distribution` drop primary key;
alter table  `momento_distribution` add  `id` int( 11 ) not null  primary key auto_increment first;
alter table  `momento_distribution` add index (  `momento_id` ) alter table  `momento_distribution` add index (  `momento_idmember` );
alter table  `momento_distribution` add foreign key ( `momento_id`) references  `momento` (`id`) on delete restrict on update restrict alter table  `momento_distribution` add foreign key ( `momento_idmember`) references  `member` (`id`) on delete restrict on update restrict;
select case from sales where sales_type = 'accessories') then 'y' else 'n' end as rec_exists from dual;
select decode(count(*), 0, 'n', 'y') rec_exists from sales where sales_type = 'accessories';
select 'y' rec_exists from sales where sales_type = 'accessories';
select null into dummy from sales where sales_type = 'accessories' and rownum = 1;
select name , decode(count(name),0, 'n', 'y') from table;
select count(1) into existence from sales where sales_type = 'accessories' and rownum=1;
select nvl ((select 'y' from  dual where exists from dual;
from table where ref_des = (select ref_des from table2 where order = '1234') and order = '1234') values (rec.lot, rec.component);** end loop;
if v_exist  is null then  end if;
select count(*) into v_counter where ******* etc...;
if v_counter > 0 then --code goes here end if;
select case from  tblusers u where u.userid =u.userid and u.passwordhash=u.passwordhash) then 'old password exists' else 'old password not exists' end as output from dual;
fillrowmethodname = "getfiles_fillrow", tabledefinition = "filepath nvarchar(4000)")];
select * from getfiles('c:\temp\');
if object_id('tempdb..#dirtree') is not null drop table #dirtree create table #dirtree ( id int identity(1,1), subdirectory nvarchar(255), depth smallint, fileflag bit, parentdirectoryid int ) exec master..xp_dirtree @backupdirectory, 10, 1 update #dirtree set parentdirectoryid = ( select max(id) from #dirtree d2 where depth = d.depth - 1 and d2.id < d.id ) from #dirtree d @backupfile varchar(max), @depth tinyint, @fileflag bit, @parentdirectoryid int, @wksubparentdirectoryid int, @wksubdirectory varchar(max) ( filenamepath varchar(max), translogflag bit, backupfile varchar(max), databasename varchar(max) ) select * from #dirtree where fileflag = 1 @backupfile, @depth, @fileflag, @parentdirectoryid set @wksubparentdirectoryid = @parentdirectoryid select @wksubdirectory = subdirectory, @wksubparentdirectoryid = parentdirectoryid from #dirtree where id = @wksubparentdirectoryid select @backupfile = @wksubdirectory + '\' + @backupfile end  select @backupfile = @backupdirectory + @backupfile @backupfile, @depth, @fileflag, @parentdirectoryid set @wksubparentdirectoryid = @parentdirectoryid end ;
exec xp_dirtree 'c:\', 2, 1;
end try end function end sub end class;
create assembly <your assembly name in here - anything you like> from 'c:\temp\clrexcelfiles.dll';
create function dbo.fngetfiles ( @pathname nvarchar(max), @pattern nvarchar(max) ) as external name <your assembly name>."clrgetexcelfiles.clrfilesindir".getfiles;
select * from dbo.fngetfiles('\\<servername>\<$share>\<folder>\' , '*.xls');
alter assembly [clrfilesindirassembly];
create table postgres=#;
create table  create table ;
create table my_table( col1 number, col2 number );
select * from my_table select * from my_table select * from my_table select * from "my_table";
select * from "my_table";
create table "my_other_table"( col1 number, col2 number );
select * from my_other_table select * from my_other_table select * from my_other_table select * from "my_other_table";
select * from "my_other_table";
set @source = 0x21232f297a57a5a743894a0e4a801fc3;
select varbin_source = @source;
select lower(substring(master.dbo.fn_varbintohexstr(0x21232f297a57a5a743894a0e4a801fc3), 3, 8000));
set @var = 0x21232f297a57a5a743894a0e4a801fc3 select cast(@var as varchar(max));
select cast(mybinarycol as varchar(max)) from mytable;
set @varbinaryfield = 0x21232f297a57a5a743894a0e4a801fc3;
select convert(varchar(max),@varbinaryfield,2), @varbinaryfield;
set @source = 0x21232f297a57a5a743894a0e4a801fc3;
select cast('' as xml).value('xs:hexbinary(sql:variable("@source"))', 'varchar(max)');
select `username`, `carprice` from `users` where `id`='4' limit 1;
select u.username, max(c.carprice) from users u where u.id = 4;
select location, max(temperature) from temperatures;
select users.username, max(cars.carprice) from users where users.id=4;
select users.username, cars.carprice from users where users.id=4;
select `username`, `carprice` from `users` select id from `cars` where belongstouser = users.id order by carprice desc limit 1 ) where `id`='4';
select `username`, `carprice` from `users` where `id`='4';
select `username`, `carprice` from `users` where `id`='4';
select * from (values(5)) as t(my_id) ) select * from users where id = (select my_id from vars);
select 1 as val ) select . . . from const cross join;
create function public.f_myid();
select public.f_myid();
create temp table val (val_id int primary key, val text);
create function f_val(_id int) select f_val(2);  -- returns 'baz';
create table myschema.val (val_id int primary key, val text);
set search_path = myschema, pg_temp;
select f_val(2);  -- returns 'wrong';
create function f_val(_id int);
create table vars ( id int not null primary key default 1, zipcode int not null default 90210, -- etc.. check (id = 1);
create function generate_var_getter() select columns.column_name from information_schema.columns where columns.table_schema = 'public' and columns.table_name = 'vars' new_rows, format('(''%s'', %s)', var_name, var_value) end loop;
create or replace function var_get(key_in text) select value from (values %s) as vars_tmp (key, value) where key = key_in;
create function vars_regenerate_update();
create trigger trigger_vars_regenerate_change;
select var_get('zipcode')::int;
update vars set zipcode = 84111;
select var_get('zipcode')::int;
select * from usertable where roles & 2 = 2;
set @mask = 6 ( id int, username varchar(50), roles int ) select 1, 'dave', 6 union select 2, 'charlie', 2 union select 3, 'susan', 4 union select 4, 'nick', 1 select * from @users where roles & @mask > 0;
select * from usertable where roles & 6 > 0;
select * from usertable where roles & 6 != 0;
as ( select 1,'dave',6 union select 2,'charlie',2 union select 3,'susan',4 union select 4,'nick',1 ) select * from test where (roles & 6) != 0  // returns dave, charlie & susan;
select * from test where (roles & 2) != 0 // returns dave & charlie;
select * from test where (roles & 7) != 0 // returns dave, charlie, susan & nick;
select datepart(year, datetimestamp) as [year];
select @d*40000*(192+2)*20000+150000;
set @mylist = '(1,2,5,7,10)';
select * from dbtable where id in (select id from @mylist);
select * from dbtable d join @mylist t on t.id = d.id;
set @list = '1,2,5,7,10';
select @pos = 0, @nextpos = 1;
select @nextpos = charindex(',', @list, @pos + 1) select @valuelen = case when @nextpos > 0 then @nextpos else len(@list) + 1 end - @pos - 1 values (convert(int, substring(@list, @pos + 1, @valuelen))) select @pos = @nextpos;
end  select * from dbtable where id in (select number from @tbl);
create function [dbo].[split](@string varchar(max), @delimiter char(1)) as begin select @idx = 1 if len(@string)<1 or @string is null  return set @idx = charindex(@delimiter,@string) if @idx!=0 set @slice = left(@string,@idx - 1) else set @slice = @string set @string = right(@string,len(@string) - @idx) if len(@string) = 0 break end return;
set @values ='1,2,5,7,10';
select * from dbtable where id  in (select items from [dbo].[split] (@values, ',') );
select field0, field1, field2 from my_table where ',' + @mysearchlist + ',' like '%,' + cast(field3 as varchar) + ',%';
set @var1 = 'james';
set @var2 = 'same';
set @var3 = 'dogcat';
select * from database where x in (@var1,@var2,@var3);
select * from t1 union select * from t1;
select * from t1 union select * from t1 union select * from t1;
select * from t1 union all select * from t1 where t1.id is null union all select * from t1 where t2.id is null union all select * from t1 where t3.id is null;
select * from t1 union select * from t2 union select * from t3;
select pub_name,country,pub_city,estd from publisher where country <> "usa";
select pub_name,country,pub_city,estd from publisher where country != "usa";
select scicom_list order by topic <> 'chair',topic,name_last;
select scicom_list order by topic <> 'chair',topic <> 'vice chair',topic,name_last;
alter table [dbo].[table_1] add  constraint [ix_table_1] unique nonclustered ( [myuniquecolumn] asc;
@b int output as begin set @b = 999 select 1111;
select e.name, d.name from employee e, department d where e.id = 123456 and e.dept_id = d.dept_id;
select e.name from employee e where e.age > 21 and e.state = 'delaware';
select id, name, score, date_added from ( select e.id, e.name, s.score, s.date_added, row_number() over (partition by e.id order by s.date_added desc) rn from entities e inner join scores s on e.id = s.entity_id;
values (1, 'apple'), (2, 'orange'), (3, 'banana'), (4, 'cherry') values (1,1,10,'2009-02-01'), (2,2,10,'2009-02-01'), (3,1,15,'2009-02-01'), (4,2,10,'2009-03-01'), (5,1,15,'2009-04-01'), (6,2,15,'2009-04-01'), (7,3,22,'2009-04-01');
select e.id, e.name, s.score, s.date_added from @entities e ( select top 1 * from @scores sc where sc.entity_id = e.id;
select e.id, e.name, s.score, s.date_added from @entities e ( select top 1 * from @scores sc where sc.entity_id = e.id;
select entities.*, scores.score, scores.date_added from entities where scores.date_added =;
select entities.*, scores.score, scores.date_added from entities ( select entity_id, max(date_added) as recent_date from scores;
select e.*, s1.score from entities e where not exists ( select 1 from score s2 where s2.id > s1.id );
select entities.*, scores.score, scores.date_added from entities where entities.id in limit 1;
select e.*, s1.score, s1.date_added from entities e where s2.id is null;
join a in db.handhelddevinfos on x.assetid equals a.devname into devinfo from aa in devinfo.defaultifempty() select new status = xx.online ?? false;
select new { status = aa == null ? (bool?)null : aa.online; // a nullable<bool>;
select new { status = aa == null ? false : aa.online;
join grunt in ctx.employees from tmp in tree.defaultifempty() select new name = tmp == null ? "" : tmp.firstname;
select [t0].[employeeid] as [id], (case else [t2].[firstname] from [dbo].[employees] as [t0] select 1 as [test], [t1].[firstname], [t1].[reportsto] from [dbo].[employees] as [t1];
create function [dbo].[initcap] ( @inputstring varchar(4000) ) as begin set @outputstring = lower(@inputstring) set @index = 1 set @char     = substring(@inputstring, @index, 1) set @prevchar = case when @index = 1 then ' ' else substring(@inputstring, @index - 1, 1) end  if @prevchar in (' ', ';', ':', '!', '?', ',', '.', '_', '-', '/', '&', '''', '(') if @prevchar != '''' or upper(@char) != 's' set @outputstring = stuff(@outputstring, @index, 1, upper(@char)) end  set @index = @index + 1 end  end go;
create function [widget].[propercase](@string varchar(8000)) returns varchar(8000) as set @string = lower(@string) set @i = ascii('a') set @string = replace( @string, ' ' + char(@i), ' ' + char(@i-32)) set @i = @i + 1 end set @string = char(ascii(left(@string, 1))-32) + right(@string, len(@string)-1) end;
create function [dbo].initcap (@value varchar(max)) @result varchar(max) = '';
select value, cast(null as varchar(max)) [x], cast('' as varchar(max)) [char], 0 [no] from (select rtrim(cast(@value as varchar(max))) [value]) as j union all select right(value, len(value)-case charindex(@separator, value) when 0 then len(value) else charindex(@separator, value) end) [value] from r where value > '') select @result = @result + case when ascii([char]) between 97 and 122 then stuff(x, 1, 1, char(ascii([char])-32)) else x end + @separator from r where x is not null;
set @result = rtrim(@result);
select left(column, 1)+ lower(right(column, len(column)-1) ) from [tablename];
select initcap(column_name) from table_name;
create function dbo.initcap(@v as varchar(max)) as return select ( select upper(left(value, 1)) + lower(substring(value, 2, len(value))) as 'data()' from string_split(@v, ' ') select cast(a.ret as varchar(max)) ret from a;
set @temp = substring(@string, @index-1, 1) if @temp = ' ' or @index = 1 set @resultstring = @resultstring + upper(substring(@string, @index, 1)) end else begin set @resultstring = @resultstring + lower(substring(@string, @index, 1)) end  set @index = @index+ 1--increase the index end select @resultstring;
select replace( replace( replace( replace( replace( replace( replace( replace( replace( replace( replace( replace( replace( replace( replace( replace( replace( replace( replace( replace( replace( replace( replace( replace( replace( replace(  from [dictionaries].[dbo].[cities] where country = 'us' and city like '% %';
set @input=upper(left(@input,1))+lower(substring(@input, 2, len(@input))) set @index=patindex('% _%',@input) if @index=0 set @index=len(@input) set @result=substring(@input,0,@index+1) set @index = @index + 1 set @char=substring(@input,@index,1) if (@prevcharisspace=1) set @char=upper(@char) if (@char=' ') set @char='' end  if (@char=' ') set @prevcharisspace=1 else set @prevcharisspace=0 set @result=@result+@char end --print @result;
select upper(left(fname,1))+substring(fname,2,len(fname)) as fname from [dbo].[akhil];
if object_id ('dbo.fncapitalizefirstletterandchangedelimiter') is not null drop function dbo.fncapitalizefirstletterandchangedelimiter create function [dbo].[fncapitalizefirstletterandchangedelimiter] (@string nvarchar(max), @delimiter nchar(1), @new_delimeter nchar(1)) as begin select @result = '';
if (len(@string) > 0) select @curr = 1 select @next = charindex(@delimiter, @string) select @result = case when len(@result) > 0 then @new_delimeter else '' end + case when @next <> 0 then lower(substring(@string, @curr+1, @next-2)) else lower(substring(@string, @curr+1, len(@string)-@curr)) end if (@next > 0) select @string = substring(@string, @next+1, len(@string)-@next) select @next = charindex(@delimiter, @string) end else select @string = '' end end return @result end go;
create function [dbo].[initcap](@text nvarchar(max)) as begin select ' ' + upper(left(s.value,1)) + lower(substring(s.value,2,len(s.value))) from openjson('["' + replace(replace(replace(replace(replace(@text,'\','\\'),'"','\"'),char(9),'\t'),char(10),'\n'),' ','","') + '"]') s end;
select convert(varchar(50), 'carl-van') union select 'dean o''brian' union select 'andrew-le-smith' union select 'eddy thompson' union select 'bobs-your-uncle' select convert(varchar(50), upper(left(name, 1)) + lower(substring(name, 2, len(name)))) name, pos = patindex('%[-'' ]%', name) from studentlist union all select convert(varchar(50), left(name, pos) + upper(substring(name, pos + 1, 1)) + substring(name, pos + 2, len(name))) name, pos = case when patindex('%[-'' ]%', right(name, len(name) - pos)) = 0 then 0 else pos + patindex('%[-'' ]%', right(name, len(name) - pos)) end from student where pos > 0 ) select name from student where pos = 0;
create function [dbo].[capitalize](@text nvarchar(max)) returns nvarchar(max) as set @c = substring(@text, @i, 1);
set @result += iif(@isprevspace = 1, upper(@c), lower(@c));
set @isprevspace = iif(@c like '[    -]', 1, 0);
end return @result;
select from_unixtime(cast(yourtable.start_time as unsigned)) as date_time;
select yourtable.start_time as date_time;
select ... from ( select idno, firstname, lastname, ...., row_number() over (partition by lower(idno) order by firstname) as rn from people where rn = 1;
select ... from x select idno, firstname, lastname, ...., row_number() over (partition by lower(idno) order by firstname) as rn from people where ...;
select * from people p where p.idno in (select distinct idno from people);
select distinct p2.* from ( select idno from people p;
create table people ( [entry] int values (1,'uqx', 'bob', 'smith'), (2,'abc', 'john', 'willis'), (3,'abc', 'john', 'willis'), (4,'abc', 'john', 'willis'), (5,'wtf', 'jeff', 'bridges'), (6,'sss', 'bill', 'doe'), (7,'sss', 'bill', 'doe'), (8,'sss', 'bill', 'doe'), (9,'ere', 'sally', 'abby'), (10,'wtf', 'jeff', 'bridges');
select upper(idno) as user_id from people p idno;
select pc.user_id from ( select p2.user_id from ( select upper(p.idno) as user_id from people p p2.user_id pdata.entry;
select * from people p where peopleid = ( select min(peopleid) from people where idno = p.idno );
select distinct p.idno collate sql_latin1_general_cp1_ci_as, p.firstname collate sql_latin1_general_cp1_ci_as, p.lastname collate sql_latin1_general_cp1_ci_as from people p;
select date, h.referer from `refresh.ga_sessions_xxxxxx*`, unnest(hits) as h;
exec sp_rename @newname = 'eng_test_a/c_type', @objtype = 'column';
set quoted_identifier on set arithabort on set numeric_roundabort off set concat_null_yields_null on set ansi_nulls on set ansi_padding on set ansi_warnings on alter table dbo.table_name set (lock_escalation = table);
exec sp_rename 'eng_test.[eng_test_a/c_type]', 'eng_test_ac_type', 'column';
exec sp_rename 'eng_test.eng_test_a/c_type', 'eng_test_ac_type', 'column';
exec sp_rename '[eng_test].[eng_test_a/c_type]', 'eng_test_ac_type', 'column';
exec sp_rename '[eng_test].[eng_test_a/c_type]', '[eng_test_ac_type]', 'column';
exec sp_rename '[eng_test].eng_test_a/c_type', 'eng_test_ac_type', 'column';
exec sp_rename 'eng_test.[[eng_test_a/c_type]]]' , 'eng_test_a/c_type', 'column' exec sp_rename 'eng_test."[eng_test_a/c_type]"' , 'eng_test_a/c_type', 'column';
set statistics time on select * from production.productcosthistory where standardcost < 500.00;
set statistics time off;
set statistics time on;
select @starttime=getdate() select @endtime=getdate() select datediff(millisecond,@starttime,@endtime) as [duration in millisecs];
set statistics io on;
set statistics io on  --io set statistics time on select lw.manifest,lw.orderid,count(distinct lineitemid) from lwmanifestorderlineitems lw select lw.manifest,lw.orderid,count( lineitemid) linecount from lwmanifestorderlineitems lw where lw.manifest in (select manifest from manifestcontainers);
set nocount on create table timesheet_hours (staff_id int, bookedhours int, posted_flag bit) set @personid = 1 if exists ( select 1 from timesheet_hours where posted_flag = 1 and staff_id = @personid ) end else if not exists ( select 1 from timesheet_hours where staff_id = @personid ) end else print 'no problems here' drop table timesheet_hours;
select 12.54 % 1;
case when 0 = cast(right(myfield, len( myfield)-charindex('.',myfield)+1 ) as float) then 'integer' else 'decimal' end as type;
select parsename(0.001,1);
select parsename(0.0010,1);
select parsename(-0.001,1);
select parsename(-1,1);
select parsename(0,1);
select parsename(1,1);
select parsename(100.00,1);
select (100.0001 % 1);
select (100.0010 % 1);
select (0.0001 % 1);
select (0001 % 1);
select (100 % 1);
select parsename((100.0001 % 1),1);
select parsename((100.0010 % 1),1);
select parsename((0.0001 % 1),1);
select parsename((0001 % 1),1);
select parsename((1 % 1),1);
select parsename((100 % 1),1);
select right(123.45,2) return => 45;
select substr('123.123',instr('123.123','.')+1, length('123.123')) from dual;
select @1 = 2.938 select parsename(@1,1);
select x, abs(x) - floor(abs(x)) from ( select 2.938 as x;
select x, substring(cast(x as varchar(max)), charindex(cast(x as varchar(max)), '.') + 3, len(cast(x as varchar(max)))) from ( select 2.938 as x;
select (num - floor(num)) * 1000 from table...;
select (num % 1);
update tbl set combined = concat(zipcode, ' - ', city, ', ', state);
select concat(zipcode, ' - ', city, ', ', state) from table;
alter table yourtable add column combined varchar(50);
update yourtable set combined = concat(zipcode, ' - ', city, ', ', state);
create trigger insert_trigger set new.combined = concat(new.zipcode, ' - ', new.city, ', ', new.state);
create trigger update_trigger set new.combined = concat(new.zipcode, ' - ', new.city, ', ', new.state);
set @givendate = getdate() select dateadd(mm,datediff(mm, 0, @givendate),0) --first day of the month select dateadd(mm,datediff(mm, -1, @givendate),-1) --last day of the month;
dateadd(month, 1, cast(month('5/15/2009') as varchar(2)) +;
set @test = getdate()  -- or any other date select dateadd(month, ((year(@test) - 1900) * 12) + month(@test), -1);
select dateadd(day,-1,dateadd(month,1,dateadd(day,(0-(datepart(dd,'2008-02-12')-1)),'2008-02-12')));
select dateadd(day, - day(@selecteddate), dateadd(month, 1 , @selecteddate)) endofmonth;
set @startdate = dateadd(month, datediff(month, 0, getdate())-1,0) set @enddate = eomonth (dateadd(month, datediff(month, 0, getdate())-1,0)) select @startdate,@enddate;
select dateadd(month, datediff(month, 0, @mydate)+1, -1) as lastofmonth;
select eomonth (@currentdate) as currentmonthed;
select eomonth (@currentdate, 1 ) as nextmonthed;
create function [dbo].[fn_getlastdate] ( @date datetime ) as begin select @result = choose(month(@date), dateadd(day, 31 -day(@date), @date), iif(year(@date) % 4 = 0, dateadd(day, 29 -day(@date), @date), dateadd(day, 28 -day(@date), @date)), dateadd(day, 31 -day(@date), @date) , dateadd(day, 30 -day(@date), @date), dateadd(day, 31 -day(@date), @date), dateadd(day, 30 -day(@date), @date), dateadd(day, 31 -day(@date), @date), dateadd(day, 31 -day(@date), @date), dateadd(day, 30 -day(@date), @date), dateadd(day, 31 -day(@date), @date), dateadd(day, 30 -day(@date), @date), dateadd(day, 31 -day(@date), @date)) end;
select [dbo].[fn_getlastdate]('2016-02-03 12:34:12') select [dbo].[fn_getlastdate](getdate());
set @a = dateadd(mm, datediff(mm,0,getdate())+1,-1) set @a = dateadd(mm, datediff(mm,0,getdate())-1,0) set @a = dateadd(mm, datediff(mm,0,getdate()),-1) set @a = dateadd(ww, datediff(ww,0,getdate()),0) set @a = dateadd(ww, datediff(ww,0,getdate())+1,-1) set @a =  dateadd(ww, datediff(ww,0,getdate())-1,0) set @a =  dateadd(ww, datediff(ww,0,getdate()),-1);
where date01 between dateadd(month,-1,dateadd(day,1,dateadd(day,-day(today()),today()))) and dateadd(day,-day(today()),today());
where month(date01) = month(dateadd(month,-1,today())) and year(date01) = year(dateadd(month,-1,today()));
select eomonth(@somegivendate);
select dateadd(month, 1, @x)           -- add a month to the supplied date @x;
select dateadd(day,  0 - day(@x), @x)  -- get last day of month previous to the supplied date @x;
select day(dateadd(day,  0 - day(dateadd(month, 1, @x)), dateadd(month, 1, @x)));
select dateadd(dd,-1,dateadd(mm,datediff(mm,0,your_date)+1,0));
select dateadd(month,1,getdate())- day(dateadd(month,1,getdate()));
set @dtdate = "your date";
set @dt = '20140312' select dateadd(month, datediff(month, '20011231', @dt), '20011231');
set @dt = '20140208' select dateadd(month, datediff(month, '20011231', @dt), '20011231');
set @dt = '20140405' select dateadd(month, datediff(month, '20011231', @dt), '20011231');
from django.db.transaction import commit_on_success;
from django.db import transaction;
from django.db import transaction;
entry(headline='this is only a test'), ]);
select @result = isnull(@result, '') + studentid + ',' from student where condition = xyz select substring(@result, 0, len(@result) - 1) --trim extra "," at end;
select @result = @result + isnull(studentid + ',', '') from student;
select @results = case else ', ' + convert( varchar(20), [studentid]) end from student where condition = abc;
select @result = stuff( (   select ',' + convert(nvarchar(20), studentid) from student where condition = abc );
select studentid from student where condition = xyz;
select group_concat(concat_ws(',', studentid) separator '; ') from student where condition = xyz;
select @results = case else @results + ', ' + convert( varchar(20), [studentid]) end from student where condition = abc;
select @result = cast(studentid as varchar) + ',' from student where condition = xyz;
select @studentid = concat(coalesce(@studentid + ',', ''), studentid) from student where studentid is not null and condition='xyz' select @studentid;
select @results = @results + from student where condition = xyz select @results;
select @studentid = coalesce(@studentid + ',', '') + studentid from student where studentid is not null and condition='xyz' select @studentid;
select mod(rownum,10) as num from   dual ) select a.num*10+b.num as num from   digits a;
select mod(rownum,100) as num from   dual allpossible as ( select a.num*100+b.num as ticketnum from   batches a ) select ticketnum as ticketssold from   allpossible where  allpossible.ticket not in (select ticketnum from ticketsreturned);
select v from dual v[iteration_number] = iteration_number + 1 );
select rownum r from dual;
select level n from dual;
select * from `dual` where id>0 and id<101;
select (select lo from bnd) - 1 + level r from dual;
create or replace function [schema].fn_table_numbers( numini integer, numfin integer, exponencial integer default 0 with tabla as (select numini, numfin from dual) select numini num from tabla union all select (select numini from tabla) + (level*to_number('1e'||to_char(exponencial))) num from dual end loop;
create or replace type [schema]."tbl_numbers" is table of number;
select column_value num from table([schema].fn_table_numbers(1,10))--integers difference: 1;2;.......;10;
select column_value num from table([schema].fn_table_numbers(1,10,-1));--with 0.1 difference: 1;1.1;1.2;.......;10 select column_value num from table([schema].fn_table_numbers(1,10,-2));--with 0.01 difference: 1;1.01;1.02;.......;10;
select rownum from (select 1 as c from dual group by cube(1,1,1,1,1,1,1) ) sub where rownum <=100;
select 1 from dual union all select n+1 from t where n < 100 ) select * from t;
select rownum from xmltable('1 to 100');
select (column_value).getnumberval() as num from xmltable('1 to 100');
set @s = '' select @s = @s + ',' + cast(x as varchar) + ',' + cast(y as varchar) from points select @s;
set @xylist = '' select @xylist = @xylist + convert(varchar, x) + ',' + convert(varchar, y) + ',' from points select left(@xylist, len(@xylist) - 1);
select  stuff(( select ',' + x + ',' + y from points;
select @xylist = coalesce(@xylist + ',', '') + convert(varchar, x) + ',' + convert(varchar, y) from points;
select string_agg (x + ',' + y, ',') as xylist from points;
delete from table where id between 79 and 296;
delete from table where id > 79 and id < 296;
delete from table_name where id between 79 and 296;
delete from [dbo].[tablename] where [tablename].[idfield] between 79 and 296;
delete * from table1 where id between 70 and 1296;
delete from tab where id > 79 and id < 296;
delete from tab where id between 80 and 295;
delete from tab where id between 79 and 296;
delete from tab where id => 79 and id <= 296;
select * from  `ht_news` limit 0 , 30;
select * from table_name where field_name like '%\n%';
select * from mytable where mycolumn regexp "\n";
select * from your_table where your_column like concat('%', char(10), '%');
select * from table_name where field_name like ('%'||chr(10)||'%');
select * from your_table where your_column like '%' + char(10) + '%';
select * from your_table where charindex(char(10), your_column) > 0;
select * from table where patindex('%' + char(13) + char(10) + '%', column) > 0;
select * from your_table where your_column like '%' + char(10) + '%';
select * from your_table where your_column like '%' + char(13) + char(10) + '%';
select cc.columnname,right(cc.columnname,1),ascii(right(cc.columnname,1)) ,cc.* from table_name cc where;
where  ascii(right(cc.columnname,1)) = 13;
if (datestr != null) {;
if (timestamp != null);
jdbctype.valueof( myresultsetmetadata.getcolumntype(  ) );
case date :  // fyi: qualified type name `jdbctype.date` not allowed in a switch, because of an obscure technical issue. use a `static import` statement. case timestamp_with_timezone : default :;
select abs(a) as absolutea, abs(b) as absoluteb from yourtable;
update mytbl set a = abs(a) where a < 0;
select case when ( a > 0 ) then (a*-1) else (a*-1) end as negativea, case when ( b > 0 ) then (b*-1) else (b*-1) end as positiveb from yourtablename;
select abs(a) * -1 as absolutea, abs(b) * -1 as absoluteb from yourtable;
select abs(a) as absolutea, abs(b)  as absoluteb from yourtable;
if object_id('tempdb..#temptable') is not null drop table #temptable;
select scope_identity();
select scope_identity();
select scope_identity();
select cast(scope_identity() as bigint) ---- incase you have a return result as int64;
select scope_identity();
set @id = scope_identity();
( caseid, partid, serialnumber, hardware, software, firmware ) values ( @caseid, @partitemid, @serialnumber, @hardware, @software, @firmware ) select id from @tmp" );
values (@val1, @val2, @val3);
var connection = var command = "insert into notes ([title],[text]) " +;
values %s"""%(table, columns_string,values_string);
tablename=my_tablename, columns=', '.join(mydict.keys()), values=tuple(mydict.values()) );
values = (str(list(dictionary.values()))[1:-1]);
empid int not null, oldvacationhours int, newvacationhours int, modifieddate datetime);
update top (10) humanresources.employee set vacationhours = vacationhours * 1.25, modifieddate = getdate() deleted.vacationhours, inserted.vacationhours, inserted.modifieddate select empid, oldvacationhours, newvacationhours, modifieddate from @mytablevar;
select top (10) businessentityid, vacationhours, modifieddate from humanresources.employee;
update mytable set mydate = sysdate where mydate in (select mydate from mytable where mydate is null);
select id from table1 with (updlock) where alertdate is null;
update table1 set alertdate = getutcdate() where alertdate is null;
select alertdate from table1 where alertdate is null set @updatetime = getutcdate() update table1 set alertdate = @updatetime  --set value where current of cur1;
set @updatetime = getutcdate() update table1 set alertdate = @updatetime where alertdate is null select id from table1 where alertdate = @updatetime;
update table1 set alertdate = getutcdate() where alertdate is null;
select @someid = id from @updatedids;
"update com.bill.credit c set c.balance = c.balance - ?1 where c.accountid = ?2 and c.balance >= ?1").executeupdate();
select a.* from table_a a where b.tag = 'chair';
where b.tag = a.<col_name>;
where b.val between a.val1 and a.val2;
select a.* from table_a a where a.id in ( select b.id from table_b b where b.tag = 'chair' );
select a.* from table_a a where b.tag = 'chair';
select a.id, a.object from table_a a where b.tag = 'chair';
update `table` set `yourdatefield` = `yourdatefield` + interval 2 day where ...;
select * from tablename where columname between curdate() and date_add(curdate(), interval 3 day);
update classes set `date` = date_add(`date`, interval 2 day) where id = 161;
select date_add(`your_field_name`, interval 2 day) from `table_name`;
update classes set `date` = date_add(`date` , interval 2 day) where `id` = 161;
update table set nameofdatefield = adddate(nameofdatefield, 2) where ...;
update tablename set coldate=date_add(coldate, interval 2 day);
select date_add(curdate(), interval 2 day);
update classes where date=(date_add(date, interval 1 day)) where id=161;
set date = date_add( fieldname, interval 2 day );
select name from my_table where name like case when ? is not null then ? else '%' end;
select name, surname from my_table where coalesce(name,'') = coalesce(?,name,'');
select * from my_table where @parameter is null or name = @parameter;
select name, surname from my_table where name = ifnull(?,name);
select name, surname from my_table where name = coalesce(?,name);
select name, surname from my_table where name = nvl(?,name);
select name, surname from my_table where name = isnull(?,name);
select a.somecolumns, b.othercolumns from localdb.dbo.localtable a exec localdb.dbo.localstoredprocedure;
select t.tenantname, t.carplatenumber, t.carcolor, t.sex, t.ssno, t.phone, t.memo, u.unitnumber, p.propertyname from tbltenant t from tbltransaction;
create procedure test_proc as select 1 as x, 2 as y union select 3,4 union select 5,6 union select 7,8 union select 9,10 create table #testing ( value1   int ) exec test_proc select * from #testing;
select t.tenantname from tbltenant t select tenant.id as tenantid, sum(isnull(trans.amount,0)) as tenantbalance from tbltenant tenant p.propertyname;
create table #temp ( tenantid int, tenantbalance int ) exec thestoredproc select t.tenantname, t.carplatenumber, t.carcolor, t.sex, t.ssno, t.phone, t.memo, u.unitnumber, p.propertyname from tbltenant t;
create view vwtenantbalance as  select tenant.id as tenantid, sum(isnull(trans.amount,0)) as tenantbalance from tbltenant tenant;
select t.tenantname, t.carplatenumber, t.carcolor, t.sex, t.ssno, t.phone, t.memo, u.unitnumber, p.propertyname, tenantbalance from tbltenant t;
create function fnmyfunc() ( select tenant.id as tenantid, sum(isnull(trans.amount,0)) as tenantbalance from tbltenant tenant );
select t.tenantname, t.carplatenumber, t.carcolor, t.sex, t.ssno, t.phone, t.memo, u.unitnumber, p.propertyname from tbltenant t;
update table1 join table2 set table1.name = table2.name, table1.`desc` = table2.`desc`;
update   table1 set table1.name = table2.name, table1.[desc] = table2.[desc] from table1 join table2;
create table table1 ( id number, name varchar2(10), desc_ varchar2(10) create table table2 ( id number, name varchar2(10), desc_ varchar2(10) select * from table1;
update tableone set field1 =(select tabletwo.field1 from tabletwo where tableone.id=tabletwo.id), field2 =(select tabletwo.field2 from tabletwo where tableone.id=tabletwo.id) where tableone.id = (select  tabletwo.id from   tabletwo where  tableone.id = tabletwo.id);
update table1 set `id` = (select table2.id from table2 where table1.`name`=table2.`name`);
update table1, table2 set table1.datacolumn= table2.datacolumn where table1.id= table2.id;
select column5, count(*) from table1;
select column5, count(column5) as occurences from mytable;
alter table tablename add constraint constraintname primary key(columnname);
if len(dfs[-1]) < chunk_size:;
alter database my set single_user with rollback immediate;
alter database my set offline;
alter database my modify file ( name = my_data, filename = 'd:\data\my.mdf' alter database my modify file ( name = my_log, filename = 'd:\data\my_1.ldf';
alter database my set online;
alter database my set multi_user;
exec xp_instance_regwrite n'hkey_local_machine', n'software\microsoft\mssqlserver\mssqlserver', n'defaultdata', reg_sz, n'd:\mssqldata' exec xp_instance_regwrite n'hkey_local_machine', n'software\microsoft\mssqlserver\mssqlserver', n'defaultlog', reg_sz, n'd:\mssqldata';
coalesce(posting_date,'1900-01-01 00:00:00.000');
select (case when value1 is null then 1 else 0 end) as valueisnull, value1, value2, value3 from tablename;
set @database = 'adventureworks2016ctp3' select spid from sys.sysprocesses where db_name(dbid) = @database set @sql = 'kill ' + cast(@spid as varchar(10)) + ';' exec (@sql) end ;
if  exists (select * from sys.objects where object_id = object_id(n'[dbo].[killconnectionshost]') and type in (n'p', n'pc')) drop procedure [dbo].[killconnectionshost] set ansi_nulls on set quoted_identifier on create procedure [dbo].[killconnectionshost] @hostname varchar(max) as declare @spid int select spid from sys.sysprocesses p join sys.sysdatabases d on (d.dbid = p.dbid) join sys.sysusers u on (p.uid = u.uid) where hostname = @hostname and hostname != '' and p.spid != @@spid set @sql = 'kill ' + rtrim(@spid) end ;
set @dbname = 'db name here' select  @processid = min(spid) from    master.dbo.sysprocesses where   dbid = db_id(@dbname) exec ('kill ' + @processid) select  @processid = min(spid) from    master.dbo.sysprocesses where   dbid = db_id(@dbname) end;
alter database yourdb set single_user with rollback immediate;
alter database yourdb set multi_user;
select cast(height as decimal(18,0)) / 10;
select height / 10.0;
select height / cast(10 as float(53));
select height / cast (10 as float);
select cast(@height as decimal(10, 5))/10 as heightdecimal;
set @height = 1023 select @height/10.0 as heightdecimal;
select height/10.0 as heightdecimal from dbo.whatever;
select convert(decimal(16,4), height/10.0) as heightdecimal from dbo.whatever;
select cast (height as decimal)/10 as heightdecimal;
set     @xx = 3 select @xx select @xx * 2  -- yields another integer select @xx/1    -- same select @xx/1.0  --yields 6 decimal places select @xx/1.00 --       6 select @xx * 1.0  --     1 decimal place - victory select @xx * 1.00 --     2         places - hooray;
select replace( ifnull(notes, ''), '\r\n' , '\n' )   as notes from sometables;
select id, client, project, task, description, time, date from ts;
drop table if exists foo_export;
create table foo_export like foo;
alter table foo_export engine=csv;
client, project, task, replace(replace(ifnull(ts.description,''),'\n',' '),'\r',' ') as description, time, date from ....;
create procedure `export_table`( in tab_name varchar(50), in select_columns varchar(1000), in filename varchar(100), in where_clause varchar(1000), in header_row varchar(2000)) select concat( "select ", header_row, " union all ", "select ", select_columns, " into outfile ", "'",filename,"'" " lines terminated by '\n'" (case when where_clause is null then "" else where_clause end);
create table table2 as select to_timestamp(to_char(tb1.date, '9999-99-99 99:99:99'),'yyyy-mm-dd hh24:mi:ss') as realdate from table1 as tb1;
alter table table2 alter realdate set data type timestamp using realdate;
select to_timestamp(20120822193532::text, 'yyyymmddhh24miss');
create function dbo.getvalue(@ncode int, @recid int) as select @recid * nvalue from c_const where code = @ncode;
alter table dbo.yourtable add newcolumnname as dbo.getvalue(ncodevalue, recidvalue);
create view anyview as  select a.rec_id, a.s_id, a.n_code, a.rec_id * c.nvalue as foo from anytable a;
alter function [dbo].[split_string]( @delimited nvarchar(max), @delimiter nvarchar(100) as begin set @xml = n'<t>' + replace(@delimited,@delimiter,'</t><t>') + '</t>' select  r.value('.','varchar(max)') as item from  @xml.nodes('/t') as records(r) end;
teststring      varchar(50) ) select 1 as n union all  select n + 1 from numbers where n < 255 -- enumerate letters in the string and select only the delimiters select  n.n from numbers n where substring(t.teststring, n, 1) = @delimiter union  select  0 from @testtable t ) select  t.teststring from @testtable t and ds.delimiter_number + 1 = de.delimiter_number;
values ('1','john/smith'),('2','jane/doe'), ('3','steve'), ('4','bob/johnson') select p.id, [1] 'firstname', [2] 'lastname', [3] 'col3', [4] 'col4' select a.id, x1.value, row_number() over (partition by a.id order by a.id) rn from @mytable a;
select value from string_split(@tags, ',') where rtrim(value) <> '';
select substring(mycolumn, 1, charindex('/', mycolumn)-1) as firstname, substring(mycolumn, charindex('/', mycolumn) + 1, 1000) as lastname from   mytable where charindex('/', mycolumn) > 0;
select substring(mycolumn, 1, charindex('/', mycolumn)-1) as firstname, substring(mycolumn, charindex('/', mycolumn) + 1, 1000) as lastname from   mytable where mycolumn like '%/%';
select substring(mycolumn, 1, case charindex('/', mycolumn) then len(mycolumn) else charindex('/', mycolumn) - 1 then len(mycolumn) + 1 else charindex('/', mycolumn) + 1 from mytable;
create function [dbo].[splitsbyindex] @string    varchar(max), @position  int ) as begin chrs varchar(8000) as (select 'table1' y(n) as (select 'table2' from x a1, x a2, x a3, x a4, x a5, x a6, x a7, x a8), -- up to 16^8 = 4 billion as (select top (isnull(len(@string), 0)) row_number() over( order by ( select null from y), delim(pos) as (select t.n from t or t.n = 0)), separated(value) as (select substring(@string, d.pos + len(@separator + 'x') - 1, lead(d.pos, 1, 2147483647) over( order by ( select null from delim d where @string is not null) select s.value from separated s where s.value <> @separator;
select @outresult = ( select chrs from @results where id = @position;
select [dbo].[splitsbyindex](' ',fieldname,2) from tablename;
select * from ( select top 1 id,name from locations order by id) x union all select top 1 id,name from locations order by id desc;
select first.id, first.name from ( select top 1 * from locations union all select last.id, last.name from ( select top 1 * from locations;
select id,name, row_number() over (order by id) as rnasc, row_number() over (order by id desc) as rndesc from locations ) select * from numberedrows where rnasc = 1 or rndesc = 1;
select top 1 id as samecolumn,name from locations union all select top 1 id as samecolumn,name from locations order by samecolumn desc;
select count(*) from ( select count(*) from movies group by id having count(genre) = 4;
select sum( select count(*) from movies group by id having count(genre) = 4;
select count(*) from   (select count(*) from   movies having count(genre) = 4) t;
select count(*) from ( select count(genre) as count from movies having (count = 4);
select count(*) from (select id from movies group by id having count(genre)=4) a;
alter table tablename add columnname bit not null constraint df_some_fixed_name default(0);
alter table dbo.tablename drop constraint df_some_fixed_name, column columnname;
select @name = name from dbo.sysobjects where name like 'df__xxx__yyy__%' and type = 'd' if @name is not null begin end;
select @name = d.name from dbo.sysobjects d where d.name like '%'+@first5charsfromcolumnname+'%' and d.type = 'd' and t.name = @tablename if @name is not null begin end;
select * from openrowset (bulk 'c:\test\test1.pdf', single_blob) a;
select bulkcolumn from openrowset (bulk 'c:\test\test1.pdf', single_blob) a;
select * from openrowset (bulk 'c:\path\filename.ext',single_blob) a;
( thumbnailphoto, thumbnailphotofilepath, largephoto, largephotofilepath ) select thumbnailphoto.*, null, null, n'tricycle_pink.gif' from openrowset;
create table [thumbnail]( [id]        [int] identity(1,1) not null, [data]      [varbinary](max) null constraint [pk_thumbnail] primary key clustered ( [id] asc;
select * from openrowset (bulk 'c:\test\testpic1.jpg', single_blob) as x;
select * from openrowset (bulk 'c:\test\testpic1.jpg', single_blob) as x;
select foo.bulkcolumn;
update t set name='high' from table1 t;
update table1 set name='high' having age in(select max(age) from table1 group by type);
update table1 set name = 'high' from table1 join (select max(age), type from table1 group by table1) t on table1.age = t.age;
update table1 as t (select type,max(age) mage from table1 group by type) t1 set name='high';
update table1# set name = 'high'#;
update table1 set name='high' where age in(select max(age) from table1);
update table1 set name = 'high' where age in (select max(age) from table1 group by name);
update archives_forum f min(earliest_post) as earliest, max(earliest_post) as latest from archives_topic set f.earliest_post = t.earliest, f.latest_post = t.latest;
select cast('the quick brown fox jumped over the lazy dog' as varchar(45));
select len(cast('the quick brown fox jumped over the lazy dog' as varchar(max)));
alter system cancel;
alter system cancel sql 'sid, serial[, @inst_id][, sql_id]';
select s.sid, s.serial#, p.spid, s.username, s.schemaname from v$session s join v$process p where s.type != 'background';
select sid, sql_id, username, blocking_session, command, module, status from v$session where blocking_session is not null;
alter system kill session 'sid,serial#';
alter system kill session '314, 2643';
alter system kill session 'sid,serial#';
select s.sid, s.serial#, p.spid, s.username, s.schemaname from v$session s join v$process p where s.type != 'background';
select s.inst_id, s.sid, s.serial#, p.spid, s.username from gv$session s join gv$process p and s.inst_id = p.inst_id where s.type != 'background';
alter system kill session 'sid,serial#' immediate;
select p.* from v$process p where s.sid = ? and s.serial# = ?;
select p.* from gv$process p where s.sid = ? and s.serial# = ?;
where s.status = 'killed';
case when tbllist.pinrequestcount <> 0 then tbllist.pinrequestcount end desc, case when tbllist.highcallalertcount <> 0 then tbllist.highcallalertcount end desc, case when tbllist.highalertcount <> 0 then tbllist.highalertcount end desc, case when tbllist.mediumcallalertcount <> 0 then tbllist.mediumcallalertcount end desc, case when tbllist.mediumalertcount <> 0 then tbllist.mediumalertcount end desc, tbllist.lastname asc, tbllist.firstname asc, tbllist.middlename asc;
case when tbllist.pinrequestcount <> 0 then tbllist.pinrequestcount end desc, tbllist.lastname asc, tbllist.firstname asc, tbllist.middlename asc;
case when tbllist.pinrequestcount <> 0 then 5 end desc, case when tbllist.pinrequestcount <> 0 then tbllist.pinrequestcount end desc, tbllist.lastname asc, tbllist.firstname asc, tbllist.middlename asc;
set @orderbyname='name' set @orderbycity='city' set @orderbycmd= 'select * from customer order by '+@orderbyname+','+@orderbycity+'';
select * from dbo.employee case when gender='male' then employeename end desc, case when gender='female' then country end asc;
if (!columnmap.containskey(columnname)) { if (tablealias != null && !tablealias.trim().isempty()) {;
select * from table1 a, table2 b where (whatever);
select a.id 'a_id', b.id 'b_id' from table1 as a, table2 as b...;
select a.columnname as columnnamea, b.columnname as columnnameb, ... from table1 a, table2 b where (whatever);
select a.column, b.column from table1 a, table2 b;
if exists (select * from information_schema.tables where table_schema = 'dbo' and table_name = 'mytable') if exists (select * from sys.tables where object_id = object_id('dbo.mytable'));
table employee (emp_id int, name varchar) and table employee_location (emp_id int, loc_id int);
delete employee_location where emp_id = x;
select * from tablea a and [here put criteria predicate that 'defines' what the first record is];
select * from tablea a and b.city + b.county = from tableb where code = b.code);
select table_a.code, table_a.emp_no, table_b.city, table_b.county from table_a join table_b and table_b.field_that_is_unique = from table_b where table_b.code = table_a.code );
select *, rnk = row_number() over (partition by code order by city) from b ) select a.code, a.emp_no, b.city, b.county from a;
select * from( select *, rnk = row_number() over (partition by code order by city) from b where rnk = 1 ) select a.code, a.emp_no, b.city, b.county from a;
select a.code, a.emp_no, b.city, b.county from a;
select * from table_a a from table_b b_1 where b_1.code = a.code;
select table_a.code, table_a.emp_no, table_b.city, table_b.county from table_a table_b and table_b.field_that_is_unique in from table_b;
select table_a.code, table_a.emp_no, table_b.city, table_b.county from table_a a and b.id = (  select id from table_b where table_b.code = table_a.code limit 1 );
exec msdb.dbo.sp_help_job @job_name = 'your job name';
select job.name, job.job_id from msdb.dbo.sysjobs_view job where run_requested_date is not null and stop_execution_date is null and job.name like 'your job prefix%';
select job.name, job.job_id, job.originating_server,activity.run_requested_date, datediff(minute, activity.run_requested_date, getdate()) as elapsed from msdb.dbo.sysjobs_view job where run_requested_date is not null and stop_execution_date is null and job.name like 'your job prefix%';
if exists(select 1 from msdb.dbo.sysjobs j join msdb.dbo.sysjobactivity a where j.name=n'your job name' and a.run_requested_date is not null and a.stop_execution_date is null ) else print 'the job is not running.';
select job.name, job.job_id, job.originating_server, activity.run_requested_date, datediff( second, activity.run_requested_date, getdate() ) as elapsed from msdb.dbo.sysjobs_view job join msdb.dbo.sysjobactivity activity join msdb.dbo.syssessions sess join ( select max( agent_start_date ) as max_agent_start_date from msdb.dbo.syssessions where run_requested_date is not null and stop_execution_date is null;
if object_id ( 'usp_getjobstatus','p' ) is not null drop procedure  usp_getjobstatus;
create procedure  usp_getjobstatus as  if object_id('tempdb..#jobresults','u') is not null drop table #jobresults create table #jobresults ( job_id   uniqueidentifier not null, last_run_date         int not null, last_run_time         int not null, next_run_date         int not null, next_run_time         int not null, next_run_schedule_id  int not null, requested_to_run      int not null, request_source        int not null, request_source_id     sysname running               int not null, current_step          int not null, current_retry_attempt int not null, job_state             int not null ) select  job.name                                                as [job_name], ( select  max(cast( stuff(stuff(cast(jh.run_date as varchar),7,0,'-'),5,0,'-') + ' ' + from    msdb.dbo.sysjobs as j where j.[name] like '%' + @jobname + '%' ( select  top 1 start_execution_date from    msdb.dbo.sysjobactivity where   job_id = r.job_id case when r.running = 0 then case when jobinfo.last_run_outcome = 0 then 'failed' else 'unknown' end when r.job_state = 0 then 'success' else 'unknown' end                                 as [run_status_description] from    #jobresults as r where   job.[enabled] = 1 and job.name like '%' + @jobname + '%';
delete activity from msdb.dbo.sysjobs_view job where activity.run_requested_date is not null and activity.stop_execution_date is null;
as ( select distinct name as [jobname] then 'enabled' else 'disabled' end [jobstatus] then 'failed' then 'succeeded' then 'retry' then 'cancelled' then 'in progress' else 'unknown' end [joboutcome] partition by s.step_name order by sjh.run_date desc from msdb..sysjobs sj and sjh.step_id = s.step_id where (sj.name like 'job name') and sjh.run_date = convert(char, getdate(), 112) ) select * from cte_jobstatus where rn = 1 and run_status not in (1,4);
exec master.dbo.xp_sqlagent_enum_jobs 1,dbo;
create table #job last_run_date         int              not null, last_run_time         int              not null, next_run_date         int              not null, next_run_time         int              not null, next_run_schedule_id  int              not null, requested_to_run      int              not null, -- bool request_source_id     sysname          collate database_default null, running               int              not null, -- bool current_retry_attempt int              not null, job_state             int              not null);
select sj.name from msdb..sysjobactivity aj join msdb..sysjobs sj where aj.stop_execution_date  is null     -- job hasn't stopped running and aj.start_execution_date is not null -- job is currently running and sj.name = '<your job name>' and not exists( -- make sure this is the most recent run select 1 from msdb..sysjobactivity new where new.job_id = aj.job_id and new.start_execution_date > aj.start_execution_date ) );
create table #list_running_sql_jobs ( job_id uniqueidentifier not null select @is_sysadmin = isnull(is_srvrolemember(n'sysadmin'), 0);
select distinct suser_sname(owner_sid)from msdb.dbo.sysjobs;
select j.name then 'no' else 'yes' end , '#min' = datediff(minute, a.start_execution_date, isnull(a.stop_execution_date, getdate())) and a.stop_execution_date is null then 'executing' then 'failed' then 'retry' then 'canceled' then 'inprog' then 'success' else 'idle' end , r.current_step from msdb.dbo.sysjobs j and a.start_execution_date is not null and not exists ( select * from msdb.dbo.sysjobactivity at where at.job_id = a.job_id and at.start_execution_date > a.start_execution_date ) and j.job_id = substring(substring(p.program_name, charindex('0x', p.program_name) + 2, 32), 7, 2) + substring(substring(p.program_name, charindex('0x', p.program_name) + 2, 32), 5, 2) + substring(substring(p.program_name, charindex('0x', p.program_name) + 2, 32), 3, 2) + substring(substring(p.program_name, charindex('0x', p.program_name) + 2, 32), 1, 2) + '-' + substring(substring(p.program_name, charindex('0x', p.program_name) + 2, 32), 11, 2) + substring(substring(p.program_name, charindex('0x', p.program_name) + 2, 32), 9, 2) + '-' + substring(substring(p.program_name, charindex('0x', p.program_name) + 2, 32), 15, 2) + substring(substring(p.program_name, charindex('0x', p.program_name) + 2, 32), 13, 2) + '-' + substring(substring(p.program_name, charindex('0x', p.program_name) + 2, 32), 17, 4) + '-' + substring(substring(p.program_name, charindex('0x', p.program_name) + 2, 32), 21, 12) and h.instance_id = a.job_history_id and t.step_id = r.current_step drop table #list_running_sql_jobs;
select sj.name, case when sja.start_execution_date is null then 'never ran' end as 'runstatus', case when sja.start_execution_date is not null and sja.stop_execution_date is null then js.stepcount else null end as totalnumberofsteps, case when sja.start_execution_date is not null and sja.stop_execution_date is null then isnull(sja.last_executed_step_id+1,js.stepcount) else null end as currentlyexecutingstep, case when sja.start_execution_date is not null and sja.stop_execution_date is null then datediff(minute, sja.run_requested_date, getdate()) else null end as elapsedtime from msdb.dbo.sysjobs sj join msdb.dbo.sysjobactivity sja where session_id = ( select max(session_id) from msdb.dbo.sysjobactivity);
select * from table limit 50 offset 1;
select top(10) * from my_table where id not in (select top(5) id from my_table);
select * from ( select row_number() over(order by id) as ronum from table_name where @n < ronum;
select * from table select top n * from table;
select * from table select * from table where rownum <= n select t.*, rownum as num from table t ) select * from tablewithnum where num > n;
select * from table;
select * from table where num > n;
select * from table_name;
select * from ( select top (@take) * from ( select top (@take + @skip) * from table_name;
select skip 10 * from table order by id;
select * from owner.tablename a where condition and  n+1 <= ( select count(distinct b.column_order) from owner.tablename b where condition and b.column_order>a.column_order );
select * from sales.salesorderheader;
( select top (10) id from my_table ) select top (5) * from my_table;
select * from table order by [some_column];
select * from `my_table` where id != (select id from my_table limit 1);
select * from table where your_dt_field >= date_sub(now(), interval 6 month);
select * from table where your_date_field >= curdate() - interval 6 month;
select * from table where your_date_field between curdate() - interval 6 month and curdate();
select month(yourtimestampordatecolumn) as month, user, actionid, count(*) as total_actions, round(sum(totalpoints)) as total_pts from mytable where month(yourtimestampordatecolumn) between month(curdate() - interval 6 month) and month(curdate());
select distinct local_tcp_port from sys.dm_exec_connections where local_tcp_port is not null;
select distinct local_net_address, local_tcp_port from sys.dm_exec_connections where local_net_address is not null;
select case when hide = 0 then false else true end from;
select case when hide = 0 then 'false' else 'true' end from;
select id, name, case when hide = 0 then 'false' else 'true' end as hide from anonymous_table;
select id, name, case when hide = 0 then false else true end as hide from anonymous_table;
select id, name, cast(hide as boolean) from table_name;
select id,name, replace(replace(hide,0,"false"),1,"true") as hide from your-table;
select if(hide = 0,false,true) col from tbl; #for boolean value return;
select if(hide = 0,'false','true') col from tbl; #for string value return;
select case status else 'validated' end as status from supp_status;
create table [dbo].[datasource] ( [rowid] int primary key values (1,  'samle data');
update [dbo].[datasource] set [rowvalue] = 'new data' where [rowid] = 1;
select * from [dbo].[datasource];
blkby varchar(200), dbname varchar(200), command varchar(200), cputime int, diskio int, lastbatch varchar(200), programname varchar(200), _spid int, requestid int) exec master.dbo.sp_who2 select v.*, t.text from @tblvariable v;
select dat.name, dat.transaction_uow, ddt.database_transaction_begin_time, ddt.database_transaction_log_bytes_reserved, ddt.database_transaction_log_bytes_used from sys.dm_tran_database_transactions ddt, sys.dm_tran_active_transactions dat, sys.dm_tran_locks dtl where ddt.transaction_id = dat.transaction_id and ) select distinct * from orphaned_tran;
set nocount on if object_id('tempdb..#locksummary') is not null drop table #locksummary if object_id('tempdb..#lock') is not null drop table #lock create table #lock (    spid int,    dbid int,    objid int,    indid int,    type char(4),    resource nchar(32),    mode char(8),    status char(6)) if object_id('tempdb..#who') is not null drop table #who create table #who (     spid int, ecid int, status char(30), loginame char(128), hostname char(128), blk char(5), dbname char(128), cmd char(16) ) select     left(loginame, 28) as loginame, left(db_name(dbid),128) as db, left(object_name(objid),30) as object, max(mode) as [tolevel], count(*) as [how many], max(case when mode= 'x' then cmd else null end) as [xclusive lock for command], l.spid, hostname from #lock l join #who w on l.spid= w.spid where dbid != db_id('tempdb') and l.status='grant' select * from #locksummary order by [tolevel] desc, [how many] desc, loginame, db, object select p.spid from      master..sysprocesses p join      master..sysdatabases d on p.dbid =  d.dbid where     exists (  select 1 from      master..sysprocesses p2 where     p2.blocked = p.spid ) select     left(loginame, 30) as loginame,  l.spid, left(db_name(dbid),15) as db, left(object_name(objid),40) as object, mode , blk, l.status from #lock l join #who w on l.spid= w.spid where dbid != db_id('tempdb') and blk <>0;
create procedure [dbo].[sp_radhe] as begin set transaction isolation level read uncommitted select es.session_id as session_id case es.transaction_isolation_level end ,coalesce(es.cpu_time,0) from sys.dm_exec_sessions es where es.is_user_process = 1 and es.session_id <> @@spid and es.status = 'running' end ;
exec sys.sp_ms_marksystemobject 'sp_radhe';
exec sp_who spid -- will give you some info;
set `title`='mytitle' where `id`='1';
'logfile' => '@runtime/logs/profile.log', 'logvars' => [], 'levels' => ['profile'], 'categories' => ['yii\db\command::query'], 'prefix' => function($message) {;
'username' => 'uname', 'password' => 'pwd', 'charset' => 'utf8', ],;
select count(case when letter = 'a' then 1 end)           as [count - end], count(case when letter = 'a' then 1 else null end) as [count - else null], count(case when letter = 'a' then 1 else 0 end)    as [count - else zero], sum(case when letter = 'a' then 1 end)             as [sum - end], sum(case when letter = 'a' then 1 else null end)   as [sum - else null], sum(case when letter = 'a' then 1 else 0 end)      as [sum - else zero] from grades;
select `smart_projects`.project_id, `smart_projects`.business_id, `smart_projects`.title, `page_pages`.`funnel_id` as `funnel_id`, count(distinct(page_pages.page_id) )as page_count, count(distinct (case when page_pages.funnel_id != 0 then  page_pages.funnel_id else null end ) ) as funnel_count from `smart_projects` where  smart_projects.status !=  0 and `smart_projects`.`business_id` = 'cd9412774edb11e9';
create table #countme (col1 char(1));
select count(case when col1 = 'a' then 1 end) as countwithoutelse, count(case when col1 = 'a' then 1 else null end) as countwithelsenull, count(case when col1 = 'a' then 1 else 0 end) as countwithelsezero from #countme;
select count(case when rsp_ind = 0 then 1 else null end) as "new", count(case when rsp_ind = 1 then 1 else null end) as "accepted" from tb_a;
select sum(case when rsp_ind = 0 then 1 else 0 end) as 'new', sum(case when rsp_ind = 1 then 1 else 0 end) as 'accepted' from tb_a;
select sum(rsp_ind = 0) as `new`, sum(rsp_ind = 1) as `accepted` from tb_a;
if nullif(isnull(@previousstartdate,''),'') is null set @previousstartdate = '01/01/2010';
if coalesce(patindex('%[^ ]%', @parameter), 0) > 0;
if isnull(@previousstartdate, '') = '' ...;
if ( coalesce( @previousstartdate, '' ) = '' ) ...;
if nullif(@previousstartdate, '') is null;
set @previousstartdate=case isdate(@previousstartdate) else '1/1/2010' end;
set @previousstartdate = coalesce(nullif(@previousstartdate, ''), '01/01/2010');
create procedure uspgetaddress @city nvarchar(30) = null, @addressline1 nvarchar(60) = null as select * from adventureworks.person.address where city = isnull(@city,city) and addressline1 like '%' + isnull(@addressline1 ,addressline1) + '%';
if len(isnull(@var, '')) = 0;
update tablename set datetimefield='19980223 14:23:05' update tablename set datetimefield='02/23/1998 14:23:05' update tablename set datetimefield='1998-12-23 14:23:05' update tablename set datetimefield='23 february 1998 14:23:05' update tablename set datetimefield='1998-02-23t14:23:05';
update mytable set mydate = convert(datetime, '2009/07/16 08:28:01', 120);
delete from ( select pf.* from productfilters pf where pf.id>=200 and pf.rowid in ( select rowid from productfilters and products.name= 'mark' );
delete from productfilters where rowid in ( select pf.rowid from productfilters pf where pf.id>=200 and pf.rowid in ( select productfilters.rowid from productfilters and products.name= 'mark' );
delete (select * from productfilters pf where pf.id >= 200 and pr.name = 'mark');
delete from docs_documents d where d.id in ( select a.id from docs_documents a where b.id is null and floor(sysdate - a.create_date) > 120;
select name from t_emp where id=1;
select name from t_emp where id=2;
select name from t_emp where id=3;
select * from employee where emp_id = empid;
select * from employee where emp_id = :empid;
create function [dbo].[daterange_to_table] ( @mindate_str nvarchar(30), @maxdate_str nvarchar(30)) as  set @mindate = convert(datetime, @mindate_str,103) set @maxdate = convert(datetime, @maxdate_str,103) select convert(nvarchar(10),@mindate,103), convert(nvarchar(30),datename(dw,@mindate)) set @mindate = (select dateadd(dd,1,@mindate)) select convert(nvarchar(10),@mindate,103), convert(nvarchar(30),datename(dw,@mindate)) end  end;
select * from dbo.daterange_to_table ('01/01/2017','31/01/2017');
select @sdate union all select dateadd(day, 1, date) from dates_cte where date < @edate ) select * from dates_cte;
set @period = 14 set @date_start = convert(date,dateadd(d, -@period, curent_timestamp)) set @date_end = convert(date,current_timestamp) set @i = 1 create table #dateslist(dts datetime) set @i = @i + 1 end select cast(dts as date) from #dateslist drop table #dateslist;
@dateto datetime = dateadd(hour, -1, getdate() + 2); -- add 2 days and minus one hour as ( select @datefrom union all select dateadd(day, 1, mydate) from mydates where mydate < @dateto ) select mydates.mydate from mydates;
as (select @datefrom union all select dateadd(hour, 1, mydate) from mydates where mydate < @dateto ) select mydates.mydate from mydates;
select top (datediff(dd, '2018-06-30', '2018-07-31')) row_number() dateadd(dd, row_number() over(order by a.name) , '2018-06-30') as dt from sys.all_objects a;
set @firstdate = dateadd( day,1, @firstdate) end insert @tbl values( @lastdate) select * from @tbl;
set language spanish create table #tmp_years ( [year] int ) select year(@startdate) + @years set @years = @years - 1 end  ( select 1 union all select 2 union all select 3 union all select 4 union all select 5 union all select 6 union all select 7 union all select 8 union all select 9 union all -- days lower than 10 select 10 union all select 11 union all select 12 union all select 13 union all select 14 union all select 15 union all select 16 union all select 17 union all select 18 union all select 19 union all -- days lower than 20 select 20 union all select 21 union all select 22 union all select 23 union all select 24 union all select 25 union all select 26 union all select 27 union all select 28 union all select 29 union all -- days lower than 30 select 30 union all select 31 -- days higher 30 [months]([month]) as -- all months at a year ( select 1 union all select 2 union all select 3 union all select 4 union all select 5 union all select 6 union all select 7 union all select 8 union all select 9 union all select 10 union all select 11 union all select 12 ) select convert(varchar, a.[year]) + '-' + replicate('0', 2 - len(convert(varchar, n.[month]))) + convert(varchar, n.[month]) + '-' + replicate('0', 2 - len(convert(varchar, d.[day]))) + convert(varchar, d.[day]) as [date] from #tmp_years a;
@maxdate date = '2020-02-01';
( select cast(@mindate as date) as day union all select cast(dateadd(day, 1, day) as date) as day from dates where cast(dateadd(day, 1, day) as date) < @maxdate );
create procedure [dbo].[p_display_dates](@startdate datetime,@enddate datetime) as begin create table #daterange (dater datetime) set @mxdate = (select max(dater) from #daterange) set @indate = dateadd(day,1,@mxdate) set @mxdate = (select max(dater) from #daterange) end select * from #daterange end;
set @startdatetime = '2015-01-01' set @enddatetime = '2015-01-12';
( select @startdatetime as date union all select dateadd(d,1,datedata) from daterange where datedata < @enddatetime ) select datedata from daterange;
@maxdate date = '20140106';
select  date from    dbo.calendar where   date >= @mindate and     date < @maxdate;
@maxdate date = '20140106';
select  top (datediff(day, @mindate, @maxdate) + 1) from    sys.all_objects a;
select  top 1 date, it_cd, qty from    t where   it_cd = 'i-1' and     date <= '20140428';
select  date, it_cd, qty from    (   select  date, it_cd, qty, rownumber = row_number() over(partition by ic_id from    t where   date  <= '20140428' where   rownumber = 1;
//    system.data.entity.core.objects.objectmaterializedeventargs e) //    // and cancel/modify the save operation as desired. //            entitystate.modified | entitystate.added));
if @@fetch_status <> 0  break end -- while;
select spro.id from sometable as spro where cty.cityid = @cityid exec updatecomputedfulltext @id end ;
from sometable as spro where cty.cityid = @cityid exec updatecomputedfulltext @oneid end ;
select spro.id from sometable as spro join [address] addr on addr.id = spro.id join city cty on cty.cityid = addr.cityid where cty.cityid = @cityid select @key = max(key) from @keys exec updatecomputedfulltext @key delete @keys where key = @key end;
where key > @key) select @key = min(key) from @keys where key > @key exec updatecomputedfulltext @key end;
select top 1 @id = spro.id from sometable as spro where cty.cityid = @cityid exec updatecomputedfulltext @id select top 1 @id = spro.id from sometable as spro where cty.cityid = @cityid and spro.id > @id end;
select supt.hostname,supt.scriptname, count(*) from event_pagehit eph where x.iscompanyformations=1 and y.iscompanyformations=0;
join cds in cds_oeinvitem on osc.products_model equals cds.itemno into p where osc.itemwebflag == 'y' select p;
if (item.itempromoflag != "n") else if ((new[] { 1, 2, 31 }.contains(item.itemcat1)) && (item.itemsalestatus == 's')) else if (item.itemsalestatus == 0) else item.products_quantity = item.itemqtyonhand - item.itemqtycommitted;
( from n in numbers where n > 0 select new text = ( n == 1 ? "one" : );
where items.itemtrackingcode.equals("a") && (items.itemqtyonhand - items.itemqtycommitted) > 0 select new  { qty = ( items.itempromoflag.equals("1") ? "100000" : );
select isnull(sum(balance),0) from mytable where customer = 'john';
select coalesce(sum(coalesce(balance,0)),0) from mytable where customer = 'john';
select sum(isnull(balance,0)) from mytable where customer = 'john';
select coalesce(sum(balance),0) from mytable where customer = 'john';
select * from a inner join b on b.mycol like concat('%', a.mycol, '%');
create table a (mycol varchar(255));
create table b (mycol varchar(255));
select * from a inner join b on b.mycol like concat('%', a.mycol, '%');
select * from table a join table b on instr(b.column, a.column) > 0;
select * from table a join table b on b.column like '%'+ a.column +'%';
select * from table a join table b on b.column like concat('%', a.column ,'%');
select * from (select upper(a.column) 'ua' table a) a join (select upper(b.column) 'ub' table b) b on instr(b.ub, a.ua) > 0;
select * from table a, table b where instr(b.column, a.column) > 0;
select * from little;
alter table modify dt_created datetime default current_timestamp alter table modify dt_modified datetime default current_timestamp on update current_timestamp;
alter table  `tablename` change  `dt`  `dt` timestamp not null default current_timestamp;
alter table  `tablename`;
alter table `tablename` change `dt` `dt` timestamp on update current_timestamp not null default current_timestamp;
select email from user where email like '%' || @email || '%';
set @email = 'test@test.com';
set @email = concat('%',@email,'%');
select email from `user` where email like @email;
set @email = 'test@test.com' collate utf8_unicode_ci;
like '%{$var}%';
set @email = 'test@test.com';
select email from `user` where email like '%' + @email + '%';
set @emailid = concat('%', 'email@email.com' ,'%');
set @t1 =concat('select * from user where email like ''', @emailid, '''');
set @email = 'test@test.com';
select email from `user` where email like concat('%', @email, '%');
select dbo.createcsv(@myxml);
create function createcsv (@myxml xml) select @liststr = from @myxml.nodes('/row') as t(c) end go select dbo.createcsv(cast((    select x from y    for xml raw) as xml));
select dbo.createcsv(cast(( select distinct number as value from master..spt_values where type = 'p' and number <= 20;
create table [dbo].[xtlist]( [list] [varchar](1000) null;
create procedure [dbo].[xpcreatelist] as begin set nocount on;
delete from xtlist end;
end close clist;
create procedure [dbo].[xpprocreateexec] ( @cmd varchar(8000), @replacewith varchar(1000) ) as begin set @query = replace(@cmd,@replacewith,@item) end  select a from table select b from table select c from table exec procedure 'a' exec procedure 'b' exec procedure 'c';
create function [dbo].[xfprocreatestr] ( @originaltext varchar(8000), @replacewith varchar(1000) ) as begin set @result = '' set @result = @result + replace(@originaltext,@replacewith,@item) + char(13) + char(10) end ;
create function [dbo].[xfprocreateinrows] ( @originaltext varchar(8000), @replacewith varchar(1000) ) ( text varchar(2000) ) as begin end ;
create type statemaster as table ( statecode varchar(2), statedescp varchar(250) );
create function tablevaluedparameterexample(@tmptable statemaster readonly) as begin select @statedescp = statedescp from @tmptable end go;
create procedure tablevaluedparameterexample_sp ( @tmptable statemaster readonly ) as begin select * from @tmptable end go exec tablevaluedparameterexample_sp @mytable;
create type tabletype as table ([value] varchar(100) null);
create function dbo.fn_get_string_with_delimeter (@table tabletype readonly,@separator varchar(5)) as begin set @return = stuff((select @separator + value from @table for xml path('')),1,1,'') end;
select dbo.fn_get_string_with_delimeter(@tab, ',');
create table project (projectid int, description varchar(50));
create table projectresource (projectid int, resourceid int, name varchar(15));
select *, (select name + ' ' as [text()] from projectresource pr where pr.projectid = p.projectid as resourcelist from project p;
create table duplicatetable (col1 int) select 8 union all select 1--duplicate union all select 2 --duplicate union all select 1 union all select 3 union all select 4 union all select 5 union select null as ( select col1, row_number() over(partition by col1 order by col1) as duplicatecount from duplicatetable where (col1 is not null) ) select col1 from cte where duplicatecount =1;
create type tabletype as table (locationname varchar(50)) select * from @mytable;
create function example( @tablename tabletype readonly) as begin select top 1 @name = locationname from @tablename end;
select * from @mytable select dbo.example(@mytable);
select field_name_2 from my_other_table;
select count(id) from syscolumns where id = object_id('tablename');
create function dbo.readxml (@xmlmatrix xml) as return t.value('./@age', 'integer') as age from @xmlmatrix.nodes('//row') x(t) ) age tinyint ) select 10000, 25 union all select 15000, 27 union all select 12000, 18 union all select 15000, 36 union all select 16000, 57 union all select 17000, 44 union all select 18000, 32 union all select 19000, 56 union all select 25000, 34 union all select 7500, 29 select @functionargument = age as [row/@age] from @source ) select * from readxml(@functionargument);
select @psuedotable = ... from ... select ... dbo.myudf (@psuedotable);
create proc dbo.tocsv ( @myquery varchar(2000), @csvout varchar(max) ) as set nocount on create table #foo (bar varchar(max)) exec (@myquery) select @csvout = substring(buzz, 2, 2000000000) from ( select bar -- maybe cast(bar as varchar(max))?? from #foo;
select    * from      scott.emp join scott.dept on (emp.deptno = dept.deptno) where     emp.ename = {0};
select @include(commonfields) from blogs where id = :id;
select column1, column2 from something;
select column1 from something where column2 in ( select * from something_else );
where user_id= $$;  /* $$ will automatically catch a parameter userid */;
select id, amount, created from user_table where amount > $amt and balance < $amt select email from vip_list ) } ;
select * from [tablename] t where t.[datecolumnname] >= dateadd(month, -1, getdate());
select dateadd(day,-30,getdate());
select dateadd(month, -1, getdate());
select name from ( select name from where id_city='34324' and datetime >= dateadd(month,-1,getdate()) union all select name from where id_city='34324' and datetime >= dateadd(month,-1,getdate());
select sum(case when col1 > col2 then col3*col4 else 0 end) as sumsomeproduct from ...;
select sumsomeproduct, count(*), <other aggregate functions> from (select <other columns you are grouping by>, sum(case when col1 > col2 then col3*col4 else 0 end) as sumsomeproduct from table;
select ... from (select ... , case when col1 > col2 then sum(col3*col4) else 0 end as some_product from ...;
from ... select ... from t;
select case when col1 > col2 then sum(col3*col4) else 0 end as some_product from some_table case when col1 > col2 then sum(col3*col4) else 0 end;
select personname, songname, status from table where name in ('holly', 'ryan');
select t1.songname from tablename t1 and t1.personname <> t2.personname and t1.status = 'complete' -- my assumption that this is necessary and t2.status = 'complete' -- my assumption that this is necessary and t1.personname in ('holly', 'ryan') and t2.personname in ('holly', 'ryan');
select songname from t where personname in ('ryan', 'holly') having count(distinct personname) = 2;
where personname in ('ryan', 'holly') and status = 'complete';
select  level from    dual;
select sysdate into l_date from dual;
select case when i = j then 0 else 1 end into l_foo from dual;
select to_char(startdate,'yyyymmdd') dateorder, to_char(startdate,'dd/mm/yyyy') startdate, ... from ...;
select datefield from mytable;
select *  from `table_name` order by str_to_date(start_date,"%d-%m-%y") asc;
select to_char(dispdate1,'dd/mm/yyyy') as dispdate, sum(applcount) as applied, sum(confcount) as confirmed from ( select count(id) as applcount, 0 as confcount, student.applied_on as dispdate1 from student where student.id = p_id union select 0 as applcount, count(id) as confcount, student.confirmed_on as dispdate1 from student where student.id = p_id );
select      [date] from        tbemp;
select * from table order_by date asc;
select date from tbemp;
select so.name, su.name, so.crdate from sysobjects so join sysusers su on so.uid = su.uid so.crdate;
create table `example` ( `id` int(11) not null auto_increment, `ipv6` varbinary(16) not null, primary key (`id`) );
select category,guid,row_number() over (partition by category order by guid) rn from mytable ) select * from numbered where rn=1;
select 'a', newid() union all select 'a', newid() union all select 'b', newid() select s.category, s.guid from ( select t.category, t.guid, row_number() over(partition by t.category order by (select 1)) as rn from @t as t where s.rn = 1;
select t1.category, (select top 1 t2.guid from @t as t2 where t1.category = t2.category) as guid from @t as t1;
select category, min(cast(guid as binary(16))) from mytable;
as ( select category, min(cast(guid as binary(16))) from mytable ) select category, cast(guid as uniqueidentifier) from categoryvalue;
select column_list_please from dbo.product -- dbo prefix please case when @sortdir = 'asc' and @sortorder = 'name' then name end, case when @sortdir = 'asc' and @sortorder = 'created_date' then created_date end, case when @sortdir = 'desc' and @sortorder = 'name' then name end desc, case when @sortdir = 'desc' and @sortorder = 'created_date' then created_date end desc;
if @sortdir not in ('asc', 'desc') or @sortorder not in ('name', 'created_date') end  from dbo.product order by ' + @sortorder + ' ' + @sortdir;
exec sp_executesql @sql;
(case when @sortorder = 'name' and @sortdir = 'desc' then name end) desc, (case when @sortorder = 'created_date' and @sortdir = 'asc' then created_date end) asc, (case when @sortorder = 'created_date' and @sortdir = 'desc' then created_date end) desc;
set @str = 'select * from product order by ' + @sortorder + ' ' + @sortdir;
select * from ( select row_number() over ( order by case when @sortorder = 'name' and @sortdir = 'asc' then name end asc, case when @sortorder = 'name' and @sortdir = 'desc' then name end desc, case when i(@sortorder = 'created_date' and @sortdir = 'asc' then created_date end asc, case when i(@sortorder = 'created_date' and @sortdir = 'desc' then created_date end asc) rownum ) rownum;
product_id int, name varchar(50), value int, created_date datetime ) select * from [product] if @sortorder = 'name' and @sortdir = 'asc' begin select * from @rawproducts end  if @sortorder = 'name' and @sortdir = 'desc' begin select * from @rawproducts end  if @sortorder = 'created_date' and @sortdir = 'asc' begin select * from @rawproducts end  if @sortorder = 'created_date' and @sortdir = 'desc' begin select * from @rawproducts end;
update tbluser set datefield = dateadd(ss,numofseconds,datefield);
update tbl set yourdatefield = dateadd (ss, 2, yourdatefield);
numbers = c("123", "456", na, ""), letters = c("abc", "def", "zzz", "hhh");
select * from numbers join letters;
from pyspark.sql.types import stringtype f.expr('numbers.numbers <=> letters.numbers')).\;
select(['field11', 'field12']) table1.outerjoin(table2, table1.tbl1_id == table2.tbl1_id)) );
case when issue_division = issue_division_2 then case when  issue_division is null then "null value found" //give your option else 1 end else 0 end as issue_division_result;
select (case when issue_division = issue_division_2 then 1 else 0 end) as issues from (  -- your query here -- select 'carat issue open' issue_comment, ...., ..., substr(gcrs.stream_name,1,case when instr(gcrs.stream_name,' (')=0 then 100 else  instr(gcrs.stream_name,' (')-1 end) issue_division, case when gcrs.stream_name like 'non-gt%' then 'non-gt' else gcrs.stream_name end as issue_division_2 from .... where upper(issue_status) like '%open%' );
create table example ( surrogatekey int identity(1,1) -- a surrogate key that increments automatically );
create table example ( primarykey int primary key -- a primary key is just an unique identifier );
select concat( "alter table ", table_name, " drop foreign key ", constraint_name,";\n", "alter table ", table_name, " drop key ", constraint_name, ";\n", "alter table ", table_name, " add key fk__", table_name, "__", referenced_table_name, " (", column_name, ");\n", "alter table ", table_name, " add constraint fk__", table_name, "__", referenced_table_name , " foreign key (", column_name, ") ", "references ", referenced_table_name, "(", referenced_column_name, ");" from information_schema.key_column_usage where table_schema='myschemaname' and constraint_name like 'fk_%';
alter table visitor_browsers drop foreign key fk_4ygermmic4fujggq1kp96dx47;
alter table visitor_browsers drop key fk_4ygermmic4fujggq1kp96dx47;
alter table visitor_browsers add key fk__visitor_browsers__websites (website);
alter table visitor_browsers add constraint fk__visitor_browsers__websites foreign key (website) references websites(id);
select concat("alter table ", table_name," drop foreign key `", constraint_name,"`; ") as runme from information_schema.key_column_usage where table_schema='my_schema_name';
alter table `thetable` drop key `oldkey`, add key `newkey` (`tablefield`);
alter table customer_account drop foreign key `fk3fedf2cc1cd51baf`;
alter table customer_account  add constraint `fk3fedf2ccd115cb1a` foreign key (campaign_id) references campaign(id);
create or replace procedure to_dbg_table(p_log varchar2) as pragma autonomous_transaction;
end to_dbg_table;
create or replace procedure to_dbg_file(p_fname varchar2, p_log varchar2) as l_file utl_file.file_type;
end to_dbg_file;
create or replace procedure write_log(p_log varchar2) as if g_debug then if g_type='file' then end if;
create table foo ( someint int not null check (someint >= 1234 and someint <= 4523) );
create table numbers ( number int not null ... ) create table numbers ( number int not null, check(number >= 1234 and number <= 4523), ... ) create table numbers ( number int not null, constraint number_range_check ... );
create table whatever ( ... ...;
alter table package_subscription add constraint check_discount_amount check (discount_amount between 0.0000 and 1.0000);
select @result = '' select @result = @result + alias from aliases where username='bob';
create function [dbo].[getaliasesbyid] ( @userid int ) as begin select @output = coalesce(@output + ', ', '') + alias from useraliases where userid = @userid end  select userid, dbo.getaliasesbyid(userid) from useraliases;
union all select 1,'mry' union all select 1,'mra' union all select 2,'abc' union all select 2,'xyz' select left(tmp.userid, 10) + (   select ', '+alias from @useraliases where userid = tmp.userid ) from tmp;
select @str=coalesce(@str,'') + cast(id as varchar(10)) + ',' from dbo.fcuser select @str;
select * from mytable with (index(0)) where myindexedcolumn = 0;
select * from mytable with (index(indexname)) where myindexedcolumn = 0;
alter index [myindex] on mytable disable;
select * from mytable where myindexedcolumn + 0 = 0;
select * from sales where salesdate between '11/11/2010' and '12/11/2010' --if using dd/mm/yyyy;
set @mydate = '11/11/2010' select * from sales where salesdate>=@mydate and salesdate<dateadd(dd,1,@mydate);
select * from sales where salesdate >= '11/11/2010' and salesdate < (convert(datetime, '11/11/2010') + 1);
select * from sales where convert(datetime, floor(convert(float, salesdate))) = '11/11/2010';
select * from sales where salesdate between '2020-05-18t00:00:00.00' and '2020-05-18t23:59:59.999';
select * from sales where dateadd(dd, datediff(dd, 0, salesdate), 0) = '11/11/2010';
select * from sales where datediff(dd, salesdate, '20101111') = 0;
select * from sales where datediff(dd, salesdate, getdate()) = 0;
select * from sales where datediff(dd, salesdate, getdate()) <= 7;
select cast(salesdate as date) [date] from sales where salesdate = '2010/11/11' select cast(salesdate as date) [date] from sales where salesdate = '11/11/2010';
alter table table_name add column column_name57 integer after column_name56;
alter table tablename add column_name57 int after column_name56;
alter table table_name add column column_name57 integer after column_name56;
alter table table_name add column column_name integer;
alter table temp_name add my_coumn int(1) not null default 1;
set @column_name =( select column_name from information_schema.columns where table_schema = 'database_name' and table_name = 'table_name' and ordinal_position = 56 set @query = concat( 'alter table `table_name` add `new_column_name` int(5) after ', @column_name from @query;
set ansi_nulls off;
if null = null else print 'false' set ansi_nulls on;
if null = null else print 'false';
select uniqueid, columntwo, '+ from information_schema.columns where tablename = @tablename and ) then 'columnthree' else 'null as columnthree' from (select * from '+@sourcename+' s exec sp_executesql @sql;
select top 0 * into #temp from (<subquery>) s;
select uniqueid from s as s2 where s2.uniqueid = s.uniqueid from (select null as columnthree) as dummy ) from s ;
select s.* from ( select null as columntwo, null as columnthree, null as columnfour columntwo, columnthree, columnfour from tablex;
select firstcolumn, secondcolumn, '+ where name = 'columnname' and id = object_id('tablename')) then 'columnname' else 'null as threecolumn' from tablename' exec sp_executesql @query;
select * from sys.types where name in (n'numeric', n'decimal');
create table [dbo].[numdec] ( [num] [numeric](18, 0) null, [dec] [decimal](18, 0) null;
select convert(decimal(18,0), [num]), -- conversion from dbo.numdec union all select [num],[dec] from dbo.numdec where [num] = @dec  -- no conversion union all select [num],[dec] from dbo.numdec where [dec] = @num; -- no conversion;
where flag=0 where flag<>0;
where flag = true;
where flag is true;
create table table1(a number, b number);
create table table2(a number, b number);
select * from (select a,b from table1 union select a,b from table2 ) where a > 1;
select * from table(dbms_xplan.display(format=>'basic +predicate'));
where a = (select max(a) from empty_table);
select cola, colb from tablea where cola > 1 union select colx, cola from tableb where cola > 1;
select * from (select cola, colb from tablea union select colx, cola from tableb) where cola > 1;
select * from (select cola, colb from tablea union select cola, colb from tableb) as tablec where tablec.cola > 1;
where tablec.cola > 1;
select * from (select * from can union select * from employee) as e where e.id = 1;
select cola, colb from tablea  where cola > 1 union select colx, cola from tableb;
select * from tablea where year(columnname) = year(current_date()) and;
select * from table where month(columnname) = month(current_date()) and year(columnname) = year(current_date());
select * from table where month(from_unixtime(columnname))= month(curdate());
set statistics time on;
set @sttime=getdate() select * from productmaster select rtrim(cast(datediff(ms, @sttime, getdate()) as char(10))) as 'timetaken';
set statistics io on;
set statistics time on;
select @starttime=getdate() select @endtime=getdate() select datediff(ms,@starttime,@endtime) as [duration in milliseconds];
set @starttime = getdate() set @endtime = getdate();
set statistics time { on | off };
set statistics time on;
select productid, startdate, enddate, standardcost from production.productcosthistory where standardcost < 500.00;
set statistics time off;
select max(id) from customers;
select max(id) from customers;
select max(id) from customers;
select max(id) from customers;
values (23, 'bob', 'smith') set @mostrecentid = scope_identity();
select last\_insert\_id();
select max(id)+1, 'barack', 'obama' from customers;
select ident_current('tablename') as lastidentity;
select * from customers order by id desc limit 1;
select * from tablename order by id desc;
select max(id) from customer;
select c1.* from customer c1, (select max(id) as max_id from customer )c2 where c1.id=c2.max_id;
if ( !$rs ) { $newid = 1; } else { $newid = $rs[newid]+1; };
id, firstname, surname) values ((( select coalesce(max(b.id)+1,1) as nextid from table_name b;
select ename, sal from emp  where sal > (select sal from emp where ename ='ford');
select empno,sal,deptid from emp e where sal=(select avg(sal) from emp where deptid=e.deptid);
select empno,fname,sal,deptid from emp e where sal=(select avg(sal) from emp where deptid=e.deptid);
select id, first_name from student_details where id in (select student_id from student_subjects where subject= 'science');
select employee_number, name from employees emp where salary > ( select avg(salary) from employees where department = emp.department);
select salary from employee e1 where n-1 = (select count(*) from employee e2 where e1.salary <e2.salary);
'excel 8.0;database=d:\testing.xls;', 'select * from [sheetname$]') select * from sqlservertable;
'excel 8.0;database=d:\testing.xls;', 'select * from [sheetname$]') select * from sqlservertable;
select * 'excel 8.0;database=d:\testing.xls;hdr=yes', 'select * from [sheet1$]');
'excel 8.0;database=d:\testing.xls;hdr=yes', 'select * from [sheetname$]');
exec sp_makewebtask @query = 'select * from database_name..sqlservertable', @colheaders =1, @fixedfont=0,@lastupdated=0,@resultstitle='testing details';
create procedure proc_generate_excel_with_columns ( @db_name    varchar(100), @table_name varchar(100), @file_name  varchar(100) ) as  select @columns=coalesce(@columns+',','')+column_name+' as '+column_name from information_schema.columns where table_name=@table_name select @columns=''''''+replace(replace(@columns,' as ',''''' as '),',',',''''') select @data_file=substring(@file_name,1,len(@file_name)-charindex('\',reverse(@file_name)))+'\data_file.xls' set @sql='exec master..xp_cmdshell ''bcp " select * from (select '+@columns+') as t" queryout "'+@file_name+'" -c''' set @sql='exec master..xp_cmdshell ''bcp "select * from '+@db_name+'..'+@table_name+'" queryout "'+@data_file+'" -c''' set @sql= 'exec master..xp_cmdshell ''type '+@data_file+' >> "'+@file_name+'"''' set @sql= 'exec master..xp_cmdshell ''del '+@data_file+'''';
exec proc_generate_excel_with_columns 'your dbname', 'your table name','your file path';
update openrowset('microsoft.jet.oledb.4.0', 'excel 8.0;database=c:\test.xls;hdr=no', 'select * from [sheet1$b7:b7]') set f1 = -99;
update openrowset('microsoft.jet.oledb.4.0', 'excel 8.0;database=c:\test.xls;hdr=no', 'select * from [sheet1$b7:b7]') set f1 = '=a7+c7';
select foo from foo foo order by foo.date desc;
select * from foo order by foo_date desc;
